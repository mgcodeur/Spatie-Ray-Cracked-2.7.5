"use strict";
var ST = Object.defineProperty;
var IT = (e, t, n) =>
  t in e
    ? ST(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (e[t] = n);
var At = (e, t, n) => (IT(e, typeof t != "symbol" ? t + "" : t, n), n);
const xe = require("electron"),
  fI = require("node:os"),
  Gl = require("node:path"),
  pt = require("path"),
  hc = require("tty"),
  wr = require("util"),
  Xt = require("fs"),
  ha = require("net"),
  Hi = require("events"),
  Kr = require("stream"),
  mc = require("zlib"),
  ks = require("buffer"),
  dI = require("string_decoder"),
  X0 = require("querystring"),
  Ya = require("url"),
  Ws = require("http"),
  pr = require("crypto"),
  Fr = require("os"),
  $T = require("constants"),
  gc = require("assert"),
  Ql = require("child_process"),
  pI = require("https"),
  CT = require("tls"),
  RT = require("dns"),
  kT = require("node:crypto");
var Tn =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function Wl(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e;
}
var Ug = { exports: {} },
  Fg = { exports: {} };
/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */ var TT = pt.relative,
  wi = LT,
  NT = process.cwd();
function hI(e, t) {
  for (
    var n = e.split(/[ ,]+/), r = String(t).toLowerCase(), i = 0;
    i < n.length;
    i++
  ) {
    var a = n[i];
    if (a && (a === "*" || a.toLowerCase() === r)) return !0;
  }
  return !1;
}
function OT(e, t, n) {
  var r = Object.getOwnPropertyDescriptor(e, t),
    i = r.value;
  return (
    (r.get = function () {
      return i;
    }),
    r.writable &&
      (r.set = function (s) {
        return (i = s);
      }),
    delete r.value,
    delete r.writable,
    Object.defineProperty(e, t, r),
    r
  );
}
function PT(e) {
  for (var t = "", n = 0; n < e; n++) t += ", arg" + n;
  return t.substr(2);
}
function DT(e) {
  var t = this.name + ": " + this.namespace;
  this.message && (t += " deprecated " + this.message);
  for (var n = 0; n < e.length; n++)
    t +=
      `
    at ` + e[n].toString();
  return t;
}
function LT(e) {
  if (!e) throw new TypeError("argument namespace is required");
  var t = jd(),
    n = Oo(t[1]),
    r = n[0];
  function i(a) {
    Zf.call(i, a);
  }
  return (
    (i._file = r),
    (i._ignored = UT(e)),
    (i._namespace = e),
    (i._traced = FT(e)),
    (i._warned = Object.create(null)),
    (i.function = qT),
    (i.property = GT),
    i
  );
}
function BT(e, t) {
  var n =
    typeof e.listenerCount != "function"
      ? e.listeners(t).length
      : e.listenerCount(t);
  return n > 0;
}
function UT(e) {
  if (process.noDeprecation) return !0;
  var t = process.env.NO_DEPRECATION || "";
  return hI(t, e);
}
function FT(e) {
  if (process.traceDeprecation) return !0;
  var t = process.env.TRACE_DEPRECATION || "";
  return hI(t, e);
}
function Zf(e, t) {
  var n = BT(process, "deprecation");
  if (!(!n && this._ignored)) {
    var r,
      i,
      a,
      s,
      o = 0,
      c = !1,
      l = jd(),
      f = this._file;
    for (
      t
        ? ((s = t), (a = Oo(l[1])), (a.name = s.name), (f = a[0]))
        : ((o = 2), (s = Oo(l[o])), (a = s));
      o < l.length;
      o++
    )
      if (((r = Oo(l[o])), (i = r[0]), i === f)) c = !0;
      else if (i === this._file) f = this._file;
      else if (c) break;
    var u = r ? s.join(":") + "__" + r.join(":") : void 0;
    if (!(u !== void 0 && u in this._warned)) {
      this._warned[u] = !0;
      var d = e;
      if ((d || (d = a === s || !a.name ? E1(s) : E1(a)), n)) {
        var p = mI(this._namespace, d, l.slice(o));
        process.emit("deprecation", p);
        return;
      }
      var h = process.stderr.isTTY ? MT : jT,
        m = h.call(this, d, r, l.slice(o));
      process.stderr.write(
        m +
          `
`,
        "utf8",
      );
    }
  }
}
function Oo(e) {
  var t = e.getFileName() || "<anonymous>",
    n = e.getLineNumber(),
    r = e.getColumnNumber();
  e.isEval() && (t = e.getEvalOrigin() + ", " + t);
  var i = [t, n, r];
  return (i.callSite = e), (i.name = e.getFunctionName()), i;
}
function E1(e) {
  var t = e.callSite,
    n = e.name;
  n || (n = "<anonymous@" + J0(e) + ">");
  var r = t.getThis(),
    i = r && t.getTypeName();
  return (
    i === "Object" && (i = void 0),
    i === "Function" && (i = r.name || i),
    i && t.getMethodName() ? i + "." + n : n
  );
}
function jT(e, t, n) {
  var r = new Date().toUTCString(),
    i = r + " " + this._namespace + " deprecated " + e;
  if (this._traced) {
    for (var a = 0; a < n.length; a++)
      i +=
        `
    at ` + n[a].toString();
    return i;
  }
  return t && (i += " at " + J0(t)), i;
}
function MT(e, t, n) {
  var r =
    "\x1B[36;1m" +
    this._namespace +
    "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" +
    e +
    "\x1B[39m";
  if (this._traced) {
    for (var i = 0; i < n.length; i++)
      r +=
        `
    \x1B[36mat ` +
        n[i].toString() +
        "\x1B[39m";
    return r;
  }
  return t && (r += " \x1B[36m" + J0(t) + "\x1B[39m"), r;
}
function J0(e) {
  return TT(NT, e[0]) + ":" + e[1] + ":" + e[2];
}
function jd() {
  var e = Error.stackTraceLimit,
    t = {},
    n = Error.prepareStackTrace;
  (Error.prepareStackTrace = HT),
    (Error.stackTraceLimit = Math.max(10, e)),
    Error.captureStackTrace(t);
  var r = t.stack.slice(1);
  return (Error.prepareStackTrace = n), (Error.stackTraceLimit = e), r;
}
function HT(e, t) {
  return t;
}
function qT(e, t) {
  if (typeof e != "function")
    throw new TypeError("argument fn must be a function");
  var n = PT(e.length),
    r = jd(),
    i = Oo(r[1]);
  i.name = e.name;
  var a = new Function(
    "fn",
    "log",
    "deprecate",
    "message",
    "site",
    `"use strict"
return function (` +
      n +
      `) {log.call(deprecate, message, site)
return fn.apply(this, arguments)
}`,
  )(e, Zf, this, t, i);
  return a;
}
function GT(e, t, n) {
  if (!e || (typeof e != "object" && typeof e != "function"))
    throw new TypeError("argument obj must be object");
  var r = Object.getOwnPropertyDescriptor(e, t);
  if (!r) throw new TypeError("must call property on owner object");
  if (!r.configurable) throw new TypeError("property must be configurable");
  var i = this,
    a = jd(),
    s = Oo(a[1]);
  (s.name = t), "value" in r && (r = OT(e, t));
  var o = r.get,
    c = r.set;
  typeof o == "function" &&
    (r.get = function () {
      return Zf.call(i, n, s), o.apply(this, arguments);
    }),
    typeof c == "function" &&
      (r.set = function () {
        return Zf.call(i, n, s), c.apply(this, arguments);
      }),
    Object.defineProperty(e, t, r);
}
function mI(e, t, n) {
  var r = new Error(),
    i;
  return (
    Object.defineProperty(r, "constructor", { value: mI }),
    Object.defineProperty(r, "message", {
      configurable: !0,
      enumerable: !1,
      value: t,
      writable: !0,
    }),
    Object.defineProperty(r, "name", {
      enumerable: !1,
      configurable: !0,
      value: "DeprecationError",
      writable: !0,
    }),
    Object.defineProperty(r, "namespace", {
      configurable: !0,
      enumerable: !1,
      value: e,
      writable: !0,
    }),
    Object.defineProperty(r, "stack", {
      configurable: !0,
      enumerable: !1,
      get: function () {
        return i !== void 0 ? i : (i = DT.call(this, n));
      },
      set: function (s) {
        i = s;
      },
    }),
    r
  );
}
var Nc = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */ var w1;
function qi() {
  if (w1) return Nc.exports;
  (w1 = 1), (Nc.exports = i), (Nc.exports.format = a), (Nc.exports.parse = s);
  var e = /\B(?=(\d{3})+(?!\d))/g,
    t = /(?:\.0*|(\.[^0]+)0+)$/,
    n = {
      b: 1,
      kb: 1024,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5),
    },
    r = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function i(o, c) {
    return typeof o == "string" ? s(o) : typeof o == "number" ? a(o, c) : null;
  }
  function a(o, c) {
    if (!Number.isFinite(o)) return null;
    var l = Math.abs(o),
      f = (c && c.thousandsSeparator) || "",
      u = (c && c.unitSeparator) || "",
      d = c && c.decimalPlaces !== void 0 ? c.decimalPlaces : 2,
      p = !!(c && c.fixedDecimals),
      h = (c && c.unit) || "";
    (!h || !n[h.toLowerCase()]) &&
      (l >= n.pb
        ? (h = "PB")
        : l >= n.tb
        ? (h = "TB")
        : l >= n.gb
        ? (h = "GB")
        : l >= n.mb
        ? (h = "MB")
        : l >= n.kb
        ? (h = "KB")
        : (h = "B"));
    var m = o / n[h.toLowerCase()],
      g = m.toFixed(d);
    return (
      p || (g = g.replace(t, "$1")),
      f &&
        (g = g
          .split(".")
          .map(function (v, y) {
            return y === 0 ? v.replace(e, f) : v;
          })
          .join(".")),
      g + u + h
    );
  }
  function s(o) {
    if (typeof o == "number" && !isNaN(o)) return o;
    if (typeof o != "string") return null;
    var c = r.exec(o),
      l,
      f = "b";
    return (
      c
        ? ((l = parseFloat(c[1])), (f = c[4].toLowerCase()))
        : ((l = parseInt(o, 10)), (f = "b")),
      isNaN(l) ? null : Math.floor(n[f] * l)
    );
  }
  return Nc.exports;
}
var Nu = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var x1;
function zs() {
  if (x1) return Nu;
  x1 = 1;
  var e =
      /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g,
    t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/,
    n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/,
    r = /\\([\u000b\u0020-\u00ff])/g,
    i = /([\\"])/g,
    a = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  (Nu.format = s), (Nu.parse = o);
  function s(u) {
    if (!u || typeof u != "object")
      throw new TypeError("argument obj is required");
    var d = u.parameters,
      p = u.type;
    if (!p || !a.test(p)) throw new TypeError("invalid type");
    var h = p;
    if (d && typeof d == "object")
      for (var m, g = Object.keys(d).sort(), v = 0; v < g.length; v++) {
        if (((m = g[v]), !n.test(m)))
          throw new TypeError("invalid parameter name");
        h += "; " + m + "=" + l(d[m]);
      }
    return h;
  }
  function o(u) {
    if (!u) throw new TypeError("argument string is required");
    var d = typeof u == "object" ? c(u) : u;
    if (typeof d != "string")
      throw new TypeError("argument string is required to be a string");
    var p = d.indexOf(";"),
      h = p !== -1 ? d.slice(0, p).trim() : d.trim();
    if (!a.test(h)) throw new TypeError("invalid media type");
    var m = new f(h.toLowerCase());
    if (p !== -1) {
      var g, v, y;
      for (e.lastIndex = p; (v = e.exec(d)); ) {
        if (v.index !== p) throw new TypeError("invalid parameter format");
        (p += v[0].length),
          (g = v[1].toLowerCase()),
          (y = v[2]),
          y.charCodeAt(0) === 34 &&
            ((y = y.slice(1, -1)),
            y.indexOf("\\") !== -1 && (y = y.replace(r, "$1"))),
          (m.parameters[g] = y);
      }
      if (p !== d.length) throw new TypeError("invalid parameter format");
    }
    return m;
  }
  function c(u) {
    var d;
    if (
      (typeof u.getHeader == "function"
        ? (d = u.getHeader("content-type"))
        : typeof u.headers == "object" &&
          (d = u.headers && u.headers["content-type"]),
      typeof d != "string")
    )
      throw new TypeError("content-type header is missing from object");
    return d;
  }
  function l(u) {
    var d = String(u);
    if (n.test(d)) return d;
    if (d.length > 0 && !t.test(d))
      throw new TypeError("invalid parameter value");
    return '"' + d.replace(i, "\\$1") + '"';
  }
  function f(u) {
    (this.parameters = Object.create(null)), (this.type = u);
  }
  return Nu;
}
var gI = { exports: {} },
  Md = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? QT : WT);
function QT(e, t) {
  return (e.__proto__ = t), e;
}
function WT(e, t) {
  for (var n in t) Object.prototype.hasOwnProperty.call(e, n) || (e[n] = t[n]);
  return e;
}
const zT = {
  100: "Continue",
  101: "Switching Protocols",
  102: "Processing",
  103: "Early Hints",
  200: "OK",
  201: "Created",
  202: "Accepted",
  203: "Non-Authoritative Information",
  204: "No Content",
  205: "Reset Content",
  206: "Partial Content",
  207: "Multi-Status",
  208: "Already Reported",
  226: "IM Used",
  300: "Multiple Choices",
  301: "Moved Permanently",
  302: "Found",
  303: "See Other",
  304: "Not Modified",
  305: "Use Proxy",
  307: "Temporary Redirect",
  308: "Permanent Redirect",
  400: "Bad Request",
  401: "Unauthorized",
  402: "Payment Required",
  403: "Forbidden",
  404: "Not Found",
  405: "Method Not Allowed",
  406: "Not Acceptable",
  407: "Proxy Authentication Required",
  408: "Request Timeout",
  409: "Conflict",
  410: "Gone",
  411: "Length Required",
  412: "Precondition Failed",
  413: "Payload Too Large",
  414: "URI Too Long",
  415: "Unsupported Media Type",
  416: "Range Not Satisfiable",
  417: "Expectation Failed",
  418: "I'm a Teapot",
  421: "Misdirected Request",
  422: "Unprocessable Entity",
  423: "Locked",
  424: "Failed Dependency",
  425: "Too Early",
  426: "Upgrade Required",
  428: "Precondition Required",
  429: "Too Many Requests",
  431: "Request Header Fields Too Large",
  451: "Unavailable For Legal Reasons",
  500: "Internal Server Error",
  501: "Not Implemented",
  502: "Bad Gateway",
  503: "Service Unavailable",
  504: "Gateway Timeout",
  505: "HTTP Version Not Supported",
  506: "Variant Also Negotiates",
  507: "Insufficient Storage",
  508: "Loop Detected",
  509: "Bandwidth Limit Exceeded",
  510: "Not Extended",
  511: "Network Authentication Required",
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var Z0 = zT,
  Hd = Ei;
Ei.message = Z0;
Ei.code = KT(Z0);
Ei.codes = VT(Z0);
Ei.redirect = { 300: !0, 301: !0, 302: !0, 303: !0, 305: !0, 307: !0, 308: !0 };
Ei.empty = { 204: !0, 205: !0, 304: !0 };
Ei.retry = { 502: !0, 503: !0, 504: !0 };
function KT(e) {
  var t = {};
  return (
    Object.keys(e).forEach(function (r) {
      var i = e[r],
        a = Number(r);
      t[i.toLowerCase()] = a;
    }),
    t
  );
}
function VT(e) {
  return Object.keys(e).map(function (n) {
    return Number(n);
  });
}
function YT(e) {
  var t = e.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(Ei.code, t))
    throw new Error('invalid status message: "' + e + '"');
  return Ei.code[t];
}
function A1(e) {
  if (!Object.prototype.hasOwnProperty.call(Ei.message, e))
    throw new Error("invalid status code: " + e);
  return Ei.message[e];
}
function Ei(e) {
  if (typeof e == "number") return A1(e);
  if (typeof e != "string")
    throw new TypeError("code must be a number or string");
  var t = parseInt(e, 10);
  return isNaN(t) ? YT(e) : A1(t);
}
var jg = { exports: {} },
  Ou = { exports: {} },
  S1;
function XT() {
  return (
    S1 ||
      ((S1 = 1),
      typeof Object.create == "function"
        ? (Ou.exports = function (t, n) {
            n &&
              ((t.super_ = n),
              (t.prototype = Object.create(n.prototype, {
                constructor: {
                  value: t,
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                },
              })));
          })
        : (Ou.exports = function (t, n) {
            if (n) {
              t.super_ = n;
              var r = function () {};
              (r.prototype = n.prototype),
                (t.prototype = new r()),
                (t.prototype.constructor = t);
            }
          })),
    Ou.exports
  );
}
try {
  var I1 = require("util");
  if (typeof I1.inherits != "function") throw "";
  jg.exports = I1.inherits;
} catch {
  jg.exports = XT();
}
var JT = jg.exports;
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var ZT = eN;
function eN(e) {
  return e
    .split(" ")
    .map(function (t) {
      return t.slice(0, 1).toUpperCase() + t.slice(1);
    })
    .join("")
    .replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e) {
  var t = wi("http-errors"),
    n = Md,
    r = Hd,
    i = JT,
    a = ZT;
  (e.exports = o),
    (e.exports.HttpError = c()),
    (e.exports.isHttpError = f(e.exports.HttpError)),
    p(e.exports, r.codes, e.exports.HttpError);
  function s(m) {
    return +(String(m).charAt(0) + "00");
  }
  function o() {
    for (var m, g, v = 500, y = {}, _ = 0; _ < arguments.length; _++) {
      var E = arguments[_],
        R = typeof E;
      if (R === "object" && E instanceof Error)
        (m = E), (v = m.status || m.statusCode || v);
      else if (R === "number" && _ === 0) v = E;
      else if (R === "string") g = E;
      else if (R === "object") y = E;
      else
        throw new TypeError("argument #" + (_ + 1) + " unsupported type " + R);
    }
    typeof v == "number" &&
      (v < 400 || v >= 600) &&
      t("non-error status code; use only 4xx or 5xx status codes"),
      (typeof v != "number" || (!r.message[v] && (v < 400 || v >= 600))) &&
        (v = 500);
    var A = o[v] || o[s(v)];
    m ||
      ((m = A ? new A(g) : new Error(g || r.message[v])),
      Error.captureStackTrace(m, o)),
      (!A || !(m instanceof A) || m.status !== v) &&
        ((m.expose = v < 500), (m.status = m.statusCode = v));
    for (var I in y) I !== "status" && I !== "statusCode" && (m[I] = y[I]);
    return m;
  }
  function c() {
    function m() {
      throw new TypeError("cannot construct abstract class");
    }
    return i(m, Error), m;
  }
  function l(m, g, v) {
    var y = h(g);
    function _(E) {
      var R = E ?? r.message[v],
        A = new Error(R);
      return (
        Error.captureStackTrace(A, _),
        n(A, _.prototype),
        Object.defineProperty(A, "message", {
          enumerable: !0,
          configurable: !0,
          value: R,
          writable: !0,
        }),
        Object.defineProperty(A, "name", {
          enumerable: !1,
          configurable: !0,
          value: y,
          writable: !0,
        }),
        A
      );
    }
    return (
      i(_, m),
      d(_, y),
      (_.prototype.status = v),
      (_.prototype.statusCode = v),
      (_.prototype.expose = !0),
      _
    );
  }
  function f(m) {
    return function (v) {
      return !v || typeof v != "object"
        ? !1
        : v instanceof m
        ? !0
        : v instanceof Error &&
          typeof v.expose == "boolean" &&
          typeof v.statusCode == "number" &&
          v.status === v.statusCode;
    };
  }
  function u(m, g, v) {
    var y = h(g);
    function _(E) {
      var R = E ?? r.message[v],
        A = new Error(R);
      return (
        Error.captureStackTrace(A, _),
        n(A, _.prototype),
        Object.defineProperty(A, "message", {
          enumerable: !0,
          configurable: !0,
          value: R,
          writable: !0,
        }),
        Object.defineProperty(A, "name", {
          enumerable: !1,
          configurable: !0,
          value: y,
          writable: !0,
        }),
        A
      );
    }
    return (
      i(_, m),
      d(_, y),
      (_.prototype.status = v),
      (_.prototype.statusCode = v),
      (_.prototype.expose = !1),
      _
    );
  }
  function d(m, g) {
    var v = Object.getOwnPropertyDescriptor(m, "name");
    v && v.configurable && ((v.value = g), Object.defineProperty(m, "name", v));
  }
  function p(m, g, v) {
    g.forEach(function (_) {
      var E,
        R = a(r.message[_]);
      switch (s(_)) {
        case 400:
          E = l(v, R, _);
          break;
        case 500:
          E = u(v, R, _);
          break;
      }
      E && ((m[_] = E), (m[R] = E));
    });
  }
  function h(m) {
    return m.substr(-5) !== "Error" ? m + "Error" : m;
  }
})(gI);
var Gi = gI.exports,
  Mg = { exports: {} },
  Pu = { exports: {} },
  Du = { exports: {} },
  rh,
  $1;
function tN() {
  if ($1) return rh;
  $1 = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    i = r * 365.25;
  rh = function (l, f) {
    f = f || {};
    var u = typeof l;
    if (u === "string" && l.length > 0) return a(l);
    if (u === "number" && isNaN(l) === !1) return f.long ? o(l) : s(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(l),
    );
  };
  function a(l) {
    if (((l = String(l)), !(l.length > 100))) {
      var f =
        /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
          l,
        );
      if (f) {
        var u = parseFloat(f[1]),
          d = (f[2] || "ms").toLowerCase();
        switch (d) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * i;
          case "days":
          case "day":
          case "d":
            return u * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function s(l) {
    return l >= r
      ? Math.round(l / r) + "d"
      : l >= n
      ? Math.round(l / n) + "h"
      : l >= t
      ? Math.round(l / t) + "m"
      : l >= e
      ? Math.round(l / e) + "s"
      : l + "ms";
  }
  function o(l) {
    return (
      c(l, r, "day") ||
      c(l, n, "hour") ||
      c(l, t, "minute") ||
      c(l, e, "second") ||
      l + " ms"
    );
  }
  function c(l, f, u) {
    if (!(l < f))
      return l < f * 1.5
        ? Math.floor(l / f) + " " + u
        : Math.ceil(l / f) + " " + u + "s";
  }
  return rh;
}
var C1;
function vI() {
  return (
    C1 ||
      ((C1 = 1),
      (function (e, t) {
        (t = e.exports = i.debug = i.default = i),
          (t.coerce = c),
          (t.disable = s),
          (t.enable = a),
          (t.enabled = o),
          (t.humanize = tN()),
          (t.names = []),
          (t.skips = []),
          (t.formatters = {});
        var n;
        function r(l) {
          var f = 0,
            u;
          for (u in l) (f = (f << 5) - f + l.charCodeAt(u)), (f |= 0);
          return t.colors[Math.abs(f) % t.colors.length];
        }
        function i(l) {
          function f() {
            if (f.enabled) {
              var u = f,
                d = +new Date(),
                p = d - (n || d);
              (u.diff = p), (u.prev = n), (u.curr = d), (n = d);
              for (
                var h = new Array(arguments.length), m = 0;
                m < h.length;
                m++
              )
                h[m] = arguments[m];
              (h[0] = t.coerce(h[0])),
                typeof h[0] != "string" && h.unshift("%O");
              var g = 0;
              (h[0] = h[0].replace(/%([a-zA-Z%])/g, function (y, _) {
                if (y === "%%") return y;
                g++;
                var E = t.formatters[_];
                if (typeof E == "function") {
                  var R = h[g];
                  (y = E.call(u, R)), h.splice(g, 1), g--;
                }
                return y;
              })),
                t.formatArgs.call(u, h);
              var v = f.log || t.log || console.log.bind(console);
              v.apply(u, h);
            }
          }
          return (
            (f.namespace = l),
            (f.enabled = t.enabled(l)),
            (f.useColors = t.useColors()),
            (f.color = r(l)),
            typeof t.init == "function" && t.init(f),
            f
          );
        }
        function a(l) {
          t.save(l), (t.names = []), (t.skips = []);
          for (
            var f = (typeof l == "string" ? l : "").split(/[\s,]+/),
              u = f.length,
              d = 0;
            d < u;
            d++
          )
            f[d] &&
              ((l = f[d].replace(/\*/g, ".*?")),
              l[0] === "-"
                ? t.skips.push(new RegExp("^" + l.substr(1) + "$"))
                : t.names.push(new RegExp("^" + l + "$")));
        }
        function s() {
          t.enable("");
        }
        function o(l) {
          var f, u;
          for (f = 0, u = t.skips.length; f < u; f++)
            if (t.skips[f].test(l)) return !1;
          for (f = 0, u = t.names.length; f < u; f++)
            if (t.names[f].test(l)) return !0;
          return !1;
        }
        function c(l) {
          return l instanceof Error ? l.stack || l.message : l;
        }
      })(Du, Du.exports)),
    Du.exports
  );
}
var R1;
function nN() {
  return (
    R1 ||
      ((R1 = 1),
      (function (e, t) {
        (t = e.exports = vI()),
          (t.log = i),
          (t.formatArgs = r),
          (t.save = a),
          (t.load = s),
          (t.useColors = n),
          (t.storage =
            typeof chrome < "u" && typeof chrome.storage < "u"
              ? chrome.storage.local
              : o()),
          (t.colors = [
            "lightseagreen",
            "forestgreen",
            "goldenrod",
            "dodgerblue",
            "darkorchid",
            "crimson",
          ]);
        function n() {
          return typeof window < "u" &&
            window.process &&
            window.process.type === "renderer"
            ? !0
            : (typeof document < "u" &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
                (typeof window < "u" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/applewebkit\/(\d+)/));
        }
        t.formatters.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
        function r(c) {
          var l = this.useColors;
          if (
            ((c[0] =
              (l ? "%c" : "") +
              this.namespace +
              (l ? " %c" : " ") +
              c[0] +
              (l ? "%c " : " ") +
              "+" +
              t.humanize(this.diff)),
            !!l)
          ) {
            var f = "color: " + this.color;
            c.splice(1, 0, f, "color: inherit");
            var u = 0,
              d = 0;
            c[0].replace(/%[a-zA-Z%]/g, function (p) {
              p !== "%%" && (u++, p === "%c" && (d = u));
            }),
              c.splice(d, 0, f);
          }
        }
        function i() {
          return (
            typeof console == "object" &&
            console.log &&
            Function.prototype.apply.call(console.log, console, arguments)
          );
        }
        function a(c) {
          try {
            c == null ? t.storage.removeItem("debug") : (t.storage.debug = c);
          } catch {}
        }
        function s() {
          var c;
          try {
            c = t.storage.debug;
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        t.enable(s());
        function o() {
          try {
            return window.localStorage;
          } catch {}
        }
      })(Pu, Pu.exports)),
    Pu.exports
  );
}
var Lu = { exports: {} },
  k1;
function rN() {
  return (
    k1 ||
      ((k1 = 1),
      (function (e, t) {
        var n = hc,
          r = wr;
        (t = e.exports = vI()),
          (t.init = d),
          (t.log = c),
          (t.formatArgs = o),
          (t.save = l),
          (t.load = f),
          (t.useColors = s),
          (t.colors = [6, 2, 3, 4, 5, 1]),
          (t.inspectOpts = Object.keys(process.env)
            .filter(function (p) {
              return /^debug_/i.test(p);
            })
            .reduce(function (p, h) {
              var m = h
                  .substring(6)
                  .toLowerCase()
                  .replace(/_([a-z])/g, function (v, y) {
                    return y.toUpperCase();
                  }),
                g = process.env[h];
              return (
                /^(yes|on|true|enabled)$/i.test(g)
                  ? (g = !0)
                  : /^(no|off|false|disabled)$/i.test(g)
                  ? (g = !1)
                  : g === "null"
                  ? (g = null)
                  : (g = Number(g)),
                (p[m] = g),
                p
              );
            }, {}));
        var i = parseInt(process.env.DEBUG_FD, 10) || 2;
        i !== 1 &&
          i !== 2 &&
          r.deprecate(
            function () {},
            "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)",
          )();
        var a = i === 1 ? process.stdout : i === 2 ? process.stderr : u(i);
        function s() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(i);
        }
        (t.formatters.o = function (p) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(p, this.inspectOpts)
              .split(
                `
`,
              )
              .map(function (h) {
                return h.trim();
              })
              .join(" ")
          );
        }),
          (t.formatters.O = function (p) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(p, this.inspectOpts)
            );
          });
        function o(p) {
          var h = this.namespace,
            m = this.useColors;
          if (m) {
            var g = this.color,
              v = "  \x1B[3" + g + ";1m" + h + " \x1B[0m";
            (p[0] =
              v +
              p[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + v,
                )),
              p.push("\x1B[3" + g + "m+" + t.humanize(this.diff) + "\x1B[0m");
          } else p[0] = new Date().toUTCString() + " " + h + " " + p[0];
        }
        function c() {
          return a.write(
            r.format.apply(r, arguments) +
              `
`,
          );
        }
        function l(p) {
          p == null ? delete process.env.DEBUG : (process.env.DEBUG = p);
        }
        function f() {
          return process.env.DEBUG;
        }
        function u(p) {
          var h,
            m = process.binding("tty_wrap");
          switch (m.guessHandleType(p)) {
            case "TTY":
              (h = new n.WriteStream(p)),
                (h._type = "tty"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            case "FILE":
              var g = Xt;
              (h = new g.SyncWriteStream(p, { autoClose: !1 })),
                (h._type = "fs");
              break;
            case "PIPE":
            case "TCP":
              var v = ha;
              (h = new v.Socket({ fd: p, readable: !1, writable: !0 })),
                (h.readable = !1),
                (h.read = null),
                (h._type = "pipe"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            default:
              throw new Error("Implement me. Unknown stream file type!");
          }
          return (h.fd = p), (h._isStdio = !0), h;
        }
        function d(p) {
          p.inspectOpts = {};
          for (var h = Object.keys(t.inspectOpts), m = 0; m < h.length; m++)
            p.inspectOpts[h[m]] = t.inspectOpts[h[m]];
        }
        t.enable(f());
      })(Lu, Lu.exports)),
    Lu.exports
  );
}
typeof process < "u" && process.type === "renderer"
  ? (Mg.exports = nN())
  : (Mg.exports = rN());
var ma = Mg.exports;
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var iN = Hi.EventEmitter,
  aN = Xt.ReadStream,
  yI = Kr,
  as = mc,
  ev = sN;
function sN(e, t) {
  return (
    dN(e) ? oN(e) : pN(e) ? lN(e) : uN(e) && e.destroy(),
    fN(e) && t && (e.removeAllListeners("error"), e.addListener("error", hN)),
    e
  );
}
function oN(e) {
  e.destroy(), typeof e.close == "function" && e.on("open", gN);
}
function cN(e) {
  if (e._hadError === !0) {
    var t = e._binding === null ? "_binding" : "_handle";
    e[t] = {
      close: function () {
        this[t] = null;
      },
    };
  }
  e.close();
}
function lN(e) {
  typeof e.destroy == "function"
    ? e._binding
      ? (e.destroy(),
        e._processing
          ? ((e._needDrain = !0), e.once("drain", mN))
          : e._binding.clear())
      : e._destroy && e._destroy !== yI.Transform.prototype._destroy
      ? e.destroy()
      : e._destroy && typeof e.close == "function"
      ? ((e.destroyed = !0), e.close())
      : e.destroy()
    : typeof e.close == "function" && cN(e);
}
function uN(e) {
  return e instanceof yI && typeof e.destroy == "function";
}
function fN(e) {
  return e instanceof iN;
}
function dN(e) {
  return e instanceof aN;
}
function pN(e) {
  return (
    e instanceof as.Gzip ||
    e instanceof as.Gunzip ||
    e instanceof as.Deflate ||
    e instanceof as.DeflateRaw ||
    e instanceof as.Inflate ||
    e instanceof as.InflateRaw ||
    e instanceof as.Unzip
  );
}
function hN() {}
function mN() {
  this._binding.clear();
}
function gN() {
  typeof this.fd == "number" && this.close();
}
var ih = { exports: {} },
  ah,
  T1;
function Xa() {
  if (T1) return ah;
  T1 = 1;
  var e = ks,
    t = e.Buffer,
    n = {},
    r;
  for (r in e)
    e.hasOwnProperty(r) &&
      (r === "SlowBuffer" || r === "Buffer" || (n[r] = e[r]));
  var i = (n.Buffer = {});
  for (r in t)
    t.hasOwnProperty(r) &&
      (r === "allocUnsafe" || r === "allocUnsafeSlow" || (i[r] = t[r]));
  if (
    ((n.Buffer.prototype = t.prototype),
    (!i.from || i.from === Uint8Array.from) &&
      (i.from = function (a, s, o) {
        if (typeof a == "number")
          throw new TypeError(
            'The "value" argument must not be of type number. Received type ' +
              typeof a,
          );
        if (a && typeof a.length > "u")
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
              typeof a,
          );
        return t(a, s, o);
      }),
    i.alloc ||
      (i.alloc = function (a, s, o) {
        if (typeof a != "number")
          throw new TypeError(
            'The "size" argument must be of type number. Received type ' +
              typeof a,
          );
        if (a < 0 || a >= 2 * (1 << 30))
          throw new RangeError(
            'The value "' + a + '" is invalid for option "size"',
          );
        var c = t(a);
        return (
          !s || s.length === 0
            ? c.fill(0)
            : typeof o == "string"
            ? c.fill(s, o)
            : c.fill(s),
          c
        );
      }),
    !n.kStringMaxLength)
  )
    try {
      n.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch {}
  return (
    n.constants ||
      ((n.constants = { MAX_LENGTH: n.kMaxLength }),
      n.kStringMaxLength &&
        (n.constants.MAX_STRING_LENGTH = n.kStringMaxLength)),
    (ah = n),
    ah
  );
}
var Bu = {},
  N1;
function vN() {
  if (N1) return Bu;
  N1 = 1;
  var e = "\uFEFF";
  Bu.PrependBOM = t;
  function t(r, i) {
    (this.encoder = r), (this.addBOM = !0);
  }
  (t.prototype.write = function (r) {
    return (
      this.addBOM && ((r = e + r), (this.addBOM = !1)), this.encoder.write(r)
    );
  }),
    (t.prototype.end = function () {
      return this.encoder.end();
    }),
    (Bu.StripBOM = n);
  function n(r, i) {
    (this.decoder = r), (this.pass = !1), (this.options = i || {});
  }
  return (
    (n.prototype.write = function (r) {
      var i = this.decoder.write(r);
      return (
        this.pass ||
          !i ||
          (i[0] === e &&
            ((i = i.slice(1)),
            typeof this.options.stripBOM == "function" &&
              this.options.stripBOM()),
          (this.pass = !0)),
        i
      );
    }),
    (n.prototype.end = function () {
      return this.decoder.end();
    }),
    Bu
  );
}
var sh = {},
  oh,
  O1;
function yN() {
  if (O1) return oh;
  O1 = 1;
  var e = Xa().Buffer;
  oh = {
    utf8: { type: "_internal", bomAware: !0 },
    cesu8: { type: "_internal", bomAware: !0 },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: !0 },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    _internal: t,
  };
  function t(c, l) {
    (this.enc = c.encodingName),
      (this.bomAware = c.bomAware),
      this.enc === "base64"
        ? (this.encoder = a)
        : this.enc === "cesu8" &&
          ((this.enc = "utf8"),
          (this.encoder = s),
          e.from("eda0bdedb2a9", "hex").toString() !== "ðŸ’©" &&
            ((this.decoder = o),
            (this.defaultCharUnicode = l.defaultCharUnicode)));
  }
  (t.prototype.encoder = i), (t.prototype.decoder = r);
  var n = dI.StringDecoder;
  n.prototype.end || (n.prototype.end = function () {});
  function r(c, l) {
    n.call(this, l.enc);
  }
  r.prototype = n.prototype;
  function i(c, l) {
    this.enc = l.enc;
  }
  (i.prototype.write = function (c) {
    return e.from(c, this.enc);
  }),
    (i.prototype.end = function () {});
  function a(c, l) {
    this.prevStr = "";
  }
  (a.prototype.write = function (c) {
    c = this.prevStr + c;
    var l = c.length - (c.length % 4);
    return (
      (this.prevStr = c.slice(l)), (c = c.slice(0, l)), e.from(c, "base64")
    );
  }),
    (a.prototype.end = function () {
      return e.from(this.prevStr, "base64");
    });
  function s(c, l) {}
  (s.prototype.write = function (c) {
    for (var l = e.alloc(c.length * 3), f = 0, u = 0; u < c.length; u++) {
      var d = c.charCodeAt(u);
      d < 128
        ? (l[f++] = d)
        : d < 2048
        ? ((l[f++] = 192 + (d >>> 6)), (l[f++] = 128 + (d & 63)))
        : ((l[f++] = 224 + (d >>> 12)),
          (l[f++] = 128 + ((d >>> 6) & 63)),
          (l[f++] = 128 + (d & 63)));
    }
    return l.slice(0, f);
  }),
    (s.prototype.end = function () {});
  function o(c, l) {
    (this.acc = 0),
      (this.contBytes = 0),
      (this.accBytes = 0),
      (this.defaultCharUnicode = l.defaultCharUnicode);
  }
  return (
    (o.prototype.write = function (c) {
      for (
        var l = this.acc, f = this.contBytes, u = this.accBytes, d = "", p = 0;
        p < c.length;
        p++
      ) {
        var h = c[p];
        (h & 192) !== 128
          ? (f > 0 && ((d += this.defaultCharUnicode), (f = 0)),
            h < 128
              ? (d += String.fromCharCode(h))
              : h < 224
              ? ((l = h & 31), (f = 1), (u = 1))
              : h < 240
              ? ((l = h & 15), (f = 2), (u = 1))
              : (d += this.defaultCharUnicode))
          : f > 0
          ? ((l = (l << 6) | (h & 63)),
            f--,
            u++,
            f === 0 &&
              (u === 2 && l < 128 && l > 0
                ? (d += this.defaultCharUnicode)
                : u === 3 && l < 2048
                ? (d += this.defaultCharUnicode)
                : (d += String.fromCharCode(l))))
          : (d += this.defaultCharUnicode);
      }
      return (this.acc = l), (this.contBytes = f), (this.accBytes = u), d;
    }),
    (o.prototype.end = function () {
      var c = 0;
      return this.contBytes > 0 && (c += this.defaultCharUnicode), c;
    }),
    oh
  );
}
var Uu = {},
  P1;
function bN() {
  if (P1) return Uu;
  P1 = 1;
  var e = Xa().Buffer;
  Uu.utf16be = t;
  function t() {}
  (t.prototype.encoder = n),
    (t.prototype.decoder = r),
    (t.prototype.bomAware = !0);
  function n() {}
  (n.prototype.write = function (c) {
    for (var l = e.from(c, "ucs2"), f = 0; f < l.length; f += 2) {
      var u = l[f];
      (l[f] = l[f + 1]), (l[f + 1] = u);
    }
    return l;
  }),
    (n.prototype.end = function () {});
  function r() {
    this.overflowByte = -1;
  }
  (r.prototype.write = function (c) {
    if (c.length == 0) return "";
    var l = e.alloc(c.length + 1),
      f = 0,
      u = 0;
    for (
      this.overflowByte !== -1 &&
      ((l[0] = c[0]), (l[1] = this.overflowByte), (f = 1), (u = 2));
      f < c.length - 1;
      f += 2, u += 2
    )
      (l[u] = c[f + 1]), (l[u + 1] = c[f]);
    return (
      (this.overflowByte = f == c.length - 1 ? c[c.length - 1] : -1),
      l.slice(0, u).toString("ucs2")
    );
  }),
    (r.prototype.end = function () {}),
    (Uu.utf16 = i);
  function i(c, l) {
    this.iconv = l;
  }
  (i.prototype.encoder = a), (i.prototype.decoder = s);
  function a(c, l) {
    (c = c || {}),
      c.addBOM === void 0 && (c.addBOM = !0),
      (this.encoder = l.iconv.getEncoder("utf-16le", c));
  }
  (a.prototype.write = function (c) {
    return this.encoder.write(c);
  }),
    (a.prototype.end = function () {
      return this.encoder.end();
    });
  function s(c, l) {
    (this.decoder = null),
      (this.initialBytes = []),
      (this.initialBytesLen = 0),
      (this.options = c || {}),
      (this.iconv = l.iconv);
  }
  (s.prototype.write = function (c) {
    if (!this.decoder) {
      if (
        (this.initialBytes.push(c),
        (this.initialBytesLen += c.length),
        this.initialBytesLen < 16)
      )
        return "";
      var c = e.concat(this.initialBytes),
        l = o(c, this.options.defaultEncoding);
      (this.decoder = this.iconv.getDecoder(l, this.options)),
        (this.initialBytes.length = this.initialBytesLen = 0);
    }
    return this.decoder.write(c);
  }),
    (s.prototype.end = function () {
      if (!this.decoder) {
        var c = e.concat(this.initialBytes),
          l = o(c, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(l, this.options);
        var f = this.decoder.write(c),
          u = this.decoder.end();
        return u ? f + u : f;
      }
      return this.decoder.end();
    });
  function o(c, l) {
    var f = l || "utf-16le";
    if (c.length >= 2)
      if (c[0] == 254 && c[1] == 255) f = "utf-16be";
      else if (c[0] == 255 && c[1] == 254) f = "utf-16le";
      else {
        for (
          var u = 0, d = 0, p = Math.min(c.length - (c.length % 2), 64), h = 0;
          h < p;
          h += 2
        )
          c[h] === 0 && c[h + 1] !== 0 && d++,
            c[h] !== 0 && c[h + 1] === 0 && u++;
        d > u ? (f = "utf-16be") : d < u && (f = "utf-16le");
      }
    return f;
  }
  return Uu;
}
var Oc = {},
  D1;
function _N() {
  if (D1) return Oc;
  D1 = 1;
  var e = Xa().Buffer;
  (Oc.utf7 = t), (Oc.unicode11utf7 = "utf7");
  function t(m, g) {
    this.iconv = g;
  }
  (t.prototype.encoder = r),
    (t.prototype.decoder = i),
    (t.prototype.bomAware = !0);
  var n = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function r(m, g) {
    this.iconv = g.iconv;
  }
  (r.prototype.write = function (m) {
    return e.from(
      m.replace(
        n,
        function (g) {
          return (
            "+" +
            (g === "+"
              ? ""
              : this.iconv
                  .encode(g, "utf16-be")
                  .toString("base64")
                  .replace(/=+$/, "")) +
            "-"
          );
        }.bind(this),
      ),
    );
  }),
    (r.prototype.end = function () {});
  function i(m, g) {
    (this.iconv = g.iconv), (this.inBase64 = !1), (this.base64Accum = "");
  }
  for (var a = /[A-Za-z0-9\/+]/, s = [], o = 0; o < 256; o++)
    s[o] = a.test(String.fromCharCode(o));
  var c = "+".charCodeAt(0),
    l = "-".charCodeAt(0),
    f = "&".charCodeAt(0);
  (i.prototype.write = function (m) {
    for (
      var g = "", v = 0, y = this.inBase64, _ = this.base64Accum, E = 0;
      E < m.length;
      E++
    )
      if (!y)
        m[E] == c &&
          ((g += this.iconv.decode(m.slice(v, E), "ascii")),
          (v = E + 1),
          (y = !0));
      else if (!s[m[E]]) {
        if (E == v && m[E] == l) g += "+";
        else {
          var R = _ + m.slice(v, E).toString();
          g += this.iconv.decode(e.from(R, "base64"), "utf16-be");
        }
        m[E] != l && E--, (v = E + 1), (y = !1), (_ = "");
      }
    if (!y) g += this.iconv.decode(m.slice(v), "ascii");
    else {
      var R = _ + m.slice(v).toString(),
        A = R.length - (R.length % 8);
      (_ = R.slice(A)),
        (R = R.slice(0, A)),
        (g += this.iconv.decode(e.from(R, "base64"), "utf16-be"));
    }
    return (this.inBase64 = y), (this.base64Accum = _), g;
  }),
    (i.prototype.end = function () {
      var m = "";
      return (
        this.inBase64 &&
          this.base64Accum.length > 0 &&
          (m = this.iconv.decode(
            e.from(this.base64Accum, "base64"),
            "utf16-be",
          )),
        (this.inBase64 = !1),
        (this.base64Accum = ""),
        m
      );
    }),
    (Oc.utf7imap = u);
  function u(m, g) {
    this.iconv = g;
  }
  (u.prototype.encoder = d),
    (u.prototype.decoder = p),
    (u.prototype.bomAware = !0);
  function d(m, g) {
    (this.iconv = g.iconv),
      (this.inBase64 = !1),
      (this.base64Accum = e.alloc(6)),
      (this.base64AccumIdx = 0);
  }
  (d.prototype.write = function (m) {
    for (
      var g = this.inBase64,
        v = this.base64Accum,
        y = this.base64AccumIdx,
        _ = e.alloc(m.length * 5 + 10),
        E = 0,
        R = 0;
      R < m.length;
      R++
    ) {
      var A = m.charCodeAt(R);
      32 <= A && A <= 126
        ? (g &&
            (y > 0 &&
              ((E += _.write(
                v
                  .slice(0, y)
                  .toString("base64")
                  .replace(/\//g, ",")
                  .replace(/=+$/, ""),
                E,
              )),
              (y = 0)),
            (_[E++] = l),
            (g = !1)),
          g || ((_[E++] = A), A === f && (_[E++] = l)))
        : (g || ((_[E++] = f), (g = !0)),
          g &&
            ((v[y++] = A >> 8),
            (v[y++] = A & 255),
            y == v.length &&
              ((E += _.write(v.toString("base64").replace(/\//g, ","), E)),
              (y = 0))));
    }
    return (this.inBase64 = g), (this.base64AccumIdx = y), _.slice(0, E);
  }),
    (d.prototype.end = function () {
      var m = e.alloc(10),
        g = 0;
      return (
        this.inBase64 &&
          (this.base64AccumIdx > 0 &&
            ((g += m.write(
              this.base64Accum
                .slice(0, this.base64AccumIdx)
                .toString("base64")
                .replace(/\//g, ",")
                .replace(/=+$/, ""),
              g,
            )),
            (this.base64AccumIdx = 0)),
          (m[g++] = l),
          (this.inBase64 = !1)),
        m.slice(0, g)
      );
    });
  function p(m, g) {
    (this.iconv = g.iconv), (this.inBase64 = !1), (this.base64Accum = "");
  }
  var h = s.slice();
  return (
    (h[",".charCodeAt(0)] = !0),
    (p.prototype.write = function (m) {
      for (
        var g = "", v = 0, y = this.inBase64, _ = this.base64Accum, E = 0;
        E < m.length;
        E++
      )
        if (!y)
          m[E] == f &&
            ((g += this.iconv.decode(m.slice(v, E), "ascii")),
            (v = E + 1),
            (y = !0));
        else if (!h[m[E]]) {
          if (E == v && m[E] == l) g += "&";
          else {
            var R = _ + m.slice(v, E).toString().replace(/,/g, "/");
            g += this.iconv.decode(e.from(R, "base64"), "utf16-be");
          }
          m[E] != l && E--, (v = E + 1), (y = !1), (_ = "");
        }
      if (!y) g += this.iconv.decode(m.slice(v), "ascii");
      else {
        var R = _ + m.slice(v).toString().replace(/,/g, "/"),
          A = R.length - (R.length % 8);
        (_ = R.slice(A)),
          (R = R.slice(0, A)),
          (g += this.iconv.decode(e.from(R, "base64"), "utf16-be"));
      }
      return (this.inBase64 = y), (this.base64Accum = _), g;
    }),
    (p.prototype.end = function () {
      var m = "";
      return (
        this.inBase64 &&
          this.base64Accum.length > 0 &&
          (m = this.iconv.decode(
            e.from(this.base64Accum, "base64"),
            "utf16-be",
          )),
        (this.inBase64 = !1),
        (this.base64Accum = ""),
        m
      );
    }),
    Oc
  );
}
var ch = {},
  L1;
function EN() {
  if (L1) return ch;
  L1 = 1;
  var e = Xa().Buffer;
  ch._sbcs = t;
  function t(i, a) {
    if (!i) throw new Error("SBCS codec is called without the data.");
    if (!i.chars || (i.chars.length !== 128 && i.chars.length !== 256))
      throw new Error(
        "Encoding '" +
          i.type +
          "' has incorrect 'chars' (must be of len 128 or 256)",
      );
    if (i.chars.length === 128) {
      for (var s = "", o = 0; o < 128; o++) s += String.fromCharCode(o);
      i.chars = s + i.chars;
    }
    this.decodeBuf = e.from(i.chars, "ucs2");
    for (
      var c = e.alloc(65536, a.defaultCharSingleByte.charCodeAt(0)), o = 0;
      o < i.chars.length;
      o++
    )
      c[i.chars.charCodeAt(o)] = o;
    this.encodeBuf = c;
  }
  (t.prototype.encoder = n), (t.prototype.decoder = r);
  function n(i, a) {
    this.encodeBuf = a.encodeBuf;
  }
  (n.prototype.write = function (i) {
    for (var a = e.alloc(i.length), s = 0; s < i.length; s++)
      a[s] = this.encodeBuf[i.charCodeAt(s)];
    return a;
  }),
    (n.prototype.end = function () {});
  function r(i, a) {
    this.decodeBuf = a.decodeBuf;
  }
  return (
    (r.prototype.write = function (i) {
      for (
        var a = this.decodeBuf, s = e.alloc(i.length * 2), o = 0, c = 0, l = 0;
        l < i.length;
        l++
      )
        (o = i[l] * 2), (c = l * 2), (s[c] = a[o]), (s[c + 1] = a[o + 1]);
      return s.toString("ucs2");
    }),
    (r.prototype.end = function () {}),
    ch
  );
}
var lh, B1;
function wN() {
  return (
    B1 ||
      ((B1 = 1),
      (lh = {
        10029: "maccenteuro",
        maccenteuro: {
          type: "_sbcs",
          chars:
            "Ã„Ä€ÄÃ‰Ä„Ã–ÃœÃ¡Ä…ÄŒÃ¤ÄÄ†Ä‡Ã©Å¹ÅºÄŽÃ­ÄÄ’Ä“Ä–Ã³Ä—Ã´Ã¶ÃµÃºÄšÄ›Ã¼â€ Â°Ä˜Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Ä™Â¨â‰ Ä£Ä®Ä¯Äªâ‰¤â‰¥Ä«Ä¶âˆ‚âˆ‘Å‚Ä»Ä¼Ä½Ä¾Ä¹ÄºÅ…Å†ÅƒÂ¬âˆšÅ„Å‡âˆ†Â«Â»â€¦Â ÅˆÅÃ•Å‘ÅŒâ€“â€”â€œâ€â€˜â€™Ã·â—ŠÅÅ”Å•Å˜â€¹â€ºÅ™Å–Å—Å â€šâ€žÅ¡ÅšÅ›ÃÅ¤Å¥ÃÅ½Å¾ÅªÃ“Ã”Å«Å®ÃšÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë‡",
        },
        808: "cp808",
        ibm808: "cp808",
        cp808: {
          type: "_sbcs",
          chars:
            "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–â‚¬â– Â ",
        },
        mik: {
          type: "_sbcs",
          chars:
            "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ””â”´â”¬â”œâ”€â”¼â•£â•‘â•šâ•”â•©â•¦â• â•â•¬â”â–‘â–’â–“â”‚â”¤â„–Â§â•—â•â”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â ",
        },
        ascii8bit: "ascii",
        usascii: "ascii",
        ansix34: "ascii",
        ansix341968: "ascii",
        ansix341986: "ascii",
        csascii: "ascii",
        cp367: "ascii",
        ibm367: "ascii",
        isoir6: "ascii",
        iso646us: "ascii",
        iso646irv: "ascii",
        us: "ascii",
        latin1: "iso88591",
        latin2: "iso88592",
        latin3: "iso88593",
        latin4: "iso88594",
        latin5: "iso88599",
        latin6: "iso885910",
        latin7: "iso885913",
        latin8: "iso885914",
        latin9: "iso885915",
        latin10: "iso885916",
        csisolatin1: "iso88591",
        csisolatin2: "iso88592",
        csisolatin3: "iso88593",
        csisolatin4: "iso88594",
        csisolatincyrillic: "iso88595",
        csisolatinarabic: "iso88596",
        csisolatingreek: "iso88597",
        csisolatinhebrew: "iso88598",
        csisolatin5: "iso88599",
        csisolatin6: "iso885910",
        l1: "iso88591",
        l2: "iso88592",
        l3: "iso88593",
        l4: "iso88594",
        l5: "iso88599",
        l6: "iso885910",
        l7: "iso885913",
        l8: "iso885914",
        l9: "iso885915",
        l10: "iso885916",
        isoir14: "iso646jp",
        isoir57: "iso646cn",
        isoir100: "iso88591",
        isoir101: "iso88592",
        isoir109: "iso88593",
        isoir110: "iso88594",
        isoir144: "iso88595",
        isoir127: "iso88596",
        isoir126: "iso88597",
        isoir138: "iso88598",
        isoir148: "iso88599",
        isoir157: "iso885910",
        isoir166: "tis620",
        isoir179: "iso885913",
        isoir199: "iso885914",
        isoir203: "iso885915",
        isoir226: "iso885916",
        cp819: "iso88591",
        ibm819: "iso88591",
        cyrillic: "iso88595",
        arabic: "iso88596",
        arabic8: "iso88596",
        ecma114: "iso88596",
        asmo708: "iso88596",
        greek: "iso88597",
        greek8: "iso88597",
        ecma118: "iso88597",
        elot928: "iso88597",
        hebrew: "iso88598",
        hebrew8: "iso88598",
        turkish: "iso88599",
        turkish8: "iso88599",
        thai: "iso885911",
        thai8: "iso885911",
        celtic: "iso885914",
        celtic8: "iso885914",
        isoceltic: "iso885914",
        tis6200: "tis620",
        tis62025291: "tis620",
        tis62025330: "tis620",
        1e4: "macroman",
        10006: "macgreek",
        10007: "maccyrillic",
        10079: "maciceland",
        10081: "macturkish",
        cspc8codepage437: "cp437",
        cspc775baltic: "cp775",
        cspc850multilingual: "cp850",
        cspcp852: "cp852",
        cspc862latinhebrew: "cp862",
        cpgr: "cp869",
        msee: "cp1250",
        mscyrl: "cp1251",
        msansi: "cp1252",
        msgreek: "cp1253",
        msturk: "cp1254",
        mshebr: "cp1255",
        msarab: "cp1256",
        winbaltrim: "cp1257",
        cp20866: "koi8r",
        20866: "koi8r",
        ibm878: "koi8r",
        cskoi8r: "koi8r",
        cp21866: "koi8u",
        21866: "koi8u",
        ibm1168: "koi8u",
        strk10482002: "rk1048",
        tcvn5712: "tcvn",
        tcvn57121: "tcvn",
        gb198880: "iso646cn",
        cn: "iso646cn",
        csiso14jisc6220ro: "iso646jp",
        jisc62201969ro: "iso646jp",
        jp: "iso646jp",
        cshproman8: "hproman8",
        r8: "hproman8",
        roman8: "hproman8",
        xroman8: "hproman8",
        ibm1051: "hproman8",
        mac: "macintosh",
        csmacintosh: "macintosh",
      })),
    lh
  );
}
var uh, U1;
function xN() {
  return (
    U1 ||
      ((U1 = 1),
      (uh = {
        437: "cp437",
        737: "cp737",
        775: "cp775",
        850: "cp850",
        852: "cp852",
        855: "cp855",
        856: "cp856",
        857: "cp857",
        858: "cp858",
        860: "cp860",
        861: "cp861",
        862: "cp862",
        863: "cp863",
        864: "cp864",
        865: "cp865",
        866: "cp866",
        869: "cp869",
        874: "windows874",
        922: "cp922",
        1046: "cp1046",
        1124: "cp1124",
        1125: "cp1125",
        1129: "cp1129",
        1133: "cp1133",
        1161: "cp1161",
        1162: "cp1162",
        1163: "cp1163",
        1250: "windows1250",
        1251: "windows1251",
        1252: "windows1252",
        1253: "windows1253",
        1254: "windows1254",
        1255: "windows1255",
        1256: "windows1256",
        1257: "windows1257",
        1258: "windows1258",
        28591: "iso88591",
        28592: "iso88592",
        28593: "iso88593",
        28594: "iso88594",
        28595: "iso88595",
        28596: "iso88596",
        28597: "iso88597",
        28598: "iso88598",
        28599: "iso88599",
        28600: "iso885910",
        28601: "iso885911",
        28603: "iso885913",
        28604: "iso885914",
        28605: "iso885915",
        28606: "iso885916",
        windows874: {
          type: "_sbcs",
          chars:
            "â‚¬ï¿½ï¿½ï¿½ï¿½â€¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½",
        },
        win874: "windows874",
        cp874: "windows874",
        windows1250: {
          type: "_sbcs",
          chars:
            "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°Å â€¹ÅšÅ¤Å½Å¹ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Å¡â€ºÅ›Å¥Å¾ÅºÂ Ë‡Ë˜ÅÂ¤Ä„Â¦Â§Â¨Â©ÅžÂ«Â¬Â­Â®Å»Â°Â±Ë›Å‚Â´ÂµÂ¶Â·Â¸Ä…ÅŸÂ»Ä½ËÄ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™",
        },
        win1250: "windows1250",
        cp1250: "windows1250",
        windows1251: {
          type: "_sbcs",
          chars:
            "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÐŒÐ‹ÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÑœÑ›ÑŸÂ ÐŽÑžÐˆÂ¤ÒÂ¦Â§ÐÂ©Ð„Â«Â¬Â­Â®Ð‡Â°Â±Ð†Ñ–Ò‘ÂµÂ¶Â·Ñ‘â„–Ñ”Â»Ñ˜Ð…Ñ•Ñ—ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ",
        },
        win1251: "windows1251",
        cp1251: "windows1251",
        windows1252: {
          type: "_sbcs",
          chars:
            "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½Å½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½Å¾Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿",
        },
        win1252: "windows1252",
        cp1252: "windows1252",
        windows1253: {
          type: "_sbcs",
          chars:
            "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Î…Î†Â£Â¤Â¥Â¦Â§Â¨Â©ï¿½Â«Â¬Â­Â®â€•Â°Â±Â²Â³Î„ÂµÂ¶Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½",
        },
        win1253: "windows1253",
        cp1253: "windows1253",
        windows1254: {
          type: "_sbcs",
          chars:
            "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿",
        },
        win1254: "windows1254",
        cp1254: "windows1254",
        windows1255: {
          type: "_sbcs",
          chars:
            "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Â¡Â¢Â£â‚ªÂ¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾Â¿Ö°Ö±Ö²Ö³Ö´ÖµÖ¶Ö·Ö¸Ö¹ÖºÖ»Ö¼Ö½Ö¾Ö¿×€××‚×ƒ×°×±×²×³×´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½",
        },
        win1255: "windows1255",
        cp1255: "windows1255",
        windows1256: {
          type: "_sbcs",
          chars:
            "â‚¬Ù¾â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Ù¹â€¹Å’Ú†Ú˜ÚˆÚ¯â€˜â€™â€œâ€â€¢â€“â€”Ú©â„¢Ú‘â€ºÅ“â€Œâ€ÚºÂ ØŒÂ¢Â£Â¤Â¥Â¦Â§Â¨Â©Ú¾Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ø›Â»Â¼Â½Â¾ØŸÛØ¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ã—Ø·Ø¸Ø¹ØºÙ€ÙÙ‚ÙƒÃ Ù„Ã¢Ù…Ù†Ù‡ÙˆÃ§Ã¨Ã©ÃªÃ«Ù‰ÙŠÃ®Ã¯Ù‹ÙŒÙÙŽÃ´ÙÙÃ·Ù‘Ã¹Ù’Ã»Ã¼â€Žâ€Û’",
        },
        win1256: "windows1256",
        cp1256: "windows1256",
        windows1257: {
          type: "_sbcs",
          chars:
            "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½Â¨Ë‡Â¸ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½Â¯Ë›ï¿½Â ï¿½Â¢Â£Â¤ï¿½Â¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³Â´ÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾Ë™",
        },
        win1257: "windows1257",
        cp1257: "windows1257",
        windows1258: {
          type: "_sbcs",
          chars:
            "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿",
        },
        win1258: "windows1258",
        cp1258: "windows1258",
        iso88591: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿",
        },
        cp28591: "iso88591",
        iso88592: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ë˜ÅÂ¤Ä½ÅšÂ§Â¨Å ÅžÅ¤Å¹Â­Å½Å»Â°Ä…Ë›Å‚Â´Ä¾Å›Ë‡Â¸Å¡ÅŸÅ¥ÅºËÅ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™",
        },
        cp28592: "iso88592",
        iso88593: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä¦Ë˜Â£Â¤ï¿½Ä¤Â§Â¨Ä°ÅžÄžÄ´Â­ï¿½Å»Â°Ä§Â²Â³Â´ÂµÄ¥Â·Â¸Ä±ÅŸÄŸÄµÂ½ï¿½Å¼Ã€ÃÃ‚ï¿½Ã„ÄŠÄˆÃ‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃï¿½Ã‘Ã’Ã“Ã”Ä Ã–Ã—ÄœÃ™ÃšÃ›ÃœÅ¬ÅœÃŸÃ Ã¡Ã¢ï¿½Ã¤Ä‹Ä‰Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ï¿½Ã±Ã²Ã³Ã´Ä¡Ã¶Ã·ÄÃ¹ÃºÃ»Ã¼Å­ÅË™",
        },
        cp28593: "iso88593",
        iso88594: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä¸Å–Â¤Ä¨Ä»Â§Â¨Å Ä’Ä¢Å¦Â­Å½Â¯Â°Ä…Ë›Å—Â´Ä©Ä¼Ë‡Â¸Å¡Ä“Ä£Å§ÅŠÅ¾Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÄªÄÅ…ÅŒÄ¶Ã”Ã•Ã–Ã—Ã˜Å²ÃšÃ›ÃœÅ¨ÅªÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ä«Ä‘Å†ÅÄ·Ã´ÃµÃ¶Ã·Ã¸Å³ÃºÃ»Ã¼Å©Å«Ë™",
        },
        cp28594: "iso88594",
        iso88595: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ÐÐ‚ÐƒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ñ“Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ",
        },
        cp28595: "iso88595",
        iso88596: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½ï¿½ï¿½Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ØŒÂ­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ø›ï¿½ï¿½ï¿½ØŸï¿½Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹Øºï¿½ï¿½ï¿½ï¿½ï¿½Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½",
        },
        cp28596: "iso88596",
        iso88597: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ â€˜â€™Â£â‚¬â‚¯Â¦Â§Â¨Â©ÍºÂ«Â¬Â­ï¿½â€•Â°Â±Â²Â³Î„Î…Î†Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½",
        },
        cp28597: "iso88597",
        iso88598: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½Â¢Â£Â¤Â¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€—××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½",
        },
        cp28598: "iso88598",
        iso88599: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿",
        },
        cp28599: "iso88599",
        iso885910: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä’Ä¢ÄªÄ¨Ä¶Â§Ä»ÄÅ Å¦Å½Â­ÅªÅŠÂ°Ä…Ä“Ä£Ä«Ä©Ä·Â·Ä¼Ä‘Å¡Å§Å¾â€•Å«Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÃÃÅ…ÅŒÃ“Ã”Ã•Ã–Å¨Ã˜Å²ÃšÃ›ÃœÃÃžÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ã¯Ã°Å†ÅÃ³Ã´ÃµÃ¶Å©Ã¸Å³ÃºÃ»Ã¼Ã½Ã¾Ä¸",
        },
        cp28600: "iso885910",
        iso885911: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½",
        },
        cp28601: "iso885911",
        iso885913: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ â€Â¢Â£Â¤â€žÂ¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³â€œÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾â€™",
        },
        cp28603: "iso885913",
        iso885914: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ á¸‚á¸ƒÂ£ÄŠÄ‹á¸ŠÂ§áº€Â©áº‚á¸‹á»²Â­Â®Å¸á¸žá¸ŸÄ Ä¡á¹€á¹Â¶á¹–áºá¹—áºƒá¹ á»³áº„áº…á¹¡Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ´Ã‘Ã’Ã“Ã”Ã•Ã–á¹ªÃ˜Ã™ÃšÃ›ÃœÃÅ¶ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÅµÃ±Ã²Ã³Ã´ÃµÃ¶á¹«Ã¸Ã¹ÃºÃ»Ã¼Ã½Å·Ã¿",
        },
        cp28604: "iso885914",
        iso885915: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£â‚¬Â¥Å Â§Å¡Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å½ÂµÂ¶Â·Å¾Â¹ÂºÂ»Å’Å“Å¸Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿",
        },
        cp28605: "iso885915",
        iso885916: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä…Åâ‚¬â€žÅ Â§Å¡Â©È˜Â«Å¹Â­ÅºÅ»Â°Â±ÄŒÅ‚Å½â€Â¶Â·Å¾ÄÈ™Â»Å’Å“Å¸Å¼Ã€ÃÃ‚Ä‚Ã„Ä†Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄÅƒÃ’Ã“Ã”ÅÃ–ÅšÅ°Ã™ÃšÃ›ÃœÄ˜ÈšÃŸÃ Ã¡Ã¢ÄƒÃ¤Ä‡Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ä‘Å„Ã²Ã³Ã´Å‘Ã¶Å›Å±Ã¹ÃºÃ»Ã¼Ä™È›Ã¿",
        },
        cp28606: "iso885916",
        cp437: {
          type: "_sbcs",
          chars:
            "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â ",
        },
        ibm437: "cp437",
        csibm437: "cp437",
        cp737: {
          type: "_sbcs",
          chars:
            "Î‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Ï…Ï†Ï‡Ïˆâ–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ï‰Î¬Î­Î®ÏŠÎ¯ÏŒÏÏ‹ÏŽÎ†ÎˆÎ‰ÎŠÎŒÎŽÎÂ±â‰¥â‰¤ÎªÎ«Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â ",
        },
        ibm737: "cp737",
        csibm737: "cp737",
        cp775: {
          type: "_sbcs",
          chars:
            "Ä†Ã¼Ã©ÄÃ¤Ä£Ã¥Ä‡Å‚Ä“Å–Å—Ä«Å¹Ã„Ã…Ã‰Ã¦Ã†ÅÃ¶Ä¢Â¢ÅšÅ›Ã–ÃœÃ¸Â£Ã˜Ã—Â¤Ä€ÄªÃ³Å»Å¼Åºâ€Â¦Â©Â®Â¬Â½Â¼ÅÂ«Â»â–‘â–’â–“â”‚â”¤Ä„ÄŒÄ˜Ä–â•£â•‘â•—â•Ä®Å â”â””â”´â”¬â”œâ”€â”¼Å²Åªâ•šâ•”â•©â•¦â• â•â•¬Å½Ä…ÄÄ™Ä—Ä¯Å¡Å³Å«Å¾â”˜â”Œâ–ˆâ–„â–Œâ–â–€Ã“ÃŸÅŒÅƒÃµÃ•ÂµÅ„Ä¶Ä·Ä»Ä¼Å†Ä’Å…â€™Â­Â±â€œÂ¾Â¶Â§Ã·â€žÂ°âˆ™Â·Â¹Â³Â²â– Â ",
        },
        ibm775: "cp775",
        csibm775: "cp775",
        cp850: {
          type: "_sbcs",
          chars:
            "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹ÃˆÄ±ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â ",
        },
        ibm850: "cp850",
        csibm850: "cp850",
        cp852: {
          type: "_sbcs",
          chars:
            "Ã‡Ã¼Ã©Ã¢Ã¤Å¯Ä‡Ã§Å‚Ã«ÅÅ‘Ã®Å¹Ã„Ä†Ã‰Ä¹ÄºÃ´Ã¶Ä½Ä¾ÅšÅ›Ã–ÃœÅ¤Å¥ÅÃ—ÄÃ¡Ã­Ã³ÃºÄ„Ä…Å½Å¾Ä˜Ä™Â¬ÅºÄŒÅŸÂ«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚ÄšÅžâ•£â•‘â•—â•Å»Å¼â”â””â”´â”¬â”œâ”€â”¼Ä‚Äƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ä‘ÄÄŽÃ‹ÄÅ‡ÃÃŽÄ›â”˜â”Œâ–ˆâ–„Å¢Å®â–€Ã“ÃŸÃ”ÅƒÅ„ÅˆÅ Å¡Å”ÃšÅ•Å°Ã½ÃÅ£Â´Â­ËË›Ë‡Ë˜Â§Ã·Â¸Â°Â¨Ë™Å±Å˜Å™â– Â ",
        },
        ibm852: "cp852",
        csibm852: "cp852",
        cp855: {
          type: "_sbcs",
          chars:
            "Ñ’Ð‚Ñ“ÐƒÑ‘ÐÑ”Ð„Ñ•Ð…Ñ–Ð†Ñ—Ð‡Ñ˜ÐˆÑ™Ð‰ÑšÐŠÑ›Ð‹ÑœÐŒÑžÐŽÑŸÐÑŽÐ®ÑŠÐªÐ°ÐÐ±Ð‘Ñ†Ð¦Ð´Ð”ÐµÐ•Ñ„Ð¤Ð³Ð“Â«Â»â–‘â–’â–“â”‚â”¤Ñ…Ð¥Ð¸Ð˜â•£â•‘â•—â•Ð¹Ð™â”â””â”´â”¬â”œâ”€â”¼ÐºÐšâ•šâ•”â•©â•¦â• â•â•¬Â¤Ð»Ð›Ð¼ÐœÐ½ÐÐ¾ÐžÐ¿â”˜â”Œâ–ˆâ–„ÐŸÑâ–€Ð¯Ñ€Ð ÑÐ¡Ñ‚Ð¢ÑƒÐ£Ð¶Ð–Ð²Ð’ÑŒÐ¬â„–Â­Ñ‹Ð«Ð·Ð—ÑˆÐ¨ÑÐ­Ñ‰Ð©Ñ‡Ð§Â§â– Â ",
        },
        ibm855: "cp855",
        csibm855: "cp855",
        cp856: {
          type: "_sbcs",
          chars:
            "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½Â£ï¿½Ã—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â®Â¬Â½Â¼ï¿½Â«Â»â–‘â–’â–“â”‚â”¤ï¿½ï¿½ï¿½Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼ï¿½ï¿½â•šâ•”â•©â•¦â• â•â•¬Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â”˜â”Œâ–ˆâ–„Â¦ï¿½â–€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Âµï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â ",
        },
        ibm856: "cp856",
        csibm856: "cp856",
        cp857: {
          type: "_sbcs",
          chars:
            "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ä±Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ä°Ã–ÃœÃ¸Â£Ã˜ÅžÅŸÃ¡Ã­Ã³ÃºÃ±Ã‘ÄžÄŸÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤ÂºÂªÃŠÃ‹Ãˆï¿½ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•Âµï¿½Ã—ÃšÃ›Ã™Ã¬Ã¿Â¯Â´Â­Â±ï¿½Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â ",
        },
        ibm857: "cp857",
        csibm857: "cp857",
        cp858: {
          type: "_sbcs",
          chars:
            "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹Ãˆâ‚¬ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â ",
        },
        ibm858: "cp858",
        csibm858: "cp858",
        cp860: {
          type: "_sbcs",
          chars:
            "Ã‡Ã¼Ã©Ã¢Ã£Ã ÃÃ§ÃªÃŠÃ¨ÃÃ”Ã¬ÃƒÃ‚Ã‰Ã€ÃˆÃ´ÃµÃ²ÃšÃ¹ÃŒÃ•ÃœÂ¢Â£Ã™â‚§Ã“Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Ã’Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â ",
        },
        ibm860: "cp860",
        csibm860: "cp860",
        cp861: {
          type: "_sbcs",
          chars:
            "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨ÃÃ°ÃžÃ„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã¾Ã»ÃÃ½Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃÃÃ“ÃšÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â ",
        },
        ibm861: "cp861",
        csibm861: "cp861",
        cp862: {
          type: "_sbcs",
          chars:
            "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â ",
        },
        ibm862: "cp862",
        csibm862: "cp862",
        cp863: {
          type: "_sbcs",
          chars:
            "Ã‡Ã¼Ã©Ã¢Ã‚Ã Â¶Ã§ÃªÃ«Ã¨Ã¯Ã®â€—Ã€Â§Ã‰ÃˆÃŠÃ´Ã‹ÃÃ»Ã¹Â¤Ã”ÃœÂ¢Â£Ã™Ã›Æ’Â¦Â´Ã³ÃºÂ¨Â¸Â³Â¯ÃŽâŒÂ¬Â½Â¼Â¾Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â ",
        },
        ibm863: "cp863",
        csibm863: "cp863",
        cp864: {
          type: "_sbcs",
          chars: `\0\x07\b
\v\f\r\x1B !"#$Ùª&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~Â°Â·âˆ™âˆšâ–’â”€â”‚â”¼â”¤â”¬â”œâ”´â”â”Œâ””â”˜Î²âˆžÏ†Â±Â½Â¼â‰ˆÂ«Â»ï»·ï»¸ï¿½ï¿½ï»»ï»¼ï¿½Â Â­ïº‚Â£Â¤ïº„ï¿½ï¿½ïºŽïºïº•ïº™ØŒïºïº¡ïº¥Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ï»‘Ø›ïº±ïºµïº¹ØŸÂ¢ïº€ïºïºƒïº…ï»Šïº‹ïºïº‘ïº“ïº—ïº›ïºŸïº£ïº§ïº©ïº«ïº­ïº¯ïº³ïº·ïº»ïº¿ï»ï»…ï»‹ï»Â¦Â¬Ã·Ã—ï»‰Ù€ï»“ï»—ï»›ï»Ÿï»£ï»§ï»«ï»­ï»¯ï»³ïº½ï»Œï»Žï»ï»¡ï¹½Ù‘ï»¥ï»©ï»¬ï»°ï»²ï»ï»•ï»µï»¶ï»ï»™ï»±â– ï¿½`,
        },
        ibm864: "cp864",
        csibm864: "cp864",
        cp865: {
          type: "_sbcs",
          chars:
            "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â¤â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â ",
        },
        ibm865: "cp865",
        csibm865: "cp865",
        cp866: {
          type: "_sbcs",
          chars:
            "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–Â¤â– Â ",
        },
        ibm866: "cp866",
        csibm866: "cp866",
        cp869: {
          type: "_sbcs",
          chars:
            "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½Â·Â¬Â¦â€˜â€™Îˆâ€•Î‰ÎŠÎªÎŒï¿½ï¿½ÎŽÎ«Â©ÎÂ²Â³Î¬Â£Î­Î®Î¯ÏŠÎÏŒÏÎ‘Î’Î“Î”Î•Î–Î—Â½Î˜Î™Â«Â»â–‘â–’â–“â”‚â”¤ÎšÎ›ÎœÎâ•£â•‘â•—â•ÎžÎŸâ”â””â”´â”¬â”œâ”€â”¼Î Î¡â•šâ•”â•©â•¦â• â•â•¬Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³â”˜â”Œâ–ˆâ–„Î´Îµâ–€Î¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Î„Â­Â±Ï…Ï†Ï‡Â§ÏˆÎ…Â°Â¨Ï‰Ï‹Î°ÏŽâ– Â ",
        },
        ibm869: "cp869",
        csibm869: "cp869",
        cp922: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®â€¾Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ Ã‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÅ½ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Å¡Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Å¾Ã¿",
        },
        ibm922: "cp922",
        csibm922: "cp922",
        cp1046: {
          type: "_sbcs",
          chars:
            "ïºˆÃ—Ã·ï£¶ï£µï£´ï£·ï¹±Âˆâ– â”‚â”€â”â”Œâ””â”˜ï¹¹ï¹»ï¹½ï¹¿ï¹·ïºŠï»°ï»³ï»²ï»Žï»ï»ï»¶ï»¸ï»ºï»¼Â ï£ºï£¹ï£¸Â¤ï£»ïº‹ïº‘ïº—ïº›ïºŸïº£ØŒÂ­ïº§ïº³Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ïº·Ø›ïº»ïº¿ï»ŠØŸï»‹Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·ï»‡Ø¹Øºï»Œïº‚ïº„ïºŽï»“Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï»—ï»›ï»Ÿï£¼ï»µï»·ï»¹ï»»ï»£ï»§ï»¬ï»©ï¿½",
        },
        ibm1046: "cp1046",
        csibm1046: "cp1046",
        cp1124: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ÐÐ‚ÒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ò‘Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ",
        },
        ibm1124: "cp1124",
        csibm1124: "cp1124",
        cp1125: {
          type: "_sbcs",
          chars:
            "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘ÒÒ‘Ð„Ñ”Ð†Ñ–Ð‡Ñ—Â·âˆšâ„–Â¤â– Â ",
        },
        ibm1125: "cp1125",
        csibm1125: "cp1125",
        cp1129: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿",
        },
        ibm1129: "cp1129",
        csibm1129: "cp1129",
        cp1133: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ àºàº‚àº„àº‡àºˆàºªàºŠàºàº”àº•àº–àº—àº™àºšàº›àºœàºàºžàºŸàº¡àº¢àº£àº¥àº§àº«àº­àº®ï¿½ï¿½ï¿½àº¯àº°àº²àº³àº´àºµàº¶àº·àº¸àº¹àº¼àº±àº»àº½ï¿½ï¿½ï¿½à»€à»à»‚à»ƒà»„à»ˆà»‰à»Šà»‹à»Œà»à»†ï¿½à»œà»â‚­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à»à»‘à»’à»“à»”à»•à»–à»—à»˜à»™ï¿½ï¿½Â¢Â¬Â¦ï¿½",
        },
        ibm1133: "cp1133",
        csibm1133: "cp1133",
        cp1161: {
          type: "_sbcs",
          chars:
            "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¹ˆà¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºà¹‰à¹Šà¹‹â‚¬à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›Â¢Â¬Â¦Â ",
        },
        ibm1161: "cp1161",
        csibm1161: "cp1161",
        cp1162: {
          type: "_sbcs",
          chars:
            "â‚¬ÂÂ‚ÂƒÂ„â€¦Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½",
        },
        ibm1162: "cp1162",
        csibm1162: "cp1162",
        cp1163: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£â‚¬Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿",
        },
        ibm1163: "cp1163",
        csibm1163: "cp1163",
        maccroatian: {
          type: "_sbcs",
          chars:
            "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Å â„¢Â´Â¨â‰ Å½Ã˜âˆžÂ±â‰¤â‰¥âˆ†Âµâˆ‚âˆ‘âˆÅ¡âˆ«ÂªÂºâ„¦Å¾Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆÄ†Â«ÄŒâ€¦Â Ã€ÃƒÃ•Å’Å“Äâ€”â€œâ€â€˜â€™Ã·â—Šï¿½Â©â„Â¤â€¹â€ºÃ†Â»â€“Â·â€šâ€žâ€°Ã‚Ä‡ÃÄÃˆÃÃŽÃÃŒÃ“Ã”Ä‘Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ï€Ã‹ËšÂ¸ÃŠÃ¦Ë‡",
        },
        maccyrillic: {
          type: "_sbcs",
          chars:
            "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°Â¢Â£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–Âµâˆ‚ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤",
        },
        macgreek: {
          type: "_sbcs",
          chars:
            "Ã„Â¹Â²Ã‰Â³Ã–ÃœÎ…Ã Ã¢Ã¤Î„Â¨Ã§Ã©Ã¨ÃªÃ«Â£â„¢Ã®Ã¯â€¢Â½â€°Ã´Ã¶Â¦Â­Ã¹Ã»Ã¼â€ Î“Î”Î˜Î›ÎžÎ ÃŸÂ®Â©Î£ÎªÂ§â‰ Â°Î‡Î‘Â±â‰¤â‰¥Â¥Î’Î•Î–Î—Î™ÎšÎœÎ¦Î«Î¨Î©Î¬ÎÂ¬ÎŸÎ¡â‰ˆÎ¤Â«Â»â€¦Â Î¥Î§Î†ÎˆÅ“â€“â€•â€œâ€â€˜â€™Ã·Î‰ÎŠÎŒÎŽÎ­Î®Î¯ÏŒÎÏÎ±Î²ÏˆÎ´ÎµÏ†Î³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿Ï€ÏŽÏÏƒÏ„Î¸Ï‰Ï‚Ï‡Ï…Î¶ÏŠÏ‹ÎÎ°ï¿½",
        },
        maciceland: {
          type: "_sbcs",
          chars:
            "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤ÃÃ°ÃžÃ¾Ã½Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡",
        },
        macroman: {
          type: "_sbcs",
          chars:
            "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡",
        },
        macromania: {
          type: "_sbcs",
          chars:
            "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ä‚ÅžâˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦ÄƒÅŸÂ¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºÅ¢Å£â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡",
        },
        macthai: {
          type: "_sbcs",
          chars:
            "Â«Â»â€¦ï¢Œï¢ï¢’ï¢•ï¢˜ï¢‹ï¢Žï¢‘ï¢”ï¢—â€œâ€ï¢™ï¿½â€¢ï¢„ï¢‰ï¢…ï¢†ï¢‡ï¢ˆï¢Šï¢ï¢ï¢“ï¢–â€˜â€™ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸º\uFEFFâ€‹â€“â€”à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹â„¢à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™Â®Â©ï¿½ï¿½ï¿½ï¿½",
        },
        macturkish: {
          type: "_sbcs",
          chars:
            "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸ÄžÄŸÄ°Ä±ÅžÅŸâ€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™ï¿½Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡",
        },
        macukraine: {
          type: "_sbcs",
          chars:
            "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°ÒÂ£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–ÂµÒ‘ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤",
        },
        koi8r: {
          type: "_sbcs",
          chars:
            "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘â•“â•”â••â•–â•—â•˜â•™â•šâ•›â•œâ•â•žâ•Ÿâ• â•¡Ðâ•¢â•£â•¤â•¥â•¦â•§â•¨â•©â•ªâ•«â•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª",
        },
        koi8u: {
          type: "_sbcs",
          chars:
            "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘â•â•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒâ•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª",
        },
        koi8ru: {
          type: "_sbcs",
          chars:
            "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘Ñžâ•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒÐŽÂ©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª",
        },
        koi8t: {
          type: "_sbcs",
          chars:
            "Ò›Ò“â€šÒ’â€žâ€¦â€ â€¡ï¿½â€°Ò³â€¹Ò²Ò·Ò¶ï¿½Òšâ€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½ï¿½Ó¯Ó®Ñ‘Â¤Ó£Â¦Â§ï¿½ï¿½ï¿½Â«Â¬Â­Â®ï¿½Â°Â±Â²Ðï¿½Ó¢Â¶Â·ï¿½â„–ï¿½Â»ï¿½ï¿½ï¿½Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª",
        },
        armscii8: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½Ö‡Ö‰)(Â»Â«â€”.Õ,-ÖŠâ€¦ÕœÕ›ÕžÔ±Õ¡Ô²Õ¢Ô³Õ£Ô´Õ¤ÔµÕ¥Ô¶Õ¦Ô·Õ§Ô¸Õ¨Ô¹Õ©ÔºÕªÔ»Õ«Ô¼Õ¬Ô½Õ­Ô¾Õ®Ô¿Õ¯Õ€Õ°ÕÕ±Õ‚Õ²ÕƒÕ³Õ„Õ´Õ…ÕµÕ†Õ¶Õ‡Õ·ÕˆÕ¸Õ‰Õ¹ÕŠÕºÕ‹Õ»ÕŒÕ¼ÕÕ½ÕŽÕ¾ÕÕ¿ÕÖ€Õ‘ÖÕ’Ö‚Õ“ÖƒÕ”Ö„Õ•Ö…Õ–Ö†Õšï¿½",
        },
        rk1048: {
          type: "_sbcs",
          chars:
            "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÒšÒºÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÒ›Ò»ÑŸÂ Ò°Ò±Ó˜Â¤Ó¨Â¦Â§ÐÂ©Ò’Â«Â¬Â­Â®Ò®Â°Â±Ð†Ñ–Ó©ÂµÂ¶Â·Ñ‘â„–Ò“Â»Ó™Ò¢Ò£Ò¯ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ",
        },
        tcvn: {
          type: "_sbcs",
          chars: `\0Ãšá»¤á»ªá»¬á»®\x07\b
\v\f\rá»¨á»°á»²á»¶á»¸Ãá»´\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~Ã€áº¢ÃƒÃáº áº¶áº¬Ãˆáººáº¼Ã‰áº¸á»†ÃŒá»ˆÄ¨Ãá»ŠÃ’á»ŽÃ•Ã“á»Œá»˜á»œá»žá» á»šá»¢Ã™á»¦Å¨Â Ä‚Ã‚ÃŠÃ”Æ Æ¯ÄÄƒÃ¢ÃªÃ´Æ¡Æ°Ä‘áº°Ì€Ì‰ÌƒÌÌ£Ã áº£Ã£Ã¡áº¡áº²áº±áº³áºµáº¯áº´áº®áº¦áº¨áºªáº¤á»€áº·áº§áº©áº«áº¥áº­Ã¨á»‚áº»áº½Ã©áº¹á»á»ƒá»…áº¿á»‡Ã¬á»‰á»„áº¾á»’Ä©Ã­á»‹Ã²á»”á»ÃµÃ³á»á»“á»•á»—á»‘á»™á»á»Ÿá»¡á»›á»£Ã¹á»–á»§Å©Ãºá»¥á»«á»­á»¯á»©á»±á»³á»·á»¹Ã½á»µá»`,
        },
        georgianacademy: {
          type: "_sbcs",
          chars:
            "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ¯áƒ°áƒ±áƒ²áƒ³áƒ´áƒµáƒ¶Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿",
        },
        georgianps: {
          type: "_sbcs",
          chars:
            "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ±áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒ²áƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ³áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ´áƒ¯áƒ°áƒµÃ¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿",
        },
        pt154: {
          type: "_sbcs",
          chars:
            "Ò–Ò’Ó®Ò“â€žâ€¦Ò¶Ò®Ò²Ò¯Ò Ó¢Ò¢ÒšÒºÒ¸Ò—â€˜â€™â€œâ€â€¢â€“â€”Ò³Ò·Ò¡Ó£Ò£Ò›Ò»Ò¹Â ÐŽÑžÐˆÓ¨Ò˜Ò°Â§ÐÂ©Ó˜Â«Â¬Ó¯Â®ÒœÂ°Ò±Ð†Ñ–Ò™Ó©Â¶Â·Ñ‘â„–Ó™Â»Ñ˜ÒªÒ«ÒÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ",
        },
        viscii: {
          type: "_sbcs",
          chars: `\0áº²áº´áºª\x07\b
\v\f\rá»¶á»¸\x1Bá»´ !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}~áº áº®áº°áº¶áº¤áº¦áº¨áº¬áº¼áº¸áº¾á»€á»‚á»„á»†á»á»’á»”á»–á»˜á»¢á»šá»œá»žá»Šá»Žá»Œá»ˆá»¦Å¨á»¤á»²Ã•áº¯áº±áº·áº¥áº§áº©áº­áº½áº¹áº¿á»á»ƒá»…á»‡á»‘á»“á»•á»—á» Æ á»™á»á»Ÿá»‹á»°á»¨á»ªá»¬Æ¡á»›Æ¯Ã€ÃÃ‚Ãƒáº¢Ä‚áº³áºµÃˆÃ‰ÃŠáººÃŒÃÄ¨á»³Äá»©Ã’Ã“Ã”áº¡á»·á»«á»­Ã™Ãšá»¹á»µÃá»¡Æ°Ã Ã¡Ã¢Ã£áº£Äƒá»¯áº«Ã¨Ã©Ãªáº»Ã¬Ã­Ä©á»‰Ä‘á»±Ã²Ã³Ã´Ãµá»á»á»¥Ã¹ÃºÅ©á»§Ã½á»£á»®`,
        },
        iso646cn: {
          type: "_sbcs",
          chars: `\0\x07\b
\v\f\r\x1B !"#Â¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`,
        },
        iso646jp: {
          type: "_sbcs",
          chars: `\0\x07\b
\v\f\r\x1B !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[Â¥]^_\`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½`,
        },
        hproman8: {
          type: "_sbcs",
          chars:
            "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ã€Ã‚ÃˆÃŠÃ‹ÃŽÃÂ´Ë‹Ë†Â¨ËœÃ™Ã›â‚¤Â¯ÃÃ½Â°Ã‡Ã§Ã‘Ã±Â¡Â¿Â¤Â£Â¥Â§Æ’Â¢Ã¢ÃªÃ´Ã»Ã¡Ã©Ã³ÃºÃ Ã¨Ã²Ã¹Ã¤Ã«Ã¶Ã¼Ã…Ã®Ã˜Ã†Ã¥Ã­Ã¸Ã¦Ã„Ã¬Ã–ÃœÃ‰Ã¯ÃŸÃ”ÃÃƒÃ£ÃÃ°ÃÃŒÃ“Ã’Ã•ÃµÅ Å¡ÃšÅ¸Ã¿ÃžÃ¾Â·ÂµÂ¶Â¾â€”Â¼Â½ÂªÂºÂ«â– Â»Â±ï¿½",
        },
        macintosh: {
          type: "_sbcs",
          chars:
            "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡",
        },
        ascii: {
          type: "_sbcs",
          chars:
            "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½",
        },
        tis620: {
          type: "_sbcs",
          chars:
            "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½",
        },
      })),
    uh
  );
}
var fh = {},
  F1;
function AN() {
  if (F1) return fh;
  F1 = 1;
  var e = Xa().Buffer;
  fh._dbcs = c;
  for (
    var t = -1, n = -2, r = -10, i = -1e3, a = new Array(256), s = -1, o = 0;
    o < 256;
    o++
  )
    a[o] = t;
  function c(d, p) {
    if (((this.encodingName = d.encodingName), !d))
      throw new Error("DBCS codec is called without the data.");
    if (!d.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var h = d.table();
    (this.decodeTables = []),
      (this.decodeTables[0] = a.slice(0)),
      (this.decodeTableSeq = []);
    for (var m = 0; m < h.length; m++) this._addDecodeChunk(h[m]);
    (this.defaultCharUnicode = p.defaultCharUnicode),
      (this.encodeTable = []),
      (this.encodeTableSeq = []);
    var g = {};
    if (d.encodeSkipVals)
      for (var m = 0; m < d.encodeSkipVals.length; m++) {
        var v = d.encodeSkipVals[m];
        if (typeof v == "number") g[v] = !0;
        else for (var y = v.from; y <= v.to; y++) g[y] = !0;
      }
    if ((this._fillEncodeTable(0, 0, g), d.encodeAdd))
      for (var _ in d.encodeAdd)
        Object.prototype.hasOwnProperty.call(d.encodeAdd, _) &&
          this._setEncodeChar(_.charCodeAt(0), d.encodeAdd[_]);
    if (
      ((this.defCharSB =
        this.encodeTable[0][p.defaultCharSingleByte.charCodeAt(0)]),
      this.defCharSB === t && (this.defCharSB = this.encodeTable[0]["?"]),
      this.defCharSB === t && (this.defCharSB = "?".charCodeAt(0)),
      typeof d.gb18030 == "function")
    ) {
      this.gb18030 = d.gb18030();
      for (
        var E = this.decodeTables.length,
          R = (this.decodeTables[E] = a.slice(0)),
          A = this.decodeTables.length,
          I = (this.decodeTables[A] = a.slice(0)),
          m = 129;
        m <= 254;
        m++
      )
        for (
          var S = i - this.decodeTables[0][m], w = this.decodeTables[S], y = 48;
          y <= 57;
          y++
        )
          w[y] = i - E;
      for (var m = 129; m <= 254; m++) R[m] = i - A;
      for (var m = 48; m <= 57; m++) I[m] = n;
    }
  }
  (c.prototype.encoder = l),
    (c.prototype.decoder = f),
    (c.prototype._getDecodeTrieNode = function (d) {
      for (var p = []; d > 0; d >>= 8) p.push(d & 255);
      p.length == 0 && p.push(0);
      for (var h = this.decodeTables[0], m = p.length - 1; m > 0; m--) {
        var g = h[p[m]];
        if (g == t)
          (h[p[m]] = i - this.decodeTables.length),
            this.decodeTables.push((h = a.slice(0)));
        else if (g <= i) h = this.decodeTables[i - g];
        else
          throw new Error(
            "Overwrite byte in " +
              this.encodingName +
              ", addr: " +
              d.toString(16),
          );
      }
      return h;
    }),
    (c.prototype._addDecodeChunk = function (d) {
      var p = parseInt(d[0], 16),
        h = this._getDecodeTrieNode(p);
      p = p & 255;
      for (var m = 1; m < d.length; m++) {
        var g = d[m];
        if (typeof g == "string")
          for (var v = 0; v < g.length; ) {
            var y = g.charCodeAt(v++);
            if (55296 <= y && y < 56320) {
              var _ = g.charCodeAt(v++);
              if (56320 <= _ && _ < 57344)
                h[p++] = 65536 + (y - 55296) * 1024 + (_ - 56320);
              else
                throw new Error(
                  "Incorrect surrogate pair in " +
                    this.encodingName +
                    " at chunk " +
                    d[0],
                );
            } else if (4080 < y && y <= 4095) {
              for (var E = 4095 - y + 2, R = [], A = 0; A < E; A++)
                R.push(g.charCodeAt(v++));
              (h[p++] = r - this.decodeTableSeq.length),
                this.decodeTableSeq.push(R);
            } else h[p++] = y;
          }
        else if (typeof g == "number")
          for (var I = h[p - 1] + 1, v = 0; v < g; v++) h[p++] = I++;
        else
          throw new Error(
            "Incorrect type '" +
              typeof g +
              "' given in " +
              this.encodingName +
              " at chunk " +
              d[0],
          );
      }
      if (p > 255)
        throw new Error(
          "Incorrect chunk in " +
            this.encodingName +
            " at addr " +
            d[0] +
            ": too long" +
            p,
        );
    }),
    (c.prototype._getEncodeBucket = function (d) {
      var p = d >> 8;
      return (
        this.encodeTable[p] === void 0 && (this.encodeTable[p] = a.slice(0)),
        this.encodeTable[p]
      );
    }),
    (c.prototype._setEncodeChar = function (d, p) {
      var h = this._getEncodeBucket(d),
        m = d & 255;
      h[m] <= r
        ? (this.encodeTableSeq[r - h[m]][s] = p)
        : h[m] == t && (h[m] = p);
    }),
    (c.prototype._setEncodeSequence = function (d, p) {
      var h = d[0],
        m = this._getEncodeBucket(h),
        g = h & 255,
        v;
      m[g] <= r
        ? (v = this.encodeTableSeq[r - m[g]])
        : ((v = {}),
          m[g] !== t && (v[s] = m[g]),
          (m[g] = r - this.encodeTableSeq.length),
          this.encodeTableSeq.push(v));
      for (var y = 1; y < d.length - 1; y++) {
        var _ = v[h];
        typeof _ == "object"
          ? (v = _)
          : ((v = v[h] = {}), _ !== void 0 && (v[s] = _));
      }
      (h = d[d.length - 1]), (v[h] = p);
    }),
    (c.prototype._fillEncodeTable = function (d, p, h) {
      for (var m = this.decodeTables[d], g = 0; g < 256; g++) {
        var v = m[g],
          y = p + g;
        h[y] ||
          (v >= 0
            ? this._setEncodeChar(v, y)
            : v <= i
            ? this._fillEncodeTable(i - v, y << 8, h)
            : v <= r && this._setEncodeSequence(this.decodeTableSeq[r - v], y));
      }
    });
  function l(d, p) {
    (this.leadSurrogate = -1),
      (this.seqObj = void 0),
      (this.encodeTable = p.encodeTable),
      (this.encodeTableSeq = p.encodeTableSeq),
      (this.defaultCharSingleByte = p.defCharSB),
      (this.gb18030 = p.gb18030);
  }
  (l.prototype.write = function (d) {
    for (
      var p = e.alloc(d.length * (this.gb18030 ? 4 : 3)),
        h = this.leadSurrogate,
        m = this.seqObj,
        g = -1,
        v = 0,
        y = 0;
      ;

    ) {
      if (g === -1) {
        if (v == d.length) break;
        var _ = d.charCodeAt(v++);
      } else {
        var _ = g;
        g = -1;
      }
      if (55296 <= _ && _ < 57344)
        if (_ < 56320)
          if (h === -1) {
            h = _;
            continue;
          } else (h = _), (_ = t);
        else
          h !== -1
            ? ((_ = 65536 + (h - 55296) * 1024 + (_ - 56320)), (h = -1))
            : (_ = t);
      else h !== -1 && ((g = _), (_ = t), (h = -1));
      var E = t;
      if (m !== void 0 && _ != t) {
        var R = m[_];
        if (typeof R == "object") {
          m = R;
          continue;
        } else
          typeof R == "number"
            ? (E = R)
            : R == null && ((R = m[s]), R !== void 0 && ((E = R), (g = _)));
        m = void 0;
      } else if (_ >= 0) {
        var A = this.encodeTable[_ >> 8];
        if ((A !== void 0 && (E = A[_ & 255]), E <= r)) {
          m = this.encodeTableSeq[r - E];
          continue;
        }
        if (E == t && this.gb18030) {
          var I = u(this.gb18030.uChars, _);
          if (I != -1) {
            var E = this.gb18030.gbChars[I] + (_ - this.gb18030.uChars[I]);
            (p[y++] = 129 + Math.floor(E / 12600)),
              (E = E % 12600),
              (p[y++] = 48 + Math.floor(E / 1260)),
              (E = E % 1260),
              (p[y++] = 129 + Math.floor(E / 10)),
              (E = E % 10),
              (p[y++] = 48 + E);
            continue;
          }
        }
      }
      E === t && (E = this.defaultCharSingleByte),
        E < 256
          ? (p[y++] = E)
          : E < 65536
          ? ((p[y++] = E >> 8), (p[y++] = E & 255))
          : ((p[y++] = E >> 16), (p[y++] = (E >> 8) & 255), (p[y++] = E & 255));
    }
    return (this.seqObj = m), (this.leadSurrogate = h), p.slice(0, y);
  }),
    (l.prototype.end = function () {
      if (!(this.leadSurrogate === -1 && this.seqObj === void 0)) {
        var d = e.alloc(10),
          p = 0;
        if (this.seqObj) {
          var h = this.seqObj[s];
          h !== void 0 &&
            (h < 256 ? (d[p++] = h) : ((d[p++] = h >> 8), (d[p++] = h & 255))),
            (this.seqObj = void 0);
        }
        return (
          this.leadSurrogate !== -1 &&
            ((d[p++] = this.defaultCharSingleByte), (this.leadSurrogate = -1)),
          d.slice(0, p)
        );
      }
    }),
    (l.prototype.findIdx = u);
  function f(d, p) {
    (this.nodeIdx = 0),
      (this.prevBuf = e.alloc(0)),
      (this.decodeTables = p.decodeTables),
      (this.decodeTableSeq = p.decodeTableSeq),
      (this.defaultCharUnicode = p.defaultCharUnicode),
      (this.gb18030 = p.gb18030);
  }
  (f.prototype.write = function (d) {
    var p = e.alloc(d.length * 2),
      h = this.nodeIdx,
      m = this.prevBuf,
      g = this.prevBuf.length,
      v = -this.prevBuf.length,
      y;
    g > 0 && (m = e.concat([m, d.slice(0, 10)]));
    for (var _ = 0, E = 0; _ < d.length; _++) {
      var R = _ >= 0 ? d[_] : m[_ + g],
        y = this.decodeTables[h][R];
      if (!(y >= 0))
        if (y === t) (_ = v), (y = this.defaultCharUnicode.charCodeAt(0));
        else if (y === n) {
          var A = v >= 0 ? d.slice(v, _ + 1) : m.slice(v + g, _ + 1 + g),
            I =
              (A[0] - 129) * 12600 +
              (A[1] - 48) * 1260 +
              (A[2] - 129) * 10 +
              (A[3] - 48),
            S = u(this.gb18030.gbChars, I);
          y = this.gb18030.uChars[S] + I - this.gb18030.gbChars[S];
        } else if (y <= i) {
          h = i - y;
          continue;
        } else if (y <= r) {
          for (var w = this.decodeTableSeq[r - y], O = 0; O < w.length - 1; O++)
            (y = w[O]), (p[E++] = y & 255), (p[E++] = y >> 8);
          y = w[w.length - 1];
        } else
          throw new Error(
            "iconv-lite internal error: invalid decoding table value " +
              y +
              " at " +
              h +
              "/" +
              R,
          );
      if (y > 65535) {
        y -= 65536;
        var Q = 55296 + Math.floor(y / 1024);
        (p[E++] = Q & 255), (p[E++] = Q >> 8), (y = 56320 + (y % 1024));
      }
      (p[E++] = y & 255), (p[E++] = y >> 8), (h = 0), (v = _ + 1);
    }
    return (
      (this.nodeIdx = h),
      (this.prevBuf = v >= 0 ? d.slice(v) : m.slice(v + g)),
      p.slice(0, E).toString("ucs2")
    );
  }),
    (f.prototype.end = function () {
      for (var d = ""; this.prevBuf.length > 0; ) {
        d += this.defaultCharUnicode;
        var p = this.prevBuf.slice(1);
        (this.prevBuf = e.alloc(0)),
          (this.nodeIdx = 0),
          p.length > 0 && (d += this.write(p));
      }
      return (this.nodeIdx = 0), d;
    });
  function u(d, p) {
    if (d[0] > p) return -1;
    for (var h = 0, m = d.length; h < m - 1; ) {
      var g = h + Math.floor((m - h + 1) / 2);
      d[g] <= p ? (h = g) : (m = g);
    }
    return h;
  }
  return fh;
}
const SN = [
    ["0", "\0", 128],
    ["a1", "ï½¡", 62],
    [
      "8140",
      "ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
      9,
      "ï¼‹ï¼Â±Ã—",
    ],
    ["8180", "Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"],
    ["81b8", "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"],
    ["81c8", "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"],
    ["81da", "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"],
    ["81f0", "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"],
    ["81fc", "â—¯"],
    ["824f", "ï¼", 9],
    ["8260", "ï¼¡", 25],
    ["8281", "ï½", 25],
    ["829f", "ã", 82],
    ["8340", "ã‚¡", 62],
    ["8380", "ãƒ ", 22],
    ["839f", "Î‘", 16, "Î£", 6],
    ["83bf", "Î±", 16, "Ïƒ", 6],
    ["8440", "Ð", 5, "ÐÐ–", 25],
    ["8470", "Ð°", 5, "Ñ‘Ð¶", 7],
    ["8480", "Ð¾", 17],
    ["849f", "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"],
    ["8740", "â‘ ", 19, "â… ", 9],
    ["875f", "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"],
    ["877e", "ã»"],
    ["8780", "ã€ã€Ÿâ„–ãâ„¡ãŠ¤", 4, "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"],
    [
      "889f",
      "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­",
    ],
    [
      "8940",
      "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††",
    ],
    [
      "8980",
      "åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œæŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹",
    ],
    [
      "8a40",
      "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«",
    ],
    [
      "8a80",
      "æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„",
    ],
    [
      "8b40",
      "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘",
    ],
    [
      "8b80",
      "æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ",
    ],
    [
      "8c40",
      "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨",
    ],
    [
      "8c80",
      "åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘",
    ],
    [
      "8d40",
      "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™",
    ],
    [
      "8d80",
      "é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·",
    ],
    [
      "8e40",
      "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢",
    ],
    [
      "8e80",
      "æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨",
    ],
    [
      "8f40",
      "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³",
    ],
    [
      "8f80",
      "æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿå‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾",
    ],
    [
      "9040",
      "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨",
    ],
    [
      "9080",
      "é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š",
    ],
    [
      "9140",
      "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»",
    ],
    [
      "9180",
      "æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Žè‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª",
    ],
    [
      "9240",
      "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„",
    ],
    [
      "9280",
      "é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µå¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“",
    ],
    [
      "9340",
      "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬",
    ],
    [
      "9380",
      "å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥",
    ],
    [
      "9440",
      "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…",
    ],
    [
      "9480",
      "æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž",
    ],
    [
      "9540",
      "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·",
    ],
    [
      "9580",
      "æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹",
    ],
    [
      "9640",
      "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†",
    ],
    [
      "9680",
      "æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’",
    ],
    [
      "9740",
      "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²",
    ],
    [
      "9780",
      "æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯",
    ],
    [
      "9840",
      "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•",
    ],
    [
      "989f",
      "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²",
    ],
    [
      "9940",
      "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­",
    ],
    [
      "9980",
      "å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨",
    ],
    [
      "9a40",
      "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸",
    ],
    [
      "9a80",
      "å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©",
    ],
    [
      "9b40",
      "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€",
    ],
    [
      "9b80",
      "å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»",
    ],
    [
      "9c40",
      "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ ",
    ],
    [
      "9c80",
      "æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚šæ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›",
    ],
    [
      "9d40",
      "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«",
    ],
    [
      "9d80",
      "æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼",
    ],
    [
      "9e40",
      "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Ž",
    ],
    [
      "9e80",
      "æ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£",
    ],
    [
      "9f40",
      "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯",
    ],
    [
      "9f80",
      "éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ",
    ],
    [
      "e040",
      "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒ",
    ],
    [
      "e080",
      "çƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±",
    ],
    [
      "e140",
      "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿",
    ],
    [
      "e180",
      "ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬",
    ],
    [
      "e240",
      "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°",
    ],
    [
      "e280",
      "çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†",
    ],
    [
      "e340",
      "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·",
    ],
    [
      "e380",
      "ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼ºç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹",
    ],
    [
      "e440",
      "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤",
    ],
    [
      "e480",
      "è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ",
    ],
    [
      "e540",
      "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬",
    ],
    [
      "e580",
      "è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž",
    ],
    [
      "e640",
      "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§",
    ],
    [
      "e680",
      "è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š",
    ],
    [
      "e740",
      "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œ",
    ],
    [
      "e780",
      "è½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®",
    ],
    [
      "e840",
      "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™",
    ],
    [
      "e880",
      "é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™žé™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°",
    ],
    [
      "e940",
      "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒ",
    ],
    [
      "e980",
      "é¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ",
    ],
    [
      "ea40",
      "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯",
    ],
    [
      "ea80",
      "é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ å ¯æ§‡é™ç‘¤å‡œç†™",
    ],
    [
      "ed40",
      "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨",
    ],
    [
      "ed80",
      "ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±",
    ],
    [
      "ee40",
      "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™",
    ],
    [
      "ee80",
      "è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘",
    ],
    ["eeef", "â…°", 9, "ï¿¢ï¿¤ï¼‡ï¼‚"],
    ["f040", "î€€", 62],
    ["f080", "î€¿", 124],
    ["f140", "î‚¼", 62],
    ["f180", "îƒ»", 124],
    ["f240", "î…¸", 62],
    ["f280", "î†·", 124],
    ["f340", "îˆ´", 62],
    ["f380", "î‰³", 124],
    ["f440", "î‹°", 62],
    ["f480", "îŒ¯", 124],
    ["f540", "îŽ¬", 62],
    ["f580", "î«", 124],
    ["f640", "î‘¨", 62],
    ["f680", "î’§", 124],
    ["f740", "î”¤", 62],
    ["f780", "î•£", 124],
    ["f840", "î— ", 62],
    ["f880", "î˜Ÿ", 124],
    ["f940", "îšœ"],
    [
      "fa40",
      "â…°",
      9,
      "â… ",
      9,
      "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡âˆµçºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Š",
    ],
    [
      "fa80",
      "å…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯",
    ],
    [
      "fb40",
      "æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™",
    ],
    [
      "fb80",
      "ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™",
    ],
    ["fc40", "é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"],
  ],
  IN = [
    ["0", "\0", 127],
    ["8ea1", "ï½¡", 62],
    [
      "a1a1",
      "ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
      9,
      "ï¼‹ï¼Â±Ã—Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡",
    ],
    ["a2a1", "â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"],
    ["a2ba", "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"],
    ["a2ca", "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"],
    ["a2dc", "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"],
    ["a2f2", "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"],
    ["a2fe", "â—¯"],
    ["a3b0", "ï¼", 9],
    ["a3c1", "ï¼¡", 25],
    ["a3e1", "ï½", 25],
    ["a4a1", "ã", 82],
    ["a5a1", "ã‚¡", 85],
    ["a6a1", "Î‘", 16, "Î£", 6],
    ["a6c1", "Î±", 16, "Ïƒ", 6],
    ["a7a1", "Ð", 5, "ÐÐ–", 25],
    ["a7d1", "Ð°", 5, "Ñ‘Ð¶", 25],
    ["a8a1", "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"],
    ["ada1", "â‘ ", 19, "â… ", 9],
    ["adc0", "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"],
    ["addf", "ã»ã€ã€Ÿâ„–ãâ„¡ãŠ¤", 4, "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"],
    [
      "b0a1",
      "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­",
    ],
    [
      "b1a1",
      "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œ",
    ],
    [
      "b2a1",
      "æŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹",
    ],
    [
      "b3a1",
      "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±",
    ],
    [
      "b4a1",
      "ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„",
    ],
    [
      "b5a1",
      "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬",
    ],
    [
      "b6a1",
      "ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ",
    ],
    [
      "b7a1",
      "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²",
    ],
    [
      "b8a1",
      "æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘",
    ],
    [
      "b9a1",
      "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼",
    ],
    [
      "baa1",
      "æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·",
    ],
    [
      "bba1",
      "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚",
    ],
    [
      "bca1",
      "æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨",
    ],
    [
      "bda1",
      "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿ",
    ],
    [
      "bea1",
      "å‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾",
    ],
    [
      "bfa1",
      "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾",
    ],
    [
      "c0a1",
      "æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š",
    ],
    [
      "c1a1",
      "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Ž",
    ],
    [
      "c2a1",
      "è‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª",
    ],
    [
      "c3a1",
      "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µ",
    ],
    [
      "c4a1",
      "å¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“",
    ],
    [
      "c5a1",
      "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°",
    ],
    [
      "c6a1",
      "è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥",
    ],
    [
      "c7a1",
      "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦",
    ],
    [
      "c8a1",
      "å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž",
    ],
    [
      "c9a1",
      "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœ",
    ],
    [
      "caa1",
      "ç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹",
    ],
    [
      "cba1",
      "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€",
    ],
    [
      "cca1",
      "æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’",
    ],
    [
      "cda1",
      "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒ",
    ],
    [
      "cea1",
      "ç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯",
    ],
    [
      "cfa1",
      "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•",
    ],
    [
      "d0a1",
      "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²",
    ],
    [
      "d1a1",
      "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨",
    ],
    [
      "d2a1",
      "è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨",
    ],
    [
      "d3a1",
      "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰",
    ],
    [
      "d4a1",
      "åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©",
    ],
    [
      "d5a1",
      "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“",
    ],
    [
      "d6a1",
      "å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»",
    ],
    [
      "d7a1",
      "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚š",
    ],
    [
      "d8a1",
      "æ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›",
    ],
    [
      "d9a1",
      "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼",
    ],
    [
      "daa1",
      "æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼",
    ],
    [
      "dba1",
      "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Žæ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£",
    ],
    [
      "dca1",
      "æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£",
    ],
    [
      "dda1",
      "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾",
    ],
    [
      "dea1",
      "æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ",
    ],
    [
      "dfa1",
      "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒçƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼",
    ],
    [
      "e0a1",
      "ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±",
    ],
    [
      "e1a1",
      "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°",
    ],
    [
      "e2a1",
      "ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬",
    ],
    [
      "e3a1",
      "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­",
    ],
    [
      "e4a1",
      "ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†",
    ],
    [
      "e5a1",
      "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼º",
    ],
    [
      "e6a1",
      "ç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹",
    ],
    [
      "e7a1",
      "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™",
    ],
    [
      "e8a1",
      "èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ",
    ],
    [
      "e9a1",
      "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™",
    ],
    [
      "eaa1",
      "è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž",
    ],
    [
      "eba1",
      "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«",
    ],
    [
      "eca1",
      "è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š",
    ],
    [
      "eda1",
      "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œè½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸",
    ],
    [
      "eea1",
      "ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®",
    ],
    [
      "efa1",
      "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™ž",
    ],
    [
      "f0a1",
      "é™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°",
    ],
    [
      "f1a1",
      "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒé¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·",
    ],
    [
      "f2a1",
      "é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ",
    ],
    [
      "f3a1",
      "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ ",
    ],
    ["f4a1", "å ¯æ§‡é™ç‘¤å‡œç†™"],
    [
      "f9a1",
      "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·",
    ],
    [
      "faa1",
      "å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±",
    ],
    [
      "fba1",
      "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡š",
    ],
    [
      "fca1",
      "é‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘",
    ],
    ["fcf1", "â…°", 9, "ï¿¢ï¿¤ï¼‡ï¼‚"],
    ["8fa2af", "Ë˜Ë‡Â¸Ë™ËÂ¯Ë›Ëšï½žÎ„Î…"],
    ["8fa2c2", "Â¡Â¦Â¿"],
    ["8fa2eb", "ÂºÂªÂ©Â®â„¢Â¤â„–"],
    ["8fa6e1", "Î†ÎˆÎ‰ÎŠÎª"],
    ["8fa6e7", "ÎŒ"],
    ["8fa6e9", "ÎŽÎ«"],
    ["8fa6ec", "Î"],
    ["8fa6f1", "Î¬Î­Î®Î¯ÏŠÎÏŒÏ‚ÏÏ‹Î°ÏŽ"],
    ["8fa7c2", "Ð‚", 10, "ÐŽÐ"],
    ["8fa7f2", "Ñ’", 10, "ÑžÑŸ"],
    ["8fa9a1", "Ã†Ä"],
    ["8fa9a4", "Ä¦"],
    ["8fa9a6", "Ä²"],
    ["8fa9a8", "ÅÄ¿"],
    ["8fa9ab", "ÅŠÃ˜Å’"],
    ["8fa9af", "Å¦Ãž"],
    ["8fa9c1", "Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å‚Å€Å‰Å‹Ã¸Å“ÃŸÅ§Ã¾"],
    ["8faaa1", "ÃÃ€Ã„Ã‚Ä‚ÇÄ€Ä„Ã…ÃƒÄ†ÄˆÄŒÃ‡ÄŠÄŽÃ‰ÃˆÃ‹ÃŠÄšÄ–Ä’Ä˜"],
    [
      "8faaba",
      "ÄœÄžÄ¢Ä Ä¤ÃÃŒÃÃŽÇÄ°ÄªÄ®Ä¨Ä´Ä¶Ä¹Ä½Ä»ÅƒÅ‡Å…Ã‘Ã“Ã’Ã–Ã”Ç‘ÅÅŒÃ•Å”Å˜Å–ÅšÅœÅ ÅžÅ¤Å¢ÃšÃ™ÃœÃ›Å¬Ç“Å°ÅªÅ²Å®Å¨Ç—Ç›Ç™Ç•Å´ÃÅ¸Å¶Å¹Å½Å»",
    ],
    ["8faba1", "Ã¡Ã Ã¤Ã¢ÄƒÇŽÄÄ…Ã¥Ã£Ä‡Ä‰ÄÃ§Ä‹ÄÃ©Ã¨Ã«ÃªÄ›Ä—Ä“Ä™ÇµÄÄŸ"],
    ["8fabbd", "Ä¡Ä¥Ã­Ã¬Ã¯Ã®Ç"],
    ["8fabc5", "Ä«Ä¯Ä©ÄµÄ·ÄºÄ¾Ä¼Å„ÅˆÅ†Ã±Ã³Ã²Ã¶Ã´Ç’Å‘ÅÃµÅ•Å™Å—Å›ÅÅ¡ÅŸÅ¥Å£ÃºÃ¹Ã¼Ã»Å­Ç”Å±Å«Å³Å¯Å©Ç˜ÇœÇšÇ–ÅµÃ½Ã¿Å·ÅºÅ¾Å¼"],
    [
      "8fb0a1",
      "ä¸‚ä¸„ä¸…ä¸Œä¸’ä¸Ÿä¸£ä¸¤ä¸¨ä¸«ä¸®ä¸¯ä¸°ä¸µä¹€ä¹ä¹„ä¹‡ä¹‘ä¹šä¹œä¹£ä¹¨ä¹©ä¹´ä¹µä¹¹ä¹¿äºäº–äº—äºäº¯äº¹ä»ƒä»ä»šä»›ä» ä»¡ä»¢ä»¨ä»¯ä»±ä»³ä»µä»½ä»¾ä»¿ä¼€ä¼‚ä¼ƒä¼ˆä¼‹ä¼Œä¼’ä¼•ä¼–ä¼—ä¼™ä¼®ä¼±ä½ ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾ä½€ä½‚ä½ˆä½‰ä½‹ä½Œä½’ä½”ä½–ä½˜ä½Ÿä½£ä½ªä½¬ä½®ä½±ä½·ä½¸ä½¹ä½ºä½½ä½¾ä¾ä¾‚ä¾„",
    ],
    [
      "8fb1a1",
      "ä¾…ä¾‰ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾”ä¾—ä¾™ä¾šä¾žä¾Ÿä¾²ä¾·ä¾¹ä¾»ä¾¼ä¾½ä¾¾ä¿€ä¿ä¿…ä¿†ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿ä¿’ä¿œä¿ ä¿¢ä¿°ä¿²ä¿¼ä¿½ä¿¿å€€å€å€„å€‡å€Šå€Œå€Žå€å€“å€—å€˜å€›å€œå€å€žå€¢å€§å€®å€°å€²å€³å€µå€åå‚å…å†åŠåŒåŽå‘å’å“å—å™åŸå å¢å£å¦å§åªå­å°å±å€»å‚å‚ƒå‚„å‚†å‚Šå‚Žå‚å‚",
    ],
    [
      "8fb2a1",
      "å‚’å‚“å‚”å‚–å‚›å‚œå‚ž",
      4,
      "å‚ªå‚¯å‚°å‚¹å‚ºå‚½åƒ€åƒƒåƒ„åƒ‡åƒŒåƒŽåƒåƒ“åƒ”åƒ˜åƒœåƒåƒŸåƒ¢åƒ¤åƒ¦åƒ¨åƒ©åƒ¯åƒ±åƒ¶åƒºåƒ¾å„ƒå„†å„‡å„ˆå„‹å„Œå„å„Žåƒ²å„å„—å„™å„›å„œå„å„žå„£å„§å„¨å„¬å„­å„¯å„±å„³å„´å„µå„¸å„¹å…‚å…Šå…å…“å…•å…—å…˜å…Ÿå…¤å…¦å…¾å†ƒå†„å†‹å†Žå†˜å†å†¡å†£å†­å†¸å†ºå†¼å†¾å†¿å‡‚",
    ],
    [
      "8fb3a1",
      "å‡ˆå‡å‡‘å‡’å‡“å‡•å‡˜å‡žå‡¢å‡¥å‡®å‡²å‡³å‡´å‡·åˆåˆ‚åˆ…åˆ’åˆ“åˆ•åˆ–åˆ˜åˆ¢åˆ¨åˆ±åˆ²åˆµåˆ¼å‰…å‰‰å‰•å‰—å‰˜å‰šå‰œå‰Ÿå‰ å‰¡å‰¦å‰®å‰·å‰¸å‰¹åŠ€åŠ‚åŠ…åŠŠåŠŒåŠ“åŠ•åŠ–åŠ—åŠ˜åŠšåŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ¯åŠ°åŠ¶åŠ·åŠ¸åŠºåŠ»åŠ½å‹€å‹„å‹†å‹ˆå‹Œå‹å‹‘å‹”å‹–å‹›å‹œå‹¡å‹¥å‹¨å‹©å‹ªå‹¬å‹°å‹±å‹´å‹¶å‹·åŒ€åŒƒåŒŠåŒ‹",
    ],
    [
      "8fb4a1",
      "åŒŒåŒ‘åŒ“åŒ˜åŒ›åŒœåŒžåŒŸåŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ°åŒ²åŒµåŒ¼åŒ½åŒ¾å‚åŒå‹å™å›å¡å£å¥å¬å­å²å¹å¾åŽƒåŽ‡åŽˆåŽŽåŽ“åŽ”åŽ™åŽåŽ¡åŽ¤åŽªåŽ«åŽ¯åŽ²åŽ´åŽµåŽ·åŽ¸åŽºåŽ½å€å…åå’å“å•åšååžå å¦å§åµå‚å“åšå¡å§å¨åªå¯å±å´åµå‘ƒå‘„å‘‡å‘å‘å‘žå‘¢å‘¤å‘¦å‘§å‘©å‘«å‘­å‘®å‘´å‘¿",
    ],
    [
      "8fb5a1",
      "å’å’ƒå’…å’ˆå’‰å’å’‘å’•å’–å’œå’Ÿå’¡å’¦å’§å’©å’ªå’­å’®å’±å’·å’¹å’ºå’»å’¿å“†å“Šå“å“Žå“ å“ªå“¬å“¯å“¶å“¼å“¾å“¿å”€å”å”…å”ˆå”‰å”Œå”å”Žå”•å”ªå”«å”²å”µå”¶å”»å”¼å”½å•å•‡å•‰å•Šå•å•å•‘å•˜å•šå•›å•žå• å•¡å•¤å•¦å•¿å–å–‚å–†å–ˆå–Žå–å–‘å–’å–“å–”å–—å–£å–¤å–­å–²å–¿å—å—ƒå—†å—‰å—‹å—Œå—Žå—‘å—’",
    ],
    [
      "8fb6a1",
      "å—“å——å—˜å—›å—žå—¢å—©å—¶å—¿å˜…å˜ˆå˜Šå˜",
      5,
      "å˜™å˜¬å˜°å˜³å˜µå˜·å˜¹å˜»å˜¼å˜½å˜¿å™€å™å™ƒå™„å™†å™‰å™‹å™å™å™”å™žå™ å™¡å™¢å™£å™¦å™©å™­å™¯å™±å™²å™µåš„åš…åšˆåš‹åšŒåš•åš™åššåšåšžåšŸåš¦åš§åš¨åš©åš«åš¬åš­åš±åš³åš·åš¾å›…å›‰å›Šå›‹å›å›å›Œå›å›™å›œå›å›Ÿå›¡å›¤",
      4,
      "å›±å›«å›­",
    ],
    [
      "8fb7a1",
      "å›¶å›·åœåœ‚åœ‡åœŠåœŒåœ‘åœ•åœšåœ›åœåœ åœ¢åœ£åœ¤åœ¥åœ©åœªåœ¬åœ®åœ¯åœ³åœ´åœ½åœ¾åœ¿å…å†åŒåå’å¢å¥å§å¨å«å­",
      4,
      "å³å´åµå·å¹åºå»å¼å¾åžåžƒåžŒåž”åž—åž™åžšåžœåžåžžåžŸåž¡åž•åž§åž¨åž©åž¬åž¸åž½åŸ‡åŸˆåŸŒåŸåŸ•åŸåŸžåŸ¤åŸ¦åŸ§åŸ©åŸ­åŸ°åŸµåŸ¶åŸ¸åŸ½åŸ¾åŸ¿å ƒå „å ˆå ‰åŸ¡",
    ],
    [
      "8fb8a1",
      "å Œå å ›å žå Ÿå  å ¦å §å ­å ²å ¹å ¿å¡‰å¡Œå¡å¡å¡å¡•å¡Ÿå¡¡å¡¤å¡§å¡¨å¡¸å¡¼å¡¿å¢€å¢å¢‡å¢ˆå¢‰å¢Šå¢Œå¢å¢å¢å¢”å¢–å¢å¢ å¢¡å¢¢å¢¦å¢©å¢±å¢²å£„å¢¼å£‚å£ˆå£å£Žå£å£’å£”å£–å£šå£å£¡å£¢å£©å£³å¤…å¤†å¤‹å¤Œå¤’å¤“å¤”è™å¤å¤¡å¤£å¤¤å¤¨å¤¯å¤°å¤³å¤µå¤¶å¤¿å¥ƒå¥†å¥’å¥“å¥™å¥›å¥å¥žå¥Ÿå¥¡å¥£å¥«å¥­",
    ],
    [
      "8fb9a1",
      "å¥¯å¥²å¥µå¥¶å¥¹å¥»å¥¼å¦‹å¦Œå¦Žå¦’å¦•å¦—å¦Ÿå¦¤å¦§å¦­å¦®å¦¯å¦°å¦³å¦·å¦ºå¦¼å§å§ƒå§„å§ˆå§Šå§å§’å§å§žå§Ÿå§£å§¤å§§å§®å§¯å§±å§²å§´å§·å¨€å¨„å¨Œå¨å¨Žå¨’å¨“å¨žå¨£å¨¤å¨§å¨¨å¨ªå¨­å¨°å©„å©…å©‡å©ˆå©Œå©å©•å©žå©£å©¥å©§å©­å©·å©ºå©»å©¾åª‹åªåª“åª–åª™åªœåªžåªŸåª åª¢åª§åª¬åª±åª²åª³åªµåª¸åªºåª»åª¿",
    ],
    [
      "8fbaa1",
      "å«„å«†å«ˆå«å«šå«œå« å«¥å«ªå«®å«µå«¶å«½å¬€å¬å¬ˆå¬—å¬´å¬™å¬›å¬å¬¡å¬¥å¬­å¬¸å­å­‹å­Œå­’å­–å­žå­¨å­®å­¯å­¼å­½å­¾å­¿å®å®„å®†å®Šå®Žå®å®‘å®“å®”å®–å®¨å®©å®¬å®­å®¯å®±å®²å®·å®ºå®¼å¯€å¯å¯å¯å¯–",
      4,
      "å¯ å¯¯å¯±å¯´å¯½å°Œå°—å°žå°Ÿå°£å°¦å°©å°«å°¬å°®å°°å°²å°µå°¶å±™å±šå±œå±¢å±£å±§å±¨å±©",
    ],
    [
      "8fbba1",
      "å±­å±°å±´å±µå±ºå±»å±¼å±½å²‡å²ˆå²Šå²å²’å²å²Ÿå² å²¢å²£å²¦å²ªå²²å²´å²µå²ºå³‰å³‹å³’å³å³—å³®å³±å³²å³´å´å´†å´å´’å´«å´£å´¤å´¦å´§å´±å´´å´¹å´½å´¿åµ‚åµƒåµ†åµˆåµ•åµ‘åµ™åµŠåµŸåµ åµ¡åµ¢åµ¤åµªåµ­åµ°åµ¹åµºåµ¾åµ¿å¶å¶ƒå¶ˆå¶Šå¶’å¶“å¶”å¶•å¶™å¶›å¶Ÿå¶ å¶§å¶«å¶°å¶´å¶¸å¶¹å·ƒå·‡å·‹å·å·Žå·˜å·™å· å·¤",
    ],
    [
      "8fbca1",
      "å·©å·¸å·¹å¸€å¸‡å¸å¸’å¸”å¸•å¸˜å¸Ÿå¸ å¸®å¸¨å¸²å¸µå¸¾å¹‹å¹å¹‰å¹‘å¹–å¹˜å¹›å¹œå¹žå¹¨å¹ª",
      4,
      "å¹°åº€åº‹åºŽåº¢åº¤åº¥åº¨åºªåº¬åº±åº³åº½åº¾åº¿å»†å»Œå»‹å»Žå»‘å»’å»”å»•å»œå»žå»¥å»«å¼‚å¼†å¼‡å¼ˆå¼Žå¼™å¼œå¼å¼¡å¼¢å¼£å¼¤å¼¨å¼«å¼¬å¼®å¼°å¼´å¼¶å¼»å¼½å¼¿å½€å½„å½…å½‡å½å½å½”å½˜å½›å½ å½£å½¤å½§",
    ],
    [
      "8fbda1",
      "å½¯å½²å½´å½µå½¸å½ºå½½å½¾å¾‰å¾å¾å¾–å¾œå¾å¾¢å¾§å¾«å¾¤å¾¬å¾¯å¾°å¾±å¾¸å¿„å¿‡å¿ˆå¿‰å¿‹å¿",
      4,
      "å¿žå¿¡å¿¢å¿¨å¿©å¿ªå¿¬å¿­å¿®å¿¯å¿²å¿³å¿¶å¿ºå¿¼æ€‡æ€Šæ€æ€“æ€”æ€—æ€˜æ€šæ€Ÿæ€¤æ€­æ€³æ€µæ€æ‡æˆæ‰æŒæ‘æ”æ–æ—ææ¡æ§æ±æ¾æ¿æ‚‚æ‚†æ‚ˆæ‚Šæ‚Žæ‚‘æ‚“æ‚•æ‚˜æ‚æ‚žæ‚¢æ‚¤æ‚¥æ‚¨æ‚°æ‚±æ‚·",
    ],
    [
      "8fbea1",
      "æ‚»æ‚¾æƒ‚æƒ„æƒˆæƒ‰æƒŠæƒ‹æƒŽæƒæƒ”æƒ•æƒ™æƒ›æƒæƒžæƒ¢æƒ¥æƒ²æƒµæƒ¸æƒ¼æƒ½æ„‚æ„‡æ„Šæ„Œæ„",
      4,
      "æ„–æ„—æ„™æ„œæ„žæ„¢æ„ªæ„«æ„°æ„±æ„µæ„¶æ„·æ„¹æ…æ……æ…†æ…‰æ…žæ… æ…¬æ…²æ…¸æ…»æ…¼æ…¿æ†€æ†æ†ƒæ†„æ†‹æ†æ†’æ†“æ†—æ†˜æ†œæ†æ†Ÿæ† æ†¥æ†¨æ†ªæ†­æ†¸æ†¹æ†¼æ‡€æ‡æ‡‚æ‡Žæ‡æ‡•æ‡œæ‡æ‡žæ‡Ÿæ‡¡æ‡¢æ‡§æ‡©æ‡¥",
    ],
    [
      "8fbfa1",
      "æ‡¬æ‡­æ‡¯æˆæˆƒæˆ„æˆ‡æˆ“æˆ•æˆœæˆ æˆ¢æˆ£æˆ§æˆ©æˆ«æˆ¹æˆ½æ‰‚æ‰ƒæ‰„æ‰†æ‰Œæ‰æ‰‘æ‰’æ‰”æ‰–æ‰šæ‰œæ‰¤æ‰­æ‰¯æ‰³æ‰ºæ‰½æŠæŠŽæŠæŠæŠ¦æŠ¨æŠ³æŠ¶æŠ·æŠºæŠ¾æŠ¿æ‹„æ‹Žæ‹•æ‹–æ‹šæ‹ªæ‹²æ‹´æ‹¼æ‹½æŒƒæŒ„æŒŠæŒ‹æŒæŒæŒ“æŒ–æŒ˜æŒ©æŒªæŒ­æŒµæŒ¶æŒ¹æŒ¼ææ‚æƒæ„æ†æŠæ‹æŽæ’æ“æ”æ˜æ›æ¥æ¦æ¬æ­æ±æ´æµ",
    ],
    [
      "8fc0a1",
      "æ¸æ¼æ½æ¿æŽ‚æŽ„æŽ‡æŽŠæŽæŽ”æŽ•æŽ™æŽšæŽžæŽ¤æŽ¦æŽ­æŽ®æŽ¯æŽ½ææ…æˆæŽæ‘æ“æ”æ•æœæ æ¥æªæ¬æ²æ³æµæ¸æ¹æ‰æŠææ’æ”æ˜æžæ æ¢æ¤æ¥æ©æªæ¯æ°æµæ½æ¿æ‘‹æ‘æ‘‘æ‘’æ‘“æ‘”æ‘šæ‘›æ‘œæ‘æ‘Ÿæ‘ æ‘¡æ‘£æ‘­æ‘³æ‘´æ‘»æ‘½æ’…æ’‡æ’æ’æ’‘æ’˜æ’™æ’›æ’æ’Ÿæ’¡æ’£æ’¦æ’¨æ’¬æ’³æ’½æ’¾æ’¿",
    ],
    [
      "8fc1a1",
      "æ“„æ“‰æ“Šæ“‹æ“Œæ“Žæ“æ“‘æ“•æ“—æ“¤æ“¥æ“©æ“ªæ“­æ“°æ“µæ“·æ“»æ“¿æ”æ”„æ”ˆæ”‰æ”Šæ”æ”“æ””æ”–æ”™æ”›æ”žæ”Ÿæ”¢æ”¦æ”©æ”®æ”±æ”ºæ”¼æ”½æ•ƒæ•‡æ•‰æ•æ•’æ•”æ•Ÿæ• æ•§æ•«æ•ºæ•½æ–æ–…æ–Šæ–’æ–•æ–˜æ–æ– æ–£æ–¦æ–®æ–²æ–³æ–´æ–¿æ—‚æ—ˆæ—‰æ—Žæ—æ—”æ—–æ—˜æ—Ÿæ—°æ—²æ—´æ—µæ—¹æ—¾æ—¿æ˜€æ˜„æ˜ˆæ˜‰æ˜æ˜‘æ˜’æ˜•æ˜–æ˜",
    ],
    [
      "8fc2a1",
      "æ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜±æ˜³æ˜¹æ˜·æ™€æ™…æ™†æ™Šæ™Œæ™‘æ™Žæ™—æ™˜æ™™æ™›æ™œæ™ æ™¡æ›»æ™ªæ™«æ™¬æ™¾æ™³æ™µæ™¿æ™·æ™¸æ™¹æ™»æš€æ™¼æš‹æšŒæšæšæš’æš™æššæš›æšœæšŸæš æš¤æš­æš±æš²æšµæš»æš¿æ›€æ›‚æ›ƒæ›ˆæ›Œæ›Žæ›æ›”æ››æ›Ÿæ›¨æ›«æ›¬æ›®æ›ºæœ…æœ‡æœŽæœ“æœ™æœœæœ æœ¢æœ³æœ¾æ…æ‡æˆæŒæ”æ•æ",
    ],
    [
      "8fc3a1",
      "æ¦æ¬æ®æ´æ¶æ»æžæž„æžŽæžæž‘æž“æž–æž˜æž™æž›æž°æž±æž²æžµæž»æž¼æž½æŸ¹æŸ€æŸ‚æŸƒæŸ…æŸˆæŸ‰æŸ’æŸ—æŸ™æŸœæŸ¡æŸ¦æŸ°æŸ²æŸ¶æŸ·æ¡’æ ”æ ™æ æ Ÿæ ¨æ §æ ¬æ ­æ ¯æ °æ ±æ ³æ »æ ¿æ¡„æ¡…æ¡Šæ¡Œæ¡•æ¡—æ¡˜æ¡›æ¡«æ¡®",
      4,
      "æ¡µæ¡¹æ¡ºæ¡»æ¡¼æ¢‚æ¢„æ¢†æ¢ˆæ¢–æ¢˜æ¢šæ¢œæ¢¡æ¢£æ¢¥æ¢©æ¢ªæ¢®æ¢²æ¢»æ£…æ£ˆæ£Œæ£",
    ],
    [
      "8fc4a1",
      "æ£æ£‘æ£“æ£–æ£™æ£œæ£æ£¥æ£¨æ£ªæ£«æ£¬æ£­æ£°æ£±æ£µæ£¶æ£»æ£¼æ£½æ¤†æ¤‰æ¤Šæ¤æ¤‘æ¤“æ¤–æ¤—æ¤±æ¤³æ¤µæ¤¸æ¤»æ¥‚æ¥…æ¥‰æ¥Žæ¥—æ¥›æ¥£æ¥¤æ¥¥æ¥¦æ¥¨æ¥©æ¥¬æ¥°æ¥±æ¥²æ¥ºæ¥»æ¥¿æ¦€æ¦æ¦’æ¦–æ¦˜æ¦¡æ¦¥æ¦¦æ¦¨æ¦«æ¦­æ¦¯æ¦·æ¦¸æ¦ºæ¦¼æ§…æ§ˆæ§‘æ§–æ§—æ§¢æ§¥æ§®æ§¯æ§±æ§³æ§µæ§¾æ¨€æ¨æ¨ƒæ¨æ¨‘æ¨•æ¨šæ¨æ¨ æ¨¤æ¨¨æ¨°æ¨²",
    ],
    [
      "8fc5a1",
      "æ¨´æ¨·æ¨»æ¨¾æ¨¿æ©…æ©†æ©‰æ©Šæ©Žæ©æ©‘æ©’æ©•æ©–æ©›æ©¤æ©§æ©ªæ©±æ©³æ©¾æªæªƒæª†æª‡æª‰æª‹æª‘æª›æªæªžæªŸæª¥æª«æª¯æª°æª±æª´æª½æª¾æª¿æ«†æ«‰æ«ˆæ«Œæ«æ«”æ«•æ«–æ«œæ«æ«¤æ«§æ«¬æ«°æ«±æ«²æ«¼æ«½æ¬‚æ¬ƒæ¬†æ¬‡æ¬‰æ¬æ¬æ¬‘æ¬—æ¬›æ¬žæ¬¤æ¬¨æ¬«æ¬¬æ¬¯æ¬µæ¬¶æ¬»æ¬¿æ­†æ­Šæ­æ­’æ­–æ­˜æ­æ­ æ­§æ­«æ­®æ­°æ­µæ­½",
    ],
    [
      "8fc6a1",
      "æ­¾æ®‚æ®…æ®—æ®›æ®Ÿæ® æ®¢æ®£æ®¨æ®©æ®¬æ®­æ®®æ®°æ®¸æ®¹æ®½æ®¾æ¯ƒæ¯„æ¯‰æ¯Œæ¯–æ¯šæ¯¡æ¯£æ¯¦æ¯§æ¯®æ¯±æ¯·æ¯¹æ¯¿æ°‚æ°„æ°…æ°‰æ°æ°Žæ°æ°’æ°™æ°Ÿæ°¦æ°§æ°¨æ°¬æ°®æ°³æ°µæ°¶æ°ºæ°»æ°¿æ±Šæ±‹æ±æ±æ±’æ±”æ±™æ±›æ±œæ±«æ±­æ±¯æ±´æ±¶æ±¸æ±¹æ±»æ²…æ²†æ²‡æ²‰æ²”æ²•æ²—æ²˜æ²œæ²Ÿæ²°æ²²æ²´æ³‚æ³†æ³æ³æ³æ³‘æ³’æ³”æ³–",
    ],
    [
      "8fc7a1",
      "æ³šæ³œæ³ æ³§æ³©æ³«æ³¬æ³®æ³²æ³´æ´„æ´‡æ´Šæ´Žæ´æ´‘æ´“æ´šæ´¦æ´§æ´¨æ±§æ´®æ´¯æ´±æ´¹æ´¼æ´¿æµ—æµžæµŸæµ¡æµ¥æµ§æµ¯æµ°æµ¼æ¶‚æ¶‡æ¶‘æ¶’æ¶”æ¶–æ¶—æ¶˜æ¶ªæ¶¬æ¶´æ¶·æ¶¹æ¶½æ¶¿æ·„æ·ˆæ·Šæ·Žæ·æ·–æ·›æ·æ·Ÿæ· æ·¢æ·¥æ·©æ·¯æ·°æ·´æ·¶æ·¼æ¸€æ¸„æ¸žæ¸¢æ¸§æ¸²æ¸¶æ¸¹æ¸»æ¸¼æ¹„æ¹…æ¹ˆæ¹‰æ¹‹æ¹æ¹‘æ¹’æ¹“æ¹”æ¹—æ¹œæ¹æ¹ž",
    ],
    [
      "8fc8a1",
      "æ¹¢æ¹£æ¹¨æ¹³æ¹»æ¹½æºæº“æº™æº æº§æº­æº®æº±æº³æº»æº¿æ»€æ»æ»ƒæ»‡æ»ˆæ»Šæ»æ»Žæ»æ»«æ»­æ»®æ»¹æ»»æ»½æ¼„æ¼ˆæ¼Šæ¼Œæ¼æ¼–æ¼˜æ¼šæ¼›æ¼¦æ¼©æ¼ªæ¼¯æ¼°æ¼³æ¼¶æ¼»æ¼¼æ¼­æ½æ½‘æ½’æ½“æ½—æ½™æ½šæ½æ½žæ½¡æ½¢æ½¨æ½¬æ½½æ½¾æ¾ƒæ¾‡æ¾ˆæ¾‹æ¾Œæ¾æ¾æ¾’æ¾“æ¾”æ¾–æ¾šæ¾Ÿæ¾ æ¾¥æ¾¦æ¾§æ¾¨æ¾®æ¾¯æ¾°æ¾µæ¾¶æ¾¼æ¿…æ¿‡æ¿ˆæ¿Š",
    ],
    [
      "8fc9a1",
      "æ¿šæ¿žæ¿¨æ¿©æ¿°æ¿µæ¿¹æ¿¼æ¿½ç€€ç€…ç€†ç€‡ç€ç€—ç€ ç€£ç€¯ç€´ç€·ç€¹ç€¼çƒç„çˆç‰çŠç‹ç”ç•ççžçŽç¤ç¥ç¬ç®çµç¶ç¾ç‚ç‚…ç‚†ç‚”",
      4,
      "ç‚›ç‚¤ç‚«ç‚°ç‚±ç‚´ç‚·çƒŠçƒ‘çƒ“çƒ”çƒ•çƒ–çƒ˜çƒœçƒ¤çƒºç„ƒ",
      4,
      "ç„‹ç„Œç„ç„žç„ ç„«ç„­ç„¯ç„°ç„±ç„¸ç…ç……ç…†ç…‡ç…Šç…‹ç…ç…’ç…—ç…šç…œç…žç… ",
    ],
    [
      "8fcaa1",
      "ç…¨ç…¹ç†€ç†…ç†‡ç†Œç†’ç†šç†›ç† ç†¢ç†¯ç†°ç†²ç†³ç†ºç†¿ç‡€ç‡ç‡„ç‡‹ç‡Œç‡“ç‡–ç‡™ç‡šç‡œç‡¸ç‡¾çˆ€çˆ‡çˆˆçˆ‰çˆ“çˆ—çˆšçˆçˆŸçˆ¤çˆ«çˆ¯çˆ´çˆ¸çˆ¹ç‰ç‰‚ç‰ƒç‰…ç‰Žç‰ç‰ç‰“ç‰•ç‰–ç‰šç‰œç‰žç‰ ç‰£ç‰¨ç‰«ç‰®ç‰¯ç‰±ç‰·ç‰¸ç‰»ç‰¼ç‰¿çŠ„çŠ‰çŠçŠŽçŠ“çŠ›çŠ¨çŠ­çŠ®çŠ±çŠ´çŠ¾ç‹ç‹‡ç‹‰ç‹Œç‹•ç‹–ç‹˜ç‹Ÿç‹¥ç‹³ç‹´ç‹ºç‹»",
    ],
    [
      "8fcba1",
      "ç‹¾çŒ‚çŒ„çŒ…çŒ‡çŒ‹çŒçŒ’çŒ“çŒ˜çŒ™çŒžçŒ¢çŒ¤çŒ§çŒ¨çŒ¬çŒ±çŒ²çŒµçŒºçŒ»çŒ½çƒççç’ç–ç˜ççžçŸç ç¦ç§ç©ç«ç¬ç®ç¯ç±ç·ç¹ç¼çŽ€çŽçŽƒçŽ…çŽ†çŽŽçŽçŽ“çŽ•çŽ—çŽ˜çŽœçŽžçŽŸçŽ çŽ¢çŽ¥çŽ¦çŽªçŽ«çŽ­çŽµçŽ·çŽ¹çŽ¼çŽ½çŽ¿ç…ç†ç‰ç‹çŒçç’ç“ç–ç™çç¡ç£ç¦ç§ç©ç´çµç·ç¹çºç»ç½",
    ],
    [
      "8fcca1",
      "ç¿ç€çç„ç‡çŠç‘çšç›ç¤ç¦ç¨",
      9,
      "ç¹ç‘€ç‘ƒç‘„ç‘†ç‘‡ç‘‹ç‘ç‘‘ç‘’ç‘—ç‘ç‘¢ç‘¦ç‘§ç‘¨ç‘«ç‘­ç‘®ç‘±ç‘²ç’€ç’ç’…ç’†ç’‡ç’‰ç’ç’ç’‘ç’’ç’˜ç’™ç’šç’œç’Ÿç’ ç’¡ç’£ç’¦ç’¨ç’©ç’ªç’«ç’®ç’¯ç’±ç’²ç’µç’¹ç’»ç’¿ç“ˆç“‰ç“Œç“ç““ç“˜ç“šç“›ç“žç“Ÿç“¤ç“¨ç“ªç“«ç“¯ç“´ç“ºç“»ç“¼ç“¿ç”†",
    ],
    [
      "8fcda1",
      "ç”’ç”–ç”—ç” ç”¡ç”¤ç”§ç”©ç”ªç”¯ç”¶ç”¹ç”½ç”¾ç”¿ç•€ç•ƒç•‡ç•ˆç•Žç•ç•’ç•—ç•žç•Ÿç•¡ç•¯ç•±ç•¹",
      5,
      "ç–ç–…ç–ç–’ç–“ç–•ç–™ç–œç–¢ç–¤ç–´ç–ºç–¿ç—€ç—ç—„ç—†ç—Œç—Žç—ç——ç—œç—Ÿç— ç—¡ç—¤ç—§ç—¬ç—®ç—¯ç—±ç—¹ç˜€ç˜‚ç˜ƒç˜„ç˜‡ç˜ˆç˜Šç˜Œç˜ç˜’ç˜“ç˜•ç˜–ç˜™ç˜›ç˜œç˜ç˜žç˜£ç˜¥ç˜¦ç˜©ç˜­ç˜²ç˜³ç˜µç˜¸ç˜¹",
    ],
    [
      "8fcea1",
      "ç˜ºç˜¼ç™Šç™€ç™ç™ƒç™„ç™…ç™‰ç™‹ç™•ç™™ç™Ÿç™¤ç™¥ç™­ç™®ç™¯ç™±ç™´çšçš…çšŒçšçš•çš›çšœçšçšŸçš çš¢",
      6,
      "çšªçš­çš½ç›ç›…ç›‰ç›‹ç›Œç›Žç›”ç›™ç› ç›¦ç›¨ç›¬ç›°ç›±ç›¶ç›¹ç›¼çœ€çœ†çœŠçœŽçœ’çœ”çœ•çœ—çœ™çœšçœœçœ¢çœ¨çœ­çœ®çœ¯çœ´çœµçœ¶çœ¹çœ½çœ¾ç‚ç…ç†çŠççŽçç’ç–ç—çœçžçŸç ç¢",
    ],
    [
      "8fcfa1",
      "ç¤ç§çªç¬ç°ç²ç³ç´çºç½çž€çž„çžŒçžçž”çž•çž–çžšçžŸçž¢çž§çžªçž®çž¯çž±çžµçž¾çŸƒçŸ‰çŸ‘çŸ’çŸ•çŸ™çŸžçŸŸçŸ çŸ¤çŸ¦çŸªçŸ¬çŸ°çŸ±çŸ´çŸ¸çŸ»ç …ç †ç ‰ç ç Žç ‘ç ç ¡ç ¢ç £ç ­ç ®ç °ç µç ·ç¡ƒç¡„ç¡‡ç¡ˆç¡Œç¡Žç¡’ç¡œç¡žç¡ ç¡¡ç¡£ç¡¤ç¡¨ç¡ªç¡®ç¡ºç¡¾ç¢Šç¢ç¢”ç¢˜ç¢¡ç¢ç¢žç¢Ÿç¢¤ç¢¨ç¢¬ç¢­ç¢°ç¢±ç¢²ç¢³",
    ],
    [
      "8fd0a1",
      "ç¢»ç¢½ç¢¿ç£‡ç£ˆç£‰ç£Œç£Žç£’ç£“ç£•ç£–ç£¤ç£›ç£Ÿç£ ç£¡ç£¦ç£ªç£²ç£³ç¤€ç£¶ç£·ç£ºç£»ç£¿ç¤†ç¤Œç¤ç¤šç¤œç¤žç¤Ÿç¤ ç¤¥ç¤§ç¤©ç¤­ç¤±ç¤´ç¤µç¤»ç¤½ç¤¿ç¥„ç¥…ç¥†ç¥Šç¥‹ç¥ç¥‘ç¥”ç¥˜ç¥›ç¥œç¥§ç¥©ç¥«ç¥²ç¥¹ç¥»ç¥¼ç¥¾ç¦‹ç¦Œç¦‘ç¦“ç¦”ç¦•ç¦–ç¦˜ç¦›ç¦œç¦¡ç¦¨ç¦©ç¦«ç¦¯ç¦±ç¦´ç¦¸ç¦»ç§‚ç§„ç§‡ç§ˆç§Šç§ç§”ç§–ç§šç§ç§ž",
    ],
    [
      "8fd1a1",
      "ç§ ç§¢ç§¥ç§ªç§«ç§­ç§±ç§¸ç§¼ç¨‚ç¨ƒç¨‡ç¨‰ç¨Šç¨Œç¨‘ç¨•ç¨›ç¨žç¨¡ç¨§ç¨«ç¨­ç¨¯ç¨°ç¨´ç¨µç¨¸ç¨¹ç¨ºç©„ç©…ç©‡ç©ˆç©Œç©•ç©–ç©™ç©œç©ç©Ÿç© ç©¥ç©§ç©ªç©­ç©µç©¸ç©¾çª€çª‚çª…çª†çªŠçª‹çªçª‘çª”çªžçª çª£çª¬çª³çªµçª¹çª»çª¼ç«†ç«‰ç«Œç«Žç«‘ç«›ç«¨ç«©ç««ç«¬ç«±ç«´ç«»ç«½ç«¾ç¬‡ç¬”ç¬Ÿç¬£ç¬§ç¬©ç¬ªç¬«ç¬­ç¬®ç¬¯ç¬°",
    ],
    [
      "8fd2a1",
      "ç¬±ç¬´ç¬½ç¬¿ç­€ç­ç­‡ç­Žç­•ç­ ç­¤ç­¦ç­©ç­ªç­­ç­¯ç­²ç­³ç­·ç®„ç®‰ç®Žç®ç®‘ç®–ç®›ç®žç® ç®¥ç®¬ç®¯ç®°ç®²ç®µç®¶ç®ºç®»ç®¼ç®½ç¯‚ç¯…ç¯ˆç¯Šç¯”ç¯–ç¯—ç¯™ç¯šç¯›ç¯¨ç¯ªç¯²ç¯´ç¯µç¯¸ç¯¹ç¯ºç¯¼ç¯¾ç°ç°‚ç°ƒç°„ç°†ç°‰ç°‹ç°Œç°Žç°ç°™ç°›ç° ç°¥ç°¦ç°¨ç°¬ç°±ç°³ç°´ç°¶ç°¹ç°ºç±†ç±Šç±•ç±‘ç±’ç±“ç±™",
      5,
    ],
    [
      "8fd3a1",
      "ç±¡ç±£ç±§ç±©ç±­ç±®ç±°ç±²ç±¹ç±¼ç±½ç²†ç²‡ç²ç²”ç²žç² ç²¦ç²°ç²¶ç²·ç²ºç²»ç²¼ç²¿ç³„ç³‡ç³ˆç³‰ç³ç³ç³“ç³”ç³•ç³—ç³™ç³šç³ç³¦ç³©ç³«ç³µç´ƒç´‡ç´ˆç´‰ç´ç´‘ç´’ç´“ç´–ç´ç´žç´£ç´¦ç´ªç´­ç´±ç´¼ç´½ç´¾çµ€çµçµ‡çµˆçµçµ‘çµ“çµ—çµ™çµšçµœçµçµ¥çµ§çµªçµ°çµ¸çµºçµ»çµ¿ç¶ç¶‚ç¶ƒç¶…ç¶†ç¶ˆç¶‹ç¶Œç¶ç¶‘ç¶–ç¶—ç¶",
    ],
    [
      "8fd4a1",
      "ç¶žç¶¦ç¶§ç¶ªç¶³ç¶¶ç¶·ç¶¹ç·‚",
      4,
      "ç·Œç·ç·Žç·—ç·™ç¸€ç·¢ç·¥ç·¦ç·ªç·«ç·­ç·±ç·µç·¶ç·¹ç·ºç¸ˆç¸ç¸‘ç¸•ç¸—ç¸œç¸ç¸ ç¸§ç¸¨ç¸¬ç¸­ç¸¯ç¸³ç¸¶ç¸¿ç¹„ç¹…ç¹‡ç¹Žç¹ç¹’ç¹˜ç¹Ÿç¹¡ç¹¢ç¹¥ç¹«ç¹®ç¹¯ç¹³ç¹¸ç¹¾çºçº†çº‡çºŠçºçº‘çº•çº˜çºšçºçºžç¼¼ç¼»ç¼½ç¼¾ç¼¿ç½ƒç½„ç½‡ç½ç½’ç½“ç½›ç½œç½ç½¡ç½£ç½¤ç½¥ç½¦ç½­",
    ],
    [
      "8fd5a1",
      "ç½±ç½½ç½¾ç½¿ç¾€ç¾‹ç¾ç¾ç¾ç¾‘ç¾–ç¾—ç¾œç¾¡ç¾¢ç¾¦ç¾ªç¾­ç¾´ç¾¼ç¾¿ç¿€ç¿ƒç¿ˆç¿Žç¿ç¿›ç¿Ÿç¿£ç¿¥ç¿¨ç¿¬ç¿®ç¿¯ç¿²ç¿ºç¿½ç¿¾ç¿¿è€‡è€ˆè€Šè€è€Žè€è€‘è€“è€”è€–è€è€žè€Ÿè€ è€¤è€¦è€¬è€®è€°è€´è€µè€·è€¹è€ºè€¼è€¾è€è„è è¤è¦è­è±èµè‚è‚ˆè‚Žè‚œè‚žè‚¦è‚§è‚«è‚¸è‚¹èƒˆèƒèƒèƒ’èƒ”èƒ•èƒ—èƒ˜èƒ èƒ­èƒ®",
    ],
    [
      "8fd6a1",
      "èƒ°èƒ²èƒ³èƒ¶èƒ¹èƒºèƒ¾è„ƒè„‹è„–è„—è„˜è„œè„žè„ è„¤è„§è„¬è„°è„µè„ºè„¼è……è…‡è…Šè…Œè…’è…—è… è…¡è…§è…¨è…©è…­è…¯è…·è†è†è†„è†…è††è†‹è†Žè†–è†˜è†›è†žè†¢è†®è†²è†´è†»è‡‹è‡ƒè‡…è‡Šè‡Žè‡è‡•è‡—è‡›è‡è‡žè‡¡è‡¤è‡«è‡¬è‡°è‡±è‡²è‡µè‡¶è‡¸è‡¹è‡½è‡¿èˆ€èˆƒèˆèˆ“èˆ”èˆ™èˆšèˆèˆ¡èˆ¢èˆ¨èˆ²èˆ´èˆºè‰ƒè‰„è‰…è‰†",
    ],
    [
      "8fd7a1",
      "è‰‹è‰Žè‰è‰‘è‰–è‰œè‰ è‰£è‰§è‰­è‰´è‰»è‰½è‰¿èŠ€èŠèŠƒèŠ„èŠ‡èŠ‰èŠŠèŠŽèŠ‘èŠ”èŠ–èŠ˜èŠšèŠ›èŠ èŠ¡èŠ£èŠ¤èŠ§èŠ¨èŠ©èŠªèŠ®èŠ°èŠ²èŠ´èŠ·èŠºèŠ¼èŠ¾èŠ¿è‹†è‹è‹•è‹šè‹ è‹¢è‹¤è‹¨è‹ªè‹­è‹¯è‹¶è‹·è‹½è‹¾èŒ€èŒèŒ‡èŒˆèŒŠèŒ‹è”èŒ›èŒèŒžèŒŸèŒ¡èŒ¢èŒ¬èŒ­èŒ®èŒ°èŒ³èŒ·èŒºèŒ¼èŒ½è‚èƒè„è‡èèŽè‘è•è–è—è°è¸",
    ],
    [
      "8fd8a1",
      "è½è¿èŽ€èŽ‚èŽ„èŽ†èŽèŽ’èŽ”èŽ•èŽ˜èŽ™èŽ›èŽœèŽèŽ¦èŽ§èŽ©èŽ¬èŽ¾èŽ¿è€è‡è‰èèè‘è”èè“è¨èªè¶è¸è¹è¼èè†èŠèè‘è•è™èŽ­è¯è¹è‘…è‘‡è‘ˆè‘Šè‘è‘è‘‘è‘’è‘–è‘˜è‘™è‘šè‘œè‘ è‘¤è‘¥è‘§è‘ªè‘°è‘³è‘´è‘¶è‘¸è‘¼è‘½è’è’…è’’è’“è’•è’žè’¦è’¨è’©è’ªè’¯è’±è’´è’ºè’½è’¾è“€è“‚è“‡è“ˆè“Œè“è““",
    ],
    [
      "8fd9a1",
      "è“œè“§è“ªè“¯è“°è“±è“²è“·è”²è“ºè“»è“½è”‚è”ƒè”‡è”Œè”Žè”è”œè”žè”¢è”£è”¤è”¥è”§è”ªè”«è”¯è”³è”´è”¶è”¿è•†è•",
      4,
      "è•–è•™è•œ",
      6,
      "è•¤è•«è•¯è•¹è•ºè•»è•½è•¿è–è–…è–†è–‰è–‹è–Œè–è–“è–˜è–è–Ÿè– è–¢è–¥è–§è–´è–¶è–·è–¸è–¼è–½è–¾è–¿è—‚è—‡è—Šè—‹è—Žè–­è—˜è—šè—Ÿè— è—¦è—¨è—­è—³è—¶è—¼",
    ],
    [
      "8fdaa1",
      "è—¿è˜€è˜„è˜…è˜è˜Žè˜è˜‘è˜’è˜˜è˜™è˜›è˜žè˜¡è˜§è˜©è˜¶è˜¸è˜ºè˜¼è˜½è™€è™‚è™†è™’è™“è™–è™—è™˜è™™è™è™ ",
      4,
      "è™©è™¬è™¯è™µè™¶è™·è™ºèšèš‘èš–èš˜èššèšœèš¡èš¦èš§èš¨èš­èš±èš³èš´èšµèš·èš¸èš¹èš¿è›€è›è›ƒè›…è›‘è›’è›•è›—è›šè›œè› è›£è›¥è›§èšˆè›ºè›¼è›½èœ„èœ…èœ‡èœ‹èœŽèœèœèœ“èœ”èœ™èœžèœŸèœ¡èœ£",
    ],
    [
      "8fdba1",
      "èœ¨èœ®èœ¯èœ±èœ²èœ¹èœºèœ¼èœ½èœ¾è€èƒè…èè˜èè¡è¤è¥è¯è±è²è»èžƒ",
      6,
      "èž‹èžŒèžèž“èž•èž—èž˜èž™èžžèž èž£èž§èž¬èž­èž®èž±èžµèž¾èž¿èŸèŸˆèŸ‰èŸŠèŸŽèŸ•èŸ–èŸ™èŸšèŸœèŸŸèŸ¢èŸ£èŸ¤èŸªèŸ«èŸ­èŸ±èŸ³èŸ¸èŸºèŸ¿è è ƒè †è ‰è Šè ‹è è ™è ’è “è ”è ˜è šè ›è œè žè Ÿè ¨è ­è ®è °è ²è µ",
    ],
    [
      "8fdca1",
      "è ºè ¼è¡è¡ƒè¡…è¡ˆè¡‰è¡Šè¡‹è¡Žè¡‘è¡•è¡–è¡˜è¡šè¡œè¡Ÿè¡ è¡¤è¡©è¡±è¡¹è¡»è¢€è¢˜è¢šè¢›è¢œè¢Ÿè¢ è¢¨è¢ªè¢ºè¢½è¢¾è£€è£Š",
      4,
      "è£‘è£’è£“è£›è£žè£§è£¯è£°è£±è£µè£·è¤è¤†è¤è¤Žè¤è¤•è¤–è¤˜è¤™è¤šè¤œè¤ è¤¦è¤§è¤¨è¤°è¤±è¤²è¤µè¤¹è¤ºè¤¾è¥€è¥‚è¥…è¥†è¥‰è¥è¥’è¥—è¥šè¥›è¥œè¥¡è¥¢è¥£è¥«è¥®è¥°è¥³è¥µè¥º",
    ],
    [
      "8fdda1",
      "è¥»è¥¼è¥½è¦‰è¦è¦è¦”è¦•è¦›è¦œè¦Ÿè¦ è¦¥è¦°è¦´è¦µè¦¶è¦·è¦¼è§”",
      4,
      "è§¥è§©è§«è§­è§±è§³è§¶è§¹è§½è§¿è¨„è¨…è¨‡è¨è¨‘è¨’è¨”è¨•è¨žè¨ è¨¢è¨¤è¨¦è¨«è¨¬è¨¯è¨µè¨·è¨½è¨¾è©€è©ƒè©…è©‡è©‰è©è©Žè©“è©–è©—è©˜è©œè©è©¡è©¥è©§è©µè©¶è©·è©¹è©ºè©»è©¾è©¿èª€èªƒèª†èª‹èªèªèª’èª–èª—èª™èªŸèª§èª©èª®èª¯èª³",
    ],
    [
      "8fdea1",
      "èª¶èª·èª»èª¾è«ƒè«†è«ˆè«‰è«Šè«‘è«“è«”è«•è«—è«è«Ÿè«¬è«°è«´è«µè«¶è«¼è«¿è¬…è¬†è¬‹è¬‘è¬œè¬žè¬Ÿè¬Šè¬­è¬°è¬·è¬¼è­‚",
      4,
      "è­ˆè­’è­“è­”è­™è­è­žè­£è­­è­¶è­¸è­¹è­¼è­¾è®è®„è®…è®‹è®è®è®”è®•è®œè®žè®Ÿè°¸è°¹è°½è°¾è±…è±‡è±‰è±‹è±è±‘è±“è±”è±—è±˜è±›è±è±™è±£è±¤è±¦è±¨è±©è±­è±³è±µè±¶è±»è±¾è²†",
    ],
    [
      "8fdfa1",
      "è²‡è²‹è²è²’è²“è²™è²›è²œè²¤è²¹è²ºè³…è³†è³‰è³‹è³è³–è³•è³™è³è³¡è³¨è³¬è³¯è³°è³²è³µè³·è³¸è³¾è³¿è´è´ƒè´‰è´’è´—è´›èµ¥èµ©èµ¬èµ®èµ¿è¶‚è¶„è¶ˆè¶è¶è¶‘è¶•è¶žè¶Ÿè¶ è¶¦è¶«è¶¬è¶¯è¶²è¶µè¶·è¶¹è¶»è·€è·…è·†è·‡è·ˆè·Šè·Žè·‘è·”è·•è·—è·™è·¤è·¥è·§è·¬è·°è¶¼è·±è·²è·´è·½è¸è¸„è¸…è¸†è¸‹è¸‘è¸”è¸–è¸ è¸¡è¸¢",
    ],
    [
      "8fe0a1",
      "è¸£è¸¦è¸§è¸±è¸³è¸¶è¸·è¸¸è¸¹è¸½è¹€è¹è¹‹è¹è¹Žè¹è¹”è¹›è¹œè¹è¹žè¹¡è¹¢è¹©è¹¬è¹­è¹¯è¹°è¹±è¹¹è¹ºè¹»èº‚èºƒèº‰èºèº’èº•èºšèº›èºèºžèº¢èº§èº©èº­èº®èº³èºµèººèº»è»€è»è»ƒè»„è»‡è»è»‘è»”è»œè»¨è»®è»°è»±è»·è»¹è»ºè»­è¼€è¼‚è¼‡è¼ˆè¼è¼è¼–è¼—è¼˜è¼žè¼ è¼¡è¼£è¼¥è¼§è¼¨è¼¬è¼­è¼®è¼´è¼µè¼¶è¼·è¼ºè½€è½",
    ],
    [
      "8fe1a1",
      "è½ƒè½‡è½è½‘",
      4,
      "è½˜è½è½žè½¥è¾è¾ è¾¡è¾¤è¾¥è¾¦è¾µè¾¶è¾¸è¾¾è¿€è¿è¿†è¿Šè¿‹è¿è¿è¿’è¿“è¿•è¿ è¿£è¿¤è¿¨è¿®è¿±è¿µè¿¶è¿»è¿¾é€‚é€„é€ˆé€Œé€˜é€›é€¨é€©é€¯é€ªé€¬é€­é€³é€´é€·é€¿éƒé„éŒé›éé¢é¦é§é¬é°é´é¹é‚…é‚ˆé‚‹é‚Œé‚Žé‚é‚•é‚—é‚˜é‚™é‚›é‚ é‚¡é‚¢é‚¥é‚°é‚²é‚³é‚´é‚¶é‚½éƒŒé‚¾éƒƒ",
    ],
    [
      "8fe2a1",
      "éƒ„éƒ…éƒ‡éƒˆéƒ•éƒ—éƒ˜éƒ™éƒœéƒéƒŸéƒ¥éƒ’éƒ¶éƒ«éƒ¯éƒ°éƒ´éƒ¾éƒ¿é„€é„„é„…é„†é„ˆé„é„é„”é„–é„—é„˜é„šé„œé„žé„ é„¥é„¢é„£é„§é„©é„®é„¯é„±é„´é„¶é„·é„¹é„ºé„¼é„½é…ƒé…‡é…ˆé…é…“é…—é…™é…šé…›é…¡é…¤é…§é…­é…´é…¹é…ºé…»é†é†ƒé†…é††é†Šé†Žé†‘é†“é†”é†•é†˜é†žé†¡é†¦é†¨é†¬é†­é†®é†°é†±é†²é†³é†¶é†»é†¼é†½é†¿",
    ],
    [
      "8fe3a1",
      "é‡‚é‡ƒé‡…é‡“é‡”é‡—é‡™é‡šé‡žé‡¤é‡¥é‡©é‡ªé‡¬",
      5,
      "é‡·é‡¹é‡»é‡½éˆ€éˆéˆ„éˆ…éˆ†éˆ‡éˆ‰éˆŠéˆŒéˆéˆ’éˆ“éˆ–éˆ˜éˆœéˆéˆ£éˆ¤éˆ¥éˆ¦éˆ¨éˆ®éˆ¯éˆ°éˆ³éˆµéˆ¶éˆ¸éˆ¹éˆºéˆ¼éˆ¾é‰€é‰‚é‰ƒé‰†é‰‡é‰Šé‰é‰Žé‰é‰‘é‰˜é‰™é‰œé‰é‰ é‰¡é‰¥é‰§é‰¨é‰©é‰®é‰¯é‰°é‰µ",
      4,
      "é‰»é‰¼é‰½é‰¿éŠˆéŠ‰éŠŠéŠéŠŽéŠ’éŠ—",
    ],
    [
      "8fe4a1",
      "éŠ™éŠŸéŠ éŠ¤éŠ¥éŠ§éŠ¨éŠ«éŠ¯éŠ²éŠ¶éŠ¸éŠºéŠ»éŠ¼éŠ½éŠ¿",
      4,
      "é‹…é‹†é‹‡é‹ˆé‹‹é‹Œé‹é‹Žé‹é‹“é‹•é‹—é‹˜é‹™é‹œé‹é‹Ÿé‹ é‹¡é‹£é‹¥é‹§é‹¨é‹¬é‹®é‹°é‹¹é‹»é‹¿éŒ€éŒ‚éŒˆéŒéŒ‘éŒ”éŒ•éŒœéŒéŒžéŒŸéŒ¡éŒ¤éŒ¥éŒ§éŒ©éŒªéŒ³éŒ´éŒ¶éŒ·é‡éˆé‰éé‘é’é•é—é˜éšéžé¤é¥é§é©éªé­é¯é°é±é³é´é¶",
    ],
    [
      "8fe5a1",
      "éºé½é¿éŽ€éŽéŽ‚éŽˆéŽŠéŽ‹éŽéŽéŽ’éŽ•éŽ˜éŽ›éŽžéŽ¡éŽ£éŽ¤éŽ¦éŽ¨éŽ«éŽ´éŽµéŽ¶éŽºéŽ©éé„é…é†é‡é‰",
      4,
      "é“é™éœéžéŸé¢é¦é§é¹é·é¸éºé»é½éé‚é„éˆé‰ééŽéé•é–é—éŸé®é¯é±é²é³é´é»é¿é½é‘ƒé‘…é‘ˆé‘Šé‘Œé‘•é‘™é‘œé‘Ÿé‘¡é‘£é‘¨é‘«é‘­é‘®é‘¯é‘±é‘²é’„é’ƒé•¸é•¹",
    ],
    [
      "8fe6a1",
      "é•¾é–„é–ˆé–Œé–é–Žé–é–žé–Ÿé–¡é–¦é–©é–«é–¬é–´é–¶é–ºé–½é–¿é—†é—ˆé—‰é—‹é—é—‘é—’é—“é—™é—šé—é—žé—Ÿé— é—¤é—¦é˜é˜žé˜¢é˜¤é˜¥é˜¦é˜¬é˜±é˜³é˜·é˜¸é˜¹é˜ºé˜¼é˜½é™é™’é™”é™–é™—é™˜é™¡é™®é™´é™»é™¼é™¾é™¿éšéš‚éšƒéš„éš‰éš‘éš–éššéšéšŸéš¤éš¥éš¦éš©éš®éš¯éš³éšºé›Šé›’å¶²é›˜é›šé›é›žé›Ÿé›©é›¯é›±é›ºéœ‚",
    ],
    [
      "8fe7a1",
      "éœƒéœ…éœ‰éœšéœ›éœéœ¡éœ¢éœ£éœ¨éœ±éœ³ééƒéŠéŽéé•é—é˜éšé›é£é§éªé®é³é¶é·é¸é»é½é¿éž€éž‰éž•éž–éž—éž™éžšéžžéžŸéž¢éž¬éž®éž±éž²éžµéž¶éž¸éž¹éžºéž¼éž¾éž¿éŸéŸ„éŸ…éŸ‡éŸ‰éŸŠéŸŒéŸéŸŽéŸéŸ‘éŸ”éŸ—éŸ˜éŸ™éŸéŸžéŸ éŸ›éŸ¡éŸ¤éŸ¯éŸ±éŸ´éŸ·éŸ¸éŸºé ‡é Šé ™é é Žé ”é –é œé žé  é £é ¦",
    ],
    [
      "8fe8a1",
      "é «é ®é ¯é °é ²é ³é µé ¥é ¾é¡„é¡‡é¡Šé¡‘é¡’é¡“é¡–é¡—é¡™é¡šé¡¢é¡£é¡¥é¡¦é¡ªé¡¬é¢«é¢­é¢®é¢°é¢´é¢·é¢¸é¢ºé¢»é¢¿é£‚é£…é£ˆé£Œé£¡é££é£¥é£¦é£§é£ªé£³é£¶é¤‚é¤‡é¤ˆé¤‘é¤•é¤–é¤—é¤šé¤›é¤œé¤Ÿé¤¢é¤¦é¤§é¤«é¤±",
      4,
      "é¤¹é¤ºé¤»é¤¼é¥€é¥é¥†é¥‡é¥ˆé¥é¥Žé¥”é¥˜é¥™é¥›é¥œé¥žé¥Ÿé¥ é¦›é¦é¦Ÿé¦¦é¦°é¦±é¦²é¦µ",
    ],
    [
      "8fe9a1",
      "é¦¹é¦ºé¦½é¦¿é§ƒé§‰é§“é§”é§™é§šé§œé§žé§§é§ªé§«é§¬é§°é§´é§µé§¹é§½é§¾é¨‚é¨ƒé¨„é¨‹é¨Œé¨é¨‘é¨–é¨žé¨ é¨¢é¨£é¨¤é¨§é¨­é¨®é¨³é¨µé¨¶é¨¸é©‡é©é©„é©Šé©‹é©Œé©Žé©‘é©”é©–é©éªªéª¬éª®éª¯éª²éª´éªµéª¶éª¹éª»éª¾éª¿é«é«ƒé«†é«ˆé«Žé«é«’é«•é«–é«—é«›é«œé« é«¤é«¥é«§é«©é«¬é«²é«³é«µé«¹é«ºé«½é«¿",
      4,
    ],
    [
      "8feaa1",
      "é¬„é¬…é¬ˆé¬‰é¬‹é¬Œé¬é¬Žé¬é¬’é¬–é¬™é¬›é¬œé¬ é¬¦é¬«é¬­é¬³é¬´é¬µé¬·é¬¹é¬ºé¬½é­ˆé­‹é­Œé­•é­–é­—é­›é­žé­¡é­£é­¥é­¦é­¨é­ª",
      4,
      "é­³é­µé­·é­¸é­¹é­¿é®€é®„é®…é®†é®‡é®‰é®Šé®‹é®é®é®é®”é®šé®é®žé®¦é®§é®©é®¬é®°é®±é®²é®·é®¸é®»é®¼é®¾é®¿é¯é¯‡é¯ˆé¯Žé¯é¯—é¯˜é¯é¯Ÿé¯¥é¯§é¯ªé¯«é¯¯é¯³é¯·é¯¸",
    ],
    [
      "8feba1",
      "é¯¹é¯ºé¯½é¯¿é°€é°‚é°‹é°é°‘é°–é°˜é°™é°šé°œé°žé°¢é°£é°¦",
      4,
      "é°±é°µé°¶é°·é°½é±é±ƒé±„é±…é±‰é±Šé±Žé±é±é±“é±”é±–é±˜é±›é±é±žé±Ÿé±£é±©é±ªé±œé±«é±¨é±®é±°é±²é±µé±·é±»é³¦é³²é³·é³¹é´‹é´‚é´‘é´—é´˜é´œé´é´žé´¯é´°é´²é´³é´´é´ºé´¼éµ…é´½éµ‚éµƒéµ‡éµŠéµ“éµ”éµŸéµ£éµ¢éµ¥éµ©éµªéµ«éµ°éµ¶éµ·éµ»",
    ],
    [
      "8feca1",
      "éµ¼éµ¾é¶ƒé¶„é¶†é¶Šé¶é¶Žé¶’é¶“é¶•é¶–é¶—é¶˜é¶¡é¶ªé¶¬é¶®é¶±é¶µé¶¹é¶¼é¶¿é·ƒé·‡é·‰é·Šé·”é·•é·–é·—é·šé·žé·Ÿé· é·¥é·§é·©é·«é·®é·°é·³é·´é·¾é¸Šé¸‚é¸‡é¸Žé¸é¸‘é¸’é¸•é¸–é¸™é¸œé¸é¹ºé¹»é¹¼éº€éº‚éºƒéº„éº…éº‡éºŽéºéº–éº˜éº›éºžéº¤éº¨éº¬éº®éº¯éº°éº³éº´éºµé»†é»ˆé»‹é»•é»Ÿé»¤é»§é»¬é»­é»®é»°é»±é»²é»µ",
    ],
    [
      "8feda1",
      "é»¸é»¿é¼‚é¼ƒé¼‰é¼é¼é¼‘é¼’é¼”é¼–é¼—é¼™é¼šé¼›é¼Ÿé¼¢é¼¦é¼ªé¼«é¼¯é¼±é¼²é¼´é¼·é¼¹é¼ºé¼¼é¼½é¼¿é½é½ƒ",
      4,
      "é½“é½•é½–é½—é½˜é½šé½é½žé½¨é½©é½­",
      4,
      "é½³é½µé½ºé½½é¾é¾é¾‘é¾’é¾”é¾–é¾—é¾žé¾¡é¾¢é¾£é¾¥",
    ],
  ],
  dh = [
    ["0", "\0", 127, "â‚¬"],
    [
      "8140",
      "ä¸‚ä¸„ä¸…ä¸†ä¸ä¸’ä¸—ä¸Ÿä¸ ä¸¡ä¸£ä¸¦ä¸©ä¸®ä¸¯ä¸±ä¸³ä¸µä¸·ä¸¼ä¹€ä¹ä¹‚ä¹„ä¹†ä¹Šä¹‘ä¹•ä¹—ä¹šä¹›ä¹¢ä¹£ä¹¤ä¹¥ä¹§ä¹¨ä¹ª",
      5,
      "ä¹²ä¹´",
      9,
      "ä¹¿",
      6,
      "äº‡äºŠ",
    ],
    [
      "8180",
      "äºäº–äº—äº™äºœäºäºžäº£äºªäº¯äº°äº±äº´äº¶äº·äº¸äº¹äº¼äº½äº¾ä»ˆä»Œä»ä»ä»’ä»šä»›ä»œä» ä»¢ä»¦ä»§ä»©ä»­ä»®ä»¯ä»±ä»´ä»¸ä»¹ä»ºä»¼ä»¾ä¼€ä¼‚",
      6,
      "ä¼‹ä¼Œä¼’",
      4,
      "ä¼œä¼ä¼¡ä¼£ä¼¨ä¼©ä¼¬ä¼­ä¼®ä¼±ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾",
      4,
      "ä½„ä½…ä½‡",
      5,
      "ä½’ä½”ä½–ä½¡ä½¢ä½¦ä½¨ä½ªä½«ä½­ä½®ä½±ä½²ä½µä½·ä½¸ä½¹ä½ºä½½ä¾€ä¾ä¾‚ä¾…ä¾†ä¾‡ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾•ä¾–ä¾˜ä¾™ä¾šä¾œä¾žä¾Ÿä¾¡ä¾¢",
    ],
    [
      "8240",
      "ä¾¤ä¾«ä¾­ä¾°",
      4,
      "ä¾¶",
      8,
      "ä¿€ä¿ä¿‚ä¿†ä¿‡ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿’",
      4,
      "ä¿™ä¿›ä¿ ä¿¢ä¿¤ä¿¥ä¿§ä¿«ä¿¬ä¿°ä¿²ä¿´ä¿µä¿¶ä¿·ä¿¹ä¿»ä¿¼ä¿½ä¿¿",
      11,
    ],
    [
      "8280",
      "å€‹å€Žå€å€‘å€“å€•å€–å€—å€›å€å€žå€ å€¢å€£å€¤å€§å€«å€¯",
      10,
      "å€»å€½å€¿å€åå‚å„å…å†å‰åŠå‹åå",
      4,
      "å–å—å˜å™å›å",
      7,
      "å¦",
      5,
      "å­",
      8,
      "å¸å¹åºå¼å½å‚å‚‚å‚ƒå‚„å‚†å‚‡å‚‰å‚Šå‚‹å‚Œå‚Ž",
      20,
      "å‚¤å‚¦å‚ªå‚«å‚­",
      4,
      "å‚³",
      6,
      "å‚¼",
    ],
    [
      "8340",
      "å‚½",
      17,
      "åƒ",
      5,
      "åƒ—åƒ˜åƒ™åƒ›",
      10,
      "åƒ¨åƒ©åƒªåƒ«åƒ¯åƒ°åƒ±åƒ²åƒ´åƒ¶",
      4,
      "åƒ¼",
      9,
      "å„ˆ",
    ],
    [
      "8380",
      "å„‰å„Šå„Œ",
      5,
      "å„“",
      13,
      "å„¢",
      28,
      "å…‚å…‡å…Šå…Œå…Žå…å…å…’å…“å…—å…˜å…™å…›å…",
      4,
      "å…£å…¤å…¦å…§å…©å…ªå…¯å…²å…ºå…¾å…¿å†ƒå†„å††å†‡å†Šå†‹å†Žå†å†å†‘å†“å†”å†˜å†šå†å†žå†Ÿå†¡å†£å†¦",
      4,
      "å†­å†®å†´å†¸å†¹å†ºå†¾å†¿å‡å‡‚å‡ƒå‡…å‡ˆå‡Šå‡å‡Žå‡å‡’",
      5,
    ],
    [
      "8440",
      "å‡˜å‡™å‡šå‡œå‡žå‡Ÿå‡¢å‡£å‡¥",
      5,
      "å‡¬å‡®å‡±å‡²å‡´å‡·å‡¾åˆ„åˆ…åˆ‰åˆ‹åˆŒåˆåˆåˆ“åˆ”åˆ•åˆœåˆžåˆŸåˆ¡åˆ¢åˆ£åˆ¥åˆ¦åˆ§åˆªåˆ¬åˆ¯åˆ±åˆ²åˆ´åˆµåˆ¼åˆ¾å‰„",
      5,
      "å‰‹å‰Žå‰å‰’å‰“å‰•å‰—å‰˜",
    ],
    [
      "8480",
      "å‰™å‰šå‰›å‰å‰Ÿå‰ å‰¢å‰£å‰¤å‰¦å‰¨å‰«å‰¬å‰­å‰®å‰°å‰±å‰³",
      9,
      "å‰¾åŠ€åŠƒ",
      4,
      "åŠ‰",
      6,
      "åŠ‘åŠ’åŠ”",
      6,
      "åŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ®åŠ¯åŠ°åŠ´",
      9,
      "å‹€å‹å‹‚å‹„å‹…å‹†å‹ˆå‹Šå‹Œå‹å‹Žå‹å‹‘å‹“å‹”å‹•å‹—å‹™",
      5,
      "å‹ å‹¡å‹¢å‹£å‹¥",
      10,
      "å‹±",
      7,
      "å‹»å‹¼å‹½åŒåŒ‚åŒƒåŒ„åŒ‡åŒ‰åŒŠåŒ‹åŒŒåŒŽ",
    ],
    [
      "8540",
      "åŒ‘åŒ’åŒ“åŒ”åŒ˜åŒ›åŒœåŒžåŒŸåŒ¢åŒ¤åŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ¯",
      9,
      "åŒ¼åŒ½å€å‚å„å†å‹åŒååå”å˜å™å›åå¥å¨åªå¬å­å²å¶å¹å»å¼å½å¾åŽ€åŽåŽƒåŽ‡åŽˆåŽŠåŽŽåŽ",
    ],
    [
      "8580",
      "åŽ",
      4,
      "åŽ–åŽ—åŽ™åŽ›åŽœåŽžåŽ åŽ¡åŽ¤åŽ§åŽªåŽ«åŽ¬åŽ­åŽ¯",
      6,
      "åŽ·åŽ¸åŽ¹åŽºåŽ¼åŽ½åŽ¾å€åƒ",
      4,
      "åŽååå’å“å•åšåœååžå¡å¢å§å´åºå¾å¿å€å‚å…å‡å‹å”å˜å™åšåœå¢å¤å¥åªå°å³å¶å·åºå½å¿å‘å‘‚å‘„å‘…å‘‡å‘‰å‘Œå‘å‘Žå‘å‘‘å‘šå‘",
      4,
      "å‘£å‘¥å‘§å‘©",
      7,
      "å‘´å‘¹å‘ºå‘¾å‘¿å’å’ƒå’…å’‡å’ˆå’‰å’Šå’å’‘å’“å’—å’˜å’œå’žå’Ÿå’ å’¡",
    ],
    [
      "8640",
      "å’¢å’¥å’®å’°å’²å’µå’¶å’·å’¹å’ºå’¼å’¾å“ƒå“…å“Šå“‹å“–å“˜å“›å“ ",
      4,
      "å“«å“¬å“¯å“°å“±å“´",
      5,
      "å“»å“¾å”€å”‚å”ƒå”„å”…å”ˆå”Š",
      4,
      "å”’å”“å”•",
      5,
      "å”œå”å”žå”Ÿå”¡å”¥å”¦",
    ],
    [
      "8680",
      "å”¨å”©å”«å”­å”²å”´å”µå”¶å”¸å”¹å”ºå”»å”½å•€å•‚å•…å•‡å•ˆå•‹",
      4,
      "å•‘å•’å•“å•”å•—",
      4,
      "å•å•žå•Ÿå• å•¢å•£å•¨å•©å•«å•¯",
      5,
      "å•¹å•ºå•½å•¿å–…å–†å–Œå–å–Žå–å–’å–“å–•å––å–—å–šå–›å–žå– ",
      6,
      "å–¨",
      8,
      "å–²å–´å–¶å–¸å–ºå–¼å–¿",
      4,
      "å—†å—‡å—ˆå—Šå—‹å—Žå—å—å—•å——",
      4,
      "å—žå— å—¢å—§å—©å—­å—®å—°å—±å—´å—¶å—¸",
      4,
      "å—¿å˜‚å˜ƒå˜„å˜…",
    ],
    [
      "8740",
      "å˜†å˜‡å˜Šå˜‹å˜å˜",
      7,
      "å˜™å˜šå˜œå˜å˜ å˜¡å˜¢å˜¥å˜¦å˜¨å˜©å˜ªå˜«å˜®å˜¯å˜°å˜³å˜µå˜·å˜¸å˜ºå˜¼å˜½å˜¾å™€",
      11,
      "å™",
      4,
      "å™•å™–å™šå™›å™",
      4,
    ],
    [
      "8780",
      "å™£å™¥å™¦å™§å™­å™®å™¯å™°å™²å™³å™´å™µå™·å™¸å™¹å™ºå™½",
      7,
      "åš‡",
      6,
      "åšåš‘åš’åš”",
      14,
      "åš¤",
      10,
      "åš°",
      6,
      "åš¸åš¹åšºåš»åš½",
      12,
      "å›‹",
      8,
      "å›•å›–å›˜å›™å›œå›£å›¥",
      5,
      "å›¬å›®å›¯å›²å›³å›¶å›·å›¸å›»å›¼åœ€åœåœ‚åœ…åœ‡åœ‹",
      6,
    ],
    [
      "8840",
      "åœ’",
      9,
      "åœåœžåœ åœ¡åœ¢åœ¤åœ¥åœ¦åœ§åœ«åœ±åœ²åœ´",
      4,
      "åœ¼åœ½åœ¿ååƒå„å…å†åˆå‰å‹å’",
      4,
      "å˜å™å¢å£å¥å§å¬å®å°å±å²å´åµå¸å¹åºå½å¾å¿åž€",
    ],
    [
      "8880",
      "åžåž‡åžˆåž‰åžŠåž",
      4,
      "åž”",
      6,
      "åžœåžåžžåžŸåž¥åž¨åžªåž¬åž¯åž°åž±åž³åžµåž¶åž·åž¹",
      8,
      "åŸ„",
      6,
      "åŸŒåŸåŸåŸ‘åŸ“åŸ–åŸ—åŸ›åŸœåŸžåŸ¡åŸ¢åŸ£åŸ¥",
      7,
      "åŸ®åŸ°åŸ±åŸ²åŸ³åŸµåŸ¶åŸ·åŸ»åŸ¼åŸ¾åŸ¿å å ƒå „å …å ˆå ‰å Šå Œå Žå å å ’å “å ”å –å —å ˜å šå ›å œå å Ÿå ¢å £å ¥",
      4,
      "å «",
      4,
      "å ±å ²å ³å ´å ¶",
      7,
    ],
    [
      "8940",
      "å ¾",
      5,
      "å¡…",
      6,
      "å¡Žå¡å¡å¡’å¡“å¡•å¡–å¡—å¡™",
      4,
      "å¡Ÿ",
      5,
      "å¡¦",
      4,
      "å¡­",
      16,
      "å¡¿å¢‚å¢„å¢†å¢‡å¢ˆå¢Šå¢‹å¢Œ",
    ],
    [
      "8980",
      "å¢",
      4,
      "å¢”",
      4,
      "å¢›å¢œå¢å¢ ",
      7,
      "å¢ª",
      17,
      "å¢½å¢¾å¢¿å£€å£‚å£ƒå£„å£†",
      10,
      "å£’å£“å£”å£–",
      13,
      "å£¥",
      5,
      "å£­å£¯å£±å£²å£´å£µå£·å£¸å£º",
      7,
      "å¤ƒå¤…å¤†å¤ˆ",
      4,
      "å¤Žå¤å¤‘å¤’å¤“å¤—å¤˜å¤›å¤å¤žå¤ å¤¡å¤¢å¤£å¤¦å¤¨å¤¬å¤°å¤²å¤³å¤µå¤¶å¤»",
    ],
    [
      "8a40",
      "å¤½å¤¾å¤¿å¥€å¥ƒå¥…å¥†å¥Šå¥Œå¥å¥å¥’å¥“å¥™å¥›",
      4,
      "å¥¡å¥£å¥¤å¥¦",
      12,
      "å¥µå¥·å¥ºå¥»å¥¼å¥¾å¥¿å¦€å¦…å¦‰å¦‹å¦Œå¦Žå¦å¦å¦‘å¦”å¦•å¦˜å¦šå¦›å¦œå¦å¦Ÿå¦ å¦¡å¦¢å¦¦",
    ],
    [
      "8a80",
      "å¦§å¦¬å¦­å¦°å¦±å¦³",
      5,
      "å¦ºå¦¼å¦½å¦¿",
      6,
      "å§‡å§ˆå§‰å§Œå§å§Žå§å§•å§–å§™å§›å§ž",
      4,
      "å§¤å§¦å§§å§©å§ªå§«å§­",
      11,
      "å§ºå§¼å§½å§¾å¨€å¨‚å¨Šå¨‹å¨å¨Žå¨å¨å¨’å¨”å¨•å¨–å¨—å¨™å¨šå¨›å¨å¨žå¨¡å¨¢å¨¤å¨¦å¨§å¨¨å¨ª",
      6,
      "å¨³å¨µå¨·",
      4,
      "å¨½å¨¾å¨¿å©",
      4,
      "å©‡å©ˆå©‹",
      9,
      "å©–å©—å©˜å©™å©›",
      5,
    ],
    [
      "8b40",
      "å©¡å©£å©¤å©¥å©¦å©¨å©©å©«",
      8,
      "å©¸å©¹å©»å©¼å©½å©¾åª€",
      17,
      "åª“",
      6,
      "åªœ",
      13,
      "åª«åª¬",
    ],
    [
      "8b80",
      "åª­",
      4,
      "åª´åª¶åª·åª¹",
      4,
      "åª¿å«€å«ƒ",
      5,
      "å«Šå«‹å«",
      4,
      "å«“å«•å«—å«™å«šå«›å«å«žå«Ÿå«¢å«¤å«¥å«§å«¨å«ªå«¬",
      4,
      "å«²",
      22,
      "å¬Š",
      11,
      "å¬˜",
      25,
      "å¬³å¬µå¬¶å¬¸",
      7,
      "å­",
      6,
    ],
    [
      "8c40",
      "å­ˆ",
      7,
      "å­’å­–å­žå­ å­¡å­§å­¨å­«å­­å­®å­¯å­²å­´å­¶å­·å­¸å­¹å­»å­¼å­¾å­¿å®‚å®†å®Šå®å®Žå®å®‘å®’å®”å®–å®Ÿå®§å®¨å®©å®¬å®­å®®å®¯å®±å®²å®·å®ºå®»å®¼å¯€å¯å¯ƒå¯ˆå¯‰å¯Šå¯‹å¯å¯Žå¯",
    ],
    [
      "8c80",
      "å¯‘å¯”",
      8,
      "å¯ å¯¢å¯£å¯¦å¯§å¯©",
      4,
      "å¯¯å¯±",
      6,
      "å¯½å¯¾å°€å°‚å°ƒå°…å°‡å°ˆå°‹å°Œå°å°Žå°å°’å°“å°—å°™å°›å°žå°Ÿå° å°¡å°£å°¦å°¨å°©å°ªå°«å°­å°®å°¯å°°å°²å°³å°µå°¶å°·å±ƒå±„å±†å±‡å±Œå±å±’å±“å±”å±–å±—å±˜å±šå±›å±œå±å±Ÿå±¢å±¤å±§",
      6,
      "å±°å±²",
      6,
      "å±»å±¼å±½å±¾å²€å²ƒ",
      4,
      "å²‰å²Šå²‹å²Žå²å²’å²“å²•å²",
      4,
      "å²¤",
      4,
    ],
    [
      "8d40",
      "å²ªå²®å²¯å²°å²²å²´å²¶å²¹å²ºå²»å²¼å²¾å³€å³‚å³ƒå³…",
      5,
      "å³Œ",
      5,
      "å³“",
      5,
      "å³š",
      6,
      "å³¢å³£å³§å³©å³«å³¬å³®å³¯å³±",
      9,
      "å³¼",
      4,
    ],
    [
      "8d80",
      "å´å´„å´…å´ˆ",
      5,
      "å´",
      4,
      "å´•å´—å´˜å´™å´šå´œå´å´Ÿ",
      4,
      "å´¥å´¨å´ªå´«å´¬å´¯",
      4,
      "å´µ",
      7,
      "å´¿",
      7,
      "åµˆåµ‰åµ",
      10,
      "åµ™åµšåµœåµž",
      10,
      "åµªåµ­åµ®åµ°åµ±åµ²åµ³åµµ",
      12,
      "å¶ƒ",
      21,
      "å¶šå¶›å¶œå¶žå¶Ÿå¶ ",
    ],
    ["8e40", "å¶¡", 21, "å¶¸", 12, "å·†", 6, "å·Ž", 12, "å·œå·Ÿå· å·£å·¤å·ªå·¬å·­"],
    [
      "8e80",
      "å·°å·µå·¶å·¸",
      4,
      "å·¿å¸€å¸„å¸‡å¸‰å¸Šå¸‹å¸å¸Žå¸’å¸“å¸—å¸ž",
      7,
      "å¸¨",
      4,
      "å¸¯å¸°å¸²",
      4,
      "å¸¹å¸ºå¸¾å¸¿å¹€å¹å¹ƒå¹†",
      5,
      "å¹",
      6,
      "å¹–",
      4,
      "å¹œå¹å¹Ÿå¹ å¹£",
      14,
      "å¹µå¹·å¹¹å¹¾åºåº‚åºƒåº…åºˆåº‰åºŒåºåºŽåº’åº˜åº›åºåº¡åº¢åº£åº¤åº¨",
      4,
      "åº®",
      4,
      "åº´åººåº»åº¼åº½åº¿",
      6,
    ],
    [
      "8f40",
      "å»†å»‡å»ˆå»‹",
      5,
      "å»”å»•å»—å»˜å»™å»šå»œ",
      11,
      "å»©å»«",
      8,
      "å»µå»¸å»¹å»»å»¼å»½å¼…å¼†å¼‡å¼‰å¼Œå¼å¼Žå¼å¼’å¼”å¼–å¼™å¼šå¼œå¼å¼žå¼¡å¼¢å¼£å¼¤",
    ],
    [
      "8f80",
      "å¼¨å¼«å¼¬å¼®å¼°å¼²",
      6,
      "å¼»å¼½å¼¾å¼¿å½",
      14,
      "å½‘å½”å½™å½šå½›å½œå½žå½Ÿå½ å½£å½¥å½§å½¨å½«å½®å½¯å½²å½´å½µå½¶å½¸å½ºå½½å½¾å½¿å¾ƒå¾†å¾å¾Žå¾å¾‘å¾“å¾”å¾–å¾šå¾›å¾å¾žå¾Ÿå¾ å¾¢",
      5,
      "å¾©å¾«å¾¬å¾¯",
      5,
      "å¾¶å¾¸å¾¹å¾ºå¾»å¾¾",
      4,
      "å¿‡å¿ˆå¿Šå¿‹å¿Žå¿“å¿”å¿•å¿šå¿›å¿œå¿žå¿Ÿå¿¢å¿£å¿¥å¿¦å¿¨å¿©å¿¬å¿¯å¿°å¿²å¿³å¿´å¿¶å¿·å¿¹å¿ºå¿¼æ€‡",
    ],
    [
      "9040",
      "æ€ˆæ€‰æ€‹æ€Œæ€æ€‘æ€“æ€—æ€˜æ€šæ€žæ€Ÿæ€¢æ€£æ€¤æ€¬æ€­æ€®æ€°",
      4,
      "æ€¶",
      4,
      "æ€½æ€¾æ€æ„",
      6,
      "æŒæŽææ‘æ“æ”æ–æ—æ˜æ›æœæžæŸæ æ¡æ¥æ¦æ®æ±æ²æ´æµæ·æ¾æ‚€",
    ],
    [
      "9080",
      "æ‚æ‚‚æ‚…æ‚†æ‚‡æ‚ˆæ‚Šæ‚‹æ‚Žæ‚æ‚æ‚‘æ‚“æ‚•æ‚—æ‚˜æ‚™æ‚œæ‚žæ‚¡æ‚¢æ‚¤æ‚¥æ‚§æ‚©æ‚ªæ‚®æ‚°æ‚³æ‚µæ‚¶æ‚·æ‚¹æ‚ºæ‚½",
      7,
      "æƒ‡æƒˆæƒ‰æƒŒ",
      4,
      "æƒ’æƒ“æƒ”æƒ–æƒ—æƒ™æƒ›æƒžæƒ¡",
      4,
      "æƒªæƒ±æƒ²æƒµæƒ·æƒ¸æƒ»",
      4,
      "æ„‚æ„ƒæ„„æ„…æ„‡æ„Šæ„‹æ„Œæ„",
      4,
      "æ„–æ„—æ„˜æ„™æ„›æ„œæ„æ„žæ„¡æ„¢æ„¥æ„¨æ„©æ„ªæ„¬",
      18,
      "æ…€",
      6,
    ],
    [
      "9140",
      "æ…‡æ…‰æ…‹æ…æ…æ…æ…’æ…“æ…”æ…–",
      6,
      "æ…žæ…Ÿæ… æ…¡æ…£æ…¤æ…¥æ…¦æ…©",
      6,
      "æ…±æ…²æ…³æ…´æ…¶æ…¸",
      18,
      "æ†Œæ†æ†",
      4,
      "æ†•",
    ],
    [
      "9180",
      "æ†–",
      6,
      "æ†ž",
      8,
      "æ†ªæ†«æ†­",
      9,
      "æ†¸",
      5,
      "æ†¿æ‡€æ‡æ‡ƒ",
      4,
      "æ‡‰æ‡Œ",
      4,
      "æ‡“æ‡•",
      16,
      "æ‡§",
      13,
      "æ‡¶",
      8,
      "æˆ€",
      5,
      "æˆ‡æˆ‰æˆ“æˆ”æˆ™æˆœæˆæˆžæˆ æˆ£æˆ¦æˆ§æˆ¨æˆ©æˆ«æˆ­æˆ¯æˆ°æˆ±æˆ²æˆµæˆ¶æˆ¸",
      4,
      "æ‰‚æ‰„æ‰…æ‰†æ‰Š",
    ],
    [
      "9240",
      "æ‰æ‰æ‰•æ‰–æ‰—æ‰™æ‰šæ‰œ",
      6,
      "æ‰¤æ‰¥æ‰¨æ‰±æ‰²æ‰´æ‰µæ‰·æ‰¸æ‰ºæ‰»æ‰½æŠæŠ‚æŠƒæŠ…æŠ†æŠ‡æŠˆæŠ‹",
      5,
      "æŠ”æŠ™æŠœæŠæŠžæŠ£æŠ¦æŠ§æŠ©æŠªæŠ­æŠ®æŠ¯æŠ°æŠ²æŠ³æŠ´æŠ¶æŠ·æŠ¸æŠºæŠ¾æ‹€æ‹",
    ],
    [
      "9280",
      "æ‹ƒæ‹‹æ‹æ‹‘æ‹•æ‹æ‹žæ‹ æ‹¡æ‹¤æ‹ªæ‹«æ‹°æ‹²æ‹µæ‹¸æ‹¹æ‹ºæ‹»æŒ€æŒƒæŒ„æŒ…æŒ†æŒŠæŒ‹æŒŒæŒæŒæŒæŒ’æŒ“æŒ”æŒ•æŒ—æŒ˜æŒ™æŒœæŒ¦æŒ§æŒ©æŒ¬æŒ­æŒ®æŒ°æŒ±æŒ³",
      5,
      "æŒ»æŒ¼æŒ¾æŒ¿æ€ææ„æ‡æˆæŠæ‘æ’æ“æ”æ–",
      7,
      "æ æ¤æ¥æ¦æ¨æªæ«æ¬æ¯æ°æ²æ³æ´æµæ¸æ¹æ¼æ½æ¾æ¿æŽæŽƒæŽ„æŽ…æŽ†æŽ‹æŽæŽ‘æŽ“æŽ”æŽ•æŽ—æŽ™",
      6,
      "æŽ¡æŽ¤æŽ¦æŽ«æŽ¯æŽ±æŽ²æŽµæŽ¶æŽ¹æŽ»æŽ½æŽ¿æ€",
    ],
    [
      "9340",
      "ææ‚æƒæ…æ‡æˆæŠæ‹æŒæ‘æ“æ”æ•æ—",
      6,
      "æŸæ¢æ¤",
      4,
      "æ«æ¬æ®æ¯æ°æ±æ³æµæ·æ¹æºæ»æ¼æ¾æƒæ„æ†",
      4,
      "ææŽæ‘æ’æ•",
      5,
      "ææŸæ¢æ£æ¤",
    ],
    [
      "9380",
      "æ¥æ§æ¨æ©æ«æ®",
      5,
      "æµ",
      4,
      "æ»æ¼æ¾æ‘€æ‘‚æ‘ƒæ‘‰æ‘‹",
      6,
      "æ‘“æ‘•æ‘–æ‘—æ‘™",
      4,
      "æ‘Ÿ",
      7,
      "æ‘¨æ‘ªæ‘«æ‘¬æ‘®",
      9,
      "æ‘»",
      6,
      "æ’ƒæ’†æ’ˆ",
      8,
      "æ’“æ’”æ’—æ’˜æ’šæ’›æ’œæ’æ’Ÿ",
      4,
      "æ’¥æ’¦æ’§æ’¨æ’ªæ’«æ’¯æ’±æ’²æ’³æ’´æ’¶æ’¹æ’»æ’½æ’¾æ’¿æ“æ“ƒæ“„æ“†",
      6,
      "æ“æ“‘æ““æ“”æ“•æ“–æ“™æ“š",
    ],
    ["9440", "æ“›æ“œæ“æ“Ÿæ“ æ“¡æ“£æ“¥æ“§", 24, "æ”", 7, "æ”Š", 7, "æ”“", 4, "æ”™", 8],
    [
      "9480",
      "æ”¢æ”£æ”¤æ”¦",
      4,
      "æ”¬æ”­æ”°æ”±æ”²æ”³æ”·æ”ºæ”¼æ”½æ•€",
      4,
      "æ•†æ•‡æ•Šæ•‹æ•æ•Žæ•æ•’æ•“æ•”æ•—æ•˜æ•šæ•œæ•Ÿæ• æ•¡æ•¤æ•¥æ•§æ•¨æ•©æ•ªæ•­æ•®æ•¯æ•±æ•³æ•µæ•¶æ•¸",
      14,
      "æ–ˆæ–‰æ–Šæ–æ–Žæ–æ–’æ–”æ–•æ––æ–˜æ–šæ–æ–žæ– æ–¢æ–£æ–¦æ–¨æ–ªæ–¬æ–®æ–±",
      7,
      "æ–ºæ–»æ–¾æ–¿æ—€æ—‚æ—‡æ—ˆæ—‰æ—Šæ—æ—æ—‘æ—“æ—”æ—•æ—˜",
      7,
      "æ—¡æ—£æ—¤æ—ªæ—«",
    ],
    [
      "9540",
      "æ—²æ—³æ—´æ—µæ—¸æ—¹æ—»",
      4,
      "æ˜æ˜„æ˜…æ˜‡æ˜ˆæ˜‰æ˜‹æ˜æ˜æ˜‘æ˜’æ˜–æ˜—æ˜˜æ˜šæ˜›æ˜œæ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜²æ˜³æ˜·",
      4,
      "æ˜½æ˜¿æ™€æ™‚æ™„",
      6,
      "æ™æ™Žæ™æ™‘æ™˜",
    ],
    [
      "9580",
      "æ™™æ™›æ™œæ™æ™žæ™ æ™¢æ™£æ™¥æ™§æ™©",
      4,
      "æ™±æ™²æ™³æ™µæ™¸æ™¹æ™»æ™¼æ™½æ™¿æš€æšæšƒæš…æš†æšˆæš‰æšŠæš‹æšæšŽæšæšæš’æš“æš”æš•æš˜",
      4,
      "æšž",
      8,
      "æš©",
      4,
      "æš¯",
      4,
      "æšµæš¶æš·æš¸æšºæš»æš¼æš½æš¿",
      25,
      "æ›šæ›ž",
      7,
      "æ›§æ›¨æ›ª",
      5,
      "æ›±æ›µæ›¶æ›¸æ›ºæ›»æ›½æœæœ‚æœƒ",
    ],
    [
      "9640",
      "æœ„æœ…æœ†æœ‡æœŒæœŽæœæœ‘æœ’æœ“æœ–æœ˜æœ™æœšæœœæœžæœ ",
      5,
      "æœ§æœ©æœ®æœ°æœ²æœ³æœ¶æœ·æœ¸æœ¹æœ»æœ¼æœ¾æœ¿ææ„æ…æ‡æŠæ‹ææ’æ”æ•æ—",
      4,
      "ææ¢æ£æ¤æ¦æ§æ«æ¬æ®æ±æ´æ¶",
    ],
    [
      "9680",
      "æ¸æ¹æºæ»æ½æž€æž‚æžƒæž…æž†æžˆæžŠæžŒæžæžŽæžæž‘æž’æž“æž”æž–æž™æž›æžŸæž æž¡æž¤æž¦æž©æž¬æž®æž±æž²æž´æž¹",
      7,
      "æŸ‚æŸ…",
      9,
      "æŸ•æŸ–æŸ—æŸ›æŸŸæŸ¡æŸ£æŸ¤æŸ¦æŸ§æŸ¨æŸªæŸ«æŸ­æŸ®æŸ²æŸµ",
      7,
      "æŸ¾æ æ ‚æ ƒæ „æ †æ æ æ ’æ ”æ •æ ˜",
      4,
      "æ žæ Ÿæ  æ ¢",
      6,
      "æ «",
      6,
      "æ ´æ µæ ¶æ ºæ »æ ¿æ¡‡æ¡‹æ¡æ¡æ¡’æ¡–",
      5,
    ],
    [
      "9740",
      "æ¡œæ¡æ¡žæ¡Ÿæ¡ªæ¡¬",
      7,
      "æ¡µæ¡¸",
      8,
      "æ¢‚æ¢„æ¢‡",
      7,
      "æ¢æ¢‘æ¢’æ¢”æ¢•æ¢–æ¢˜",
      9,
      "æ¢£æ¢¤æ¢¥æ¢©æ¢ªæ¢«æ¢¬æ¢®æ¢±æ¢²æ¢´æ¢¶æ¢·æ¢¸",
    ],
    [
      "9780",
      "æ¢¹",
      6,
      "æ£æ£ƒ",
      5,
      "æ£Šæ£Œæ£Žæ£æ£æ£‘æ£“æ£”æ£–æ£—æ£™æ£›",
      4,
      "æ£¡æ£¢æ£¤",
      9,
      "æ£¯æ£²æ£³æ£´æ£¶æ£·æ£¸æ£»æ£½æ£¾æ£¿æ¤€æ¤‚æ¤ƒæ¤„æ¤†",
      4,
      "æ¤Œæ¤æ¤‘æ¤“",
      11,
      "æ¤¡æ¤¢æ¤£æ¤¥",
      7,
      "æ¤®æ¤¯æ¤±æ¤²æ¤³æ¤µæ¤¶æ¤·æ¤¸æ¤ºæ¤»æ¤¼æ¤¾æ¥€æ¥æ¥ƒ",
      16,
      "æ¥•æ¥–æ¥˜æ¥™æ¥›æ¥œæ¥Ÿ",
    ],
    [
      "9840",
      "æ¥¡æ¥¢æ¥¤æ¥¥æ¥§æ¥¨æ¥©æ¥ªæ¥¬æ¥­æ¥¯æ¥°æ¥²",
      4,
      "æ¥ºæ¥»æ¥½æ¥¾æ¥¿æ¦æ¦ƒæ¦…æ¦Šæ¦‹æ¦Œæ¦Ž",
      5,
      "æ¦–æ¦—æ¦™æ¦šæ¦",
      9,
      "æ¦©æ¦ªæ¦¬æ¦®æ¦¯æ¦°æ¦²æ¦³æ¦µæ¦¶æ¦¸æ¦¹æ¦ºæ¦¼æ¦½",
    ],
    [
      "9880",
      "æ¦¾æ¦¿æ§€æ§‚",
      7,
      "æ§‹æ§æ§æ§‘æ§’æ§“æ§•",
      5,
      "æ§œæ§æ§žæ§¡",
      11,
      "æ§®æ§¯æ§°æ§±æ§³",
      9,
      "æ§¾æ¨€",
      9,
      "æ¨‹",
      11,
      "æ¨™",
      5,
      "æ¨ æ¨¢",
      5,
      "æ¨©æ¨«æ¨¬æ¨­æ¨®æ¨°æ¨²æ¨³æ¨´æ¨¶",
      6,
      "æ¨¿",
      4,
      "æ©…æ©†æ©ˆ",
      7,
      "æ©‘",
      6,
      "æ©š",
    ],
    [
      "9940",
      "æ©œ",
      4,
      "æ©¢æ©£æ©¤æ©¦",
      10,
      "æ©²",
      6,
      "æ©ºæ©»æ©½æ©¾æ©¿æªæª‚æªƒæª…",
      8,
      "æªæª’",
      4,
      "æª˜",
      7,
      "æª¡",
      5,
    ],
    ["9980", "æª§æª¨æªªæª­", 114, "æ¬¥æ¬¦æ¬¨", 6],
    [
      "9a40",
      "æ¬¯æ¬°æ¬±æ¬³æ¬´æ¬µæ¬¶æ¬¸æ¬»æ¬¼æ¬½æ¬¿æ­€æ­æ­‚æ­„æ­…æ­ˆæ­Šæ­‹æ­",
      11,
      "æ­š",
      7,
      "æ­¨æ­©æ­«",
      13,
      "æ­ºæ­½æ­¾æ­¿æ®€æ®…æ®ˆ",
    ],
    [
      "9a80",
      "æ®Œæ®Žæ®æ®æ®‘æ®”æ®•æ®—æ®˜æ®™æ®œ",
      4,
      "æ®¢",
      7,
      "æ®«",
      7,
      "æ®¶æ®¸",
      6,
      "æ¯€æ¯ƒæ¯„æ¯†",
      4,
      "æ¯Œæ¯Žæ¯æ¯‘æ¯˜æ¯šæ¯œ",
      4,
      "æ¯¢",
      7,
      "æ¯¬æ¯­æ¯®æ¯°æ¯±æ¯²æ¯´æ¯¶æ¯·æ¯¸æ¯ºæ¯»æ¯¼æ¯¾",
      6,
      "æ°ˆ",
      4,
      "æ°Žæ°’æ°—æ°œæ°æ°žæ° æ°£æ°¥æ°«æ°¬æ°­æ°±æ°³æ°¶æ°·æ°¹æ°ºæ°»æ°¼æ°¾æ°¿æ±ƒæ±„æ±…æ±ˆæ±‹",
      4,
      "æ±‘æ±’æ±“æ±–æ±˜",
    ],
    [
      "9b40",
      "æ±™æ±šæ±¢æ±£æ±¥æ±¦æ±§æ±«",
      4,
      "æ±±æ±³æ±µæ±·æ±¸æ±ºæ±»æ±¼æ±¿æ²€æ²„æ²‡æ²Šæ²‹æ²æ²Žæ²‘æ²’æ²•æ²–æ²—æ²˜æ²šæ²œæ²æ²žæ² æ²¢æ²¨æ²¬æ²¯æ²°æ²´æ²µæ²¶æ²·æ²ºæ³€æ³æ³‚æ³ƒæ³†æ³‡æ³ˆæ³‹æ³æ³Žæ³æ³‘æ³’æ³˜",
    ],
    [
      "9b80",
      "æ³™æ³šæ³œæ³æ³Ÿæ³¤æ³¦æ³§æ³©æ³¬æ³­æ³²æ³´æ³¹æ³¿æ´€æ´‚æ´ƒæ´…æ´†æ´ˆæ´‰æ´Šæ´æ´æ´æ´‘æ´“æ´”æ´•æ´–æ´˜æ´œæ´æ´Ÿ",
      5,
      "æ´¦æ´¨æ´©æ´¬æ´­æ´¯æ´°æ´´æ´¶æ´·æ´¸æ´ºæ´¿æµ€æµ‚æµ„æµ‰æµŒæµæµ•æµ–æµ—æµ˜æµ›æµæµŸæµ¡æµ¢æµ¤æµ¥æµ§æµ¨æµ«æµ¬æµ­æµ°æµ±æµ²æµ³æµµæµ¶æµ¹æµºæµ»æµ½",
      4,
      "æ¶ƒæ¶„æ¶†æ¶‡æ¶Šæ¶‹æ¶æ¶æ¶æ¶’æ¶–",
      4,
      "æ¶œæ¶¢æ¶¥æ¶¬æ¶­æ¶°æ¶±æ¶³æ¶´æ¶¶æ¶·æ¶¹",
      5,
      "æ·æ·‚æ·ƒæ·ˆæ·‰æ·Š",
    ],
    [
      "9c40",
      "æ·æ·Žæ·æ·æ·’æ·“æ·”æ·•æ·—æ·šæ·›æ·œæ·Ÿæ·¢æ·£æ·¥æ·§æ·¨æ·©æ·ªæ·­æ·¯æ·°æ·²æ·´æ·µæ·¶æ·¸æ·ºæ·½",
      7,
      "æ¸†æ¸‡æ¸ˆæ¸‰æ¸‹æ¸æ¸’æ¸“æ¸•æ¸˜æ¸™æ¸›æ¸œæ¸žæ¸Ÿæ¸¢æ¸¦æ¸§æ¸¨æ¸ªæ¸¬æ¸®æ¸°æ¸±æ¸³æ¸µ",
    ],
    [
      "9c80",
      "æ¸¶æ¸·æ¸¹æ¸»",
      7,
      "æ¹…",
      7,
      "æ¹æ¹æ¹‘æ¹’æ¹•æ¹—æ¹™æ¹šæ¹œæ¹æ¹žæ¹ ",
      10,
      "æ¹¬æ¹­æ¹¯",
      14,
      "æº€æºæº‚æº„æº‡æºˆæºŠ",
      4,
      "æº‘",
      6,
      "æº™æºšæº›æºæºžæº æº¡æº£æº¤æº¦æº¨æº©æº«æº¬æº­æº®æº°æº³æºµæº¸æº¹æº¼æº¾æº¿æ»€æ»ƒæ»„æ»…æ»†æ»ˆæ»‰æ»Šæ»Œæ»æ»Žæ»æ»’æ»–æ»˜æ»™æ»›æ»œæ»æ»£æ»§æ»ª",
      5,
    ],
    [
      "9d40",
      "æ»°æ»±æ»²æ»³æ»µæ»¶æ»·æ»¸æ»º",
      7,
      "æ¼ƒæ¼„æ¼…æ¼‡æ¼ˆæ¼Š",
      4,
      "æ¼æ¼‘æ¼’æ¼–",
      9,
      "æ¼¡æ¼¢æ¼£æ¼¥æ¼¦æ¼§æ¼¨æ¼¬æ¼®æ¼°æ¼²æ¼´æ¼µæ¼·",
      6,
      "æ¼¿æ½€æ½æ½‚",
    ],
    [
      "9d80",
      "æ½ƒæ½„æ½…æ½ˆæ½‰æ½Šæ½Œæ½Ž",
      9,
      "æ½™æ½šæ½›æ½æ½Ÿæ½ æ½¡æ½£æ½¤æ½¥æ½§",
      5,
      "æ½¯æ½°æ½±æ½³æ½µæ½¶æ½·æ½¹æ½»æ½½",
      6,
      "æ¾…æ¾†æ¾‡æ¾Šæ¾‹æ¾",
      12,
      "æ¾æ¾žæ¾Ÿæ¾ æ¾¢",
      4,
      "æ¾¨",
      10,
      "æ¾´æ¾µæ¾·æ¾¸æ¾º",
      5,
      "æ¿æ¿ƒ",
      5,
      "æ¿Š",
      6,
      "æ¿“",
      10,
      "æ¿Ÿæ¿¢æ¿£æ¿¤æ¿¥",
    ],
    ["9e40", "æ¿¦", 7, "æ¿°", 32, "ç€’", 7, "ç€œ", 6, "ç€¤", 6],
    [
      "9e80",
      "ç€«",
      9,
      "ç€¶ç€·ç€¸ç€º",
      17,
      "ççŽç",
      13,
      "çŸ",
      11,
      "ç®ç±ç²ç³ç´ç·ç¹çºç»ç½ç‚ç‚‚ç‚ƒç‚„ç‚†ç‚‡ç‚ˆç‚‹ç‚Œç‚ç‚ç‚ç‚‘ç‚“ç‚—ç‚˜ç‚šç‚›ç‚ž",
      12,
      "ç‚°ç‚²ç‚´ç‚µç‚¶ç‚ºç‚¾ç‚¿çƒ„çƒ…çƒ†çƒ‡çƒ‰çƒ‹",
      12,
      "çƒš",
    ],
    [
      "9f40",
      "çƒœçƒçƒžçƒ çƒ¡çƒ¢çƒ£çƒ¥çƒªçƒ®çƒ°",
      6,
      "çƒ¸çƒºçƒ»çƒ¼çƒ¾",
      10,
      "ç„‹",
      4,
      "ç„‘ç„’ç„”ç„—ç„›",
      10,
      "ç„§",
      7,
      "ç„²ç„³ç„´",
    ],
    [
      "9f80",
      "ç„µç„·",
      13,
      "ç…†ç…‡ç…ˆç…‰ç…‹ç…ç…",
      12,
      "ç…ç…Ÿ",
      4,
      "ç…¥ç…©",
      4,
      "ç…¯ç…°ç…±ç…´ç…µç…¶ç…·ç…¹ç…»ç…¼ç…¾",
      5,
      "ç†…",
      4,
      "ç†‹ç†Œç†ç†Žç†ç†‘ç†’ç†“ç†•ç†–ç†—ç†š",
      4,
      "ç†¡",
      6,
      "ç†©ç†ªç†«ç†­",
      5,
      "ç†´ç†¶ç†·ç†¸ç†º",
      8,
      "ç‡„",
      9,
      "ç‡",
      4,
    ],
    ["a040", "ç‡–", 9, "ç‡¡ç‡¢ç‡£ç‡¤ç‡¦ç‡¨", 5, "ç‡¯", 9, "ç‡º", 11, "çˆ‡", 19],
    [
      "a080",
      "çˆ›çˆœçˆž",
      9,
      "çˆ©çˆ«çˆ­çˆ®çˆ¯çˆ²çˆ³çˆ´çˆºçˆ¼çˆ¾ç‰€",
      6,
      "ç‰‰ç‰Šç‰‹ç‰Žç‰ç‰ç‰‘ç‰“ç‰”ç‰•ç‰—ç‰˜ç‰šç‰œç‰žç‰ ç‰£ç‰¤ç‰¥ç‰¨ç‰ªç‰«ç‰¬ç‰­ç‰°ç‰±ç‰³ç‰´ç‰¶ç‰·ç‰¸ç‰»ç‰¼ç‰½çŠ‚çŠƒçŠ…",
      4,
      "çŠŒçŠŽçŠçŠ‘çŠ“",
      11,
      "çŠ ",
      11,
      "çŠ®çŠ±çŠ²çŠ³çŠµçŠº",
      6,
      "ç‹…ç‹†ç‹‡ç‹‰ç‹Šç‹‹ç‹Œç‹ç‹‘ç‹“ç‹”ç‹•ç‹–ç‹˜ç‹šç‹›",
    ],
    [
      "a1a1",
      "ã€€ã€ã€‚Â·Ë‰Ë‡Â¨ã€ƒã€…â€”ï½žâ€–â€¦â€˜â€™â€œâ€ã€”ã€•ã€ˆ",
      7,
      "ã€–ã€—ã€ã€‘Â±Ã—Ã·âˆ¶âˆ§âˆ¨âˆ‘âˆâˆªâˆ©âˆˆâˆ·âˆšâŠ¥âˆ¥âˆ âŒ’âŠ™âˆ«âˆ®â‰¡â‰Œâ‰ˆâˆ½âˆâ‰ â‰®â‰¯â‰¤â‰¥âˆžâˆµâˆ´â™‚â™€Â°â€²â€³â„ƒï¼„Â¤ï¿ ï¿¡â€°Â§â„–â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â€»â†’â†â†‘â†“ã€“",
    ],
    ["a2a1", "â…°", 9],
    ["a2b1", "â’ˆ", 19, "â‘´", 19, "â‘ ", 9],
    ["a2e5", "ãˆ ", 9],
    ["a2f1", "â… ", 11],
    ["a3a1", "ï¼ï¼‚ï¼ƒï¿¥ï¼…", 88, "ï¿£"],
    ["a4a1", "ã", 82],
    ["a5a1", "ã‚¡", 85],
    ["a6a1", "Î‘", 16, "Î£", 6],
    ["a6c1", "Î±", 16, "Ïƒ", 6],
    ["a6e0", "ï¸µï¸¶ï¸¹ï¸ºï¸¿ï¹€ï¸½ï¸¾ï¹ï¹‚ï¹ƒï¹„"],
    ["a6ee", "ï¸»ï¸¼ï¸·ï¸¸ï¸±"],
    ["a6f4", "ï¸³ï¸´"],
    ["a7a1", "Ð", 5, "ÐÐ–", 25],
    ["a7d1", "Ð°", 5, "Ñ‘Ð¶", 25],
    ["a840", "ËŠË‹Ë™â€“â€•â€¥â€µâ„…â„‰â†–â†—â†˜â†™âˆ•âˆŸâˆ£â‰’â‰¦â‰§âŠ¿â•", 35, "â–", 6],
    ["a880", "â–ˆ", 7, "â–“â–”â–•â–¼â–½â—¢â—£â—¤â—¥â˜‰âŠ•ã€’ã€ã€ž"],
    ["a8a1", "ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœÃ¼ÃªÉ‘"],
    ["a8bd", "Å„Åˆ"],
    ["a8c0", "É¡"],
    ["a8c5", "ã„…", 36],
    ["a940", "ã€¡", 8, "ãŠ£ãŽŽãŽãŽœãŽãŽžãŽ¡ã„ãŽã‘ã’ã•ï¸°ï¿¢ï¿¤"],
    ["a959", "â„¡ãˆ±"],
    ["a95c", "â€"],
    ["a960", "ãƒ¼ã‚›ã‚œãƒ½ãƒ¾ã€†ã‚ã‚žï¹‰", 9, "ï¹”ï¹•ï¹–ï¹—ï¹™", 8],
    ["a980", "ï¹¢", 4, "ï¹¨ï¹©ï¹ªï¹«"],
    ["a996", "ã€‡"],
    ["a9a4", "â”€", 75],
    [
      "aa40",
      "ç‹œç‹ç‹Ÿç‹¢",
      5,
      "ç‹ªç‹«ç‹µç‹¶ç‹¹ç‹½ç‹¾ç‹¿çŒ€çŒ‚çŒ„",
      5,
      "çŒ‹çŒŒçŒçŒçŒçŒ‘çŒ’çŒ”çŒ˜çŒ™çŒšçŒŸçŒ çŒ£çŒ¤çŒ¦çŒ§çŒ¨çŒ­çŒ¯çŒ°çŒ²çŒ³çŒµçŒ¶çŒºçŒ»çŒ¼çŒ½ç€",
      8,
    ],
    ["aa80", "ç‰çŠç‹çŒçŽçç‘ç“ç”ç•ç–ç˜", 7, "ç¡", 10, "ç®ç°ç±"],
    [
      "ab40",
      "ç²",
      11,
      "ç¿",
      4,
      "çŽ…çŽ†çŽˆçŽŠçŽŒçŽçŽçŽçŽ’çŽ“çŽ”çŽ•çŽ—çŽ˜çŽ™çŽšçŽœçŽçŽžçŽ çŽ¡çŽ£",
      5,
      "çŽªçŽ¬çŽ­çŽ±çŽ´çŽµçŽ¶çŽ¸çŽ¹çŽ¼çŽ½çŽ¾çŽ¿ççƒ",
      4,
    ],
    ["ab80", "ç‹çŒçŽç’", 6, "çšç›çœççŸç¡ç¢ç£ç¤ç¦ç¨çªç«ç¬ç®ç¯ç°ç±ç³", 4],
    [
      "ac40",
      "ç¸",
      10,
      "ç„ç‡çˆç‹çŒççŽç‘",
      8,
      "çœ",
      5,
      "ç£ç¤ç§ç©ç«ç­ç¯ç±ç²ç·",
      4,
      "ç½ç¾ç¿ç‘€ç‘‚",
      11,
    ],
    ["ac80", "ç‘Ž", 6, "ç‘–ç‘˜ç‘ç‘ ", 12, "ç‘®ç‘¯ç‘±", 4, "ç‘¸ç‘¹ç‘º"],
    [
      "ad40",
      "ç‘»ç‘¼ç‘½ç‘¿ç’‚ç’„ç’…ç’†ç’ˆç’‰ç’Šç’Œç’ç’ç’‘",
      10,
      "ç’ç’Ÿ",
      7,
      "ç’ª",
      15,
      "ç’»",
      12,
    ],
    ["ad80", "ç“ˆ", 9, "ç““", 8, "ç“ç“Ÿç“¡ç“¥ç“§", 6, "ç“°ç“±ç“²"],
    [
      "ae40",
      "ç“³ç“µç“¸",
      6,
      "ç”€ç”ç”‚ç”ƒç”…",
      7,
      "ç”Žç”ç”’ç””ç”•ç”–ç”—ç”›ç”ç”žç” ",
      4,
      "ç”¦ç”§ç”ªç”®ç”´ç”¶ç”¹ç”¼ç”½ç”¿ç•ç•‚ç•ƒç•„ç•†ç•‡ç•‰ç•Šç•ç•ç•‘ç•’ç•“ç••ç•–ç•—ç•˜",
    ],
    ["ae80", "ç•", 7, "ç•§ç•¨ç•©ç•«", 6, "ç•³ç•µç•¶ç•·ç•º", 4, "ç–€ç–ç–‚ç–„ç–…ç–‡"],
    [
      "af40",
      "ç–ˆç–‰ç–Šç–Œç–ç–Žç–ç–“ç–•ç–˜ç–›ç–œç–žç–¢ç–¦",
      4,
      "ç–­ç–¶ç–·ç–ºç–»ç–¿ç—€ç—ç—†ç—‹ç—Œç—Žç—ç—ç—‘ç—“ç——ç—™ç—šç—œç—ç—Ÿç— ç—¡ç—¥ç—©ç—¬ç—­ç—®ç—¯ç—²ç—³ç—µç—¶ç—·ç—¸ç—ºç—»ç—½ç—¾ç˜‚ç˜„ç˜†ç˜‡",
    ],
    [
      "af80",
      "ç˜ˆç˜‰ç˜‹ç˜ç˜Žç˜ç˜‘ç˜’ç˜“ç˜”ç˜–ç˜šç˜œç˜ç˜žç˜¡ç˜£ç˜§ç˜¨ç˜¬ç˜®ç˜¯ç˜±ç˜²ç˜¶ç˜·ç˜¹ç˜ºç˜»ç˜½ç™ç™‚ç™„",
    ],
    [
      "b040",
      "ç™…",
      6,
      "ç™Ž",
      5,
      "ç™•ç™—",
      4,
      "ç™ç™Ÿç™ ç™¡ç™¢ç™¤",
      6,
      "ç™¬ç™­ç™®ç™°",
      7,
      "ç™¹ç™ºç™¼ç™¿çš€çšçšƒçš…çš‰çšŠçšŒçšçšçšçš’çš”çš•çš—çš˜çššçš›",
    ],
    [
      "b080",
      "çšœ",
      7,
      "çš¥",
      8,
      "çš¯çš°çš³çšµ",
      9,
      "ç›€ç›ç›ƒå•Šé˜¿åŸƒæŒ¨å“Žå”‰å“€çš‘ç™Œè”¼çŸ®è‰¾ç¢çˆ±éš˜éžæ°¨å®‰ä¿ºæŒ‰æš—å²¸èƒºæ¡ˆè‚®æ˜‚ç›Žå‡¹æ•–ç†¬ç¿±è¢„å‚²å¥¥æ‡Šæ¾³èŠ­æŒæ‰’å­å§ç¬†å…«ç–¤å·´æ‹”è·‹é¶æŠŠè€™åéœ¸ç½¢çˆ¸ç™½æŸç™¾æ‘†ä½°è´¥æ‹œç¨—æ–‘ç­æ¬æ‰³èˆ¬é¢æ¿ç‰ˆæ‰®æ‹Œä¼´ç“£åŠåŠžç»Šé‚¦å¸®æ¢†æ¦œè†€ç»‘æ£’ç£…èšŒé•‘å‚è°¤è‹žèƒžåŒ…è¤’å‰¥",
    ],
    [
      "b140",
      "ç›„ç›‡ç›‰ç›‹ç›Œç›“ç›•ç›™ç›šç›œç›ç›žç› ",
      4,
      "ç›¦",
      7,
      "ç›°ç›³ç›µç›¶ç›·ç›ºç›»ç›½ç›¿çœ€çœ‚çœƒçœ…çœ†çœŠçœŒçœŽ",
      10,
      "çœ›çœœçœçœžçœ¡çœ£çœ¤çœ¥çœ§çœªçœ«",
    ],
    [
      "b180",
      "çœ¬çœ®çœ°",
      4,
      "çœ¹çœ»çœ½çœ¾çœ¿ç‚ç„ç…ç†çˆ",
      7,
      "ç’",
      7,
      "çœè–„é›¹ä¿å ¡é¥±å®æŠ±æŠ¥æš´è±¹é²çˆ†æ¯ç¢‘æ‚²å‘åŒ—è¾ˆèƒŒè´é’¡å€ç‹ˆå¤‡æƒ«ç„™è¢«å¥”è‹¯æœ¬ç¬¨å´©ç»·ç”­æ³µè¹¦è¿¸é€¼é¼»æ¯”é„™ç¬”å½¼ç¢§è“–è”½æ¯•æ¯™æ¯–å¸åº‡ç—¹é—­æ•å¼Šå¿…è¾Ÿå£è‡‚é¿é™›éž­è¾¹ç¼–è´¬æ‰ä¾¿å˜åžè¾¨è¾©è¾«éæ ‡å½ªè†˜è¡¨é³–æ†‹åˆ«ç˜ªå½¬æ–Œæ¿’æ»¨å®¾æ‘ˆå…µå†°æŸ„ä¸™ç§‰é¥¼ç‚³",
    ],
    [
      "b240",
      "ççžçŸç ç¤ç§ç©çªç­",
      11,
      "çºç»ç¼çžçž‚çžƒçž†",
      5,
      "çžçžçž“",
      11,
      "çž¡çž£çž¤çž¦çž¨çž«çž­çž®çž¯çž±çž²çž´çž¶",
      4,
    ],
    [
      "b280",
      "çž¼çž¾çŸ€",
      12,
      "çŸŽ",
      8,
      "çŸ˜çŸ™çŸšçŸ",
      4,
      "çŸ¤ç—…å¹¶çŽ»è æ’­æ‹¨é’µæ³¢åšå‹ƒæé“‚ç®”ä¼¯å¸›èˆ¶è„–è†Šæ¸¤æ³Šé©³æ•åœå“ºè¡¥åŸ ä¸å¸ƒæ­¥ç°¿éƒ¨æ€–æ“¦çŒœè£ææ‰è´¢ç¬è¸©é‡‡å½©èœè”¡é¤å‚èš•æ®‹æƒ­æƒ¨ç¿è‹èˆ±ä»“æ²§è—æ“ç³™æ§½æ›¹è‰åŽ•ç­–ä¾§å†Œæµ‹å±‚è¹­æ’å‰èŒ¬èŒ¶æŸ¥ç¢´æ½å¯Ÿå²”å·®è¯§æ‹†æŸ´è±ºæ€æŽºè‰é¦‹è°—ç¼ é“²äº§é˜é¢¤æ˜ŒçŒ–",
    ],
    [
      "b340",
      "çŸ¦çŸ¨çŸªçŸ¯çŸ°çŸ±çŸ²çŸ´çŸµçŸ·çŸ¹çŸºçŸ»çŸ¼ç ƒ",
      5,
      "ç Šç ‹ç Žç ç ç “ç •ç ™ç ›ç žç  ç ¡ç ¢ç ¤ç ¨ç ªç «ç ®ç ¯ç ±ç ²ç ³ç µç ¶ç ½ç ¿ç¡ç¡‚ç¡ƒç¡„ç¡†ç¡ˆç¡‰ç¡Šç¡‹ç¡ç¡ç¡‘ç¡“ç¡”ç¡˜ç¡™ç¡š",
    ],
    [
      "b380",
      "ç¡›ç¡œç¡ž",
      11,
      "ç¡¯",
      7,
      "ç¡¸ç¡¹ç¡ºç¡»ç¡½",
      6,
      "åœºå°å¸¸é•¿å¿è‚ åŽ‚æ•žç•…å”±å€¡è¶…æŠ„é’žæœå˜²æ½®å·¢åµç‚’è½¦æ‰¯æ’¤æŽ£å½»æ¾ˆéƒ´è‡£è¾°å°˜æ™¨å¿±æ²‰é™ˆè¶è¡¬æ’‘ç§°åŸŽæ©™æˆå‘ˆä¹˜ç¨‹æƒ©æ¾„è¯šæ‰¿é€žéª‹ç§¤åƒç—´æŒåŒ™æ± è¿Ÿå¼›é©°è€»é½¿ä¾ˆå°ºèµ¤ç¿…æ–¥ç‚½å……å†²è™«å´‡å® æŠ½é…¬ç•´è¸Œç¨ æ„ç­¹ä»‡ç»¸çž…ä¸‘è‡­åˆå‡ºæ©±åŽ¨èº‡é”„é›æ»é™¤æ¥š",
    ],
    [
      "b440",
      "ç¢„ç¢…ç¢†ç¢ˆç¢Šç¢‹ç¢ç¢ç¢’ç¢”ç¢•ç¢–ç¢™ç¢ç¢žç¢ ç¢¢ç¢¤ç¢¦ç¢¨",
      7,
      "ç¢µç¢¶ç¢·ç¢¸ç¢ºç¢»ç¢¼ç¢½ç¢¿ç£€ç£‚ç£ƒç£„ç£†ç£‡ç£ˆç£Œç£ç£Žç£ç£‘ç£’ç£“ç£–ç£—ç£˜ç£š",
      9,
    ],
    [
      "b480",
      "ç£¤ç£¥ç£¦ç£§ç£©ç£ªç£«ç£­",
      4,
      "ç£³ç£µç£¶ç£¸ç£¹ç£»",
      5,
      "ç¤‚ç¤ƒç¤„ç¤†",
      6,
      "ç¡€å‚¨çŸ—æè§¦å¤„æ£å·ç©¿æ¤½ä¼ èˆ¹å–˜ä¸²ç–®çª—å¹¢åºŠé—¯åˆ›å¹ç‚Šæ¶é”¤åž‚æ˜¥æ¤¿é†‡å”‡æ·³çº¯è ¢æˆ³ç»°ç–µèŒ¨ç£é›Œè¾žæ…ˆç“·è¯æ­¤åˆºèµæ¬¡èªè‘±å›±åŒ†ä»Žä¸›å‡‘ç²—é†‹ç°‡ä¿ƒè¹¿ç¯¡çªœæ‘§å´”å‚¬è„†ç˜ç²¹æ·¬ç¿ æ‘å­˜å¯¸ç£‹æ’®æ“æŽªæŒ«é”™æ­è¾¾ç­”ç˜©æ‰“å¤§å‘†æ­¹å‚£æˆ´å¸¦æ®†ä»£è´·è¢‹å¾…é€®",
    ],
    [
      "b540",
      "ç¤",
      5,
      "ç¤”",
      9,
      "ç¤Ÿ",
      4,
      "ç¤¥",
      14,
      "ç¤µ",
      4,
      "ç¤½ç¤¿ç¥‚ç¥ƒç¥„ç¥…ç¥‡ç¥Š",
      8,
      "ç¥”ç¥•ç¥˜ç¥™ç¥¡ç¥£",
    ],
    [
      "b580",
      "ç¥¤ç¥¦ç¥©ç¥ªç¥«ç¥¬ç¥®ç¥°",
      6,
      "ç¥¹ç¥»",
      4,
      "ç¦‚ç¦ƒç¦†ç¦‡ç¦ˆç¦‰ç¦‹ç¦Œç¦ç¦Žç¦ç¦‘ç¦’æ€ è€½æ‹…ä¸¹å•éƒ¸æŽ¸èƒ†æ—¦æ°®ä½†æƒ®æ·¡è¯žå¼¹è›‹å½“æŒ¡å…šè¡æ¡£åˆ€æ£è¹ˆå€’å²›ç¥·å¯¼åˆ°ç¨»æ‚¼é“ç›—å¾·å¾—çš„è¹¬ç¯ç™»ç­‰çžªå‡³é‚“å ¤ä½Žæ»´è¿ªæ•Œç¬›ç‹„æ¶¤ç¿Ÿå«¡æŠµåº•åœ°è’‚ç¬¬å¸å¼Ÿé€’ç¼”é¢ æŽ‚æ»‡ç¢˜ç‚¹å…¸é›åž«ç”µä½ƒç”¸åº—æƒ¦å¥ æ·€æ®¿ç¢‰å¼é›•å‡‹åˆæŽ‰åŠé’“è°ƒè·Œçˆ¹ç¢Ÿè¶è¿­è°å ",
    ],
    [
      "b640",
      "ç¦“",
      6,
      "ç¦›",
      11,
      "ç¦¨",
      10,
      "ç¦´",
      4,
      "ç¦¼ç¦¿ç§‚ç§„ç§…ç§‡ç§ˆç§Šç§Œç§Žç§ç§ç§“ç§”ç§–ç§—ç§™",
      5,
      "ç§ ç§¡ç§¢ç§¥ç§¨ç§ª",
    ],
    [
      "b680",
      "ç§¬ç§®ç§±",
      6,
      "ç§¹ç§ºç§¼ç§¾ç§¿ç¨ç¨„ç¨…ç¨‡ç¨ˆç¨‰ç¨Šç¨Œç¨",
      4,
      "ç¨•ç¨–ç¨˜ç¨™ç¨›ç¨œä¸ç›¯å®é’‰é¡¶é¼Žé”­å®šè®¢ä¸¢ä¸œå†¬è‘£æ‡‚åŠ¨æ ‹ä¾—æ«å†»æ´žå…œæŠ–æ–—é™¡è±†é€—ç—˜éƒ½ç£æ¯’çŠŠç‹¬è¯»å µç¹èµŒæœé•€è‚šåº¦æ¸¡å¦’ç«¯çŸ­é”»æ®µæ–­ç¼Žå †å…‘é˜Ÿå¯¹å¢©å¨è¹²æ•¦é¡¿å›¤é’ç›¾éæŽ‡å“†å¤šå¤ºåž›èº²æœµè·ºèˆµå‰æƒ°å •è›¾å³¨é¹…ä¿„é¢è®¹å¨¥æ¶åŽ„æ‰¼éé„‚é¥¿æ©è€Œå„¿è€³å°”é¥µæ´±äºŒ",
    ],
    ["b740", "ç¨ç¨Ÿç¨¡ç¨¢ç¨¤", 14, "ç¨´ç¨µç¨¶ç¨¸ç¨ºç¨¾ç©€", 5, "ç©‡", 9, "ç©’", 4, "ç©˜", 16],
    [
      "b780",
      "ç©©",
      6,
      "ç©±ç©²ç©³ç©µç©»ç©¼ç©½ç©¾çª‚çª…çª‡çª‰çªŠçª‹çªŒçªŽçªçªçª“çª”çª™çªšçª›çªžçª¡çª¢è´°å‘ç½šç­ä¼ä¹é˜€æ³•çè—©å¸†ç•ªç¿»æ¨ŠçŸ¾é’’ç¹å‡¡çƒ¦åè¿”èŒƒè´©çŠ¯é¥­æ³›åŠèŠ³æ–¹è‚ªæˆ¿é˜²å¦¨ä»¿è®¿çººæ”¾è²éžå•¡é£žè‚¥åŒªè¯½å è‚ºåºŸæ²¸è´¹èŠ¬é…šå©æ°›åˆ†çº·åŸç„šæ±¾ç²‰å¥‹ä»½å¿¿æ„¤ç²ªä¸°å°æž«èœ‚å³°é”‹é£Žç–¯çƒ½é€¢å†¯ç¼è®½å¥‰å‡¤ä½›å¦å¤«æ•·è‚¤å­µæ‰¶æ‹‚è¾å¹…æ°Ÿç¬¦ä¼ä¿˜æœ",
    ],
    [
      "b840",
      "çª£çª¤çª§çª©çªªçª«çª®",
      4,
      "çª´",
      10,
      "ç«€",
      10,
      "ç«Œ",
      9,
      "ç«—ç«˜ç«šç«›ç«œç«ç«¡ç«¢ç«¤ç«§",
      5,
      "ç«®ç«°ç«±ç«²ç«³",
    ],
    [
      "b880",
      "ç«´",
      4,
      "ç«»ç«¼ç«¾ç¬€ç¬ç¬‚ç¬…ç¬‡ç¬‰ç¬Œç¬ç¬Žç¬ç¬’ç¬“ç¬–ç¬—ç¬˜ç¬šç¬œç¬ç¬Ÿç¬¡ç¬¢ç¬£ç¬§ç¬©ç¬­æµ®æ¶ªç¦è¢±å¼—ç”«æŠšè¾…ä¿¯é‡œæ–§è„¯è…‘åºœè…èµ´å‰¯è¦†èµ‹å¤å‚…ä»˜é˜œçˆ¶è…¹è´Ÿå¯Œè®£é™„å¦‡ç¼šå’å™¶å˜Žè¯¥æ”¹æ¦‚é’™ç›–æº‰å¹²ç”˜æ†æŸ‘ç«¿è‚èµ¶æ„Ÿç§†æ•¢èµ£å†ˆåˆšé’¢ç¼¸è‚›çº²å²—æ¸¯æ ç¯™çš‹é«˜è†ç¾”ç³•æžé•ç¨¿å‘Šå“¥æ­Œææˆˆé¸½èƒ³ç–™å‰²é©è‘›æ ¼è›¤é˜éš”é“¬ä¸ªå„ç»™æ ¹è·Ÿè€•æ›´åºšç¾¹",
    ],
    [
      "b940",
      "ç¬¯ç¬°ç¬²ç¬´ç¬µç¬¶ç¬·ç¬¹ç¬»ç¬½ç¬¿",
      5,
      "ç­†ç­ˆç­Šç­ç­Žç­“ç­•ç­—ç­™ç­œç­žç­Ÿç­¡ç­£",
      10,
      "ç­¯ç­°ç­³ç­´ç­¶ç­¸ç­ºç­¼ç­½ç­¿ç®ç®‚ç®ƒç®„ç®†",
      6,
      "ç®Žç®",
    ],
    [
      "b980",
      "ç®‘ç®’ç®“ç®–ç®˜ç®™ç®šç®›ç®žç®Ÿç® ç®£ç®¤ç®¥ç®®ç®¯ç®°ç®²ç®³ç®µç®¶ç®·ç®¹",
      7,
      "ç¯‚ç¯ƒç¯„åŸ‚è€¿æ¢—å·¥æ”»åŠŸæ­é¾šä¾›èº¬å…¬å®«å¼“å·©æ±žæ‹±è´¡å…±é’©å‹¾æ²Ÿè‹Ÿç‹—åž¢æž„è´­å¤Ÿè¾œè‡å’•ç®ä¼°æ²½å­¤å§‘é¼“å¤è›Šéª¨è°·è‚¡æ•…é¡¾å›ºé›‡åˆ®ç“œå‰å¯¡æŒ‚è¤‚ä¹–æ‹æ€ªæ£ºå…³å®˜å† è§‚ç®¡é¦†ç½æƒ¯çŒè´¯å…‰å¹¿é€›ç‘°è§„åœ­ç¡…å½’é¾Ÿé—ºè½¨é¬¼è¯¡ç™¸æ¡‚æŸœè·ªè´µåˆ½è¾Šæ»šæ£é”…éƒ­å›½æžœè£¹è¿‡å“ˆ",
    ],
    [
      "ba40",
      "ç¯…ç¯ˆç¯‰ç¯Šç¯‹ç¯ç¯Žç¯ç¯ç¯’ç¯”",
      4,
      "ç¯›ç¯œç¯žç¯Ÿç¯ ç¯¢ç¯£ç¯¤ç¯§ç¯¨ç¯©ç¯«ç¯¬ç¯­ç¯¯ç¯°ç¯²",
      4,
      "ç¯¸ç¯¹ç¯ºç¯»ç¯½ç¯¿",
      7,
      "ç°ˆç°‰ç°Šç°ç°Žç°",
      5,
      "ç°—ç°˜ç°™",
    ],
    [
      "ba80",
      "ç°š",
      4,
      "ç° ",
      5,
      "ç°¨ç°©ç°«",
      12,
      "ç°¹",
      5,
      "ç±‚éª¸å­©æµ·æ°¦äº¥å®³éª‡é…£æ†¨é‚¯éŸ©å«æ¶µå¯’å‡½å–Šç½•ç¿°æ’¼ææ—±æ†¾æ‚ç„Šæ±—æ±‰å¤¯æ­èˆªå£•åšŽè±ªæ¯«éƒå¥½è€—å·æµ©å‘µå–è·èæ ¸ç¦¾å’Œä½•åˆç›’è²‰é˜‚æ²³æ¶¸èµ«è¤é¹¤è´ºå˜¿é»‘ç—•å¾ˆç‹ æ¨å“¼äº¨æ¨ªè¡¡æ’è½°å“„çƒ˜è™¹é¸¿æ´ªå®å¼˜çº¢å–‰ä¾¯çŒ´å¼åŽšå€™åŽå‘¼ä¹Žå¿½ç‘šå£¶è‘«èƒ¡è´ç‹ç³Šæ¹–",
    ],
    ["bb40", "ç±ƒ", 9, "ç±Ž", 36, "ç±µ", 5, "ç±¾", 9],
    [
      "bb80",
      "ç²ˆç²Š",
      6,
      "ç²“ç²”ç²–ç²™ç²šç²›ç² ç²¡ç²£ç²¦ç²§ç²¨ç²©ç²«ç²¬ç²­ç²¯ç²°ç²´",
      4,
      "ç²ºç²»å¼§è™Žå”¬æŠ¤äº’æ²ªæˆ·èŠ±å“—åŽçŒ¾æ»‘ç”»åˆ’åŒ–è¯æ§å¾Šæ€€æ·®åæ¬¢çŽ¯æ¡“è¿˜ç¼“æ¢æ‚£å”¤ç—ªè±¢ç„•æ¶£å®¦å¹»è’æ…Œé»„ç£ºè—ç°§çš‡å‡°æƒ¶ç…Œæ™ƒå¹Œæè°Žç°æŒ¥è¾‰å¾½æ¢è›”å›žæ¯æ‚”æ…§å‰æƒ æ™¦è´¿ç§½ä¼šçƒ©æ±‡è®³è¯²ç»˜è¤æ˜å©šé­‚æµ‘æ··è±æ´»ä¼™ç«èŽ·æˆ–æƒ‘éœè´§ç¥¸å‡»åœ¾åŸºæœºç•¸ç¨½ç§¯ç®•",
    ],
    [
      "bc40",
      "ç²¿ç³€ç³‚ç³ƒç³„ç³†ç³‰ç³‹ç³Ž",
      6,
      "ç³˜ç³šç³›ç³ç³žç³¡",
      6,
      "ç³©",
      5,
      "ç³°",
      7,
      "ç³¹ç³ºç³¼",
      13,
      "ç´‹",
      5,
    ],
    [
      "bc80",
      "ç´‘",
      14,
      "ç´¡ç´£ç´¤ç´¥ç´¦ç´¨ç´©ç´ªç´¬ç´­ç´®ç´°",
      6,
      "è‚Œé¥¥è¿¹æ¿€è®¥é¸¡å§¬ç»©ç¼‰å‰æžæ£˜è¾‘ç±é›†åŠæ€¥ç–¾æ±²å³å«‰çº§æŒ¤å‡ è„Šå·±è“ŸæŠ€å†€å­£ä¼Žç¥­å‰‚æ‚¸æµŽå¯„å¯‚è®¡è®°æ—¢å¿Œé™…å¦“ç»§çºªå˜‰æž·å¤¹ä½³å®¶åŠ èšé¢Šè´¾ç”²é’¾å‡ç¨¼ä»·æž¶é©¾å«æ­¼ç›‘åšå°–ç¬ºé—´ç…Žå…¼è‚©è‰°å¥¸ç¼„èŒ§æ£€æŸ¬ç¢±ç¡·æ‹£æ¡ç®€ä¿­å‰ªå‡èæ§›é‰´è·µè´±è§é”®ç®­ä»¶",
    ],
    ["bd40", "ç´·", 54, "çµ¯", 7],
    [
      "bd80",
      "çµ¸",
      32,
      "å¥èˆ°å‰‘é¥¯æ¸æº…æ¶§å»ºåƒµå§œå°†æµ†æ±Ÿç–†è’‹æ¡¨å¥–è®²åŒ é…±é™è•‰æ¤’ç¤ç„¦èƒ¶äº¤éƒŠæµ‡éª„å¨‡åš¼æ…é“°çŸ«ä¾¥è„šç‹¡è§’é¥ºç¼´ç»žå‰¿æ•™é…µè½¿è¾ƒå«çª–æ­æŽ¥çš†ç§¸è¡—é˜¶æˆªåŠ«èŠ‚æ¡”æ°æ·ç«ç«­æ´ç»“è§£å§æˆ’è—‰èŠ¥ç•Œå€Ÿä»‹ç–¥è¯«å±Šå·¾ç­‹æ–¤é‡‘ä»Šæ´¥è¥Ÿç´§é”¦ä»…è°¨è¿›é³æ™‹ç¦è¿‘çƒ¬æµ¸",
    ],
    ["be40", "ç¶™", 12, "ç¶§", 6, "ç¶¯", 42],
    [
      "be80",
      "ç·š",
      32,
      "å°½åŠ²è†å…¢èŒŽç›æ™¶é²¸äº¬æƒŠç²¾ç²³ç»äº•è­¦æ™¯é¢ˆé™å¢ƒæ•¬é•œå¾„ç—‰é–ç«Ÿç«žå‡€ç‚¯çª˜æªç©¶çº çŽ–éŸ­ä¹…ç¸ä¹é…’åŽ©æ•‘æ—§è‡¼èˆ…å’Žå°±ç–šéž æ‹˜ç‹™ç–½å±…é©¹èŠå±€å’€çŸ©ä¸¾æ²®èšæ‹’æ®å·¨å…·è·è¸žé”¯ä¿±å¥æƒ§ç‚¬å‰§æé¹ƒå¨Ÿå€¦çœ·å·ç»¢æ’…æ”«æŠ‰æŽ˜å€”çˆµè§‰å†³è¯€ç»å‡èŒé’§å†›å›å³»",
    ],
    ["bf40", "ç·»", 62],
    [
      "bf80",
      "ç¸ºç¸¼",
      4,
      "ç¹‚",
      4,
      "ç¹ˆ",
      21,
      "ä¿Šç«£æµšéƒ¡éªå–€å’–å¡å’¯å¼€æ©æ¥·å‡¯æ…¨åˆŠå ªå‹˜åŽç çœ‹åº·æ…·ç³ æ‰›æŠ—äº¢ç‚•è€ƒæ‹·çƒ¤é å·è‹›æŸ¯æ£µç£•é¢—ç§‘å£³å’³å¯æ¸´å…‹åˆ»å®¢è¯¾è‚¯å•ƒåž¦æ³å‘å­ç©ºæå­”æŽ§æŠ å£æ‰£å¯‡æž¯å“­çªŸè‹¦é…·åº“è£¤å¤¸åž®æŒŽè·¨èƒ¯å—ç­·ä¾©å¿«å®½æ¬¾åŒ¡ç­ç‹‚æ¡†çŸ¿çœ¶æ—·å†µäºç›”å²¿çª¥è‘µå¥Žé­å‚€",
    ],
    ["c040", "ç¹ž", 35, "çºƒ", 23, "çºœçºçºž"],
    [
      "c080",
      "çº®çº´çº»çº¼ç»–ç»¤ç»¬ç»¹ç¼Šç¼ç¼žç¼·ç¼¹ç¼»",
      6,
      "ç½ƒç½†",
      9,
      "ç½’ç½“é¦ˆæ„§æºƒå¤æ˜†æ†å›°æ‹¬æ‰©å»“é˜”åžƒæ‹‰å–‡èœ¡è…Šè¾£å•¦èŽ±æ¥èµ–è“å©ªæ æ‹¦ç¯®é˜‘å…°æ¾œè°°æ½è§ˆæ‡’ç¼†çƒ‚æ»¥ç…æ¦”ç‹¼å»ŠéƒŽæœ—æµªæžåŠ³ç‰¢è€ä½¬å§¥é…ªçƒ™æ¶å‹’ä¹é›·é•­è•¾ç£Šç´¯å„¡åž’æ“‚è‚‹ç±»æ³ªæ£±æ¥žå†·åŽ˜æ¢¨çŠé»Žç¯±ç‹¸ç¦»æ¼“ç†æŽé‡Œé²¤ç¤¼èŽ‰è”åæ —ä¸½åŽ‰åŠ±ç ¾åŽ†åˆ©å‚ˆä¾‹ä¿",
    ],
    [
      "c140",
      "ç½–ç½™ç½›ç½œç½ç½žç½ ç½£",
      4,
      "ç½«ç½¬ç½­ç½¯ç½°ç½³ç½µç½¶ç½·ç½¸ç½ºç½»ç½¼ç½½ç½¿ç¾€ç¾‚",
      7,
      "ç¾‹ç¾ç¾",
      4,
      "ç¾•",
      4,
      "ç¾›ç¾œç¾ ç¾¢ç¾£ç¾¥ç¾¦ç¾¨",
      6,
      "ç¾±",
    ],
    [
      "c180",
      "ç¾³",
      4,
      "ç¾ºç¾»ç¾¾ç¿€ç¿‚ç¿ƒç¿„ç¿†ç¿‡ç¿ˆç¿‰ç¿‹ç¿ç¿",
      4,
      "ç¿–ç¿—ç¿™",
      5,
      "ç¿¢ç¿£ç—¢ç«‹ç²’æ²¥éš¶åŠ›ç’ƒå“©ä¿©è”èŽ²è¿žé•°å»‰æ€œæ¶Ÿå¸˜æ•›è„¸é“¾æ‹ç‚¼ç»ƒç²®å‡‰æ¢ç²±è‰¯ä¸¤è¾†é‡æ™¾äº®è°…æ’©èŠåƒšç–—ç‡Žå¯¥è¾½æ½¦äº†æ’‚é•£å»–æ–™åˆ—è£‚çƒˆåŠ£çŒŽç³æž—ç£·éœ–ä¸´é‚»é³žæ·‹å‡›èµåæ‹ŽçŽ²è±é›¶é¾„é“ƒä¼¶ç¾šå‡Œçµé™µå²­é¢†å¦ä»¤æºœç‰æ¦´ç¡«é¦ç•™åˆ˜ç˜¤æµæŸ³å…­é¾™è‹å’™ç¬¼çª¿",
    ],
    [
      "c240",
      "ç¿¤ç¿§ç¿¨ç¿ªç¿«ç¿¬ç¿­ç¿¯ç¿²ç¿´",
      6,
      "ç¿½ç¿¾ç¿¿è€‚è€‡è€ˆè€‰è€Šè€Žè€è€‘è€“è€šè€›è€è€žè€Ÿè€¡è€£è€¤è€«",
      5,
      "è€²è€´è€¹è€ºè€¼è€¾è€èè„è…è‡èˆè‰èŽèèè‘è“è•è–è—",
    ],
    [
      "c280",
      "è™è›",
      13,
      "è«",
      5,
      "è²",
      11,
      "éš†åž„æ‹¢é™‡æ¥¼å¨„æ‚ç¯“æ¼é™‹èŠ¦å¢é¢…åºç‚‰æŽ³å¤è™é²éº“ç¢Œéœ²è·¯èµ‚é¹¿æ½žç¦„å½•é™†æˆ®é©´å•é“ä¾£æ—…å±¥å±¡ç¼•è™‘æ°¯å¾‹çŽ‡æ»¤ç»¿å³¦æŒ›å­ªæ»¦åµä¹±æŽ ç•¥æŠ¡è½®ä¼¦ä»‘æ²¦çº¶è®ºèèžºç½—é€»é”£ç®©éª¡è£¸è½æ´›éª†ç»œå¦ˆéº»çŽ›ç èš‚é©¬éª‚å˜›å—åŸ‹ä¹°éº¦å–è¿ˆè„‰çž’é¦’è›®æ»¡è”“æ›¼æ…¢æ¼«",
    ],
    [
      "c340",
      "è¾è‚è‚‚è‚…è‚ˆè‚Šè‚",
      5,
      "è‚”è‚•è‚—è‚™è‚žè‚£è‚¦è‚§è‚¨è‚¬è‚°è‚³è‚µè‚¶è‚¸è‚¹è‚»èƒ…èƒ‡",
      4,
      "èƒ",
      6,
      "èƒ˜èƒŸèƒ èƒ¢èƒ£èƒ¦èƒ®èƒµèƒ·èƒ¹èƒ»èƒ¾èƒ¿è„€è„è„ƒè„„è„…è„‡è„ˆè„‹",
    ],
    [
      "c380",
      "è„Œè„•è„—è„™è„›è„œè„è„Ÿ",
      12,
      "è„­è„®è„°è„³è„´è„µè„·è„¹",
      4,
      "è„¿è°©èŠ’èŒ«ç›²æ°“å¿™èŽ½çŒ«èŒ…é”šæ¯›çŸ›é“†å¯èŒ‚å†’å¸½è²Œè´¸ä¹ˆçŽ«æžšæ¢…é…¶éœ‰ç…¤æ²¡çœ‰åª’é•æ¯ç¾Žæ˜§å¯å¦¹åªšé—¨é—·ä»¬èŒè’™æª¬ç›Ÿé”°çŒ›æ¢¦å­Ÿçœ¯é†šé¡ç³œè¿·è°œå¼¥ç±³ç§˜è§…æ³Œèœœå¯†å¹‚æ£‰çœ ç»µå†•å…å‹‰å¨©ç¼…é¢è‹—æçž„è—ç§’æ¸ºåº™å¦™è”‘ç­æ°‘æŠ¿çš¿æ•æ‚¯é—½æ˜ŽèžŸé¸£é“­åå‘½è°¬æ‘¸",
    ],
    [
      "c440",
      "è…€",
      5,
      "è…‡è…‰è…è…Žè…è…’è…–è…—è…˜è…›",
      4,
      "è…¡è…¢è…£è…¤è…¦è…¨è…ªè…«è…¬è…¯è…²è…³è…µè…¶è…·è…¸è†è†ƒ",
      4,
      "è†‰è†‹è†Œè†è†Žè†è†’",
      5,
      "è†™è†šè†ž",
      4,
      "è†¤è†¥",
    ],
    [
      "c480",
      "è†§è†©è†«",
      7,
      "è†´",
      5,
      "è†¼è†½è†¾è†¿è‡„è‡…è‡‡è‡ˆè‡‰è‡‹è‡",
      6,
      "æ‘¹è˜‘æ¨¡è†œç£¨æ‘©é­”æŠ¹æœ«èŽ«å¢¨é»˜æ²«æ¼ å¯žé™Œè°‹ç‰ŸæŸæ‹‡ç‰¡äº©å§†æ¯å¢“æš®å¹•å‹Ÿæ…•æœ¨ç›®ç¦ç‰§ç©†æ‹¿å“ªå‘é’ é‚£å¨œçº³æ°–ä¹ƒå¥¶è€å¥ˆå—ç”·éš¾å›ŠæŒ è„‘æ¼é—¹æ·–å‘¢é¦å†…å«©èƒ½å¦®éœ“å€ªæ³¥å°¼æ‹Ÿä½ åŒ¿è…»é€†æººè”«æ‹ˆå¹´ç¢¾æ’µæ»å¿µå¨˜é…¿é¸Ÿå°¿æè‚å­½å•®é•Šé•æ¶…æ‚¨æŸ ç‹žå‡å®",
    ],
    [
      "c540",
      "è‡”",
      14,
      "è‡¤è‡¥è‡¦è‡¨è‡©è‡«è‡®",
      4,
      "è‡µ",
      5,
      "è‡½è‡¿èˆƒèˆ‡",
      4,
      "èˆŽèˆèˆ‘èˆ“èˆ•",
      5,
      "èˆèˆ èˆ¤èˆ¥èˆ¦èˆ§èˆ©èˆ®èˆ²èˆºèˆ¼èˆ½èˆ¿",
    ],
    [
      "c580",
      "è‰€è‰è‰‚è‰ƒè‰…è‰†è‰ˆè‰Šè‰Œè‰è‰Žè‰",
      7,
      "è‰™è‰›è‰œè‰è‰žè‰ ",
      7,
      "è‰©æ‹§æ³žç‰›æ‰­é’®çº½è„“æµ“å†œå¼„å¥´åŠªæ€’å¥³æš–è™ç–ŸæŒªæ‡¦ç³¯è¯ºå“¦æ¬§é¸¥æ®´è—•å‘•å¶æ²¤å•ªè¶´çˆ¬å¸•æ€•ç¶æ‹æŽ’ç‰Œå¾˜æ¹ƒæ´¾æ”€æ½˜ç›˜ç£ç›¼ç•”åˆ¤å›ä¹“åºžæ—è€ªèƒ–æŠ›å’†åˆ¨ç‚®è¢è·‘æ³¡å‘¸èƒšåŸ¹è£´èµ”é™ªé…ä½©æ²›å–·ç›†ç °æŠ¨çƒ¹æ¾Žå½­è“¬æ£šç¡¼ç¯·è†¨æœ‹é¹æ§ç¢°å¯ç ’éœ¹æ‰¹æŠ«åŠˆçµæ¯—",
    ],
    [
      "c640",
      "è‰ªè‰«è‰¬è‰­è‰±è‰µè‰¶è‰·è‰¸è‰»è‰¼èŠ€èŠèŠƒèŠ…èŠ†èŠ‡èŠ‰èŠŒèŠèŠ“èŠ”èŠ•èŠ–èŠšèŠ›èŠžèŠ èŠ¢èŠ£èŠ§èŠ²èŠµèŠ¶èŠºèŠ»èŠ¼èŠ¿è‹€è‹‚è‹ƒè‹…è‹†è‹‰è‹è‹–è‹™è‹šè‹è‹¢è‹§è‹¨è‹©è‹ªè‹¬è‹­è‹®è‹°è‹²è‹³è‹µè‹¶è‹¸",
    ],
    [
      "c680",
      "è‹ºè‹¼",
      4,
      "èŒŠèŒ‹èŒèŒèŒ’èŒ“èŒ–èŒ˜èŒ™èŒ",
      9,
      "èŒ©èŒªèŒ®èŒ°èŒ²èŒ·èŒ»èŒ½å•¤è„¾ç–²çš®åŒ¹ç—žåƒ»å±è­¬ç¯‡åç‰‡éª—é£˜æ¼‚ç“¢ç¥¨æ’‡çž¥æ‹¼é¢‘è´«å“è˜ä¹’åªè‹¹èå¹³å‡­ç“¶è¯„å±å¡æ³¼é¢‡å©†ç ´é­„è¿«ç²•å‰–æ‰‘é“ºä»†èŽ†è‘¡è©è’²åŸ”æœ´åœƒæ™®æµ¦è°±æ›ç€‘æœŸæ¬ºæ –æˆšå¦»ä¸ƒå‡„æ¼†æŸ’æ²å…¶æ£‹å¥‡æ­§ç•¦å´Žè„é½æ——ç¥ˆç¥éª‘èµ·å²‚ä¹žä¼å¯å¥‘ç Œå™¨æ°”è¿„å¼ƒæ±½æ³£è®«æŽ",
    ],
    [
      "c740",
      "èŒ¾èŒ¿èè‚è„è…èˆèŠ",
      4,
      "è“è•",
      4,
      "èè¢è°",
      6,
      "è¹èºè¾",
      6,
      "èŽ‡èŽˆèŽŠèŽ‹èŽŒèŽèŽèŽèŽ‘èŽ”èŽ•èŽ–èŽ—èŽ™èŽšèŽèŽŸèŽ¡",
      6,
      "èŽ¬èŽ­èŽ®",
    ],
    [
      "c780",
      "èŽ¯èŽµèŽ»èŽ¾èŽ¿è‚èƒè„è†èˆè‰è‹èèŽèè‘è’è“è•è—è™èšè›èžè¢è£è¤è¦è§è¨è«è¬è­æ°æ´½ç‰µæ‰¦é’Žé“…åƒè¿ç­¾ä»Ÿè°¦ä¹¾é»”é’±é’³å‰æ½œé£æµ…è°´å ‘åµŒæ¬ æ­‰æžªå‘›è…”ç¾Œå¢™è”·å¼ºæŠ¢æ©‡é”¹æ•²æ‚„æ¡¥çž§ä¹”ä¾¨å·§éž˜æ’¬ç¿˜å³­ä¿çªåˆ‡èŒ„ä¸”æ€¯çªƒé’¦ä¾µäº²ç§¦ç´å‹¤èŠ¹æ“’ç¦½å¯æ²é’è½»æ°¢å€¾å¿æ¸…æ“Žæ™´æ°°æƒ…é¡·è¯·åº†ç¼ç©·ç§‹ä¸˜é‚±çƒæ±‚å›šé…‹æ³…è¶‹åŒºè›†æ›²èº¯å±ˆé©±æ¸ ",
    ],
    [
      "c840",
      "è®è¯è³",
      4,
      "èºè»è¼è¾è¿è€è‚è…è‡èˆè‰èŠèè’",
      5,
      "è™èšè›èž",
      5,
      "è©",
      7,
      "è²",
      5,
      "è¹èºè»è¾",
      7,
      "è‘‡è‘ˆè‘‰",
    ],
    [
      "c880",
      "è‘Š",
      6,
      "è‘’",
      4,
      "è‘˜è‘è‘žè‘Ÿè‘ è‘¢è‘¤",
      4,
      "è‘ªè‘®è‘¯è‘°è‘²è‘´è‘·è‘¹è‘»è‘¼å–å¨¶é¾‹è¶£åŽ»åœˆé¢§æƒé†›æ³‰å…¨ç—Šæ‹³çŠ¬åˆ¸åŠç¼ºç‚”ç˜¸å´é¹Šæ¦·ç¡®é›€è£™ç¾¤ç„¶ç‡ƒå†‰æŸ“ç“¤å£¤æ”˜åš·è®©é¥¶æ‰°ç»•æƒ¹çƒ­å£¬ä»äººå¿éŸ§ä»»è®¤åˆƒå¦Šçº«æ‰”ä»æ—¥æˆŽèŒ¸è“‰è£èžç†”æº¶å®¹ç»’å†—æ‰æŸ”è‚‰èŒ¹è •å„’å­ºå¦‚è¾±ä¹³æ±å…¥è¤¥è½¯é˜®è•Šç‘žé”é—°æ¶¦è‹¥å¼±æ’’æ´’è¨è…®é³ƒå¡žèµ›ä¸‰å",
    ],
    [
      "c940",
      "è‘½",
      4,
      "è’ƒè’„è’…è’†è’Šè’è’",
      7,
      "è’˜è’šè’›è’è’žè’Ÿè’ è’¢",
      12,
      "è’°è’±è’³è’µè’¶è’·è’»è’¼è’¾è“€è“‚è“ƒè“…è“†è“‡è“ˆè“‹è“Œè“Žè“è“’è“”è“•è“—",
    ],
    [
      "c980",
      "è“˜",
      4,
      "è“žè“¡è“¢è“¤è“§",
      4,
      "è“­è“®è“¯è“±",
      10,
      "è“½è“¾è”€è”è”‚ä¼žæ•£æ¡‘å—“ä¸§æ”éªšæ‰«å«‚ç‘Ÿè‰²æ¶©æ£®åƒ§èŽŽç ‚æ€åˆ¹æ²™çº±å‚»å•¥ç…žç­›æ™’çŠè‹«æ‰å±±åˆ ç…½è¡«é—ªé™•æ“…èµ¡è†³å–„æ±•æ‰‡ç¼®å¢’ä¼¤å•†èµæ™Œä¸Šå°šè£³æ¢¢æŽç¨çƒ§èŠå‹ºéŸ¶å°‘å“¨é‚µç»å¥¢èµŠè›‡èˆŒèˆèµ¦æ‘„å°„æ…‘æ¶‰ç¤¾è®¾ç ·ç”³å‘»ä¼¸èº«æ·±å¨ ç»…ç¥žæ²ˆå®¡å©¶ç”šè‚¾æ…Žæ¸—å£°ç”Ÿç”¥ç‰²å‡ç»³",
    ],
    [
      "ca40",
      "è”ƒ",
      8,
      "è”è”Žè”è”è”’è””è”•è”–è”˜è”™è”›è”œè”è”žè” è”¢",
      8,
      "è”­",
      9,
      "è”¾",
      4,
      "è•„è•…è•†è•‡è•‹",
      10,
    ],
    [
      "ca80",
      "è•—è•˜è•šè•›è•œè•è•Ÿ",
      4,
      "è•¥è•¦è•§è•©",
      8,
      "è•³è•µè•¶è•·è•¸è•¼è•½è•¿è–€è–çœç››å‰©èƒœåœ£å¸ˆå¤±ç‹®æ–½æ¹¿è¯—å°¸è™±åçŸ³æ‹¾æ—¶ä»€é£Ÿèš€å®žè¯†å²çŸ¢ä½¿å±Žé©¶å§‹å¼ç¤ºå£«ä¸–æŸ¿äº‹æ‹­èª“é€åŠ¿æ˜¯å—œå™¬é€‚ä»•ä¾é‡Šé¥°æ°å¸‚æƒå®¤è§†è¯•æ”¶æ‰‹é¦–å®ˆå¯¿æŽˆå”®å—ç˜¦å…½è”¬æž¢æ¢³æ®ŠæŠ’è¾“å”èˆ’æ·‘ç–ä¹¦èµŽå­°ç†Ÿè–¯æš‘æ›™ç½²èœ€é»é¼ å±žæœ¯è¿°æ ‘æŸæˆç«–å¢…åº¶æ•°æ¼±",
    ],
    [
      "cb40",
      "è–‚è–ƒè–†è–ˆ",
      6,
      "è–",
      10,
      "è–",
      6,
      "è–¥è–¦è–§è–©è–«è–¬è–­è–±",
      5,
      "è–¸è–º",
      6,
      "è—‚",
      6,
      "è—Š",
      4,
      "è—‘è—’",
    ],
    [
      "cb80",
      "è—”è—–",
      5,
      "è—",
      6,
      "è—¥è—¦è—§è—¨è—ª",
      14,
      "æ•åˆ·è€æ‘”è¡°ç”©å¸…æ “æ‹´éœœåŒçˆ½è°æ°´ç¡ç¨Žå®çž¬é¡ºèˆœè¯´ç¡•æœ”çƒæ–¯æ’•å˜¶æ€ç§å¸ä¸æ­»è‚†å¯ºå—£å››ä¼ºä¼¼é¥²å·³æ¾è€¸æ€‚é¢‚é€å®‹è®¼è¯µæœè‰˜æ“žå—½è‹é…¥ä¿—ç´ é€Ÿç²Ÿåƒ³å¡‘æº¯å®¿è¯‰è‚ƒé…¸è’œç®—è™½éš‹éšç»¥é«“ç¢Žå²ç©—é‚éš§ç¥Ÿå­™æŸç¬‹è“‘æ¢­å”†ç¼©çç´¢é”æ‰€å¡Œä»–å®ƒå¥¹å¡”",
    ],
    [
      "cc40",
      "è—¹è—ºè—¼è—½è—¾è˜€",
      4,
      "è˜†",
      10,
      "è˜’è˜“è˜”è˜•è˜—",
      15,
      "è˜¨è˜ª",
      13,
      "è˜¹è˜ºè˜»è˜½è˜¾è˜¿è™€",
    ],
    [
      "cc80",
      "è™",
      11,
      "è™’è™“è™•",
      4,
      "è™›è™œè™è™Ÿè™ è™¡è™£",
      7,
      "ç­æŒžè¹‹è¸èƒŽè‹”æŠ¬å°æ³°é…žå¤ªæ€æ±°åæ‘Šè´ªç˜«æ»©å›æª€ç—°æ½­è°­è°ˆå¦æ¯¯è¢’ç¢³æŽ¢å¹ç‚­æ±¤å¡˜æªå ‚æ£ è†›å”ç³–å€˜èººæ·Œè¶Ÿçƒ«æŽæ¶›æ»”ç»¦è„æ¡ƒé€ƒæ·˜é™¶è®¨å¥—ç‰¹è—¤è…¾ç–¼èªŠæ¢¯å‰”è¸¢é”‘æé¢˜è¹„å•¼ä½“æ›¿åšæƒ•æ¶•å‰ƒå±‰å¤©æ·»å¡«ç”°ç”œæ¬èˆ”è…†æŒ‘æ¡è¿¢çœºè·³è´´é“å¸–åŽ…å¬çƒƒ",
    ],
    [
      "cd40",
      "è™­è™¯è™°è™²",
      6,
      "èšƒ",
      6,
      "èšŽ",
      4,
      "èš”èš–",
      5,
      "èšž",
      4,
      "èš¥èš¦èš«èš­èš®èš²èš³èš·èš¸èš¹èš»",
      4,
      "è›è›‚è›ƒè›…è›ˆè›Œè›è›’è›“è›•è›–è›—è›šè›œ",
    ],
    [
      "cd80",
      "è›è› è›¡è›¢è›£è›¥è›¦è›§è›¨è›ªè›«è›¬è›¯è›µè›¶è›·è›ºè›»è›¼è›½è›¿èœèœ„èœ…èœ†èœ‹èœŒèœŽèœèœèœ‘èœ”èœ–æ±€å»·åœäº­åº­æŒºè‰‡é€šæ¡é…®çž³åŒé“œå½¤ç«¥æ¡¶æ…ç­’ç»Ÿç—›å·æŠ•å¤´é€å‡¸ç§ƒçªå›¾å¾’é€”æ¶‚å± åœŸåå…”æ¹å›¢æŽ¨é¢“è…¿èœ•è¤ªé€€åžå±¯è‡€æ‹–æ‰˜è„±é¸µé™€é©®é©¼æ¤­å¦¥æ‹“å”¾æŒ–å“‡è›™æ´¼å¨ƒç“¦è¢œæ­ªå¤–è±Œå¼¯æ¹¾çŽ©é¡½ä¸¸çƒ·å®Œç¢—æŒ½æ™šçš–æƒ‹å®›å©‰ä¸‡è…•æ±ªçŽ‹äº¡æž‰ç½‘å¾€æ—ºæœ›å¿˜å¦„å¨",
    ],
    [
      "ce40",
      "èœ™èœ›èœèœŸèœ èœ¤èœ¦èœ§èœ¨èœªèœ«èœ¬èœ­èœ¯èœ°èœ²èœ³èœµèœ¶èœ¸èœ¹èœºèœ¼èœ½è€",
      6,
      "èŠè‹èèèè‘è’è”è•è–è˜èš",
      5,
      "è¡è¢è¦",
      7,
      "è¯è±è²è³èµ",
    ],
    [
      "ce80",
      "è·è¸è¹èºè¿èž€èžèž„èž†èž‡èž‰èžŠèžŒèžŽ",
      4,
      "èž”èž•èž–èž˜",
      6,
      "èž ",
      4,
      "å·å¾®å±éŸ¦è¿æ¡…å›´å”¯æƒŸä¸ºæ½ç»´è‹‡èŽå§”ä¼Ÿä¼ªå°¾çº¬æœªè”šå‘³ç•èƒƒå–‚é­ä½æ¸­è°“å°‰æ…°å«ç˜Ÿæ¸©èšŠæ–‡é—»çº¹å»ç¨³ç´Šé—®å—¡ç¿ç“®æŒèœ—æ¶¡çªæˆ‘æ–¡å§æ¡æ²ƒå·«å‘œé’¨ä¹Œæ±¡è¯¬å±‹æ— èŠœæ¢§å¾å´æ¯‹æ­¦äº”æ‚åˆèˆžä¼ä¾®åžæˆŠé›¾æ™¤ç‰©å‹¿åŠ¡æ‚Ÿè¯¯æ˜”ç†™æžè¥¿ç¡’çŸ½æ™°å˜»å¸é”¡ç‰º",
    ],
    [
      "cf40",
      "èž¥èž¦èž§èž©èžªèž®èž°èž±èž²èž´èž¶èž·èž¸èž¹èž»èž¼èž¾èž¿èŸ",
      4,
      "èŸ‡èŸˆèŸ‰èŸŒ",
      4,
      "èŸ”",
      6,
      "èŸœèŸèŸžèŸŸèŸ¡èŸ¢èŸ£èŸ¤èŸ¦èŸ§èŸ¨èŸ©èŸ«èŸ¬èŸ­èŸ¯",
      9,
    ],
    [
      "cf80",
      "èŸºèŸ»èŸ¼èŸ½èŸ¿è €è è ‚è „",
      5,
      "è ‹",
      7,
      "è ”è —è ˜è ™è šè œ",
      4,
      "è £ç¨€æ¯å¸Œæ‚‰è†å¤•æƒœç†„çƒ¯æºªæ±çŠ€æª„è¢­å¸­ä¹ åª³å–œé“£æ´—ç³»éš™æˆç»†çžŽè™¾åŒ£éœžè¾–æš‡å³¡ä¾ ç‹­ä¸‹åŽ¦å¤å“æŽ€é”¨å…ˆä»™é²œçº¤å’¸è´¤è¡”èˆ·é—²æ¶Žå¼¦å«Œæ˜¾é™©çŽ°çŒ®åŽ¿è…ºé¦…ç¾¡å®ªé™·é™çº¿ç›¸åŽ¢é•¶é¦™ç®±è¥„æ¹˜ä¹¡ç¿”ç¥¥è¯¦æƒ³å“äº«é¡¹å··æ©¡åƒå‘è±¡è§ç¡éœ„å‰Šå“®åš£é”€æ¶ˆå®µæ·†æ™“",
    ],
    [
      "d040",
      "è ¤",
      13,
      "è ³",
      5,
      "è ºè »è ½è ¾è ¿è¡è¡‚è¡ƒè¡†",
      5,
      "è¡Ž",
      5,
      "è¡•è¡–è¡˜è¡š",
      6,
      "è¡¦è¡§è¡ªè¡­è¡¯è¡±è¡³è¡´è¡µè¡¶è¡¸è¡¹è¡º",
    ],
    [
      "d080",
      "è¡»è¡¼è¢€è¢ƒè¢†è¢‡è¢‰è¢Šè¢Œè¢Žè¢è¢è¢‘è¢“è¢”è¢•è¢—",
      4,
      "è¢",
      4,
      "è¢£è¢¥",
      5,
      "å°å­æ ¡è‚–å•¸ç¬‘æ•ˆæ¥”äº›æ­‡èŽéž‹åæŒŸæºé‚ªæ–œèƒè°å†™æ¢°å¸èŸ¹æ‡ˆæ³„æ³»è°¢å±‘è–ªèŠ¯é”Œæ¬£è¾›æ–°å¿»å¿ƒä¿¡è¡…æ˜Ÿè…¥çŒ©æƒºå…´åˆ‘åž‹å½¢é‚¢è¡Œé†’å¹¸ææ€§å§“å…„å‡¶èƒ¸åŒˆæ±¹é›„ç†Šä¼‘ä¿®ç¾žæœ½å—…é”ˆç§€è¢–ç»£å¢ŸæˆŒéœ€è™šå˜˜é¡»å¾è®¸è“„é…—å™æ—­åºç•œæ¤çµ®å©¿ç»ªç»­è½©å–§å®£æ‚¬æ—‹çŽ„",
    ],
    [
      "d140",
      "è¢¬è¢®è¢¯è¢°è¢²",
      4,
      "è¢¸è¢¹è¢ºè¢»è¢½è¢¾è¢¿è£€è£ƒè£„è£‡è£ˆè£Šè£‹è£Œè£è£è£è£‘è£“è£–è£—è£š",
      4,
      "è£ è£¡è£¦è£§è£©",
      6,
      "è£²è£µè£¶è£·è£ºè£»è£½è£¿è¤€è¤è¤ƒ",
      5,
    ],
    [
      "d180",
      "è¤‰è¤‹",
      4,
      "è¤‘è¤”",
      4,
      "è¤œ",
      4,
      "è¤¢è¤£è¤¤è¤¦è¤§è¤¨è¤©è¤¬è¤­è¤®è¤¯è¤±è¤²è¤³è¤µè¤·é€‰ç™£çœ©ç»šé´è–›å­¦ç©´é›ªè¡€å‹‹ç†å¾ªæ—¬è¯¢å¯»é©¯å·¡æ®‰æ±›è®­è®¯é€Šè¿…åŽ‹æŠ¼é¸¦é¸­å‘€ä¸«èŠ½ç‰™èšœå´–è¡™æ¶¯é›…å“‘äºšè®¶ç„‰å’½é˜‰çƒŸæ·¹ç›ä¸¥ç ”èœ’å²©å»¶è¨€é¢œé˜Žç‚Žæ²¿å¥„æŽ©çœ¼è¡æ¼”è‰³å °ç‡•åŽŒç šé›å”å½¦ç„°å®´è°šéªŒæ®ƒå¤®é¸¯ç§§æ¨æ‰¬ä½¯ç–¡ç¾Šæ´‹é˜³æ°§ä»°ç—’å…»æ ·æ¼¾é‚€è…°å¦–ç‘¶",
    ],
    ["d240", "è¤¸", 8, "è¥‚è¥ƒè¥…", 24, "è¥ ", 5, "è¥§", 19, "è¥¼"],
    [
      "d280",
      "è¥½è¥¾è¦€è¦‚è¦„è¦…è¦‡",
      26,
      "æ‘‡å°§é¥çª‘è°£å§šå’¬èˆ€è¯è¦è€€æ¤°å™Žè€¶çˆ·é‡Žå†¶ä¹Ÿé¡µæŽ–ä¸šå¶æ›³è…‹å¤œæ¶²ä¸€å£¹åŒ»æ–é“±ä¾ä¼Šè¡£é¢å¤·é—ç§»ä»ªèƒ°ç–‘æ²‚å®œå§¨å½æ¤…èšå€šå·²ä¹™çŸ£ä»¥è‰ºæŠ‘æ˜“é‚‘å±¹äº¿å½¹è‡†é€¸è‚„ç–«äº¦è£”æ„æ¯…å¿†ä¹‰ç›Šæº¢è¯£è®®è°Šè¯‘å¼‚ç¿¼ç¿Œç»ŽèŒµè«å› æ®·éŸ³é˜´å§»åŸé“¶æ·«å¯…é¥®å°¹å¼•éš",
    ],
    [
      "d340",
      "è¦¢",
      30,
      "è§ƒè§è§“è§”è§•è§—è§˜è§™è§›è§è§Ÿè§ è§¡è§¢è§¤è§§è§¨è§©è§ªè§¬è§­è§®è§°è§±è§²è§´",
      6,
    ],
    [
      "d380",
      "è§»",
      4,
      "è¨",
      5,
      "è¨ˆ",
      21,
      "å°è‹±æ¨±å©´é¹°åº”ç¼¨èŽ¹è¤è¥è§è‡è¿Žèµ¢ç›ˆå½±é¢–ç¡¬æ˜ å“Ÿæ‹¥ä½£è‡ƒç—ˆåº¸é›è¸Šè›¹å’æ³³æ¶Œæ°¸æ¿å‹‡ç”¨å¹½ä¼˜æ‚ å¿§å°¤ç”±é‚®é“€çŠ¹æ²¹æ¸¸é…‰æœ‰å‹å³ä½‘é‡‰è¯±åˆå¹¼è¿‚æ·¤äºŽç›‚æ¦†è™žæ„šèˆ†ä½™ä¿žé€¾é±¼æ„‰æ¸æ¸”éš…äºˆå¨±é›¨ä¸Žå±¿ç¦¹å®‡è¯­ç¾½çŽ‰åŸŸèŠ‹éƒåé‡å–»å³ªå¾¡æ„ˆæ¬²ç‹±è‚²èª‰",
    ],
    ["d440", "è¨ž", 31, "è¨¿", 8, "è©‰", 21],
    [
      "d480",
      "è©Ÿ",
      25,
      "è©º",
      6,
      "æµ´å¯“è£•é¢„è±«é©­é¸³æ¸Šå†¤å…ƒåž£è¢åŽŸæ´è¾•å›­å‘˜åœ†çŒ¿æºç¼˜è¿œè‹‘æ„¿æ€¨é™¢æ›°çº¦è¶Šè·ƒé’¥å²³ç²¤æœˆæ‚¦é˜…è€˜äº‘éƒ§åŒ€é™¨å…è¿è•´é…æ™•éŸµå­•åŒç ¸æ‚æ ½å“‰ç¾å®°è½½å†åœ¨å’±æ”’æš‚èµžèµƒè„è‘¬é­ç³Ÿå‡¿è—»æž£æ—©æ¾¡èš¤èºå™ªé€ çš‚ç¶ç‡¥è´£æ‹©åˆ™æ³½è´¼æ€Žå¢žæ†Žæ›¾èµ æ‰Žå–³æ¸£æœ­è½§",
    ],
    ["d540", "èª", 7, "èª‹", 7, "èª”", 46],
    [
      "d580",
      "è«ƒ",
      32,
      "é“¡é—¸çœ¨æ …æ¦¨å’‹ä¹ç‚¸è¯ˆæ‘˜æ–‹å®…çª„å€ºå¯¨çž»æ¯¡è©¹ç²˜æ²¾ç›æ–©è¾—å´­å±•è˜¸æ ˆå æˆ˜ç«™æ¹›ç»½æ¨Ÿç« å½°æ¼³å¼ æŽŒæ¶¨æ–ä¸ˆå¸è´¦ä»—èƒ€ç˜´éšœæ‹›æ˜­æ‰¾æ²¼èµµç…§ç½©å…†è‚‡å¬é®æŠ˜å“²è›°è¾™è€…é”—è”—è¿™æµ™çæ–ŸçœŸç”„ç §è‡»è´žé’ˆä¾¦æž•ç–¹è¯Šéœ‡æŒ¯é•‡é˜µè’¸æŒ£çå¾ç‹°äº‰æ€”æ•´æ‹¯æ­£æ”¿",
    ],
    ["d640", "è«¤", 34, "è¬ˆ", 27],
    [
      "d680",
      "è¬¤è¬¥è¬§",
      30,
      "å¸§ç—‡éƒ‘è¯èŠæžæ”¯å±èœ˜çŸ¥è‚¢è„‚æ±ä¹‹ç»‡èŒç›´æ¤æ®–æ‰§å€¼ä¾„å€æŒ‡æ­¢è¶¾åªæ—¨çº¸å¿—æŒšæŽ·è‡³è‡´ç½®å¸œå³™åˆ¶æ™ºç§©ç¨šè´¨ç‚™ç—”æ»žæ²»çª’ä¸­ç›…å¿ é’Ÿè¡·ç»ˆç§è‚¿é‡ä»²ä¼—èˆŸå‘¨å·žæ´²è¯Œç²¥è½´è‚˜å¸šå’’çš±å®™æ˜¼éª¤ç æ ªè››æœ±çŒªè¯¸è¯›é€ç«¹çƒ›ç…®æ‹„çž©å˜±ä¸»è‘—æŸ±åŠ©è›€è´®é“¸ç­‘",
    ],
    ["d740", "è­†", 31, "è­§", 4, "è­­", 25],
    [
      "d780",
      "è®‡",
      24,
      "è®¬è®±è®»è¯‡è¯è¯ªè°‰è°žä½æ³¨ç¥é©»æŠ“çˆªæ‹½ä¸“ç –è½¬æ’°èµšç¯†æ¡©åº„è£…å¦†æ’žå£®çŠ¶æ¤Žé”¥è¿½èµ˜å ç¼€è°†å‡†æ‰æ‹™å“æ¡Œç¢èŒé…Œå•„ç€ç¼æµŠå…¹å’¨èµ„å§¿æ»‹æ·„å­œç´«ä»”ç±½æ»“å­è‡ªæ¸å­—é¬ƒæ£•è¸ªå®—ç»¼æ€»çºµé‚¹èµ°å¥æç§Ÿè¶³å’æ—ç¥–è¯…é˜»ç»„é’»çº‚å˜´é†‰æœ€ç½ªå°Šéµæ˜¨å·¦ä½æŸžåšä½œååº§",
    ],
    [
      "d840",
      "è°¸",
      8,
      "è±‚è±ƒè±„è±…è±ˆè±Šè±‹è±",
      7,
      "è±–è±—è±˜è±™è±›",
      5,
      "è±£",
      6,
      "è±¬",
      6,
      "è±´è±µè±¶è±·è±»",
      6,
      "è²ƒè²„è²†è²‡",
    ],
    [
      "d880",
      "è²ˆè²‹è²",
      6,
      "è²•è²–è²—è²™",
      20,
      "äºä¸Œå…€ä¸å»¿å…ä¸•äº˜ä¸žé¬²å­¬å™©ä¸¨ç¦ºä¸¿åŒ•ä¹‡å¤­çˆ»å®æ°å›Ÿèƒ¤é¦—æ¯“ç¾é¼—ä¸¶äºŸé¼ä¹œä¹©äº“èŠˆå­›å•¬å˜ä»„åŽåŽåŽ£åŽ¥åŽ®é¥èµåŒšåµåŒ¦åŒ®åŒ¾èµœå¦å£åˆ‚åˆˆåˆŽåˆ­åˆ³åˆ¿å‰€å‰Œå‰žå‰¡å‰œè’¯å‰½åŠ‚åŠåŠåŠ“å†‚ç½”äº»ä»ƒä»‰ä»‚ä»¨ä»¡ä»«ä»žä¼›ä»³ä¼¢ä½¤ä»µä¼¥ä¼§ä¼‰ä¼«ä½žä½§æ”¸ä½šä½",
    ],
    ["d940", "è²®", 62],
    [
      "d980",
      "è³­",
      32,
      "ä½Ÿä½—ä¼²ä¼½ä½¶ä½´ä¾‘ä¾‰ä¾ƒä¾ä½¾ä½»ä¾ªä½¼ä¾¬ä¾”ä¿¦ä¿¨ä¿ªä¿…ä¿šä¿£ä¿œä¿‘ä¿Ÿä¿¸å€©åŒä¿³å€¬å€å€®å€­ä¿¾å€œå€Œå€¥å€¨å¾åƒå•åˆåŽå¬å»å‚¥å‚§å‚©å‚ºåƒ–å„†åƒ­åƒ¬åƒ¦åƒ®å„‡å„‹ä»æ°½ä½˜ä½¥ä¿Žé¾ æ±†ç±´å…®å·½é»‰é¦˜å†å¤”å‹¹åŒè¨‡åŒå‡«å¤™å…•äº å…–äº³è¡®è¢¤äºµè„”è£’ç¦€å¬´è ƒç¾¸å†«å†±å†½å†¼",
    ],
    [
      "da40",
      "è´Ž",
      14,
      "è´ èµ‘èµ’èµ—èµŸèµ¥èµ¨èµ©èµªèµ¬èµ®èµ¯èµ±èµ²èµ¸",
      8,
      "è¶‚è¶ƒè¶†è¶‡è¶ˆè¶‰è¶Œ",
      4,
      "è¶’è¶“è¶•",
      9,
      "è¶ è¶¡",
    ],
    [
      "da80",
      "è¶¢è¶¤",
      12,
      "è¶²è¶¶è¶·è¶¹è¶»è¶½è·€è·è·‚è·…è·‡è·ˆè·‰è·Šè·è·è·’è·“è·”å‡‡å†–å†¢å†¥è® è®¦è®§è®ªè®´è®µè®·è¯‚è¯ƒè¯‹è¯è¯Žè¯’è¯“è¯”è¯–è¯˜è¯™è¯œè¯Ÿè¯ è¯¤è¯¨è¯©è¯®è¯°è¯³è¯¶è¯¹è¯¼è¯¿è°€è°‚è°„è°‡è°Œè°è°‘è°’è°”è°•è°–è°™è°›è°˜è°è°Ÿè° è°¡è°¥è°§è°ªè°«è°®è°¯è°²è°³è°µè°¶å©åºé˜é˜¢é˜¡é˜±é˜ªé˜½é˜¼é™‚é™‰é™”é™Ÿé™§é™¬é™²é™´éšˆéšéš—éš°é‚—é‚›é‚é‚™é‚¬é‚¡é‚´é‚³é‚¶é‚º",
    ],
    [
      "db40",
      "è·•è·˜è·™è·œè· è·¡è·¢è·¥è·¦è·§è·©è·­è·®è·°è·±è·²è·´è·¶è·¼è·¾",
      6,
      "è¸†è¸‡è¸ˆè¸‹è¸è¸Žè¸è¸‘è¸’è¸“è¸•",
      7,
      "è¸ è¸¡è¸¤",
      4,
      "è¸«è¸­è¸°è¸²è¸³è¸´è¸¶è¸·è¸¸è¸»è¸¼è¸¾",
    ],
    [
      "db80",
      "è¸¿è¹ƒè¹…è¹†è¹Œ",
      4,
      "è¹“",
      5,
      "è¹š",
      11,
      "è¹§è¹¨è¹ªè¹«è¹®è¹±é‚¸é‚°éƒéƒ…é‚¾éƒéƒ„éƒ‡éƒ“éƒ¦éƒ¢éƒœéƒ—éƒ›éƒ«éƒ¯éƒ¾é„„é„¢é„žé„£é„±é„¯é„¹é…ƒé…†åˆå¥‚åŠ¢åŠ¬åŠ­åŠ¾å“¿å‹å‹–å‹°åŸç‡®çŸå»´å‡µå‡¼é¬¯åŽ¶å¼ç•šå·¯åŒåž©åž¡å¡¾å¢¼å£…å£‘åœ©åœ¬åœªåœ³åœ¹åœ®åœ¯åœåœ»å‚å©åž…å«åž†å¼å»å¨å­å¶å³åž­åž¤åžŒåž²åŸåž§åž´åž“åž åŸ•åŸ˜åŸšåŸ™åŸ’åž¸åŸ´åŸ¯åŸ¸åŸ¤åŸ",
    ],
    [
      "dc40",
      "è¹³è¹µè¹·",
      4,
      "è¹½è¹¾èº€èº‚èºƒèº„èº†èºˆ",
      6,
      "èº‘èº’èº“èº•",
      6,
      "èºèºŸ",
      11,
      "èº­èº®èº°èº±èº³",
      6,
      "èº»",
      7,
    ],
    [
      "dc80",
      "è»ƒ",
      10,
      "è»",
      21,
      "å ‹å åŸ½åŸ­å €å žå ™å¡„å  å¡¥å¡¬å¢å¢‰å¢šå¢€é¦¨é¼™æ‡¿è‰¹è‰½è‰¿èŠèŠŠèŠ¨èŠ„èŠŽèŠ‘èŠ—èŠ™èŠ«èŠ¸èŠ¾èŠ°è‹ˆè‹Šè‹£èŠ˜èŠ·èŠ®è‹‹è‹Œè‹èŠ©èŠ´èŠ¡èŠªèŠŸè‹„è‹ŽèŠ¤è‹¡èŒ‰è‹·è‹¤èŒèŒ‡è‹œè‹´è‹’è‹˜èŒŒè‹»è‹“èŒ‘èŒšèŒ†èŒ”èŒ•è‹ è‹•èŒœè‘è›èœèŒˆèŽ’èŒ¼èŒ´èŒ±èŽ›èžèŒ¯èè‡èƒèŸè€èŒ—è èŒ­èŒºèŒ³è¦è¥",
    ],
    ["dd40", "è»¥", 62],
    [
      "dd80",
      "è¼¤",
      32,
      "è¨èŒ›è©è¬èªè­è®èŽ°è¸èŽ³èŽ´èŽ èŽªèŽ“èŽœèŽ…è¼èŽ¶èŽ©è½èŽ¸è»èŽ˜èŽžèŽ¨èŽºèŽ¼èèè¥è˜å ‡è˜è‹èè½è–èœè¸è‘è†è”èŸèèƒè¸è¹èªè…è€è¦è°è¡è‘œè‘‘è‘šè‘™è‘³è’‡è’ˆè‘ºè’‰è‘¸è¼è‘†è‘©è‘¶è’Œè’Žè±è‘­è“è“è“è“¦è’½è““è“Šè’¿è’ºè“ è’¡è’¹è’´è’—è“¥è“£è”Œç”è”¸è“°è”¹è”Ÿè”º",
    ],
    [
      "de40",
      "è½…",
      32,
      "è½ªè¾€è¾Œè¾’è¾è¾ è¾¡è¾¢è¾¤è¾¥è¾¦è¾§è¾ªè¾¬è¾­è¾®è¾¯è¾²è¾³è¾´è¾µè¾·è¾¸è¾ºè¾»è¾¼è¾¿è¿€è¿ƒè¿†",
    ],
    [
      "de80",
      "è¿‰",
      4,
      "è¿è¿’è¿–è¿—è¿šè¿ è¿¡è¿£è¿§è¿¬è¿¯è¿±è¿²è¿´è¿µè¿¶è¿ºè¿»è¿¼è¿¾è¿¿é€‡é€ˆé€Œé€Žé€“é€•é€˜è•–è”»è“¿è“¼è•™è•ˆè•¨è•¤è•žè•ºçž¢è•ƒè•²è•»è–¤è–¨è–‡è–è•¹è–®è–œè–…è–¹è–·è–°è—“è—è—œè—¿è˜§è˜…è˜©è˜–è˜¼å»¾å¼ˆå¤¼å¥è€·å¥•å¥šå¥˜åŒå°¢å°¥å°¬å°´æ‰Œæ‰ªæŠŸæŠ»æ‹Šæ‹šæ‹—æ‹®æŒ¢æ‹¶æŒ¹æ‹æƒæŽ­æ¶æ±æºæŽŽæŽ´æ­æŽ¬æŽŠæ©æŽ®æŽ¼æ²æ¸æ æ¿æ„æžæŽæ‘’æ†æŽ¾æ‘…æ‘æ‹æ›æ æŒæ¦æ¡æ‘žæ’„æ‘­æ’–",
    ],
    [
      "df40",
      "é€™é€œé€£é€¤é€¥é€§",
      5,
      "é€°",
      4,
      "é€·é€¹é€ºé€½é€¿é€éƒé…é†éˆ",
      4,
      "éŽé”é•é–é™éšéœ",
      5,
      "é¤é¦é§é©éªé«é¬é¯",
      4,
      "é¶",
      6,
      "é¾é‚",
    ],
    [
      "df80",
      "é‚„é‚…é‚†é‚‡é‚‰é‚Šé‚Œ",
      4,
      "é‚’é‚”é‚–é‚˜é‚šé‚œé‚žé‚Ÿé‚ é‚¤é‚¥é‚§é‚¨é‚©é‚«é‚­é‚²é‚·é‚¼é‚½é‚¿éƒ€æ‘ºæ’·æ’¸æ’™æ’ºæ“€æ“æ“—æ“¤æ“¢æ”‰æ”¥æ”®å¼‹å¿’ç”™å¼‘åŸå±å½å©å¨å»å’å–å†å‘‹å‘’å‘“å‘”å‘–å‘ƒå¡å‘—å‘™å£å²å’‚å’”å‘·å‘±å‘¤å’šå’›å’„å‘¶å‘¦å’å“å’­å“‚å’´å“’å’§å’¦å““å“”å‘²å’£å“•å’»å’¿å“Œå“™å“šå“œå’©å’ªå’¤å“å“å“žå”›å“§å” å“½å””å“³å”¢å”£å”å”‘å”§å”ªå•§å–å–µå•‰å•­å•å••å”¿å•å”¼",
    ],
    [
      "e040",
      "éƒ‚éƒƒéƒ†éƒˆéƒ‰éƒ‹éƒŒéƒéƒ’éƒ”éƒ•éƒ–éƒ˜éƒ™éƒšéƒžéƒŸéƒ éƒ£éƒ¤éƒ¥éƒ©éƒªéƒ¬éƒ®éƒ°éƒ±éƒ²éƒ³éƒµéƒ¶éƒ·éƒ¹éƒºéƒ»éƒ¼éƒ¿é„€é„é„ƒé„…",
      19,
      "é„šé„›é„œ",
    ],
    [
      "e080",
      "é„é„Ÿé„ é„¡é„¤",
      10,
      "é„°é„²",
      6,
      "é„º",
      8,
      "é…„å”·å•–å•µå•¶å•·å”³å”°å•œå–‹å—’å–ƒå–±å–¹å–ˆå–å–Ÿå•¾å—–å–‘å•»å—Ÿå–½å–¾å–”å–™å—ªå—·å—‰å˜Ÿå—‘å—«å—¬å—”å—¦å—å—„å—¯å—¥å—²å—³å—Œå—å—¨å—µå—¤è¾”å˜žå˜ˆå˜Œå˜å˜¤å˜£å—¾å˜€å˜§å˜­å™˜å˜¹å™—å˜¬å™å™¢å™™å™œå™Œå™”åš†å™¤å™±å™«å™»å™¼åš…åš“åš¯å›”å›—å›å›¡å›µå›«å›¹å›¿åœ„åœŠåœ‰åœœå¸å¸™å¸”å¸‘å¸±å¸»å¸¼",
    ],
    [
      "e140",
      "é……é…‡é…ˆé…‘é…“é…”é…•é…–é…˜é…™é…›é…œé…Ÿé… é…¦é…§é…¨é…«é…­é…³é…ºé…»é…¼é†€",
      4,
      "é††é†ˆé†Šé†Žé†é†“",
      6,
      "é†œ",
      5,
      "é†¤",
      5,
      "é†«é†¬é†°é†±é†²é†³é†¶é†·é†¸é†¹é†»",
    ],
    [
      "e180",
      "é†¼",
      10,
      "é‡ˆé‡‹é‡é‡’",
      9,
      "é‡",
      8,
      "å¸·å¹„å¹”å¹›å¹žå¹¡å²Œå±ºå²å²å²–å²ˆå²˜å²™å²‘å²šå²œå²µå²¢å²½å²¬å²«å²±å²£å³å²·å³„å³’å³¤å³‹å³¥å´‚å´ƒå´§å´¦å´®å´¤å´žå´†å´›åµ˜å´¾å´´å´½åµ¬åµ›åµ¯åµåµ«åµ‹åµŠåµ©åµ´å¶‚å¶™å¶è±³å¶·å·…å½³å½·å¾‚å¾‡å¾‰å¾Œå¾•å¾™å¾œå¾¨å¾­å¾µå¾¼è¡¢å½¡çŠ­çŠ°çŠ´çŠ·çŠ¸ç‹ƒç‹ç‹Žç‹ç‹’ç‹¨ç‹¯ç‹©ç‹²ç‹´ç‹·çŒç‹³çŒƒç‹º",
    ],
    ["e240", "é‡¦", 62],
    [
      "e280",
      "éˆ¥",
      32,
      "ç‹»çŒ—çŒ“çŒ¡çŒŠçŒžçŒçŒ•çŒ¢çŒ¹çŒ¥çŒ¬çŒ¸çŒ±ççç—ç ç¬ç¯ç¾èˆ›å¤¥é£§å¤¤å¤‚é¥£é¥§",
      5,
      "é¥´é¥·é¥½é¦€é¦„é¦‡é¦Šé¦é¦é¦‘é¦“é¦”é¦•åº€åº‘åº‹åº–åº¥åº åº¹åºµåº¾åº³èµ“å»’å»‘å»›å»¨å»ªè†ºå¿„å¿‰å¿–å¿æ€ƒå¿®æ€„å¿¡å¿¤å¿¾æ€…æ€†å¿ªå¿­å¿¸æ€™æ€µæ€¦æ€›æ€æ€æ€©æ€«æ€Šæ€¿æ€¡æ¸æ¹æ»æºæ‚",
    ],
    ["e340", "é‰†", 45, "é‰µ", 16],
    [
      "e380",
      "éŠ†",
      7,
      "éŠ",
      24,
      "æªæ½æ‚–æ‚šæ‚­æ‚æ‚ƒæ‚’æ‚Œæ‚›æƒ¬æ‚»æ‚±æƒæƒ˜æƒ†æƒšæ‚´æ„ æ„¦æ„•æ„£æƒ´æ„€æ„Žæ„«æ…Šæ…µæ†¬æ†”æ†§æ†·æ‡”æ‡µå¿éš³é—©é—«é—±é—³é—µé—¶é—¼é—¾é˜ƒé˜„é˜†é˜ˆé˜Šé˜‹é˜Œé˜é˜é˜’é˜•é˜–é˜—é˜™é˜šä¸¬çˆ¿æˆ•æ°µæ±”æ±œæ±Šæ²£æ²…æ²æ²”æ²Œæ±¨æ±©æ±´æ±¶æ²†æ²©æ³æ³”æ²­æ³·æ³¸æ³±æ³—æ²²æ³ æ³–æ³ºæ³«æ³®æ²±æ³“æ³¯æ³¾",
    ],
    ["e440", "éŠ¨", 5, "éŠ¯", 24, "é‹‰", 31],
    [
      "e480",
      "é‹©",
      32,
      "æ´¹æ´§æ´Œæµƒæµˆæ´‡æ´„æ´™æ´Žæ´«æµæ´®æ´µæ´šæµæµ’æµ”æ´³æ¶‘æµ¯æ¶žæ¶ æµžæ¶“æ¶”æµœæµ æµ¼æµ£æ¸šæ·‡æ·…æ·žæ¸Žæ¶¿æ· æ¸‘æ·¦æ·æ·™æ¸–æ¶«æ¸Œæ¶®æ¸«æ¹®æ¹Žæ¹«æº²æ¹Ÿæº†æ¹“æ¹”æ¸²æ¸¥æ¹„æ»Ÿæº±æº˜æ» æ¼­æ»¢æº¥æº§æº½æº»æº·æ»—æº´æ»æºæ»‚æºŸæ½¢æ½†æ½‡æ¼¤æ¼•æ»¹æ¼¯æ¼¶æ½‹æ½´æ¼ªæ¼‰æ¼©æ¾‰æ¾æ¾Œæ½¸æ½²æ½¼æ½ºæ¿‘",
    ],
    ["e540", "éŒŠ", 51, "éŒ¿", 10],
    [
      "e580",
      "éŠ",
      31,
      "é«æ¿‰æ¾§æ¾¹æ¾¶æ¿‚æ¿¡æ¿®æ¿žæ¿ æ¿¯ç€šç€£ç€›ç€¹ç€µççžå®€å®„å®•å®“å®¥å®¸ç”¯éªžæ´å¯¤å¯®è¤°å¯°è¹‡è¬‡è¾¶è¿“è¿•è¿¥è¿®è¿¤è¿©è¿¦è¿³è¿¨é€…é€„é€‹é€¦é€‘é€é€–é€¡é€µé€¶é€­é€¯é„é‘é’éé¨é˜é¢é›æš¹é´é½é‚‚é‚ˆé‚ƒé‚‹å½å½—å½–å½˜å°»å’«å±å±™å­±å±£å±¦ç¾¼å¼ªå¼©å¼­è‰´å¼¼é¬»å±®å¦å¦ƒå¦å¦©å¦ªå¦£",
    ],
    ["e640", "é¬", 34, "éŽ", 27],
    [
      "e680",
      "éŽ¬",
      29,
      "é‹éŒéå¦—å§Šå¦«å¦žå¦¤å§’å¦²å¦¯å§—å¦¾å¨…å¨†å§å¨ˆå§£å§˜å§¹å¨Œå¨‰å¨²å¨´å¨‘å¨£å¨“å©€å©§å©Šå©•å¨¼å©¢å©µèƒ¬åªªåª›å©·å©ºåª¾å««åª²å«’å«”åª¸å« å«£å«±å«–å«¦å«˜å«œå¬‰å¬—å¬–å¬²å¬·å­€å°•å°œå­šå­¥å­³å­‘å­“å­¢é©µé©·é©¸é©ºé©¿é©½éª€éªéª…éªˆéªŠéªéª’éª“éª–éª˜éª›éªœéªéªŸéª éª¢éª£éª¥éª§çºŸçº¡çº£çº¥çº¨çº©",
    ],
    ["e740", "éŽ", 7, "é—", 54],
    [
      "e780",
      "éŽ",
      32,
      "çº­çº°çº¾ç»€ç»ç»‚ç»‰ç»‹ç»Œç»ç»”ç»—ç»›ç» ç»¡ç»¨ç»«ç»®ç»¯ç»±ç»²ç¼ç»¶ç»ºç»»ç»¾ç¼ç¼‚ç¼ƒç¼‡ç¼ˆç¼‹ç¼Œç¼ç¼‘ç¼’ç¼—ç¼™ç¼œç¼›ç¼Ÿç¼¡",
      6,
      "ç¼ªç¼«ç¼¬ç¼­ç¼¯",
      4,
      "ç¼µå¹ºç•¿å·›ç”¾é‚•çŽŽçŽ‘çŽ®çŽ¢çŽŸçç‚ç‘çŽ·çŽ³ç€ç‰çˆç¥ç™é¡¼çŠç©ç§çžçŽºç²ççªç‘›ç¦ç¥ç¨ç°ç®ç¬",
    ],
    ["e840", "é¯", 14, "é¿", 43, "é‘¬é‘­é‘®é‘¯"],
    [
      "e880",
      "é‘°",
      20,
      "é’‘é’–é’˜é“‡é“é““é“”é“šé“¦é“»é”œé” ç›çšç‘ç‘œç‘—ç‘•ç‘™ç‘·ç‘­ç‘¾ç’œç’Žç’€ç’ç’‡ç’‹ç’žç’¨ç’©ç’ç’§ç“’ç’ºéŸªéŸ«éŸ¬æŒæ“æžæˆæ©æž¥æž‡æªæ³æž˜æž§æµæž¨æžžæž­æž‹æ·æ¼æŸ°æ ‰æŸ˜æ ŠæŸ©æž°æ ŒæŸ™æžµæŸšæž³æŸæ €æŸƒæž¸æŸ¢æ ŽæŸæŸ½æ ²æ ³æ¡ æ¡¡æ¡Žæ¡¢æ¡„æ¡¤æ¢ƒæ æ¡•æ¡¦æ¡æ¡§æ¡€æ ¾æ¡Šæ¡‰æ ©æ¢µæ¢æ¡´æ¡·æ¢“æ¡«æ£‚æ¥®æ£¼æ¤Ÿæ¤ æ£¹",
    ],
    ["e940", "é”§é”³é”½é•ƒé•ˆé•‹é••é•šé• é•®é•´é•µé•·", 7, "é–€", 42],
    [
      "e980",
      "é–«",
      32,
      "æ¤¤æ£°æ¤‹æ¤æ¥—æ££æ¤æ¥±æ¤¹æ¥ æ¥‚æ¥æ¦„æ¥«æ¦€æ¦˜æ¥¸æ¤´æ§Œæ¦‡æ¦ˆæ§Žæ¦‰æ¥¦æ¥£æ¥¹æ¦›æ¦§æ¦»æ¦«æ¦­æ§”æ¦±æ§æ§Šæ§Ÿæ¦•æ§ æ¦æ§¿æ¨¯æ§­æ¨—æ¨˜æ©¥æ§²æ©„æ¨¾æª æ©æ©›æ¨µæªŽæ©¹æ¨½æ¨¨æ©˜æ©¼æª‘æªæª©æª—æª«çŒ·ç’æ®æ®‚æ®‡æ®„æ®’æ®“æ®æ®šæ®›æ®¡æ®ªè½«è½­è½±è½²è½³è½µè½¶è½¸è½·è½¹è½ºè½¼è½¾è¾è¾‚è¾„è¾‡è¾‹",
    ],
    [
      "ea40",
      "é—Œ",
      27,
      "é—¬é—¿é˜‡é˜“é˜˜é˜›é˜žé˜ é˜£",
      6,
      "é˜«é˜¬é˜­é˜¯é˜°é˜·é˜¸é˜¹é˜ºé˜¾é™é™ƒé™Šé™Žé™é™‘é™’é™“é™–é™—",
    ],
    [
      "ea80",
      "é™˜é™™é™šé™œé™é™žé™ é™£é™¥é™¦é™«é™­",
      4,
      "é™³é™¸",
      12,
      "éš‡éš‰éšŠè¾è¾Žè¾è¾˜è¾šè»Žæˆ‹æˆ—æˆ›æˆŸæˆ¢æˆ¡æˆ¥æˆ¤æˆ¬è‡§ç“¯ç“´ç“¿ç”ç”‘ç”“æ”´æ—®æ—¯æ—°æ˜Šæ˜™æ²æ˜ƒæ˜•æ˜€ç‚…æ›·æ˜æ˜´æ˜±æ˜¶æ˜µè€†æ™Ÿæ™”æ™æ™æ™–æ™¡æ™—æ™·æš„æšŒæš§æšæš¾æ››æ›œæ›¦æ›©è´²è´³è´¶è´»è´½èµ€èµ…èµ†èµˆèµ‰èµ‡èµèµ•èµ™è§‡è§Šè§‹è§Œè§Žè§è§è§‘ç‰®çŠŸç‰ç‰¦ç‰¯ç‰¾ç‰¿çŠ„çŠ‹çŠçŠçŠ’æŒˆæŒ²æŽ°",
    ],
    [
      "eb40",
      "éšŒéšŽéš‘éš’éš“éš•éš–éššéš›éš",
      9,
      "éš¨",
      7,
      "éš±éš²éš´éšµéš·éš¸éšºéš»éš¿é›‚é›ƒé›ˆé›Šé›‹é›é›‘é›“é›”é›–",
      9,
      "é›¡",
      6,
      "é›«",
    ],
    [
      "eb80",
      "é›¬é›­é›®é›°é›±é›²é›´é›µé›¸é›ºé›»é›¼é›½é›¿éœ‚éœƒéœ…éœŠéœ‹éœŒéœéœ‘éœ’éœ”éœ•éœ—",
      4,
      "éœéœŸéœ æ¿æ“˜è€„æ¯ªæ¯³æ¯½æ¯µæ¯¹æ°…æ°‡æ°†æ°æ°•æ°˜æ°™æ°šæ°¡æ°©æ°¤æ°ªæ°²æ”µæ••æ•«ç‰ç‰’ç‰–çˆ°è™¢åˆ–è‚Ÿè‚œè‚“è‚¼æœŠè‚½è‚±è‚«è‚­è‚´è‚·èƒ§èƒ¨èƒ©èƒªèƒ›èƒ‚èƒ„èƒ™èƒèƒ—æœèƒèƒ«èƒ±èƒ´èƒ­è„è„Žèƒ²èƒ¼æœ•è„’è±šè„¶è„žè„¬è„˜è„²è…ˆè…Œè…“è…´è…™è…šè…±è… è…©è…¼è…½è…­è…§å¡åªµè†ˆè†‚è†‘æ»•è†£è†ªè‡Œæœ¦è‡Šè†»",
    ],
    [
      "ec40",
      "éœ¡",
      8,
      "éœ«éœ¬éœ®éœ¯éœ±éœ³",
      4,
      "éœºéœ»éœ¼éœ½éœ¿",
      18,
      "é”é•é—é˜éšéœééŸé£é¤é¦é§é¨éª",
      7,
    ],
    [
      "ec80",
      "é²éµé·",
      4,
      "é½",
      7,
      "éž†",
      4,
      "éžŒéžŽéžéžéž“éž•éž–éž—éž™",
      4,
      "è‡è†¦æ¬¤æ¬·æ¬¹æ­ƒæ­†æ­™é£‘é£’é£“é£•é£™é£šæ®³å½€æ¯‚è§³æ–é½‘æ–“æ–¼æ—†æ—„æ—ƒæ—Œæ—Žæ—’æ—–ç‚€ç‚œç‚–ç‚ç‚»çƒ€ç‚·ç‚«ç‚±çƒ¨çƒŠç„ç„“ç„–ç„¯ç„±ç…³ç…œç…¨ç……ç…²ç…Šç…¸ç…ºç†˜ç†³ç†µç†¨ç† ç‡ ç‡”ç‡§ç‡¹çˆçˆ¨ç¬ç„˜ç…¦ç†¹æˆ¾æˆ½æ‰ƒæ‰ˆæ‰‰ç¤»ç¥€ç¥†ç¥‰ç¥›ç¥œç¥“ç¥šç¥¢ç¥—ç¥ ç¥¯ç¥§ç¥ºç¦…ç¦Šç¦šç¦§ç¦³å¿‘å¿",
    ],
    ["ed40", "éžžéžŸéž¡éž¢éž¤", 6, "éž¬éž®éž°éž±éž³éžµ", 46],
    [
      "ed80",
      "éŸ¤éŸ¥éŸ¨éŸ®",
      4,
      "éŸ´éŸ·",
      23,
      "æ€¼ææšæ§ææ™æ£æ‚«æ„†æ„æ…æ†©æ†æ‡‹æ‡‘æˆ†è‚€è¿æ²“æ³¶æ·¼çŸ¶çŸ¸ç €ç ‰ç —ç ˜ç ‘æ–«ç ­ç œç ç ¹ç ºç »ç Ÿç ¼ç ¥ç ¬ç £ç ©ç¡Žç¡­ç¡–ç¡—ç ¦ç¡ç¡‡ç¡Œç¡ªç¢›ç¢“ç¢šç¢‡ç¢œç¢¡ç¢£ç¢²ç¢¹ç¢¥ç£”ç£™ç£‰ç£¬ç£²ç¤…ç£´ç¤“ç¤¤ç¤žç¤´é¾›é»¹é»»é»¼ç›±çœ„çœç›¹çœ‡çœˆçœšçœ¢çœ™çœ­çœ¦çœµçœ¸çç‘ç‡çƒçšç¨",
    ],
    ["ee40", "é ", 62],
    [
      "ee80",
      "é¡Ž",
      32,
      "ç¢ç¥ç¿çžç½çž€çžŒçž‘çžŸçž çž°çžµçž½ç”ºç•€ç•Žç•‹ç•ˆç•›ç•²ç•¹ç–ƒç½˜ç½¡ç½Ÿè©ˆç½¨ç½´ç½±ç½¹ç¾ç½¾ç›ç›¥è ²é’…é’†é’‡é’‹é’Šé’Œé’é’é’é’”é’—é’•é’šé’›é’œé’£é’¤é’«é’ªé’­é’¬é’¯é’°é’²é’´é’¶",
      4,
      "é’¼é’½é’¿é“„é“ˆ",
      6,
      "é“é“‘é“’é“•é“–é“—é“™é“˜é“›é“žé“Ÿé“ é“¢é“¤é“¥é“§é“¨é“ª",
    ],
    ["ef40", "é¡¯", 5, "é¢‹é¢Žé¢’é¢•é¢™é¢£é¢¨", 37, "é£é£é£”é£–é£—é£›é£œé£é£ ", 4],
    [
      "ef80",
      "é£¥é£¦é£©",
      30,
      "é“©é“«é“®é“¯é“³é“´é“µé“·é“¹é“¼é“½é“¿é”ƒé”‚é”†é”‡é”‰é”Šé”é”Žé”é”’",
      4,
      "é”˜é”›é”é”žé”Ÿé”¢é”ªé”«é”©é”¬é”±é”²é”´é”¶é”·é”¸é”¼é”¾é”¿é•‚é”µé•„é•…é•†é•‰é•Œé•Žé•é•’é•“é•”é•–é•—é•˜é•™é•›é•žé•Ÿé•é•¡é•¢é•¤",
      8,
      "é•¯é•±é•²é•³é”ºçŸ§çŸ¬é›‰ç§•ç§­ç§£ç§«ç¨†åµ‡ç¨ƒç¨‚ç¨žç¨”",
    ],
    ["f040", "é¤ˆ", 4, "é¤Žé¤é¤‘", 28, "é¤¯", 26],
    [
      "f080",
      "é¥Š",
      9,
      "é¥–",
      12,
      "é¥¤é¥¦é¥³é¥¸é¥¹é¥»é¥¾é¦‚é¦ƒé¦‰ç¨¹ç¨·ç©‘é»é¦¥ç©°çšˆçšŽçš“çš™çš¤ç“žç“ ç”¬é¸ é¸¢é¸¨",
      4,
      "é¸²é¸±é¸¶é¸¸é¸·é¸¹é¸ºé¸¾é¹é¹‚é¹„é¹†é¹‡é¹ˆé¹‰é¹‹é¹Œé¹Žé¹‘é¹•é¹—é¹šé¹›é¹œé¹žé¹£é¹¦",
      6,
      "é¹±é¹­é¹³ç–’ç–”ç––ç– ç–ç–¬ç–£ç–³ç–´ç–¸ç—„ç–±ç–°ç—ƒç—‚ç—–ç—ç—£ç—¨ç—¦ç—¤ç—«ç—§ç˜ƒç—±ç—¼ç—¿ç˜ç˜€ç˜…ç˜Œç˜—ç˜Šç˜¥ç˜˜ç˜•ç˜™",
    ],
    ["f140", "é¦Œé¦Žé¦š", 10, "é¦¦é¦§é¦©", 47],
    [
      "f180",
      "é§™",
      32,
      "ç˜›ç˜¼ç˜¢ç˜ ç™€ç˜­ç˜°ç˜¿ç˜µç™ƒç˜¾ç˜³ç™ç™žç™”ç™œç™–ç™«ç™¯ç¿Šç«¦ç©¸ç©¹çª€çª†çªˆçª•çª¦çª çª¬çª¨çª­çª³è¡¤è¡©è¡²è¡½è¡¿è¢‚è¢¢è£†è¢·è¢¼è£‰è£¢è£Žè££è£¥è£±è¤šè£¼è£¨è£¾è£°è¤¡è¤™è¤“è¤›è¤Šè¤´è¤«è¤¶è¥è¥¦è¥»ç–‹èƒ¥çš²çš´çŸœè€’è€”è€–è€œè€ è€¢è€¥è€¦è€§è€©è€¨è€±è€‹è€µèƒè†èè’è©è±è¦ƒé¡¸é¢€é¢ƒ",
    ],
    ["f240", "é§º", 62],
    [
      "f280",
      "é¨¹",
      32,
      "é¢‰é¢Œé¢é¢é¢”é¢šé¢›é¢žé¢Ÿé¢¡é¢¢é¢¥é¢¦è™è™”è™¬è™®è™¿è™ºè™¼è™»èš¨èšèš‹èš¬èšèš§èš£èšªèš“èš©èš¶è›„èšµè›Žèš°èšºèš±èš¯è›‰è›èš´è›©è›±è›²è›­è›³è›èœ“è›žè›´è›Ÿè›˜è›‘èœƒèœ‡è›¸èœˆèœŠèœèœ‰èœ£èœ»èœžèœ¥èœ®èœšèœ¾èˆèœ´èœ±èœ©èœ·èœ¿èž‚èœ¢è½è¾è»è è°èŒè®èž‹è“è£è¼è¤è™è¥èž“èž¯èž¨èŸ’",
    ],
    [
      "f340",
      "é©š",
      17,
      "é©²éªƒéª‰éªéªŽéª”éª•éª™éª¦éª©",
      6,
      "éª²éª³éª´éªµéª¹éª»éª½éª¾éª¿é«ƒé«„é«†",
      4,
      "é«é«Žé«é«é«’é«”é«•é«–é«—é«™é«šé«›é«œ",
    ],
    [
      "f380",
      "é«é«žé« é«¢é«£é«¤é«¥é«§é«¨é«©é«ªé«¬é«®é«°",
      8,
      "é«ºé«¼",
      6,
      "é¬„é¬…é¬†èŸ†èžˆèž…èž­èž—èžƒèž«èŸ¥èž¬èžµèž³èŸ‹èŸ“èž½èŸ‘èŸ€èŸŠèŸ›èŸªèŸ èŸ®è –è “èŸ¾è Šè ›è ¡è ¹è ¼ç¼¶ç½‚ç½„ç½…èˆç«ºç«½ç¬ˆç¬ƒç¬„ç¬•ç¬Šç¬«ç¬ç­‡ç¬¸ç¬ªç¬™ç¬®ç¬±ç¬ ç¬¥ç¬¤ç¬³ç¬¾ç¬žç­˜ç­šç­…ç­µç­Œç­ç­ ç­®ç­»ç­¢ç­²ç­±ç®ç®¦ç®§ç®¸ç®¬ç®ç®¨ç®…ç®ªç®œç®¢ç®«ç®´ç¯‘ç¯ç¯Œç¯ç¯šç¯¥ç¯¦ç¯ªç°Œç¯¾ç¯¼ç°ç°–ç°‹",
    ],
    [
      "f440",
      "é¬‡é¬‰",
      5,
      "é¬é¬‘é¬’é¬”",
      10,
      "é¬ é¬¡é¬¢é¬¤",
      10,
      "é¬°é¬±é¬³",
      7,
      "é¬½é¬¾é¬¿é­€é­†é­Šé­‹é­Œé­Žé­é­’é­“é­•",
      5,
    ],
    [
      "f480",
      "é­›",
      32,
      "ç°Ÿç°ªç°¦ç°¸ç±ç±€è‡¾èˆèˆ‚èˆ„è‡¬è¡„èˆ¡èˆ¢èˆ£èˆ­èˆ¯èˆ¨èˆ«èˆ¸èˆ»èˆ³èˆ´èˆ¾è‰„è‰‰è‰‹è‰è‰šè‰Ÿè‰¨è¡¾è¢…è¢ˆè£˜è£Ÿè¥žç¾ç¾Ÿç¾§ç¾¯ç¾°ç¾²ç±¼æ•‰ç²‘ç²ç²œç²žç²¢ç²²ç²¼ç²½ç³ç³‡ç³Œç³ç³ˆç³…ç³—ç³¨è‰®æš¨ç¾¿ç¿Žç¿•ç¿¥ç¿¡ç¿¦ç¿©ç¿®ç¿³ç³¸çµ·ç¶¦ç¶®ç¹‡çº›éº¸éº´èµ³è¶„è¶”è¶‘è¶±èµ§èµ­è±‡è±‰é…Šé…é…Žé…é…¤",
    ],
    ["f540", "é­¼", 62],
    [
      "f580",
      "é®»",
      32,
      "é…¢é…¡é…°é…©é…¯é…½é…¾é…²é…´é…¹é†Œé†…é†é†é†‘é†¢é†£é†ªé†­é†®é†¯é†µé†´é†ºè±•é¹¾è¶¸è·«è¸…è¹™è¹©è¶µè¶¿è¶¼è¶ºè·„è·–è·—è·šè·žè·Žè·è·›è·†è·¬è··è·¸è·£è·¹è·»è·¤è¸‰è·½è¸”è¸è¸Ÿè¸¬è¸®è¸£è¸¯è¸ºè¹€è¸¹è¸µè¸½è¸±è¹‰è¹è¹‚è¹‘è¹’è¹Šè¹°è¹¶è¹¼è¹¯è¹´èº…èºèº”èºèºœèºžè±¸è²‚è²Šè²…è²˜è²”æ–›è§–è§žè§šè§œ",
    ],
    ["f640", "é¯œ", 62],
    [
      "f680",
      "é°›",
      32,
      "è§¥è§«è§¯è¨¾è¬¦é“é›©é›³é›¯éœ†éœéœˆéœéœŽéœªéœ­éœ°éœ¾é¾€é¾ƒé¾…",
      5,
      "é¾Œé»¾é¼‹é¼éš¹éš¼éš½é›Žé›’çž¿é› éŠŽéŠ®é‹ˆéŒ¾éªéŠéŽé¾é‘«é±¿é²‚é²…é²†é²‡é²ˆç¨£é²‹é²Žé²é²‘é²’é²”é²•é²šé²›é²ž",
      5,
      "é²¥",
      4,
      "é²«é²­é²®é²°",
      7,
      "é²ºé²»é²¼é²½é³„é³…é³†é³‡é³Šé³‹",
    ],
    ["f740", "é°¼", 62],
    [
      "f780",
      "é±»é±½é±¾é²€é²ƒé²„é²‰é²Šé²Œé²é²“é²–é²—é²˜é²™é²é²ªé²¬é²¯é²¹é²¾",
      4,
      "é³ˆé³‰é³‘é³’é³šé³›é³ é³¡é³Œ",
      4,
      "é³“é³”é³•é³—é³˜é³™é³œé³é³Ÿé³¢é¼éž…éž‘éž’éž”éž¯éž«éž£éž²éž´éª±éª°éª·é¹˜éª¶éªºéª¼é«é«€é«…é«‚é«‹é«Œé«‘é­…é­ƒé­‡é­‰é­ˆé­é­‘é£¨é¤é¤®é¥•é¥”é«Ÿé«¡é«¦é«¯é««é«»é«­é«¹é¬ˆé¬é¬“é¬Ÿé¬£éº½éº¾ç¸»éº‚éº‡éºˆéº‹éº’é–éºéºŸé»›é»œé»é» é»Ÿé»¢é»©é»§é»¥é»ªé»¯é¼¢é¼¬é¼¯é¼¹é¼·é¼½é¼¾é½„",
    ],
    ["f840", "é³£", 62],
    ["f880", "é´¢", 32],
    ["f940", "éµƒ", 62],
    ["f980", "é¶‚", 32],
    ["fa40", "é¶£", 62],
    ["fa80", "é·¢", 32],
    [
      "fb40",
      "é¸ƒ",
      27,
      "é¸¤é¸§é¸®é¸°é¸´é¸»é¸¼é¹€é¹é¹é¹’é¹“é¹”é¹–é¹™é¹é¹Ÿé¹ é¹¡é¹¢é¹¥é¹®é¹¯é¹²é¹´",
      9,
      "éº€",
    ],
    ["fb80", "éºéºƒéº„éº…éº†éº‰éºŠéºŒ", 5, "éº”", 8, "éºžéº ", 5, "éº§éº¨éº©éºª"],
    [
      "fc40",
      "éº«",
      8,
      "éºµéº¶éº·éº¹éººéº¼éº¿",
      4,
      "é»…é»†é»‡é»ˆé»Šé»‹é»Œé»é»’é»“é»•é»–é»—é»™é»šé»žé»¡é»£é»¤é»¦é»¨é»«é»¬é»­é»®é»°",
      8,
      "é»ºé»½é»¿",
      6,
    ],
    ["fc80", "é¼†", 4, "é¼Œé¼é¼‘é¼’é¼”é¼•é¼–é¼˜é¼š", 5, "é¼¡é¼£", 8, "é¼­é¼®é¼°é¼±"],
    ["fd40", "é¼²", 4, "é¼¸é¼ºé¼¼é¼¿", 4, "é½…", 10, "é½’", 38],
    ["fd80", "é½¹", 5, "é¾é¾‚é¾", 11, "é¾œé¾é¾žé¾¡", 4, "ï¤¬ï¥¹ï¦•ï§§ï§±"],
    ["fe40", "ï¨Œï¨ï¨Žï¨ï¨‘ï¨“ï¨”ï¨˜ï¨Ÿï¨ ï¨¡ï¨£ï¨¤ï¨§ï¨¨ï¨©"],
  ],
  j1 = [
    ["a140", "î“†", 62],
    ["a180", "î”…", 32],
    ["a240", "î”¦", 62],
    ["a280", "î•¥", 32],
    ["a2ab", "î¦", 5],
    ["a2e3", "â‚¬î­"],
    ["a2ef", "î®î¯"],
    ["a2fd", "î°î±"],
    ["a340", "î–†", 62],
    ["a380", "î—…", 31, "ã€€"],
    ["a440", "î—¦", 62],
    ["a480", "î˜¥", 32],
    ["a4f4", "î²", 10],
    ["a540", "î™†", 62],
    ["a580", "îš…", 32],
    ["a5f7", "î½", 7],
    ["a640", "îš¦", 62],
    ["a680", "î›¥", 32],
    ["a6b9", "îž…", 7],
    ["a6d9", "îž", 6],
    ["a6ec", "îž”îž•"],
    ["a6f3", "îž–"],
    ["a6f6", "îž—", 8],
    ["a740", "îœ†", 62],
    ["a780", "î…", 32],
    ["a7c2", "îž ", 14],
    ["a7f2", "îž¯", 12],
    ["a896", "îž¼", 10],
    ["a8bc", "îŸ‡"],
    ["a8bf", "Ç¹"],
    ["a8c1", "îŸ‰îŸŠîŸ‹îŸŒ"],
    ["a8ea", "îŸ", 20],
    ["a958", "îŸ¢"],
    ["a95b", "îŸ£"],
    ["a95d", "îŸ¤îŸ¥îŸ¦"],
    ["a989", "ã€¾â¿°", 11],
    ["a997", "îŸ´", 12],
    ["a9f0", "î ", 14],
    ["aaa1", "î€€", 93],
    ["aba1", "îž", 93],
    ["aca1", "î‚¼", 93],
    ["ada1", "î„š", 93],
    ["aea1", "î…¸", 93],
    ["afa1", "î‡–", 93],
    ["d7fa", "î ", 4],
    ["f8a1", "îˆ´", 93],
    ["f9a1", "îŠ’", 93],
    ["faa1", "î‹°", 93],
    ["fba1", "îŽ", 93],
    ["fca1", "îŽ¬", 93],
    ["fda1", "îŠ", 93],
    [
      "fe50",
      "âºî –î —î ˜âº„ã‘³ã‘‡âºˆâº‹î žã–žã˜šã˜ŽâºŒâº—ã¥®ã¤˜î ¦ã§ã§Ÿã©³ã§î «î ¬ã­Žã±®ã³ âº§î ±î ²âºªä–ä…Ÿâº®äŒ·âº³âº¶âº·î »äŽ±äŽ¬âº»ää“–ä™¡ä™Œî¡ƒ",
    ],
    ["fe80", "äœ£äœ©ä¼äžâ»Šä¥‡ä¥ºä¥½ä¦‚ä¦ƒä¦…ä¦†ä¦Ÿä¦›ä¦·ä¦¶î¡”î¡•ä²£ä²Ÿä² ä²¡ä±·ä²¢ä´“", 6, "ä¶®î¡¤î‘¨", 93],
  ],
  $N = [
    128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276,
    284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506,
    594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215,
    8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471,
    8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740,
    8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854,
    8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652,
    9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913,
    11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292,
    12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850,
    12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727,
    13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471,
    16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301,
    18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620,
    19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437,
    59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016,
    64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127,
    65132, 65375, 65510, 65536,
  ],
  CN = [
    0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148,
    172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443,
    544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927,
    7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236,
    8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394,
    8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496,
    8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108,
    9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346,
    11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692,
    11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336,
    12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973,
    13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318,
    16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859,
    17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962,
    19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513,
    33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066,
    38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265,
    39394, 189e3,
  ],
  RN = { uChars: $N, gbChars: CN },
  kN = [
    ["0", "\0", 127],
    ["8141", "ê°‚ê°ƒê°…ê°†ê°‹", 4, "ê°˜ê°žê°Ÿê°¡ê°¢ê°£ê°¥", 6, "ê°®ê°²ê°³ê°´"],
    ["8161", "ê°µê°¶ê°·ê°ºê°»ê°½ê°¾ê°¿ê±", 9, "ê±Œê±Ž", 5, "ê±•"],
    [
      "8181",
      "ê±–ê±—ê±™ê±šê±›ê±",
      18,
      "ê±²ê±³ê±µê±¶ê±¹ê±»",
      4,
      "ê²‚ê²‡ê²ˆê²ê²Žê²ê²‘ê²’ê²“ê²•",
      6,
      "ê²žê²¢",
      5,
      "ê²«ê²­ê²®ê²±",
      6,
      "ê²ºê²¾ê²¿ê³€ê³‚ê³ƒê³…ê³†ê³‡ê³‰ê³Šê³‹ê³",
      7,
      "ê³–ê³˜",
      7,
      "ê³¢ê³£ê³¥ê³¦ê³©ê³«ê³­ê³®ê³²ê³´ê³·",
      4,
      "ê³¾ê³¿ê´ê´‚ê´ƒê´…ê´‡",
      4,
      "ê´Žê´ê´’ê´“",
    ],
    ["8241", "ê´”ê´•ê´–ê´—ê´™ê´šê´›ê´ê´žê´Ÿê´¡", 7, "ê´ªê´«ê´®", 5],
    ["8261", "ê´¶ê´·ê´¹ê´ºê´»ê´½", 6, "êµ†êµˆêµŠ", 5, "êµ‘êµ’êµ“êµ•êµ–êµ—"],
    [
      "8281",
      "êµ™",
      7,
      "êµ¢êµ¤",
      7,
      "êµ®êµ¯êµ±êµ²êµ·êµ¸êµ¹êµºêµ¾ê¶€ê¶ƒ",
      4,
      "ê¶Šê¶‹ê¶ê¶Žê¶ê¶‘",
      10,
      "ê¶ž",
      5,
      "ê¶¥",
      17,
      "ê¶¸",
      7,
      "ê·‚ê·ƒê·…ê·†ê·‡ê·‰",
      6,
      "ê·’ê·”",
      7,
      "ê·ê·žê·Ÿê·¡ê·¢ê·£ê·¥",
      18,
    ],
    ["8341", "ê·ºê·»ê·½ê·¾ê¸‚", 5, "ê¸Šê¸Œê¸Ž", 5, "ê¸•", 7],
    ["8361", "ê¸", 18, "ê¸²ê¸³ê¸µê¸¶ê¸¹ê¸»ê¸¼"],
    [
      "8381",
      "ê¸½ê¸¾ê¸¿ê¹‚ê¹„ê¹‡ê¹ˆê¹‰ê¹‹ê¹ê¹‘ê¹’ê¹“ê¹•ê¹—",
      4,
      "ê¹žê¹¢ê¹£ê¹¤ê¹¦ê¹§ê¹ªê¹«ê¹­ê¹®ê¹¯ê¹±",
      6,
      "ê¹ºê¹¾",
      5,
      "êº†",
      5,
      "êº",
      46,
      "êº¿ê»ê»‚ê»ƒê»…",
      6,
      "ê»Žê»’",
      5,
      "ê»šê»›ê»",
      8,
    ],
    ["8441", "ê»¦ê»§ê»©ê»ªê»¬ê»®", 5, "ê»µê»¶ê»·ê»¹ê»ºê»»ê»½", 8],
    ["8461", "ê¼†ê¼‰ê¼Šê¼‹ê¼Œê¼Žê¼ê¼‘", 18],
    [
      "8481",
      "ê¼¤",
      7,
      "ê¼®ê¼¯ê¼±ê¼³ê¼µ",
      6,
      "ê¼¾ê½€ê½„ê½…ê½†ê½‡ê½Š",
      5,
      "ê½‘",
      10,
      "ê½ž",
      5,
      "ê½¦",
      18,
      "ê½º",
      5,
      "ê¾ê¾‚ê¾ƒê¾…ê¾†ê¾‡ê¾‰",
      6,
      "ê¾’ê¾“ê¾”ê¾–",
      5,
      "ê¾",
      26,
      "ê¾ºê¾»ê¾½ê¾¾",
    ],
    ["8541", "ê¾¿ê¿", 5, "ê¿Šê¿Œê¿", 4, "ê¿•", 6, "ê¿", 4],
    ["8561", "ê¿¢", 5, "ê¿ª", 5, "ê¿²ê¿³ê¿µê¿¶ê¿·ê¿¹", 6, "ë€‚ë€ƒ"],
    [
      "8581",
      "ë€…",
      6,
      "ë€ë€Žë€ë€‘ë€’ë€“ë€•",
      6,
      "ë€ž",
      9,
      "ë€©",
      26,
      "ë†ë‡ë‰ë‹ëëëë‘ë’ë–ë˜ëšë›ëœëž",
      29,
      "ë¾ë¿ë‚ë‚‚ë‚ƒë‚…",
      6,
      "ë‚Žë‚ë‚’",
      5,
      "ë‚›ë‚ë‚žë‚£ë‚¤",
    ],
    ["8641", "ë‚¥ë‚¦ë‚§ë‚ªë‚°ë‚²ë‚¶ë‚·ë‚¹ë‚ºë‚»ë‚½", 6, "ëƒ†ëƒŠ", 5, "ëƒ’"],
    ["8661", "ëƒ“ëƒ•ëƒ–ëƒ—ëƒ™", 6, "ëƒ¡ëƒ¢ëƒ£ëƒ¤ëƒ¦", 10],
    [
      "8681",
      "ëƒ±",
      22,
      "ë„Šë„ë„Žë„ë„‘ë„”ë„•ë„–ë„—ë„šë„ž",
      4,
      "ë„¦ë„§ë„©ë„ªë„«ë„­",
      6,
      "ë„¶ë„º",
      5,
      "ë…‚ë…ƒë……ë…†ë…‡ë…‰",
      6,
      "ë…’ë…“ë…–ë…—ë…™ë…šë…›ë…ë…žë…Ÿë…¡",
      22,
      "ë…ºë…»ë…½ë…¾ë…¿ë†ë†ƒ",
      4,
      "ë†Šë†Œë†Žë†ë†ë†‘ë†•ë†–ë†—ë†™ë†šë†›ë†",
    ],
    ["8741", "ë†ž", 9, "ë†©", 15],
    ["8761", "ë†¹", 18, "ë‡ë‡Žë‡ë‡‘ë‡’ë‡“ë‡•"],
    [
      "8781",
      "ë‡–",
      5,
      "ë‡žë‡ ",
      7,
      "ë‡ªë‡«ë‡­ë‡®ë‡¯ë‡±",
      7,
      "ë‡ºë‡¼ë‡¾",
      5,
      "ëˆ†ëˆ‡ëˆ‰ëˆŠëˆ",
      6,
      "ëˆ–ëˆ˜ëˆš",
      5,
      "ëˆ¡",
      18,
      "ëˆµ",
      6,
      "ëˆ½",
      26,
      "ë‰™ë‰šë‰›ë‰ë‰žë‰Ÿë‰¡",
      6,
      "ë‰ª",
      4,
    ],
    ["8841", "ë‰¯", 4, "ë‰¶", 5, "ë‰½", 6, "ëŠ†ëŠ‡ëŠˆëŠŠ", 4],
    ["8861", "ëŠëŠ’ëŠ“ëŠ•ëŠ–ëŠ—ëŠ›", 4, "ëŠ¢ëŠ¤ëŠ§ëŠ¨ëŠ©ëŠ«ëŠ­ëŠ®ëŠ¯ëŠ±ëŠ²ëŠ³ëŠµëŠ¶ëŠ·"],
    [
      "8881",
      "ëŠ¸",
      15,
      "ë‹Šë‹‹ë‹ë‹Žë‹ë‹‘ë‹“",
      4,
      "ë‹šë‹œë‹žë‹Ÿë‹ ë‹¡ë‹£ë‹§ë‹©ë‹ªë‹°ë‹±ë‹²ë‹¶ë‹¼ë‹½ë‹¾ëŒ‚ëŒƒëŒ…ëŒ†ëŒ‡ëŒ‰",
      6,
      "ëŒ’ëŒ–",
      5,
      "ëŒ",
      54,
      "ë—ë™ëšëë ë¡ë¢ë£",
    ],
    ["8941", "ë¦ë¨ëªë¬ë­ë¯ë²ë³ëµë¶ë·ë¹", 6, "ëŽ‚ëŽ†", 5, "ëŽ"],
    ["8961", "ëŽŽëŽëŽ‘ëŽ’ëŽ“ëŽ•", 10, "ëŽ¢", 5, "ëŽ©ëŽªëŽ«ëŽ­"],
    [
      "8981",
      "ëŽ®",
      21,
      "ë†ë‡ë‰ëŠëëë‘ë’ë“ë–ë˜ëšëœëžëŸë¡ë¢ë£ë¥ë¦ë§ë©",
      18,
      "ë½",
      18,
      "ë‘",
      6,
      "ë™ëšë›ëëžëŸë¡",
      6,
      "ëªë¬",
      7,
      "ëµ",
      15,
    ],
    ["8a41", "ë‘…", 10, "ë‘’ë‘“ë‘•ë‘–ë‘—ë‘™", 6, "ë‘¢ë‘¤ë‘¦"],
    ["8a61", "ë‘§", 4, "ë‘­", 18, "ë’ë’‚"],
    [
      "8a81",
      "ë’ƒ",
      4,
      "ë’‰",
      19,
      "ë’ž",
      5,
      "ë’¥ë’¦ë’§ë’©ë’ªë’«ë’­",
      7,
      "ë’¶ë’¸ë’º",
      5,
      "ë“ë“‚ë“ƒë“…ë“†ë“‡ë“‰",
      6,
      "ë“‘ë“’ë““ë“”ë“–",
      5,
      "ë“žë“Ÿë“¡ë“¢ë“¥ë“§",
      4,
      "ë“®ë“°ë“²",
      5,
      "ë“¹",
      26,
      "ë”–ë”—ë”™ë”šë”",
    ],
    ["8b41", "ë”ž", 5, "ë”¦ë”«", 4, "ë”²ë”³ë”µë”¶ë”·ë”¹", 6, "ë•‚ë•†"],
    ["8b61", "ë•‡ë•ˆë•‰ë•Šë•Žë•ë•‘ë•’ë•“ë••", 6, "ë•žë•¢", 8],
    [
      "8b81",
      "ë•«",
      52,
      "ë–¢ë–£ë–¥ë–¦ë–§ë–©ë–¬ë–­ë–®ë–¯ë–²ë–¶",
      4,
      "ë–¾ë–¿ë—ë—‚ë—ƒë—…",
      6,
      "ë—Žë—’",
      5,
      "ë—™",
      18,
      "ë—­",
      18,
    ],
    ["8c41", "ë˜€", 15, "ë˜’ë˜“ë˜•ë˜–ë˜—ë˜™", 4],
    ["8c61", "ë˜ž", 6, "ë˜¦", 5, "ë˜­", 6, "ë˜µ", 5],
    [
      "8c81",
      "ë˜»",
      12,
      "ë™‰",
      26,
      "ë™¥ë™¦ë™§ë™©",
      50,
      "ëšžëšŸëš¡ëš¢ëš£ëš¥",
      5,
      "ëš­ëš®ëš¯ëš°ëš²",
      16,
    ],
    ["8d41", "ë›ƒ", 16, "ë›•", 8],
    ["8d61", "ë›ž", 17, "ë›±ë›²ë›³ë›µë›¶ë›·ë›¹ë›º"],
    [
      "8d81",
      "ë›»",
      4,
      "ëœ‚ëœƒëœ„ëœ†",
      33,
      "ëœªëœ«ëœ­ëœ®ëœ±",
      6,
      "ëœºëœ¼",
      7,
      "ë…ë†ë‡ë‰ëŠë‹ë",
      6,
      "ë–",
      9,
      "ë¡ë¢ë£ë¥ë¦ë§ë©",
      6,
      "ë²ë´ë¶",
      5,
      "ë¾ë¿ëžëž‚ëžƒëž…",
      6,
      "ëžŽëž“ëž”ëž•ëžšëž›ëžëžž",
    ],
    ["8e41", "ëžŸëž¡", 6, "ëžªëž®", 5, "ëž¶ëž·ëž¹", 8],
    ["8e61", "ëŸ‚", 4, "ëŸˆëŸŠ", 19],
    [
      "8e81",
      "ëŸž",
      13,
      "ëŸ®ëŸ¯ëŸ±ëŸ²ëŸ³ëŸµ",
      6,
      "ëŸ¾ë ‚",
      4,
      "ë Šë ‹ë ë Žë ë ‘",
      6,
      "ë šë œë ž",
      5,
      "ë ¦ë §ë ©ë ªë «ë ­",
      6,
      "ë ¶ë º",
      5,
      "ë¡ë¡‚ë¡ƒë¡…",
      11,
      "ë¡’ë¡”",
      7,
      "ë¡žë¡Ÿë¡¡ë¡¢ë¡£ë¡¥",
      6,
      "ë¡®ë¡°ë¡²",
      5,
      "ë¡¹ë¡ºë¡»ë¡½",
      7,
    ],
    ["8f41", "ë¢…", 7, "ë¢Ž", 17],
    ["8f61", "ë¢ ", 7, "ë¢©", 6, "ë¢±ë¢²ë¢³ë¢µë¢¶ë¢·ë¢¹", 4],
    [
      "8f81",
      "ë¢¾ë¢¿ë£‚ë£„ë£†",
      5,
      "ë£ë£Žë£ë£‘ë£’ë£“ë£•",
      7,
      "ë£žë£ ë£¢",
      5,
      "ë£ªë£«ë£­ë£®ë£¯ë£±",
      6,
      "ë£ºë£¼ë£¾",
      5,
      "ë¤…",
      18,
      "ë¤™",
      6,
      "ë¤¡",
      26,
      "ë¤¾ë¤¿ë¥ë¥‚ë¥ƒë¥…",
      6,
      "ë¥ë¥Žë¥ë¥’",
      5,
    ],
    ["9041", "ë¥šë¥›ë¥ë¥žë¥Ÿë¥¡", 6, "ë¥ªë¥¬ë¥®", 5, "ë¥¶ë¥·ë¥¹ë¥ºë¥»ë¥½"],
    ["9061", "ë¥¾", 5, "ë¦†ë¦ˆë¦‹ë¦Œë¦", 15],
    [
      "9081",
      "ë¦Ÿ",
      12,
      "ë¦®ë¦¯ë¦±ë¦²ë¦³ë¦µ",
      6,
      "ë¦¾ë§€ë§‚",
      5,
      "ë§Šë§‹ë§ë§“",
      4,
      "ë§šë§œë§Ÿë§ ë§¢ë§¦ë§§ë§©ë§ªë§«ë§­",
      6,
      "ë§¶ë§»",
      4,
      "ë¨‚",
      5,
      "ë¨‰",
      11,
      "ë¨–",
      33,
      "ë¨ºë¨»ë¨½ë¨¾ë¨¿ë©ë©ƒë©„ë©…ë©†",
    ],
    ["9141", "ë©‡ë©Šë©Œë©ë©ë©‘ë©’ë©–ë©—ë©™ë©šë©›ë©", 6, "ë©¦ë©ª", 5],
    ["9161", "ë©²ë©³ë©µë©¶ë©·ë©¹", 9, "ëª†ëªˆëª‰ëªŠëª‹ëª", 5],
    [
      "9181",
      "ëª“",
      20,
      "ëªªëª­ëª®ëª¯ëª±ëª³",
      4,
      "ëªºëª¼ëª¾",
      5,
      "ë«…ë«†ë«‡ë«‰",
      14,
      "ë«š",
      33,
      "ë«½ë«¾ë«¿ë¬ë¬‚ë¬ƒë¬…",
      7,
      "ë¬Žë¬ë¬’",
      5,
      "ë¬™ë¬šë¬›ë¬ë¬žë¬Ÿë¬¡",
      6,
    ],
    ["9241", "ë¬¨ë¬ªë¬¬", 7, "ë¬·ë¬¹ë¬ºë¬¿", 4, "ë­†ë­ˆë­Šë­‹ë­Œë­Žë­‘ë­’"],
    ["9261", "ë­“ë­•ë­–ë­—ë­™", 7, "ë­¢ë­¤", 7, "ë­­", 4],
    [
      "9281",
      "ë­²",
      21,
      "ë®‰ë®Šë®‹ë®ë®Žë®ë®‘",
      18,
      "ë®¥ë®¦ë®§ë®©ë®ªë®«ë®­",
      6,
      "ë®µë®¶ë®¸",
      7,
      "ë¯ë¯‚ë¯ƒë¯…ë¯†ë¯‡ë¯‰",
      6,
      "ë¯‘ë¯’ë¯”",
      35,
      "ë¯ºë¯»ë¯½ë¯¾ë°",
    ],
    ["9341", "ë°ƒ", 4, "ë°Šë°Žë°ë°’ë°“ë°™ë°šë° ë°¡ë°¢ë°£ë°¦ë°¨ë°ªë°«ë°¬ë°®ë°¯ë°²ë°³ë°µ"],
    ["9361", "ë°¶ë°·ë°¹", 6, "ë±‚ë±†ë±‡ë±ˆë±Šë±‹ë±Žë±ë±‘", 8],
    [
      "9381",
      "ë±šë±›ë±œë±ž",
      37,
      "ë²†ë²‡ë²‰ë²Šë²ë²",
      4,
      "ë²–ë²˜ë²›",
      4,
      "ë²¢ë²£ë²¥ë²¦ë²©",
      6,
      "ë²²ë²¶",
      5,
      "ë²¾ë²¿ë³ë³‚ë³ƒë³…",
      7,
      "ë³Žë³’ë³“ë³”ë³–ë³—ë³™ë³šë³›ë³",
      22,
      "ë³·ë³¹ë³ºë³»ë³½",
    ],
    ["9441", "ë³¾", 5, "ë´†ë´ˆë´Š", 5, "ë´‘ë´’ë´“ë´•", 8],
    ["9461", "ë´ž", 5, "ë´¥", 6, "ë´­", 12],
    [
      "9481",
      "ë´º",
      5,
      "ëµ",
      6,
      "ëµŠëµ‹ëµëµŽëµëµ‘",
      6,
      "ëµš",
      9,
      "ëµ¥ëµ¦ëµ§ëµ©",
      22,
      "ë¶‚ë¶ƒë¶…ë¶†ë¶‹",
      4,
      "ë¶’ë¶”ë¶–ë¶—ë¶˜ë¶›ë¶",
      6,
      "ë¶¥",
      10,
      "ë¶±",
      6,
      "ë¶¹",
      24,
    ],
    ["9541", "ë·’ë·“ë·–ë·—ë·™ë·šë·›ë·", 11, "ë·ª", 5, "ë·±"],
    ["9561", "ë·²ë·³ë·µë·¶ë··ë·¹", 6, "ë¸ë¸‚ë¸„ë¸†", 5, "ë¸Žë¸ë¸‘ë¸’ë¸“"],
    [
      "9581",
      "ë¸•",
      6,
      "ë¸žë¸ ",
      35,
      "ë¹†ë¹‡ë¹‰ë¹Šë¹‹ë¹ë¹",
      4,
      "ë¹–ë¹˜ë¹œë¹ë¹žë¹Ÿë¹¢ë¹£ë¹¥ë¹¦ë¹§ë¹©ë¹«",
      4,
      "ë¹²ë¹¶",
      4,
      "ë¹¾ë¹¿ëºëº‚ëºƒëº…",
      6,
      "ëºŽëº’",
      5,
      "ëºš",
      13,
      "ëº©",
      14,
    ],
    ["9641", "ëº¸", 23, "ë»’ë»“"],
    ["9661", "ë»•ë»–ë»™", 6, "ë»¡ë»¢ë»¦", 5, "ë»­", 8],
    [
      "9681",
      "ë»¶",
      10,
      "ë¼‚",
      5,
      "ë¼Š",
      13,
      "ë¼šë¼ž",
      33,
      "ë½‚ë½ƒë½…ë½†ë½‡ë½‰",
      6,
      "ë½’ë½“ë½”ë½–",
      44,
    ],
    ["9741", "ë¾ƒ", 16, "ë¾•", 8],
    ["9761", "ë¾ž", 17, "ë¾±", 7],
    ["9781", "ë¾¹", 11, "ë¿†", 5, "ë¿Žë¿ë¿‘ë¿’ë¿“ë¿•", 6, "ë¿ë¿žë¿ ë¿¢", 89, "ì€½ì€¾ì€¿"],
    ["9841", "ì€", 16, "ì’", 5, "ì™ìšì›"],
    ["9861", "ììžìŸì¡", 6, "ìª", 15],
    [
      "9881",
      "ìº",
      21,
      "ì‚’ì‚“ì‚•ì‚–ì‚—ì‚™",
      6,
      "ì‚¢ì‚¤ì‚¦",
      5,
      "ì‚®ì‚±ì‚²ì‚·",
      4,
      "ì‚¾ìƒ‚ìƒƒìƒ„ìƒ†ìƒ‡ìƒŠìƒ‹ìƒìƒŽìƒìƒ‘",
      6,
      "ìƒšìƒž",
      5,
      "ìƒ¦ìƒ§ìƒ©ìƒªìƒ«ìƒ­",
      6,
      "ìƒ¶ìƒ¸ìƒº",
      5,
      "ì„ì„‚ì„ƒì„…ì„†ì„‡ì„‰",
      6,
      "ì„‘ì„’ì„“ì„”ì„–",
      5,
      "ì„¡ì„¢ì„¥ì„¨ì„©ì„ªì„«ì„®",
    ],
    ["9941", "ì„²ì„³ì„´ì„µì„·ì„ºì„»ì„½ì„¾ì„¿ì…", 6, "ì…Šì…Ž", 5, "ì…–ì…—"],
    ["9961", "ì…™ì…šì…›ì…", 6, "ì…¦ì…ª", 5, "ì…±ì…²ì…³ì…µì…¶ì…·ì…¹ì…ºì…»"],
    [
      "9981",
      "ì…¼",
      8,
      "ì††",
      5,
      "ì†ì†‘ì†’ì†“ì†•ì†—",
      4,
      "ì†žì† ì†¢ì†£ì†¤ì†¦ì†§ì†ªì†«ì†­ì†®ì†¯ì†±",
      11,
      "ì†¾",
      5,
      "ì‡…ì‡†ì‡‡ì‡‰ì‡Šì‡‹ì‡",
      6,
      "ì‡•ì‡–ì‡™",
      6,
      "ì‡¡ì‡¢ì‡£ì‡¥ì‡¦ì‡§ì‡©",
      6,
      "ì‡²ì‡´",
      7,
      "ì‡¾ì‡¿ìˆìˆ‚ìˆƒìˆ…",
      6,
      "ìˆŽìˆìˆ’",
      5,
      "ìˆšìˆ›ìˆìˆžìˆ¡ìˆ¢ìˆ£",
    ],
    ["9a41", "ìˆ¤ìˆ¥ìˆ¦ìˆ§ìˆªìˆ¬ìˆ®ìˆ°ìˆ³ìˆµ", 16],
    ["9a61", "ì‰†ì‰‡ì‰‰", 6, "ì‰’ì‰“ì‰•ì‰–ì‰—ì‰™", 6, "ì‰¡ì‰¢ì‰£ì‰¤ì‰¦"],
    [
      "9a81",
      "ì‰§",
      4,
      "ì‰®ì‰¯ì‰±ì‰²ì‰³ì‰µ",
      6,
      "ì‰¾ìŠ€ìŠ‚",
      5,
      "ìŠŠ",
      5,
      "ìŠ‘",
      6,
      "ìŠ™ìŠšìŠœìŠž",
      5,
      "ìŠ¦ìŠ§ìŠ©ìŠªìŠ«ìŠ®",
      5,
      "ìŠ¶ìŠ¸ìŠº",
      33,
      "ì‹žì‹Ÿì‹¡ì‹¢ì‹¥",
      5,
      "ì‹®ì‹°ì‹²ì‹³ì‹´ì‹µì‹·ì‹ºì‹½ì‹¾ì‹¿ìŒ",
      6,
      "ìŒŠìŒ‹ìŒŽìŒ",
    ],
    ["9b41", "ìŒìŒ‘ìŒ’ìŒ–ìŒ—ìŒ™ìŒšìŒ›ìŒ", 6, "ìŒ¦ìŒ§ìŒª", 8],
    ["9b61", "ìŒ³", 17, "ì†", 7],
    [
      "9b81",
      "ìŽ",
      25,
      "ìªì«ì­ì®ì¯ì±ì³",
      4,
      "ìºì»ì¾",
      5,
      "ìŽ…ìŽ†ìŽ‡ìŽ‰ìŽŠìŽ‹ìŽ",
      50,
      "ì",
      22,
      "ìš",
    ],
    ["9c41", "ì›ììžì¡ì£", 4, "ìªì«ì¬ì®", 5, "ì¶ì·ì¹", 5],
    ["9c61", "ì¿", 8, "ì‰", 6, "ì‘", 9],
    [
      "9c81",
      "ì›",
      8,
      "ì¥",
      6,
      "ì­ì®ì¯ì±ì²ì³ìµ",
      6,
      "ì¾",
      9,
      "ì‘‰",
      26,
      "ì‘¦ì‘§ì‘©ì‘ªì‘«ì‘­",
      6,
      "ì‘¶ì‘·ì‘¸ì‘º",
      5,
      "ì’",
      18,
      "ì’•",
      6,
      "ì’",
      12,
    ],
    ["9d41", "ì’ª", 13, "ì’¹ì’ºì’»ì’½", 8],
    ["9d61", "ì“†", 25],
    [
      "9d81",
      "ì“ ",
      8,
      "ì“ª",
      5,
      "ì“²ì“³ì“µì“¶ì“·ì“¹ì“»ì“¼ì“½ì“¾ì”‚",
      9,
      "ì”ì”Žì”ì”‘ì”’ì”“ì”•",
      6,
      "ì”",
      10,
      "ì”ªì”«ì”­ì”®ì”¯ì”±",
      6,
      "ì”ºì”¼ì”¾",
      5,
      "ì•†ì•‡ì•‹ì•ì•ì•‘ì•’ì•–ì•šì•›ì•œì•Ÿì•¢ì•£ì•¥ì•¦ì•§ì•©",
      6,
      "ì•²ì•¶",
      5,
      "ì•¾ì•¿ì–ì–‚ì–ƒì–…ì–†ì–ˆì–‰ì–Šì–‹ì–Žì–ì–’ì–“ì–”",
    ],
    ["9e41", "ì––ì–™ì–šì–›ì–ì–žì–Ÿì–¡", 7, "ì–ª", 9, "ì–¶"],
    ["9e61", "ì–·ì–ºì–¿", 4, "ì—‹ì—ì—ì—’ì—“ì—•ì—–ì——ì—™", 6, "ì—¢ì—¤ì—¦ì—§"],
    [
      "9e81",
      "ì—¨ì—©ì—ªì—«ì—¯ì—±ì—²ì—³ì—µì—¸ì—¹ì—ºì—»ì˜‚ì˜ƒì˜„ì˜‰ì˜Šì˜‹ì˜ì˜Žì˜ì˜‘",
      6,
      "ì˜šì˜",
      6,
      "ì˜¦ì˜§ì˜©ì˜ªì˜«ì˜¯ì˜±ì˜²ì˜¶ì˜¸ì˜ºì˜¼ì˜½ì˜¾ì˜¿ì™‚ì™ƒì™…ì™†ì™‡ì™‰",
      6,
      "ì™’ì™–",
      5,
      "ì™žì™Ÿì™¡",
      10,
      "ì™­ì™®ì™°ì™²",
      5,
      "ì™ºì™»ì™½ì™¾ì™¿ìš",
      6,
      "ìšŠìšŒìšŽ",
      5,
      "ìš–ìš—ìš™ìššìš›ìš",
      6,
      "ìš¦",
    ],
    ["9f41", "ìš¨ìšª", 5, "ìš²ìš³ìšµìš¶ìš·ìš»", 4, "ì›‚ì›„ì›†", 5, "ì›Ž"],
    ["9f61", "ì›ì›‘ì›’ì›“ì›•", 6, "ì›žì›Ÿì›¢", 5, "ì›ªì›«ì›­ì›®ì›¯ì›±ì›²"],
    [
      "9f81",
      "ì›³",
      4,
      "ì›ºì›»ì›¼ì›¾",
      5,
      "ìœ†ìœ‡ìœ‰ìœŠìœ‹ìœ",
      6,
      "ìœ–ìœ˜ìœš",
      5,
      "ìœ¢ìœ£ìœ¥ìœ¦ìœ§ìœ©",
      6,
      "ìœ²ìœ´ìœ¶ìœ¸ìœ¹ìœºìœ»ìœ¾ìœ¿ìì‚ìƒì…",
      4,
      "ì‹ìŽìì™ìšì›ììžìŸì¡",
      6,
      "ì©ìªì¬",
      7,
      "ì¶ì·ì¹ìºì»ì¿ìž€ìžìž‚ìž†ìž‹ìžŒìžìžìž’ìž“ìž•ìž™ìž›",
      4,
      "ìž¢ìž§",
      4,
      "ìž®ìž¯ìž±ìž²ìž³ìžµìž¶ìž·",
    ],
    ["a041", "ìž¸ìž¹ìžºìž»ìž¾ìŸ‚", 5, "ìŸŠìŸ‹ìŸìŸìŸ‘", 6, "ìŸ™ìŸšìŸ›ìŸœ"],
    ["a061", "ìŸž", 5, "ìŸ¥ìŸ¦ìŸ§ìŸ©ìŸªìŸ«ìŸ­", 13],
    [
      "a081",
      "ìŸ»",
      4,
      "ì ‚ì ƒì …ì †ì ‡ì ‰ì ‹",
      4,
      "ì ’ì ”ì —",
      4,
      "ì žì Ÿì ¡ì ¢ì £ì ¥",
      6,
      "ì ®ì °ì ²",
      5,
      "ì ¹ì ºì »ì ½ì ¾ì ¿ì¡",
      6,
      "ì¡Šì¡‹ì¡Ž",
      5,
      "ì¡•",
      26,
      "ì¡²ì¡³ì¡µì¡¶ì¡·ì¡¹ì¡»",
      4,
      "ì¢‚ì¢„ì¢ˆì¢‰ì¢Šì¢Ž",
      5,
      "ì¢•",
      7,
      "ì¢žì¢ ì¢¢ì¢£ì¢¤",
    ],
    ["a141", "ì¢¥ì¢¦ì¢§ì¢©", 18, "ì¢¾ì¢¿ì£€ì£"],
    ["a161", "ì£‚ì£ƒì£…ì£†ì£‡ì£‰ì£Šì£‹ì£", 6, "ì£–ì£˜ì£š", 5, "ì£¢ì££ì£¥"],
    [
      "a181",
      "ì£¦",
      14,
      "ì£¶",
      5,
      "ì£¾ì£¿ì¤ì¤‚ì¤ƒì¤‡",
      4,
      "ì¤Žã€€ã€ã€‚Â·â€¥â€¦Â¨ã€ƒÂ­â€•âˆ¥ï¼¼âˆ¼â€˜â€™â€œâ€ã€”ã€•ã€ˆ",
      9,
      "Â±Ã—Ã·â‰ â‰¤â‰¥âˆžâˆ´Â°â€²â€³â„ƒâ„«ï¿ ï¿¡ï¿¥â™‚â™€âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’Â§â€»â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â†’â†â†‘â†“â†”ã€“â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©âˆ§âˆ¨ï¿¢",
    ],
    ["a241", "ì¤ì¤’", 5, "ì¤™", 18],
    ["a261", "ì¤­", 6, "ì¤µ", 18],
    [
      "a281",
      "ì¥ˆ",
      7,
      "ì¥’ì¥“ì¥•ì¥–ì¥—ì¥™",
      6,
      "ì¥¢ì¥¤",
      7,
      "ì¥­ì¥®ì¥¯â‡’â‡”âˆ€âˆƒÂ´ï½žË‡Ë˜ËËšË™Â¸Ë›Â¡Â¿Ëâˆ®âˆ‘âˆÂ¤â„‰â€°â—â—€â–·â–¶â™¤â™ â™¡â™¥â™§â™£âŠ™â—ˆâ–£â—â—‘â–’â–¤â–¥â–¨â–§â–¦â–©â™¨â˜â˜Žâ˜œâ˜žÂ¶â€ â€¡â†•â†—â†™â†–â†˜â™­â™©â™ªâ™¬ã‰¿ãˆœâ„–ã‡â„¢ã‚ã˜â„¡â‚¬Â®",
    ],
    ["a341", "ì¥±ì¥²ì¥³ì¥µ", 6, "ì¥½", 10, "ì¦Šì¦‹ì¦ì¦Žì¦"],
    ["a361", "ì¦‘", 6, "ì¦šì¦œì¦ž", 16],
    ["a381", "ì¦¯", 16, "ì§‚ì§ƒì§…ì§†ì§‰ì§‹", 4, "ì§’ì§”ì§—ì§˜ì§›ï¼", 58, "ï¿¦ï¼½", 32, "ï¿£"],
    ["a441", "ì§žì§Ÿì§¡ì§£ì§¥ì§¦ì§¨ì§©ì§ªì§«ì§®ì§²", 5, "ì§ºì§»ì§½ì§¾ì§¿ì¨ì¨‚ì¨ƒì¨„"],
    ["a461", "ì¨…ì¨†ì¨‡ì¨Šì¨Ž", 5, "ì¨•ì¨–ì¨—ì¨™", 12],
    ["a481", "ì¨¦ì¨§ì¨¨ì¨ª", 28, "ã„±", 93],
    ["a541", "ì©‡", 4, "ì©Žì©ì©‘ì©’ì©“ì©•", 6, "ì©žì©¢", 5, "ì©©ì©ª"],
    ["a561", "ì©«", 17, "ì©¾", 5, "ìª…ìª†"],
    ["a581", "ìª‡", 16, "ìª™", 14, "â…°", 9],
    ["a5b0", "â… ", 9],
    ["a5c1", "Î‘", 16, "Î£", 6],
    ["a5e1", "Î±", 16, "Ïƒ", 6],
    ["a641", "ìª¨", 19, "ìª¾ìª¿ì«ì«‚ì«ƒì«…"],
    ["a661", "ì«†", 5, "ì«Žì«ì«’ì«”ì«•ì«–ì«—ì«š", 5, "ì«¡", 6],
    [
      "a681",
      "ì«¨ì«©ì«ªì««ì«­",
      6,
      "ì«µ",
      18,
      "ì¬‰ì¬Šâ”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚â”’â”‘â”šâ”™â”–â”•â”Žâ”â”žâ”Ÿâ”¡â”¢â”¦â”§â”©â”ªâ”­â”®â”±â”²â”µâ”¶â”¹â”ºâ”½â”¾â•€â•â•ƒ",
      7,
    ],
    ["a741", "ì¬‹", 4, "ì¬‘ì¬’ì¬“ì¬•ì¬–ì¬—ì¬™", 6, "ì¬¢", 7],
    ["a761", "ì¬ª", 22, "ì­‚ì­ƒì­„"],
    [
      "a781",
      "ì­…ì­†ì­‡ì­Šì­‹ì­ì­Žì­ì­‘",
      6,
      "ì­šì­›ì­œì­ž",
      5,
      "ì­¥",
      7,
      "ãŽ•ãŽ–ãŽ—â„“ãŽ˜ã„ãŽ£ãŽ¤ãŽ¥ãŽ¦ãŽ™",
      9,
      "ãŠãŽãŽŽãŽããŽˆãŽ‰ãˆãŽ§ãŽ¨ãŽ°",
      9,
      "ãŽ€",
      4,
      "ãŽº",
      5,
      "ãŽ",
      4,
      "â„¦ã€ããŽŠãŽ‹ãŽŒã–ã…ãŽ­ãŽ®ãŽ¯ã›ãŽ©ãŽªãŽ«ãŽ¬ããã“ãƒã‰ãœã†",
    ],
    ["a841", "ì­­", 10, "ì­º", 14],
    ["a861", "ì®‰", 18, "ì®", 6],
    ["a881", "ì®¤", 19, "ì®¹", 11, "Ã†ÃÂªÄ¦"],
    ["a8a6", "Ä²"],
    ["a8a8", "Ä¿ÅÃ˜Å’ÂºÃžÅ¦ÅŠ"],
    ["a8b1", "ã‰ ", 27, "â“", 25, "â‘ ", 14, "Â½â…“â…”Â¼Â¾â…›â…œâ…â…ž"],
    ["a941", "ì¯…", 14, "ì¯•", 10],
    ["a961", "ì¯ ì¯¡ì¯¢ì¯£ì¯¥ì¯¦ì¯¨ì¯ª", 18],
    [
      "a981",
      "ì¯½",
      14,
      "ì°Žì°ì°‘ì°’ì°“ì°•",
      6,
      "ì°žì°Ÿì° ì°£ì°¤Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å€Å‚Ã¸Å“ÃŸÃ¾Å§Å‹Å‰ãˆ€",
      27,
      "â’œ",
      25,
      "â‘´",
      14,
      "Â¹Â²Â³â´â¿â‚â‚‚â‚ƒâ‚„",
    ],
    ["aa41", "ì°¥ì°¦ì°ªì°«ì°­ì°¯ì°±", 6, "ì°ºì°¿", 4, "ì±†ì±‡ì±‰ì±Šì±‹ì±ì±Ž"],
    ["aa61", "ì±", 4, "ì±–ì±š", 5, "ì±¡ì±¢ì±£ì±¥ì±§ì±©", 6, "ì±±ì±²"],
    ["aa81", "ì±³ì±´ì±¶", 29, "ã", 82],
    ["ab41", "ì²”ì²•ì²–ì²—ì²šì²›ì²ì²žì²Ÿì²¡", 6, "ì²ªì²®", 5, "ì²¶ì²·ì²¹"],
    ["ab61", "ì²ºì²»ì²½", 6, "ì³†ì³ˆì³Š", 5, "ì³‘ì³’ì³“ì³•", 5],
    ["ab81", "ì³›", 8, "ì³¥", 6, "ì³­ì³®ì³¯ì³±", 12, "ã‚¡", 85],
    ["ac41", "ì³¾ì³¿ì´€ì´‚", 5, "ì´Šì´‹ì´ì´Žì´ì´‘", 6, "ì´šì´œì´žì´Ÿì´ "],
    ["ac61", "ì´¡ì´¢ì´£ì´¥ì´¦ì´§ì´©ì´ªì´«ì´­", 11, "ì´º", 4],
    ["ac81", "ì´¿", 28, "ìµìµžìµŸÐ", 5, "ÐÐ–", 25],
    ["acd1", "Ð°", 5, "Ñ‘Ð¶", 25],
    ["ad41", "ìµ¡ìµ¢ìµ£ìµ¥", 6, "ìµ®ìµ°ìµ²", 5, "ìµ¹", 7],
    ["ad61", "ì¶", 6, "ì¶‰", 10, "ì¶–ì¶—ì¶™ì¶šì¶›ì¶ì¶žì¶Ÿ"],
    ["ad81", "ì¶ ì¶¡ì¶¢ì¶£ì¶¦ì¶¨ì¶ª", 5, "ì¶±", 18, "ì·…"],
    ["ae41", "ì·†", 5, "ì·ì·Žì·ì·‘", 16],
    ["ae61", "ì·¢", 5, "ì·©ì·ªì·«ì·­ì·®ì·¯ì·±", 6, "ì·ºì·¼ì·¾", 4],
    ["ae81", "ì¸ƒì¸…ì¸†ì¸‡ì¸‰ì¸Šì¸‹ì¸", 6, "ì¸•ì¸–ì¸—ì¸˜ì¸š", 5, "ì¸¢ì¸£ì¸¥ì¸¦ì¸§ì¸©ì¸ªì¸«"],
    ["af41", "ì¸¬ì¸­ì¸®ì¸¯ì¸²ì¸´ì¸¶", 19],
    ["af61", "ì¹Š", 13, "ì¹šì¹›ì¹ì¹žì¹¢", 5, "ì¹ªì¹¬"],
    ["af81", "ì¹®", 5, "ì¹¶ì¹·ì¹¹ì¹ºì¹»ì¹½", 6, "ìº†ìºˆìºŠ", 5, "ìº’ìº“ìº•ìº–ìº—ìº™"],
    ["b041", "ìºš", 5, "ìº¢ìº¦", 5, "ìº®", 12],
    ["b061", "ìº»", 5, "ì»‚", 19],
    [
      "b081",
      "ì»–",
      13,
      "ì»¦ì»§ì»©ì»ªì»­",
      6,
      "ì»¶ì»º",
      5,
      "ê°€ê°ê°„ê°‡ê°ˆê°‰ê°Šê°",
      7,
      "ê°™",
      4,
      "ê° ê°¤ê°¬ê°­ê°¯ê°°ê°±ê°¸ê°¹ê°¼ê±€ê±‹ê±ê±”ê±˜ê±œê±°ê±±ê±´ê±·ê±¸ê±ºê²€ê²ê²ƒê²„ê²…ê²†ê²‰ê²Šê²‹ê²Œê²ê²”ê²œê²ê²Ÿê² ê²¡ê²¨ê²©ê²ªê²¬ê²¯ê²°ê²¸ê²¹ê²»ê²¼ê²½ê³ê³„ê³ˆê³Œê³•ê³—ê³ ê³¡ê³¤ê³§ê³¨ê³ªê³¬ê³¯ê³°ê³±ê³³ê³µê³¶ê³¼ê³½ê´€ê´„ê´†",
    ],
    ["b141", "ì¼‚ì¼ƒì¼…ì¼†ì¼‡ì¼‰", 6, "ì¼’ì¼”ì¼–", 5, "ì¼ì¼žì¼Ÿì¼¡ì¼¢ì¼£"],
    ["b161", "ì¼¥", 6, "ì¼®ì¼²", 5, "ì¼¹", 11],
    [
      "b181",
      "ì½…",
      14,
      "ì½–ì½—ì½™ì½šì½›ì½",
      6,
      "ì½¦ì½¨ì½ªì½«ì½¬ê´Œê´ê´ê´‘ê´˜ê´œê´ ê´©ê´¬ê´­ê´´ê´µê´¸ê´¼êµ„êµ…êµ‡êµ‰êµêµ”êµ˜êµ¡êµ£êµ¬êµ­êµ°êµ³êµ´êµµêµ¶êµ»êµ¼êµ½êµ¿ê¶ê¶‚ê¶ˆê¶‰ê¶Œê¶ê¶œê¶ê¶¤ê¶·ê·€ê·ê·„ê·ˆê·ê·‘ê·“ê·œê· ê·¤ê·¸ê·¹ê·¼ê·¿ê¸€ê¸ê¸ˆê¸‰ê¸‹ê¸ê¸”ê¸°ê¸±ê¸´ê¸·ê¸¸ê¸ºê¹€ê¹ê¹ƒê¹…ê¹†ê¹Šê¹Œê¹ê¹Žê¹ê¹”ê¹–ê¹œê¹ê¹Ÿê¹ ê¹¡ê¹¥ê¹¨ê¹©ê¹¬ê¹°ê¹¸",
    ],
    ["b241", "ì½­ì½®ì½¯ì½²ì½³ì½µì½¶ì½·ì½¹", 6, "ì¾ì¾‚ì¾ƒì¾„ì¾†", 5, "ì¾"],
    ["b261", "ì¾Ž", 18, "ì¾¢", 5, "ì¾©"],
    [
      "b281",
      "ì¾ª",
      5,
      "ì¾±",
      18,
      "ì¿…",
      6,
      "ê¹¹ê¹»ê¹¼ê¹½êº„êº…êºŒêº¼êº½êº¾ê»€ê»„ê»Œê»ê»ê»ê»‘ê»˜ê»™ê»œê»¨ê»«ê»­ê»´ê»¸ê»¼ê¼‡ê¼ˆê¼ê¼ê¼¬ê¼­ê¼°ê¼²ê¼´ê¼¼ê¼½ê¼¿ê½ê½‚ê½ƒê½ˆê½‰ê½ê½œê½ê½¤ê½¥ê½¹ê¾€ê¾„ê¾ˆê¾ê¾‘ê¾•ê¾œê¾¸ê¾¹ê¾¼ê¿€ê¿‡ê¿ˆê¿‰ê¿‹ê¿ê¿Žê¿”ê¿œê¿¨ê¿©ê¿°ê¿±ê¿´ê¿¸ë€€ë€ë€„ë€Œë€ë€”ë€œë€ë€¨ë„ë…ëˆëŠëŒëŽë“ë”ë•ë—ë™",
    ],
    ["b341", "ì¿Œ", 19, "ì¿¢ì¿£ì¿¥ì¿¦ì¿§ì¿©"],
    ["b361", "ì¿ª", 5, "ì¿²ì¿´ì¿¶", 5, "ì¿½ì¿¾ì¿¿í€í€‚í€ƒí€…", 5],
    [
      "b381",
      "í€‹",
      5,
      "í€’",
      5,
      "í€™",
      19,
      "ëë¼ë½ë‚€ë‚„ë‚Œë‚ë‚ë‚‘ë‚˜ë‚™ë‚šë‚œë‚Ÿë‚ ë‚¡ë‚¢ë‚¨ë‚©ë‚«",
      4,
      "ë‚±ë‚³ë‚´ë‚µë‚¸ë‚¼ëƒ„ëƒ…ëƒ‡ëƒˆëƒ‰ëƒëƒ‘ëƒ”ëƒ˜ëƒ ëƒ¥ë„ˆë„‰ë„‹ë„Œë„ë„’ë„“ë„˜ë„™ë„›ë„œë„ë„£ë„¤ë„¥ë„¨ë„¬ë„´ë„µë„·ë„¸ë„¹ë…€ë…ë…„ë…ˆë…ë…‘ë…”ë…•ë…˜ë…œë… ë…¸ë…¹ë…¼ë†€ë†‚ë†ˆë†‰ë†‹ë†ë†’ë†“ë†”ë†˜ë†œë†¨ë‡Œë‡ë‡”ë‡œë‡",
    ],
    ["b441", "í€®", 5, "í€¶í€·í€¹í€ºí€»í€½", 6, "í†íˆíŠ", 5],
    ["b461", "í‘í’í“í•í–í—í™", 6, "í¡", 10, "í®í¯"],
    [
      "b481",
      "í±í²í³íµ",
      6,
      "í¾í¿í‚€í‚‚",
      18,
      "ë‡Ÿë‡¨ë‡©ë‡¬ë‡°ë‡¹ë‡»ë‡½ëˆ„ëˆ…ëˆˆëˆ‹ëˆŒëˆ”ëˆ•ëˆ—ëˆ™ëˆ ëˆ´ëˆ¼ë‰˜ë‰œë‰ ë‰¨ë‰©ë‰´ë‰µë‰¼ëŠ„ëŠ…ëŠ‰ëŠëŠ‘ëŠ”ëŠ˜ëŠ™ëŠšëŠ ëŠ¡ëŠ£ëŠ¥ëŠ¦ëŠªëŠ¬ëŠ°ëŠ´ë‹ˆë‹‰ë‹Œë‹ë‹’ë‹˜ë‹™ë‹›ë‹ë‹¢ë‹¤ë‹¥ë‹¦ë‹¨ë‹«",
      4,
      "ë‹³ë‹´ë‹µë‹·",
      4,
      "ë‹¿ëŒ€ëŒëŒ„ëŒˆëŒëŒ‘ëŒ“ëŒ”ëŒ•ëŒœë”ë•ë–ë˜ë›ëœëžëŸë¤ë¥",
    ],
    ["b541", "í‚•", 14, "í‚¦í‚§í‚©í‚ªí‚«í‚­", 5],
    ["b561", "í‚³í‚¶í‚¸í‚º", 5, "íƒ‚íƒƒíƒ…íƒ†íƒ‡íƒŠ", 5, "íƒ’íƒ–", 4],
    [
      "b581",
      "íƒ›íƒžíƒŸíƒ¡íƒ¢íƒ£íƒ¥",
      6,
      "íƒ®íƒ²",
      5,
      "íƒ¹",
      11,
      "ë§ë©ë«ë®ë°ë±ë´ë¸ëŽ€ëŽëŽƒëŽ„ëŽ…ëŽŒëŽëŽ”ëŽ ëŽ¡ëŽ¨ëŽ¬ë„ë…ëˆë‹ëŒëŽëë”ë•ë—ë™ë›ëë ë¤ë¨ë¼ëë˜ëœë ë¨ë©ë«ë´ë‘ë‘‘ë‘”ë‘˜ë‘ ë‘¡ë‘£ë‘¥ë‘¬ë’€ë’ˆë’ë’¤ë’¨ë’¬ë’µë’·ë’¹ë“€ë“„ë“ˆë“ë“•ë“œë“ë“ ë“£ë“¤ë“¦ë“¬ë“­ë“¯ë“±ë“¸ë””ë”•ë”˜ë”›ë”œë”¤ë”¥ë”§ë”¨ë”©ë”ªë”°ë”±ë”´ë”¸",
    ],
    ["b641", "í„…", 7, "í„Ž", 17],
    ["b661", "í„ ", 15, "í„²í„³í„µí„¶í„·í„¹í„»í„¼í„½í„¾"],
    [
      "b681",
      "í„¿í…‚í…†",
      5,
      "í…Ží…í…‘í…’í…“í…•",
      6,
      "í…ží… í…¢",
      5,
      "í…©í…ªí…«í…­ë•€ë•ë•ƒë•„ë•…ë•‹ë•Œë•ë•ë•”ë•œë•ë•Ÿë• ë•¡ë– ë–¡ë–¤ë–¨ë–ªë–«ë–°ë–±ë–³ë–´ë–µë–»ë–¼ë–½ë—€ë—„ë—Œë—ë—ë—ë—‘ë—˜ë—¬ë˜ë˜‘ë˜”ë˜˜ë˜¥ë˜¬ë˜´ë™ˆë™¤ë™¨ëšœëšëš ëš¤ëš«ëš¬ëš±ë›”ë›°ë›´ë›¸ëœ€ëœëœ…ëœ¨ëœ©ëœ¬ëœ¯ëœ°ëœ¸ëœ¹ëœ»ë„ëˆëŒë”ë•ë ë¤ë¨ë°ë±ë³ëµë¼ë½ëž€ëž„ëžŒëžëžëžëž‘ëž’ëž–ëž—",
    ],
    ["b741", "í…®", 13, "í…½", 6, "í†…í††í†‡í†‰í†Š"],
    ["b761", "í†‹", 20, "í†¢í†£í†¥í†¦í†§"],
    [
      "b781",
      "í†©",
      6,
      "í†²í†´í†¶í†·í†¸í†¹í†»í†½í†¾í†¿í‡",
      14,
      "ëž˜ëž™ëžœëž ëž¨ëž©ëž«ëž¬ëž­ëž´ëžµëž¸ëŸ‡ëŸ‰ëŸ¬ëŸ­ëŸ°ëŸ´ëŸ¼ëŸ½ëŸ¿ë €ë ë ‡ë ˆë ‰ë Œë ë ˜ë ™ë ›ë ë ¤ë ¥ë ¨ë ¬ë ´ë µë ·ë ¸ë ¹ë¡€ë¡„ë¡‘ë¡“ë¡œë¡ë¡ ë¡¤ë¡¬ë¡­ë¡¯ë¡±ë¡¸ë¡¼ë¢ë¢¨ë¢°ë¢´ë¢¸ë£€ë£ë£ƒë£…ë£Œë£ë£”ë£ë£Ÿë£¡ë£¨ë£©ë£¬ë£°ë£¸ë£¹ë£»ë£½ë¤„ë¤˜ë¤ ë¤¼ë¤½ë¥€ë¥„ë¥Œë¥ë¥‘ë¥˜ë¥™ë¥œë¥ ë¥¨ë¥©",
    ],
    ["b841", "í‡", 7, "í‡™", 17],
    ["b861", "í‡«", 8, "í‡µí‡¶í‡·í‡¹", 13],
    [
      "b881",
      "íˆˆíˆŠ",
      5,
      "íˆ‘",
      24,
      "ë¥«ë¥­ë¥´ë¥µë¥¸ë¥¼ë¦„ë¦…ë¦‡ë¦‰ë¦Šë¦ë¦Žë¦¬ë¦­ë¦°ë¦´ë¦¼ë¦½ë¦¿ë§ë§ˆë§‰ë§Œë§Ž",
      4,
      "ë§˜ë§™ë§›ë§ë§žë§¡ë§£ë§¤ë§¥ë§¨ë§¬ë§´ë§µë§·ë§¸ë§¹ë§ºë¨€ë¨ë¨ˆë¨•ë¨¸ë¨¹ë¨¼ë©€ë©‚ë©ˆë©‰ë©‹ë©ë©Žë©“ë©”ë©•ë©˜ë©œë©¤ë©¥ë©§ë©¨ë©©ë©°ë©±ë©´ë©¸ëªƒëª„ëª…ëª‡ëªŒëª¨ëª©ëª«ëª¬ëª°ëª²ëª¸ëª¹ëª»ëª½ë«„ë«ˆë«˜ë«™ë«¼",
    ],
    ["b941", "íˆªíˆ«íˆ®íˆ¯íˆ±íˆ²íˆ³íˆµ", 6, "íˆ¾í‰€í‰‚", 5, "í‰‰í‰Ší‰‹í‰Œ"],
    ["b961", "í‰", 14, "í‰", 6, "í‰¥í‰¦í‰§í‰¨"],
    [
      "b981",
      "í‰©",
      22,
      "íŠ‚íŠƒíŠ…íŠ†íŠ‡íŠ‰íŠŠíŠ‹íŠŒë¬€ë¬„ë¬ë¬ë¬‘ë¬˜ë¬œë¬ ë¬©ë¬«ë¬´ë¬µë¬¶ë¬¸ë¬»ë¬¼ë¬½ë¬¾ë­„ë­…ë­‡ë­‰ë­ë­ë­ë­”ë­˜ë­¡ë­£ë­¬ë®ˆë®Œë®ë®¤ë®¨ë®¬ë®´ë®·ë¯€ë¯„ë¯ˆë¯ë¯“ë¯¸ë¯¹ë¯¼ë¯¿ë°€ë°‚ë°ˆë°‰ë°‹ë°Œë°ë°ë°‘ë°”",
      4,
      "ë°›",
      4,
      "ë°¤ë°¥ë°§ë°©ë°­ë°°ë°±ë°´ë°¸ë±€ë±ë±ƒë±„ë±…ë±‰ë±Œë±ë±ë±ë²„ë²…ë²ˆë²‹ë²Œë²Žë²”ë²•ë²—",
    ],
    ["ba41", "íŠíŠŽíŠíŠ’íŠ“íŠ”íŠ–", 5, "íŠíŠžíŠŸíŠ¡íŠ¢íŠ£íŠ¥", 6, "íŠ­"],
    ["ba61", "íŠ®íŠ¯íŠ°íŠ²", 5, "íŠºíŠ»íŠ½íŠ¾í‹í‹ƒ", 4, "í‹Ší‹Œ", 5],
    [
      "ba81",
      "í‹’í‹“í‹•í‹–í‹—í‹™í‹ší‹›í‹",
      6,
      "í‹¦",
      9,
      "í‹²í‹³í‹µí‹¶í‹·í‹¹í‹ºë²™ë²šë² ë²¡ë²¤ë²§ë²¨ë²°ë²±ë²³ë²´ë²µë²¼ë²½ë³€ë³„ë³ë³ë³ë³‘ë³•ë³˜ë³œë³´ë³µë³¶ë³¸ë³¼ë´„ë´…ë´‡ë´‰ë´ë´”ë´¤ë´¬ëµ€ëµˆëµ‰ëµŒëµëµ˜ëµ™ëµ¤ëµ¨ë¶€ë¶ë¶„ë¶‡ë¶ˆë¶‰ë¶Šë¶ë¶‘ë¶“ë¶•ë¶™ë¶šë¶œë¶¤ë¶°ë¶¸ë·”ë·•ë·˜ë·œë·©ë·°ë·´ë·¸ë¸€ë¸ƒë¸…ë¸Œë¸ë¸ë¸”ë¸œë¸ë¸Ÿë¹„ë¹…ë¹ˆë¹Œë¹Žë¹”ë¹•ë¹—ë¹™ë¹šë¹›ë¹ ë¹¡ë¹¤",
    ],
    ["bb41", "í‹»", 4, "íŒ‚íŒ„íŒ†", 5, "íŒíŒ‘íŒ’íŒ“íŒ•íŒ—", 4, "íŒžíŒ¢íŒ£"],
    ["bb61", "íŒ¤íŒ¦íŒ§íŒªíŒ«íŒ­íŒ®íŒ¯íŒ±", 6, "íŒºíŒ¾", 5, "í†í‡íˆí‰"],
    [
      "bb81",
      "íŠ",
      31,
      "ë¹¨ë¹ªë¹°ë¹±ë¹³ë¹´ë¹µë¹»ë¹¼ë¹½ëº€ëº„ëºŒëºëºëºëº‘ëº˜ëº™ëº¨ë»ë»‘ë»”ë»—ë»˜ë» ë»£ë»¤ë»¥ë»¬ë¼ë¼ˆë¼‰ë¼˜ë¼™ë¼›ë¼œë¼ë½€ë½ë½„ë½ˆë½ë½‘ë½•ë¾”ë¾°ë¿…ë¿Œë¿ë¿ë¿”ë¿œë¿Ÿë¿¡ì€¼ì‘ì˜ìœì ì¨ì©ì‚ì‚‘ì‚”ì‚˜ì‚ ì‚¡ì‚£ì‚¥ì‚¬ì‚­ì‚¯ì‚°ì‚³ì‚´ì‚µì‚¶ì‚¼ì‚½ì‚¿ìƒ€ìƒìƒ…ìƒˆìƒ‰ìƒŒìƒìƒ˜ìƒ™ìƒ›ìƒœìƒìƒ¤",
    ],
    ["bc41", "íª", 17, "í¾í¿íŽíŽ‚íŽƒíŽ…íŽ†íŽ‡"],
    ["bc61", "íŽˆíŽ‰íŽŠíŽ‹íŽŽíŽ’", 5, "íŽšíŽ›íŽíŽžíŽŸíŽ¡", 6, "íŽªíŽ¬íŽ®"],
    [
      "bc81",
      "íŽ¯",
      4,
      "íŽµíŽ¶íŽ·íŽ¹íŽºíŽ»íŽ½",
      6,
      "í†í‡íŠ",
      5,
      "í‘",
      5,
      "ìƒ¥ìƒ¨ìƒ¬ìƒ´ìƒµìƒ·ìƒ¹ì„€ì„„ì„ˆì„ì„•ì„œ",
      4,
      "ì„£ì„¤ì„¦ì„§ì„¬ì„­ì„¯ì„°ì„±ì„¶ì„¸ì„¹ì„¼ì…€ì…ˆì…‰ì…‹ì…Œì…ì…”ì…•ì…˜ì…œì…¤ì…¥ì…§ì…¨ì…©ì…°ì…´ì…¸ì†…ì†Œì†ì†Žì†ì†”ì†–ì†œì†ì†Ÿì†¡ì†¥ì†¨ì†©ì†¬ì†°ì†½ì‡„ì‡ˆì‡Œì‡”ì‡—ì‡˜ì‡ ì‡¤ì‡¨ì‡°ì‡±ì‡³ì‡¼ì‡½ìˆ€ìˆ„ìˆŒìˆìˆìˆ‘ìˆ˜ìˆ™ìˆœìˆŸìˆ ìˆ¨ìˆ©ìˆ«ìˆ­",
    ],
    ["bd41", "í—í™", 7, "í¢í¤", 7, "í®í¯í±í²í³íµí¶í·"],
    ["bd61", "í¸í¹íºí»í¾í€í‚", 5, "í‰", 13],
    [
      "bd81",
      "í—",
      5,
      "íž",
      25,
      "ìˆ¯ìˆ±ìˆ²ìˆ´ì‰ˆì‰ì‰‘ì‰”ì‰˜ì‰ ì‰¥ì‰¬ì‰­ì‰°ì‰´ì‰¼ì‰½ì‰¿ìŠìŠˆìŠ‰ìŠìŠ˜ìŠ›ìŠìŠ¤ìŠ¥ìŠ¨ìŠ¬ìŠ­ìŠ´ìŠµìŠ·ìŠ¹ì‹œì‹ì‹ ì‹£ì‹¤ì‹«ì‹¬ì‹­ì‹¯ì‹±ì‹¶ì‹¸ì‹¹ì‹»ì‹¼ìŒ€ìŒˆìŒ‰ìŒŒìŒìŒ“ìŒ”ìŒ•ìŒ˜ìŒœìŒ¤ìŒ¥ìŒ¨ìŒ©ì…ì¨ì©ì¬ì°ì²ì¸ì¹ì¼ì½ìŽ„ìŽˆìŽŒì€ì˜ì™ìœìŸì ì¢ì¨ì©ì­ì´ìµì¸ìˆìì¤ì¬ì°",
    ],
    ["be41", "í¸", 7, "í‘í‘‚í‘ƒí‘…", 14],
    ["be61", "í‘”", 7, "í‘í‘ží‘Ÿí‘¡í‘¢í‘£í‘¥", 7, "í‘®í‘°í‘±í‘²"],
    [
      "be81",
      "í‘³",
      4,
      "í‘ºí‘»í‘½í‘¾í’í’ƒ",
      4,
      "í’Ší’Œí’Ž",
      5,
      "í’•",
      8,
      "ì´ì¼ì½ì‘ˆì‘¤ì‘¥ì‘¨ì‘¬ì‘´ì‘µì‘¹ì’€ì’”ì’œì’¸ì’¼ì“©ì“°ì“±ì“´ì“¸ì“ºì“¿ì”€ì”ì”Œì”ì””ì”œì”¨ì”©ì”¬ì”°ì”¸ì”¹ì”»ì”½ì•„ì•…ì•ˆì•‰ì•Šì•Œì•ì•Žì•“ì•”ì••ì•—ì•˜ì•™ì•ì•žì• ì•¡ì•¤ì•¨ì•°ì•±ì•³ì•´ì•µì•¼ì•½ì–€ì–„ì–‡ì–Œì–ì–ì–‘ì–•ì–—ì–˜ì–œì– ì–©ì–´ì–µì–¸ì–¹ì–»ì–¼ì–½ì–¾ì—„",
      6,
      "ì—Œì—Ž",
    ],
    ["bf41", "í’ž", 10, "í’ª", 14],
    ["bf61", "í’¹", 18, "í“í“Ží“í“‘í“’í““í“•"],
    [
      "bf81",
      "í“–",
      5,
      "í“í“ží“ ",
      7,
      "í“©í“ªí“«í“­í“®í“¯í“±",
      6,
      "í“¹í“ºí“¼ì—ì—‘ì—”ì—˜ì— ì—¡ì—£ì—¥ì—¬ì—­ì—®ì—°ì—´ì—¶ì—·ì—¼",
      5,
      "ì˜…ì˜†ì˜‡ì˜ˆì˜Œì˜ì˜˜ì˜™ì˜›ì˜œì˜¤ì˜¥ì˜¨ì˜¬ì˜­ì˜®ì˜°ì˜³ì˜´ì˜µì˜·ì˜¹ì˜»ì™€ì™ì™„ì™ˆì™ì™‘ì™“ì™”ì™•ì™œì™ì™ ì™¬ì™¯ì™±ì™¸ì™¹ì™¼ìš€ìšˆìš‰ìš‹ìšìš”ìš•ìš˜ìšœìš¤ìš¥ìš§ìš©ìš°ìš±ìš´ìš¸ìš¹ìšºì›€ì›ì›ƒì›…ì›Œì›ì›ì›”ì›œì›ì› ì›¡ì›¨",
    ],
    ["c041", "í“¾", 5, "í”…í”†í”‡í”‰í”Ší”‹í”", 6, "í”–í”˜", 5],
    ["c061", "í”ž", 25],
    [
      "c081",
      "í”¸í”¹í”ºí”»í”¾í”¿í•í•‚í•ƒí•…",
      6,
      "í•Ží•í•’",
      5,
      "í•ší•›í•í•ží•Ÿí•¡í•¢í•£ì›©ì›¬ì›°ì›¸ì›¹ì›½ìœ„ìœ…ìœˆìœŒìœ”ìœ•ìœ—ìœ™ìœ ìœ¡ìœ¤ìœ¨ìœ°ìœ±ìœ³ìœµìœ·ìœ¼ìœ½ì€ì„ìŠìŒììì‘",
      7,
      "ìœì ì¨ì«ì´ìµì¸ì¼ì½ì¾ìžƒìž„ìž…ìž‡ìžˆìž‰ìžŠìžŽìžìž‘ìž”ìž–ìž—ìž˜ìžšìž ìž¡ìž£ìž¤ìž¥ìž¦ìž¬ìž­ìž°ìž´ìž¼ìž½ìž¿ìŸ€ìŸìŸˆìŸ‰ìŸŒìŸŽìŸìŸ˜ìŸìŸ¤ìŸ¨ìŸ¬ì €ì ì „ì ˆì Š",
    ],
    ["c141", "í•¤í•¦í•§í•ªí•¬í•®", 5, "í•¶í•·í•¹í•ºí•»í•½", 6, "í–†í–Ší–‹"],
    ["c161", "í–Œí–í–Ží–í–‘", 19, "í–¦í–§"],
    [
      "c181",
      "í–¨",
      31,
      "ì ì ‘ì “ì •ì –ì œì ì  ì ¤ì ¬ì ­ì ¯ì ±ì ¸ì ¼ì¡€ì¡ˆì¡‰ì¡Œì¡ì¡”ì¡°ì¡±ì¡´ì¡¸ì¡ºì¢€ì¢ì¢ƒì¢…ì¢†ì¢‡ì¢‹ì¢Œì¢ì¢”ì¢ì¢Ÿì¢¡ì¢¨ì¢¼ì¢½ì£„ì£ˆì£Œì£”ì£•ì£—ì£™ì£ ì£¡ì£¤ì£µì£¼ì£½ì¤€ì¤„ì¤…ì¤†ì¤Œì¤ì¤ì¤‘ì¤˜ì¤¬ì¤´ì¥ì¥‘ì¥”ì¥˜ì¥ ì¥¡ì¥£ì¥¬ì¥°ì¥´ì¥¼ì¦ˆì¦‰ì¦Œì¦ì¦˜ì¦™ì¦›ì¦ì§€ì§ì§„ì§‡ì§ˆì§Šì§ì§‘ì§“",
    ],
    ["c241", "í—Ší—‹í—í—Ží—í—‘í—“", 4, "í—ší—œí—ž", 5, "í—¦í—§í—©í—ªí—«í—­í—®"],
    ["c261", "í—¯", 4, "í—¶í—¸í—º", 5, "í˜‚í˜ƒí˜…í˜†í˜‡í˜‰", 6, "í˜’"],
    [
      "c281",
      "í˜–",
      5,
      "í˜í˜ží˜Ÿí˜¡í˜¢í˜£í˜¥",
      7,
      "í˜®",
      9,
      "í˜ºí˜»ì§•ì§–ì§™ì§šì§œì§ì§ ì§¢ì§¤ì§§ì§¬ì§­ì§¯ì§°ì§±ì§¸ì§¹ì§¼ì¨€ì¨ˆì¨‰ì¨‹ì¨Œì¨ì¨”ì¨˜ì¨©ì©Œì©ì©ì©”ì©œì©ì©Ÿì© ì©¡ì©¨ì©½ìª„ìª˜ìª¼ìª½ì«€ì«„ì«Œì«ì«ì«‘ì«“ì«˜ì«™ì« ì«¬ì«´ì¬ˆì¬ì¬”ì¬˜ì¬ ì¬¡ì­ì­ˆì­‰ì­Œì­ì­˜ì­™ì­ì­¤ì­¸ì­¹ì®œì®¸ì¯”ì¯¤ì¯§ì¯©ì°Œì°ì°ì°”ì°œì°ì°¡ì°¢ì°§ì°¨ì°©ì°¬ì°®ì°°ì°¸ì°¹ì°»",
    ],
    ["c341", "í˜½í˜¾í˜¿í™í™‚í™ƒí™„í™†í™‡í™Ší™Œí™Ží™í™í™’í™“í™–í™—í™™í™ší™›í™", 4],
    ["c361", "í™¢", 4, "í™¨í™ª", 5, "í™²í™³í™µ", 11],
    [
      "c381",
      "íšíš‚íš„íš†",
      5,
      "íšŽíšíš‘íš’íš“íš•",
      7,
      "íšžíš íš¢",
      5,
      "íš©íšªì°¼ì°½ì°¾ì±„ì±…ì±ˆì±Œì±”ì±•ì±—ì±˜ì±™ì± ì±¤ì±¦ì±¨ì±°ì±µì²˜ì²™ì²œì² ì²¨ì²©ì²«ì²¬ì²­ì²´ì²µì²¸ì²¼ì³„ì³…ì³‡ì³‰ì³ì³”ì³¤ì³¬ì³°ì´ì´ˆì´‰ì´Œì´ì´˜ì´™ì´›ì´ì´¤ì´¨ì´¬ì´¹ìµœìµ ìµ¤ìµ¬ìµ­ìµ¯ìµ±ìµ¸ì¶ˆì¶”ì¶•ì¶˜ì¶œì¶¤ì¶¥ì¶§ì¶©ì¶°ì·„ì·Œì·ì·¨ì·¬ì·°ì·¸ì·¹ì·»ì·½ì¸„ì¸ˆì¸Œì¸”ì¸™ì¸ ì¸¡ì¸¤ì¸¨ì¸°ì¸±ì¸³ì¸µ",
    ],
    ["c441", "íš«íš­íš®íš¯íš±", 7, "íšºíš¼", 7, "í›†í›‡í›‰í›Ší›‹"],
    ["c461", "í›í›Ží›í›í›’í›“í›•í›–í›˜í›š", 5, "í›¡í›¢í›£í›¥í›¦í›§í›©", 4],
    [
      "c481",
      "í›®í›¯í›±í›²í›³í›´í›¶",
      5,
      "í›¾í›¿íœíœ‚íœƒíœ…",
      11,
      "íœ’íœ“íœ”ì¹˜ì¹™ì¹œì¹Ÿì¹ ì¹¡ì¹¨ì¹©ì¹«ì¹­ì¹´ì¹µì¹¸ì¹¼ìº„ìº…ìº‡ìº‰ìºìº‘ìº”ìº˜ìº ìº¡ìº£ìº¤ìº¥ìº¬ìº­ì»ì»¤ì»¥ì»¨ì»«ì»¬ì»´ì»µì»·ì»¸ì»¹ì¼€ì¼ì¼„ì¼ˆì¼ì¼‘ì¼“ì¼•ì¼œì¼ ì¼¤ì¼¬ì¼­ì¼¯ì¼°ì¼±ì¼¸ì½”ì½•ì½˜ì½œì½¤ì½¥ì½§ì½©ì½°ì½±ì½´ì½¸ì¾€ì¾…ì¾Œì¾¡ì¾¨ì¾°ì¿„ì¿ ì¿¡ì¿¤ì¿¨ì¿°ì¿±ì¿³ì¿µì¿¼í€€í€„í€‘í€˜í€­í€´í€µí€¸í€¼",
    ],
    ["c541", "íœ•íœ–íœ—íœšíœ›íœíœžíœŸíœ¡", 6, "íœªíœ¬íœ®", 5, "íœ¶íœ·íœ¹"],
    ["c561", "íœºíœ»íœ½", 6, "í…í†íˆíŠ", 5, "í’í“í•íš", 4],
    [
      "c581",
      "íŸí¢í¤í¦í§í¨íªí«í­í®í¯í±í²í³íµ",
      6,
      "í¾í¿íž€íž‚",
      5,
      "ížŠíž‹í„í…í‡í‰íí”í˜í í¬í­í°í´í¼í½í‚í‚¤í‚¥í‚¨í‚¬í‚´í‚µí‚·í‚¹íƒ€íƒíƒ„íƒˆíƒ‰íƒíƒ‘íƒ“íƒ”íƒ•íƒœíƒíƒ íƒ¤íƒ¬íƒ­íƒ¯íƒ°íƒ±íƒ¸í„í„°í„±í„´í„¸í„ºí…€í…í…ƒí…„í……í…Œí…í…í…”í…œí…í…Ÿí…¡í…¨í…¬í…¼í†„í†ˆí† í†¡í†¤í†¨í†°í†±í†³í†µí†ºí†¼í‡€í‡˜í‡´í‡¸íˆ‡íˆ‰íˆíˆ¬íˆ­íˆ°íˆ´íˆ¼íˆ½íˆ¿í‰í‰ˆí‰œ",
    ],
    ["c641", "ížížŽížíž‘", 6, "ížšížœížž", 5],
    [
      "c6a1",
      "í‰¤íŠ€íŠíŠ„íŠˆíŠíŠ‘íŠ•íŠœíŠ íŠ¤íŠ¬íŠ±íŠ¸íŠ¹íŠ¼íŠ¿í‹€í‹‚í‹ˆí‹‰í‹‹í‹”í‹˜í‹œí‹¤í‹¥í‹°í‹±í‹´í‹¸íŒ€íŒíŒƒíŒ…íŒŒíŒíŒŽíŒíŒ”íŒ–íŒœíŒíŒŸíŒ íŒ¡íŒ¥íŒ¨íŒ©íŒ¬íŒ°íŒ¸íŒ¹íŒ»íŒ¼íŒ½í„í…í¼í½íŽ€íŽ„íŽŒíŽíŽíŽíŽ‘íŽ˜íŽ™íŽœíŽ íŽ¨íŽ©íŽ«íŽ­íŽ´íŽ¸íŽ¼í„í…íˆí‰íí˜í¡í£í¬í­í°í´í¼í½í¿í",
    ],
    [
      "c7a1",
      "íˆíí‘€í‘„í‘œí‘ í‘¤í‘­í‘¯í‘¸í‘¹í‘¼í‘¿í’€í’‚í’ˆí’‰í’‹í’í’”í’©í“Œí“í“”í“œí“Ÿí“¨í“¬í“°í“¸í“»í“½í”„í”ˆí”Œí””í”•í”—í”¼í”½í•€í•„í•Œí•í•í•‘í•˜í•™í•œí• í•¥í•¨í•©í•«í•­í•´í•µí•¸í•¼í–„í–…í–‡í–ˆí–‰í–í–¥í—ˆí—‰í—Œí—í—’í—˜í—™í—›í—í—¤í—¥í—¨í—¬í—´í—µí—·í—¹í˜€í˜í˜„í˜ˆí˜í˜‘í˜“í˜”í˜•í˜œí˜ ",
    ],
    [
      "c8a1",
      "í˜¤í˜­í˜¸í˜¹í˜¼í™€í™…í™ˆí™‰í™‹í™í™‘í™”í™•í™˜í™œí™§í™©í™°í™±í™´íšƒíš…íšŒíšíšíš”íšíšŸíš¡íš¨íš¬íš°íš¹íš»í›„í›…í›ˆí›Œí›‘í›”í›—í›™í› í›¤í›¨í›°í›µí›¼í›½íœ€íœ„íœ‘íœ˜íœ™íœœíœ íœ¨íœ©íœ«íœ­íœ´íœµíœ¸íœ¼í„í‡í‰íí‘í”í–í—í˜í™í í¡í£í¥í©í¬í°í´í¼í½ížížˆíž‰ížŒížíž˜íž™íž›íž",
    ],
    [
      "caa1",
      "ä¼½ä½³å‡åƒ¹åŠ å¯å‘µå“¥å˜‰å«å®¶æš‡æž¶æž·æŸ¯æ­Œç‚ç—‚ç¨¼è‹›èŒ„è¡—è¢ˆè¨¶è³ˆè·è»»è¿¦é§•åˆ»å´å„æªæ…¤æ®¼çè„šè¦ºè§’é–£ä¾ƒåˆŠå¢¾å¥¸å§¦å¹²å¹¹æ‡‡æ€æ†æŸ¬æ¡¿æ¾—ç™Žçœ‹ç£µç¨ˆç«¿ç°¡è‚è‰®è‰±è««é–“ä¹«å–æ›·æ¸´ç¢£ç«­è‘›è¤èŽéž¨å‹˜åŽå ªåµŒæ„Ÿæ†¾æˆ¡æ•¢æŸ‘æ©„æ¸›ç”˜ç–³ç›£çž°ç´ºé‚¯é‘‘é‘’é¾•",
    ],
    [
      "cba1",
      "åŒ£å²¬ç”²èƒ›é‰€é–˜å‰›å ˆå§œå²¡å´—åº·å¼ºå½Šæ…·æ±Ÿç•ºç–†ç³ çµ³ç¶±ç¾Œè…”èˆ¡è–‘è¥è¬›é‹¼é™é±‡ä»‹ä»·å€‹å‡±å¡æ„·æ„¾æ…¨æ”¹æ§ªæ¼‘ç–¥çš†ç›–ç®‡èŠ¥è“‹ï¤€éŽ§é–‹å–€å®¢å‘ï¤ç²³ç¾¹é†µå€¨åŽ»å±…å·¨æ‹’æ®æ“šæ“§æ¸ ç‚¬ç¥›è·è¸žï¤‚é½é‰…é‹¸ä¹¾ä»¶å¥å·¾å»ºæ„†æ¥—è…±è™”è¹‡éµé¨«ä¹žå‚‘æ°æ¡€å„‰åŠåŠ’æª¢",
    ],
    [
      "cca1",
      "çž¼éˆé»”åŠ«æ€¯è¿²åˆæ†©æ­æ“Šæ ¼æª„æ¿€è†ˆè¦¡éš”å …ç‰½çŠ¬ç”„çµ¹ç¹­è‚©è¦‹è­´é£éµ‘æŠ‰æ±ºæ½”çµç¼ºè¨£å…¼æ…Šç®è¬™é‰—éŽŒäº¬ä¿“å€žå‚¾å„†å‹å‹å¿å°å¢ƒåºšå¾‘æ…¶æ†¬æ“Žæ•¬æ™¯æš»æ›´æ¢—æ¶‡ç‚…çƒ±ç’Ÿç’¥ç“Šç—™ç¡¬ç£¬ç«Ÿç«¶çµ…ç¶“è€•è€¿è„›èŽ–è­¦è¼•é€•é¡é ƒé ¸é©šé¯¨ä¿‚å•“å ºå¥‘å­£å±†æ‚¸æˆ’æ¡‚æ¢°",
    ],
    [
      "cda1",
      "æ£¨æºªç•Œç™¸ç£Žç¨½ç³»ç¹«ç¹¼è¨ˆèª¡è°¿éšŽé·„å¤å©å‘Šå‘±å›ºå§‘å­¤å°»åº«æ‹·æ”·æ•…æ•²æš æž¯æ§æ²½ç—¼çšç¾ç¨¿ç¾”è€ƒè‚¡è†è‹¦è‹½è°è—è ±è¢´èª¥ï¤ƒè¾œéŒ®é›‡é¡§é«˜é¼“å“­æ–›æ›²æ¢ç©€è°·éµ å›°å¤å´‘æ˜†æ¢±æ£æ»¾ç¨è¢žé¯¤æ±¨ï¤„éª¨ä¾›å…¬å…±åŠŸå­”å·¥ææ­æ‹±æŽ§æ”»ç™ç©ºèš£è²¢éžä¸²å¯¡æˆˆæžœç“œ",
    ],
    [
      "cea1",
      "ç§‘è“èª‡èª²è·¨éŽé‹é¡†å»“æ§¨è—¿éƒ­ï¤…å† å®˜å¯¬æ…£æ£ºæ¬¾çŒç¯ç“˜ç®¡ç½è…è§€è²«é—œé¤¨åˆ®ææ‹¬é€‚ä¾Šå…‰åŒ¡å£™å»£æ› æ´¸ç‚šç‹‚ç–ç­èƒ±é‘›å¦æŽ›ç½«ä¹–å‚€å¡Šå£žæ€ªæ„§æ‹æ§é­å®ç´˜è‚±è½Ÿäº¤åƒ‘å’¬å–¬å¬Œå¶ å·§æ”ªæ•Žæ ¡æ©‹ç‹¡çšŽçŸ¯çµžç¿¹è† è•Žè›Ÿè¼ƒè½ŽéƒŠé¤ƒé©•é®«ä¸˜ä¹…ä¹ä»‡ä¿±å…·å‹¾",
    ],
    [
      "cfa1",
      "å€å£å¥å’Žå˜”åµåž¢å¯‡å¶‡å»æ‡¼æ‹˜æ•‘æž¸æŸ©æ§‹æ­æ¯†æ¯¬æ±‚æºç¸ç‹—çŽ–çƒçž¿çŸ©ç©¶çµ¿è€‰è‡¼èˆ…èˆŠè‹Ÿè¡¢è¬³è³¼è»€é€‘é‚±é‰¤éŠ¶é§’é©…é³©é·—é¾œåœ‹å±€èŠéž éž«éº´å›çª˜ç¾¤è£™è»éƒ¡å €å±ˆæŽ˜çªŸå®®å¼“ç©¹çª®èŠŽèº¬å€¦åˆ¸å‹¸å·åœˆæ‹³æ²æ¬Šæ·ƒçœ·åŽ¥ç—è•¨è¹¶é—•æœºæ«ƒæ½°è©­è»Œé¥‹ï¤†æ™·æ­¸è²´",
    ],
    [
      "d0a1",
      "é¬¼ï¤‡å«åœ­å¥Žæ†æ§»çªç¡…çªºç«…ç³¾è‘µè¦èµ³é€µé–¨å‹»å‡ç•‡ç­ èŒéˆžï¤ˆæ©˜å…‹å‰‹åŠ‡æˆŸæ£˜æ¥µéš™åƒ…åŠ¤å‹¤æ‡ƒæ–¤æ ¹æ§¿ç‘¾ç­‹èŠ¹è«è¦²è¬¹è¿‘é¥‰ï¤‰ä»Šå¦—æ“’æ˜‘æªŽç´ç¦ç¦½èŠ©è¡¾è¡¿è¥Ÿï¤ŠéŒ¦ä¼‹åŠæ€¥æ‰±æ±²ç´šçµ¦äº˜å…¢çŸœè‚¯ä¼ä¼Žå…¶å†€å—œå™¨åœ»åŸºåŸ¼å¤”å¥‡å¦“å¯„å²å´Žå·±å¹¾å¿ŒæŠ€æ——æ—£",
    ],
    [
      "d1a1",
      "æœžæœŸæžæ£‹æ£„æ©Ÿæ¬ºæ°£æ±½æ²‚æ·‡çŽ˜ç¦çªç’‚ç’£ç•¸ç•¿ç¢ç£¯ç¥ç¥‡ç¥ˆç¥ºç®•ç´€ç¶ºç¾ˆè€†è€­è‚Œè¨˜è­è±ˆèµ·éŒ¡éŒ¤é£¢é¥‘é¨Žé¨é©¥éº’ç·Šä½¶å‰æ‹®æ¡”é‡‘å–«å„ºï¤‹ï¤Œå¨œæ‡¦ï¤æ‹æ‹¿ï¤Ž",
      5,
      "é‚£ï¤”",
      4,
      "è«¾ï¤™ï¤šï¤›ï¤œæš–ï¤ç…–ï¤žï¤Ÿé›£ï¤ ææºå—ï¤¡æžæ¥ æ¹³ï¤¢ç”·ï¤£ï¤¤ï¤¥",
    ],
    [
      "d2a1",
      "ç´ï¤¦ï¤§è¡²å›Šå¨˜ï¤¨",
      4,
      "ä¹ƒï¤­å…§å¥ˆæŸ°è€ï¤®å¥³å¹´æ’šç§Šå¿µæ¬æ‹ˆæ»å¯§å¯—åŠªï¤¯å¥´å¼©æ€’ï¤°ï¤±ï¤²ç‘™ï¤³",
      5,
      "é§‘ï¤¹",
      10,
      "æ¿ƒï¥„ï¥…è†¿è¾²æƒ±ï¥†ï¥‡è…¦ï¥ˆï¥‰å°¿ï¥Š",
      7,
      "å«©è¨¥æ»ç´ï¥’",
      5,
      "èƒ½ï¥˜ï¥™å°¼æ³¥åŒ¿æººå¤šèŒ¶",
    ],
    [
      "d3a1",
      "ä¸¹äº¶ä½†å–®åœ˜å£‡å½–æ–·æ—¦æª€æ®µæ¹çŸ­ç«¯ç°žç·žè›‹è¢’é„²é›æ’»æ¾¾çºç–¸é”å•–åæ†ºæ“”æ›‡æ·¡æ¹›æ½­æ¾¹ç—°èƒè†½è•è¦ƒè«‡è­šéŒŸæ²“ç•“ç­”è¸éå”å ‚å¡˜å¹¢æˆ‡æ’žæ£ ç•¶ç³–èž³é»¨ä»£åžˆå®å¤§å°å²±å¸¶å¾…æˆ´æ“¡çŽ³è‡ºè¢‹è²¸éšŠé»›å®…å¾·æ‚³å€’åˆ€åˆ°åœ–å µå¡—å°Žå± å³¶å¶‹åº¦å¾’æ‚¼æŒ‘æŽ‰æ—æ¡ƒ",
    ],
    [
      "d4a1",
      "æ£¹æ«‚æ·˜æ¸¡æ»”æ¿¤ç‡¾ç›œç¹ç¦±ç¨»è„è¦©è³­è·³è¹ˆé€ƒé€”é“éƒ½éé™¶éŸœæ¯’ç€†ç‰˜çŠ¢ç¨ç£ç¦¿ç¯¤çº›è®€å¢©æƒ‡æ•¦æ—½æš¾æ²Œç„žç‡‰è±šé “ä¹­çªä»å†¬å‡å‹•åŒæ†§æ±æ¡æ£Ÿæ´žæ½¼ç–¼çž³ç«¥èƒ´è‘£éŠ…å…œæ–—æœæž“ç—˜ç«‡è³ï¥šè±†é€—é ­å±¯è‡€èŠšéé¯éˆå¾—å¶æ©™ç‡ˆç™»ç­‰è—¤è¬„é„§é¨°å–‡æ‡¶ï¥›ç™©ç¾…",
    ],
    [
      "d5a1",
      "è˜¿èžºè£¸é‚ï¥œæ´›çƒ™çžçµ¡è½ï¥é…ªé§±ï¥žäº‚åµæ¬„æ¬’ç€¾çˆ›è˜­é¸žå‰Œè¾£åµæ“¥æ”¬æ¬–æ¿«ç±ƒçºœè—è¥¤è¦½æ‹‰è‡˜è Ÿå»Šæœ—æµªç‹¼ç…ç‘¯èž‚éƒžä¾†å´å¾ èŠå†·æŽ ç•¥äº®å€†å…©å‡‰æ¢æ¨‘ç²®ç²±ç³§è‰¯è«’è¼›é‡ä¾¶å„·å‹µå‘‚å»¬æ…®æˆ¾æ—…æ«šæ¿¾ç¤ªè—œè £é–­é©¢é©ªéº—é»ŽåŠ›æ›†æ­·ç€ç¤«è½¢é‚æ†æˆ€æ”£æ¼£",
    ],
    [
      "d6a1",
      "ç…‰ç’‰ç·´è¯è“®è¼¦é€£éŠå†½åˆ—åŠ£æ´Œçƒˆè£‚å»‰æ–‚æ®®æ¿‚ç°¾çµä»¤ä¼¶å›¹ï¥Ÿå²ºå¶ºæ€œçŽ²ç¬­ç¾šç¿Žè†é€žéˆ´é›¶éˆé ˜é½¡ä¾‹æ¾§ç¦®é†´éš·å‹žï¥ æ’ˆæ“„æ«“æ½žç€˜çˆç›§è€è˜†è™œè·¯è¼…éœ²é­¯é·ºé¹µç¢Œç¥¿ç¶ è‰éŒ„é¹¿éº“è«–å£Ÿå¼„æœ§ç€§ç“ç± è¾å„¡ç€¨ç‰¢ç£Šè³‚è³šè³´é›·äº†åƒšå¯®å»–æ–™ç‡Žç™‚çž­èŠè“¼",
    ],
    [
      "d7a1",
      "é¼é¬§é¾å£˜å©å±¢æ¨“æ·šæ¼ç˜»ç´¯ç¸·è”žè¤¸é¤é™‹åŠ‰æ—’æŸ³æ¦´æµæºœç€ç‰ç‘ ç•™ç˜¤ç¡«è¬¬é¡žå…­æˆ®é™¸ä¾–å€«å´™æ·ªç¶¸è¼ªå¾‹æ…„æ —ï¥¡éš†å‹’è‚‹å‡œå‡Œæ¥žç¨œç¶¾è±é™µä¿šåˆ©åŽ˜åå”Žå±¥æ‚§æŽæ¢¨æµ¬çŠç‹¸ç†ç’ƒï¥¢ç—¢ç±¬ç½¹ç¾¸èŽ‰è£è£¡é‡Œé‡é›¢é¯‰åæ½¾ç‡ç’˜è—ºèºªéš£é±—éºŸæž—æ·‹ç³è‡¨éœ–ç ¬",
    ],
    [
      "d8a1",
      "ç«‹ç¬ ç²’æ‘©ç‘ªç—²ç¢¼ç£¨é¦¬é­”éº»å¯žå¹•æ¼ è†œèŽ«é‚ˆä¸‡åå¨©å·’å½Žæ…¢æŒ½æ™©æ›¼æ»¿æ¼«ç£çžžè¬è”“è »è¼“é¥…é°»å”œæŠ¹æœ«æ²«èŒ‰è¥ªéºäº¡å¦„å¿˜å¿™æœ›ç¶²ç½”èŠ’èŒ«èŽ½è¼žé‚™åŸ‹å¦¹åª’å¯æ˜§æžšæ¢…æ¯ç…¤ç½µè²·è³£é‚é­…è„ˆè²Šé™Œé©€éº¥å­Ÿæ°“çŒ›ç›²ç›ŸèŒå†ªè¦“å…å†•å‹‰æ£‰æ²”çœ„çœ ç¶¿ç·¬é¢éºµæ»…",
    ],
    [
      "d9a1",
      "è”‘å†¥åå‘½æ˜Žæšæ¤§æºŸçš¿çž‘èŒ—è“‚èžŸé…©éŠ˜é³´è¢‚ä¾®å†’å‹Ÿå§†å¸½æ…•æ‘¸æ‘¹æš®æŸæ¨¡æ¯æ¯›ç‰Ÿç‰¡ç‘çœ¸çŸ›è€—èŠ¼èŒ…è¬€è¬¨è²Œæœ¨æ²ç‰§ç›®ç¦ç©†é¶©æ­¿æ²’å¤¢æœ¦è’™å¯å¢“å¦™å»Ÿææ˜´æ³æ¸ºçŒ«ç«—è‹—éŒ¨å‹™å·«æ†®æ‡‹æˆŠæ‹‡æ’«æ— æ¥™æ­¦æ¯‹ç„¡ç·ç•ç¹†èˆžèŒ‚è•ªèª£è²¿éœ§éµ¡å¢¨é»˜å€‘åˆŽå»å•æ–‡",
    ],
    [
      "daa1",
      "æ±¶ç´Šç´‹èžèšŠé–€é›¯å‹¿æ²•ç‰©å‘³åªšå°¾åµ‹å½Œå¾®æœªæ¢¶æ¥£æ¸¼æ¹„çœ‰ç±³ç¾Žè–‡è¬Žè¿·é¡é»´å²·æ‚¶æ„æ†«æ•æ—»æ—¼æ°‘æ³¯çŽŸç‰ç·¡é–”å¯†èœœè¬å‰åšæ‹ææ’²æœ´æ¨¸æ³Šç€ç’žç®”ç²•ç¸›è†Šèˆ¶è–„è¿«é›¹é§ä¼´åŠåå›æ‹Œæ¬æ”€æ–‘æ§ƒæ³®æ½˜ç­ç•”ç˜¢ç›¤ç›¼ç£ç£»ç¤¬çµ†èˆ¬èŸ è¿”é ’é£¯å‹ƒæ‹”æ’¥æ¸¤æ½‘",
    ],
    [
      "dba1",
      "ç™¼è·‹é†±é‰¢é«®é­ƒå€£å‚åŠå¦¨å°¨å¹‡å½·æˆ¿æ”¾æ–¹æ—æ˜‰æž‹æ¦œæ»‚ç£…ç´¡è‚ªè†€èˆ«èŠ³è’¡èšŒè¨ªè¬—é‚¦é˜²é¾å€ä¿³ï¥£åŸ¹å¾˜æ‹œæŽ’æ¯æ¹ƒç„™ç›ƒèƒŒèƒšè£´è£µè¤™è³ è¼©é…é™ªä¼¯ä½°å¸›æŸæ ¢ç™½ç™¾é­„å¹¡æ¨Šç…©ç‡”ç•ªï¥¤ç¹è•ƒè—©é£œä¼ç­ç½°é–¥å‡¡å¸†æ¢µæ°¾æ±Žæ³›çŠ¯ç¯„èŒƒæ³•çºåƒ»åŠˆå£æ“˜æª—ç’§ç™–",
    ],
    [
      "dca1",
      "ç¢§è˜—é—¢éœ¹ï¥¥åžå¼è®Šè¾¨è¾¯é‚Šåˆ¥çž¥é±‰é¼ˆä¸™å€‚å…µå±›å¹·æ˜žæ˜ºæŸ„æ£…ç‚³ç”ç—…ç§‰ç«è¼§é¤ é¨ˆä¿å ¡å ±å¯¶æ™®æ­¥æ´‘æ¹ºæ½½ç¤ç”«è©è£œè¤“è­œè¼”ä¼åƒ•åŒåœå®“å¾©æœç¦è…¹èŒ¯è””è¤‡è¦†è¼¹è¼»é¦¥é°’æœ¬ä¹¶ä¿¸å¥‰å°å³¯å³°æ§æ£’çƒ½ç†¢ç«ç¸«è“¬èœ‚é€¢é‹’é³³ä¸ä»˜ä¿¯å‚…å‰–å‰¯å¦å’åŸ å¤«å©¦",
    ],
    [
      "dda1",
      "å­šå­µå¯Œåºœï¥¦æ‰¶æ•·æ–§æµ®æº¥çˆ¶ç¬¦ç°¿ç¼¶è…è…‘è†šè‰€èŠ™èŽ©è¨ƒè² è³¦è³»èµ´è¶ºéƒ¨é‡œé˜œé™„é§™é³§åŒ—åˆ†å©å™´å¢³å¥”å¥®å¿¿æ†¤æ‰®æ˜æ±¾ç„šç›†ç²‰ç³žç´›èŠ¬è³é›°ï¥§ä½›å¼—å½¿æ‹‚å´©æœ‹æ£šç¡¼ç¹ƒéµ¬ä¸•å‚™åŒ•åŒªå‘å¦ƒå©¢åº‡æ‚²æ†Šæ‰‰æ‰¹æ–æž‡æ¦§æ¯”æ¯–æ¯—æ¯˜æ²¸ï¥¨çµç—ºç ’ç¢‘ç§•ç§˜ç²ƒç·‹ç¿¡è‚¥",
    ],
    [
      "dea1",
      "è„¾è‡‚è²èœšè£¨èª¹è­¬è²»é„™éžé£›é¼»åš¬å¬ªå½¬æ–Œæª³æ®¯æµœæ¿±ç€•ç‰çŽ­è²§è³“é »æ†‘æ°·è˜é¨ä¹äº‹äº›ä»•ä¼ºä¼¼ä½¿ä¿Ÿåƒ¿å²å¸å”†å—£å››å£«å¥¢å¨‘å¯«å¯ºå°„å·³å¸«å¾™æ€æ¨æ–œæ–¯æŸ¶æŸ»æ¢­æ­»æ²™æ³—æ¸£ç€‰ç…ç ‚ç¤¾ç¥€ç¥ ç§ç¯©ç´—çµ²è‚†èˆèŽŽè“‘è›‡è£Ÿè©è©žè¬è³œèµ¦è¾­é‚ªé£¼é§Ÿéºå‰Šï¥©æœ”ï¥ª",
    ],
    [
      "dfa1",
      "å‚˜åˆªå±±æ•£æ±•çŠç”£ç–ç®—è’œé…¸éœ°ä¹·æ’’æ®ºç…žè–©ä¸‰ï¥«æ‰æ£®æ¸—èŠŸè”˜è¡«æ·æ¾éˆ’é¢¯ä¸Šå‚·åƒå„Ÿå•†å–ªå˜—å­€å°™å³ å¸¸åºŠåº å»‚æƒ³æ¡‘æ©¡æ¹˜çˆ½ç‰€ç‹€ç›¸ç¥¥ç®±ç¿”è£³è§´è©³è±¡è³žéœœå¡žç’½è³½å—‡ï¥¬ç©¡ç´¢è‰²ç‰²ç”Ÿç”¥ï¥­ç¬™å¢…å£»å¶¼åºåº¶å¾æ•æŠ’æ¿æ•æš‘æ›™æ›¸æ –æ£²çŠ€ç‘žç­®çµ®ç·–ç½²",
    ],
    [
      "e0a1",
      "èƒ¥èˆ’è–¯è¥¿èª“é€é‹¤é»é¼ å¤•å¥­å¸­æƒœæ˜”æ™³æžæ±æ·…æ½ŸçŸ³ç¢©è“†é‡‹éŒ«ä»™åƒŠå…ˆå–„å¬‹å®£æ‰‡æ•¾æ—‹æ¸²ç…½çç‘„ç’‡ç’¿ç™¬ç¦ªç·šç¹•ç¾¨è…ºè†³èˆ¹è˜šèŸ¬è©µè·£é¸éŠ‘é¥é¥é®®å¨å±‘æ¥”æ³„æ´©æ¸«èˆŒè–›è¤»è¨­èªªé›ªé½§å‰¡æš¹æ®²çº–èŸ¾è´é–ƒé™æ”æ¶‰ç‡®ï¥®åŸŽå§“å®¬æ€§æƒºæˆæ˜Ÿæ™ŸçŒ©ç¹ç››çœç­¬",
    ],
    [
      "e1a1",
      "è–è²è…¥èª é†’ä¸–å‹¢æ­²æ´—ç¨…ç¬¹ç´°ï¥¯è²°å¬å˜¯å¡‘å®µå°å°‘å·¢æ‰€æŽƒæ”æ˜­æ¢³æ²¼æ¶ˆæº¯ç€Ÿç‚¤ç‡’ç”¦ç–ç–Žç˜™ç¬‘ç¯ ç°«ç´ ç´¹è”¬è•­è˜‡è¨´é€é¡é‚µéŠ·éŸ¶é¨·ä¿—å±¬æŸæ¶‘ç²ŸçºŒè¬–è´–é€Ÿå­«å·½æè“€éœé£¡çŽ‡å®‹æ‚šæ¾æ·žè¨Ÿèª¦é€é Œåˆ·ï¥°ç‘ç¢ŽéŽ–è¡°é‡—ä¿®å—å—½å›šåž‚å£½å«‚å®ˆå²«å³€å¸¥æ„",
    ],
    [
      "e2a1",
      "æˆæ‰‹æŽˆæœæ”¶æ•¸æ¨¹æ®Šæ°´æ´™æ¼±ç‡§ç‹©ç¸ç‡ç’²ç˜¦ç¡ç§€ç©—ç«ªç²¹ç¶ç¶¬ç¹¡ç¾žè„©èŒ±è’è“šè—ªè¢–èª°è®è¼¸é‚é‚ƒé…¬éŠ–éŠ¹éš‹éš§éš¨é›–éœ€é ˆé¦–é«“é¬šå”å¡¾å¤™å­°å®¿æ·‘æ½šç†Ÿç¡ç’¹è‚…è½å·¡å¾‡å¾ªæ‚æ—¬æ ’æ¥¯æ©“æ®‰æ´µæ·³ç£ç›¾çž¬ç­ç´”è„£èˆœè€è“´è•£è©¢è«„é†‡éŒžé †é¦´æˆŒè¡“è¿°é‰¥å´‡å´§",
    ],
    [
      "e3a1",
      "åµ©ç‘Ÿè†è¨æ¿•æ‹¾ç¿’è¤¶è¥²ä¸žä¹˜åƒ§å‹å‡æ‰¿æ˜‡ç¹©è …é™žä¾åŒ™å˜¶å§‹åª¤å°¸å±Žå±å¸‚å¼‘æƒæ–½æ˜¯æ™‚æž¾æŸ´çŒœçŸ¢ç¤ºç¿…è’”è“è¦–è©¦è©©è«¡è±•è±ºåŸ´å¯”å¼æ¯æ‹­æ¤æ®–æ¹œç†„ç¯’è•è­˜è»¾é£Ÿé£¾ä¼¸ä¾ä¿¡å‘»å¨ å®¸æ„¼æ–°æ™¨ç‡¼ç”³ç¥žç´³è…Žè‡£èŽ˜è–ªè—Žèœƒè¨Šèº«è¾›ï¥±è¿…å¤±å®¤å¯¦æ‚‰å¯©å°‹å¿ƒæ²",
    ],
    [
      "e4a1",
      "ï¥²æ·±ç€‹ç”šèŠ¯è«¶ä»€åï¥³é›™æ°äºžä¿„å…’å•žå¨¥å³¨æˆ‘ç‰™èŠ½èŽªè›¾è¡™è¨é˜¿é›…é¤“é´‰éµå Šå²³å¶½å¹„æƒ¡æ„•æ¡æ¨‚æ¸¥é„‚é”é¡Žé°é½·å®‰å²¸æŒ‰æ™æ¡ˆçœ¼é›éžé¡”é®Ÿæ–¡è¬è»‹é–¼å”µå²©å·–åºµæš—ç™Œè´é—‡å£“æŠ¼ç‹Žé´¨ä»°å¤®æ€æ˜»æ®ƒç§§é´¦åŽ“å“€åŸƒå´–æ„›æ›–æ¶¯ç¢è‰¾éš˜é„åŽ„æ‰¼æŽ–æ¶²ç¸Šè…‹é¡",
    ],
    [
      "e5a1",
      "æ«»ç½Œé¶¯é¸šä¹Ÿå€»å†¶å¤œæƒ¹æ¶æ¤°çˆºè€¶ï¥´é‡Žå¼±ï¥µï¥¶ç´„è‹¥è‘¯è’»è—¥èºï¥·ä½¯ï¥¸ï¥¹å£¤å­ƒæ™æšæ”˜æ•­æš˜ï¥ºæ¥Šæ¨£æ´‹ç€ç…¬ç—’ç˜ç¦³ç©°ï¥»ç¾Šï¥¼è¥„ï¥½è®“é‡€é™½ï¥¾é¤Šåœ„å¾¡æ–¼æ¼ç˜€ç¦¦èªžé¦­é­šé½¬å„„æ†¶æŠ‘æªè‡†åƒå °å½¦ç„‰è¨€è«ºå­¼è˜–ä¿ºå„¼åš´å¥„æŽ©æ·¹å¶ªæ¥­å††äºˆä½™ï¥¿ï¦€ï¦å¦‚ï¦‚",
    ],
    [
      "e6a1",
      "ï¦ƒæ­Ÿæ±ï¦„ç’µç¤–ï¦…èˆ‡è‰…èŒ¹è¼¿è½ï¦†é¤˜ï¦‡ï¦ˆï¦‰äº¦ï¦ŠåŸŸå½¹æ˜“ï¦‹ï¦Œç–«ç¹¹è­¯ï¦é€†é©›åš¥å §å§¸å¨Ÿå®´ï¦Žå»¶ï¦ï¦ææŒ»ï¦‘æ¤½æ²‡æ²¿æ¶Žæ¶“æ·µæ¼”ï¦’çƒŸç„¶ç…™ï¦“ç‡ƒç‡•ï¦”ç¡ç¡¯ï¦•ç­µç·£ï¦–ç¸¯ï¦—è¡è»Ÿï¦˜ï¦™ï¦šé‰›ï¦›é³¶ï¦œï¦ï¦žæ‚…æ¶…ï¦Ÿç†±ï¦ ï¦¡é–±åŽ­ï¦¢ï¦£ï¦¤æŸ“ï¦¥ç‚Žç„°ç°è‰¶è‹’",
    ],
    [
      "e7a1",
      "ï¦¦é–»é«¥é¹½æ›„ï¦§ç‡è‘‰ï¦¨ï¦©å¡‹ï¦ªï¦«å¶¸å½±ï¦¬æ˜ æšŽæ¥¹æ¦®æ°¸æ³³æ¸¶æ½æ¿šç€›ç€¯ç…ç‡Ÿç°ï¦­ç‘›ï¦®ç“”ç›ˆç©Žçº“ï¦¯ï¦°è‹±è© è¿Žï¦±éˆï¦²éœ™ï¦³ï¦´ä¹‚å€ªï¦µåˆˆå¡æ›³æ±­æ¿ŠçŒŠç¿ç©¢èŠ®è—è˜‚ï¦¶è£”è©£è­½è±«ï¦·éŠ³ï¦¸éœ“é äº”ä¼ä¿‰å‚²åˆå¾å³å—šå¡¢å¢ºå¥§å¨›å¯¤æ‚Ÿï¦¹æ‡Šæ•–æ—¿æ™¤æ¢§æ±šæ¾³",
    ],
    [
      "e8a1",
      "çƒç†¬ç’ç­½èœˆèª¤é°²é¼‡å±‹æ²ƒç„çŽ‰éˆºæº«ç‘¥ç˜Ÿç©©ç¸•è˜Šå…€å£…æ“ç“®ç”•ç™°ç¿é‚•é›é¥”æ¸¦ç“¦çª©çªªè‡¥è›™è¸è¨›å©‰å®Œå®›æ¢¡æ¤€æµ£çŽ©ç“ç¬ç¢—ç·©ç¿«è„˜è…•èŽžè±Œé˜®é ‘æ›°å¾€æ—ºæž‰æ±ªçŽ‹å€­å¨ƒæ­ªçŸ®å¤–åµ¬å·çŒ¥ç•ï¦ºï¦»åƒ¥å‡¹å ¯å¤­å¦–å§šå¯¥ï¦¼ï¦½å¶¢æ‹—æ–æ’“æ“¾ï¦¾æ›œï¦¿æ©ˆï§€ç‡¿ç‘¤ï§",
    ],
    [
      "e9a1",
      "çªˆçª¯ç¹‡ç¹žè€€è…°ï§‚èŸ¯è¦è¬ é™ï§ƒé‚€é¥’æ…¾æ¬²æµ´ç¸Ÿè¤¥è¾±ä¿‘å‚­å†—å‹‡åŸ‡å¢‰å®¹åº¸æ…‚æ¦•æ¶Œæ¹§æº¶ç†”ç‘¢ç”¨ç”¬è³èŒ¸è“‰è¸ŠéŽ”éžï§„äºŽä½‘å¶å„ªåˆå‹å³å®‡å¯“å°¤æ„šæ†‚æ—´ç‰›çŽ—ç‘€ç›‚ç¥ç¦‘ç¦¹ç´†ç¾½èŠ‹è—•è™žè¿‚é‡éƒµé‡ªéš…é›¨é›©å‹–å½§æ—­æ˜±æ ¯ç…œç¨¶éƒé Šäº‘ï§…æ©’æ®žæ¾ç†‰è€˜èŠ¸è•“",
    ],
    [
      "eaa1",
      "é‹éš•é›²éŸ»è”šé¬±äºç†Šé›„å…ƒåŽŸå“¡åœ“åœ’åž£åª›å«„å¯ƒæ€¨æ„¿æ´æ²…æ´¹æ¹²æºçˆ°çŒ¿ç‘—è‹‘è¢è½…é ï§†é™¢é¡˜é´›æœˆè¶Šé‰žä½å‰åƒžå±åœå§”å¨å°‰æ…°æšæ¸­çˆ²ç‘‹ç·¯èƒƒèŽè‘¦è”¿èŸè¡›è¤˜è¬‚é•éŸ‹é­ä¹³ä¾‘å„’å…ªï§‡å”¯å–©å­ºå®¥å¹¼å¹½åº¾æ‚ æƒŸæ„ˆæ„‰æ„æ”¸æœ‰ï§ˆæŸ”æŸšï§‰æ¥¡æ¥¢æ²¹æ´§ï§Šæ¸¸ï§‹",
    ],
    [
      "eba1",
      "æ¿¡çŒ¶çŒ·ï§Œç‘œç”±ï§ç™’ï§Žï§ç¶­è‡¾è¸è£•èª˜è«›è«­è¸°è¹‚éŠé€¾éºé…‰é‡‰é®ï§ï§‘å ‰ï§’æ¯“è‚‰è‚²ï§“ï§”å…å¥«å°¹ï§•ï§–æ½¤çŽ§èƒ¤è´‡ï§—éˆ—é–ï§˜ï§™ï§šï§›è¿æˆŽç€œçµ¨èžï§œåž æ©æ…‡æ®·èª¾éŠ€éš±ä¹™åŸæ·«è”­é™°éŸ³é£®æ–æ³£é‚‘å‡æ‡‰è†ºé·¹ä¾å€šå„€å®œæ„æ‡¿æ“¬æ¤…æ¯…ç–‘çŸ£ç¾©è‰¤è–èŸ»è¡£èª¼",
    ],
    [
      "eca1",
      "è­°é†«äºŒä»¥ä¼Šï§ï§žå¤·å§¨ï§Ÿå·²å¼›å½›æ€¡ï§ ï§¡ï§¢ï§£çˆ¾ç¥ï§¤ç•°ç—ï§¥ç§»ï§¦è€Œè€³è‚„è‹¡è‘ï§§ï§¨è²½è²³é‚‡ï§©ï§ªé£´é¤Œï§«ï§¬ç€·ç›Šç¿Šç¿Œç¿¼è¬šäººä»åˆƒå°ï§­å’½å› å§»å¯…å¼•å¿æ¹®ï§®ï§¯çµªèŒµï§°èš“èªï§±é­é·ï§²ï§³ä¸€ä½šä½¾å£¹æ—¥æº¢é€¸éŽ°é¦¹ä»»å£¬å¦Šå§™æï§´ï§µç¨”ï§¶èè³ƒå…¥å„",
    ],
    [
      "eda1",
      "ï§·ï§¸ï§¹ä»å‰©å­•èŠ¿ä»”åˆºå’¨å§‰å§¿å­å­—å­œæ£æ…ˆæ»‹ç‚™ç…®çŽ†ç“·ç–µç£ç´«è€…è‡ªèŒ¨è”—è—‰è«®è³‡é›Œä½œå‹ºåš¼æ–«æ˜¨ç¼ç‚¸çˆµç¶½èŠé…Œé›€éµ²å­±æ£§æ®˜æ½ºç›žå²‘æš«æ½›ç®´ç°ªè ¶é›œä¸ˆä»—åŒ å ´å¢»å£¯å¥¬å°‡å¸³åº„å¼µæŽŒæš²æ–æ¨Ÿæª£æ¬Œæ¼¿ç‰†ï§ºçç’‹ç« ç²§è…¸è‡Ÿè‡§èŽŠè‘¬è”£è–”è—è£è´“é†¬é•·",
    ],
    [
      "eea1",
      "éšœå†å“‰åœ¨å®°æ‰ææ ½æ¢“æ¸½æ»“ç½ç¸¡è£è²¡è¼‰é½‹é½Žçˆ­ç®è«éŒšä½‡ä½Žå„²å’€å§åº•æŠµæµæ¥®æ¨—æ²®æ¸šç‹™çŒªç–½ç®¸ç´µè‹§è¹è‘—è—·è©›è²¯èº‡é€™é‚¸é›Žé½Ÿå‹£åŠå«¡å¯‚æ‘˜æ•µæ»´ç‹„ï§»çš„ç©ç¬›ç±ç¸¾ç¿Ÿè»è¬«è³Šèµ¤è·¡è¹Ÿè¿ªè¿¹é©é‘ä½ƒä½ºå‚³å…¨å…¸å‰å‰ªå¡¡å¡¼å¥ å°ˆå±•å»›æ‚›æˆ°æ “æ®¿æ°ˆæ¾±",
    ],
    [
      "efa1",
      "ç…Žç ç”°ç”¸ç•‘ç™²ç­Œç®‹ç®­ç¯†çºè©®è¼¾è½‰éˆ¿éŠ“éŒ¢é«é›»é¡šé¡«é¤žåˆ‡æˆªæŠ˜æµ™ç™¤ç«Šç¯€çµ¶å å²¾åº—æ¼¸ç‚¹ç²˜éœ‘é®Žé»žæŽ¥æ‘ºè¶ä¸äº•äº­åœåµå‘ˆå§ƒå®šå¹€åº­å»·å¾æƒ…æŒºæ”¿æ•´æ—Œæ™¶æ™¸æŸ¾æ¥¨æª‰æ­£æ±€æ·€æ·¨æ¸Ÿæ¹žç€žç‚¡çŽŽç½ç”ºç›ç¢‡ç¦Žç¨‹ç©½ç²¾ç¶Žè‰‡è¨‚è«ªè²žé„­é…Šé‡˜é‰¦é‹ŒéŒ éœ†é–",
    ],
    [
      "f0a1",
      "éœé ‚é¼Žåˆ¶åŠ‘å•¼å ¤å¸å¼Ÿæ‚Œææ¢¯æ¿Ÿç¥­ç¬¬è‡è–ºè£½è«¸è¹„é†é™¤éš›éœ½é¡Œé½Šä¿Žå…†å‡‹åŠ©å˜²å¼”å½«æŽªæ“æ—©æ™æ›ºæ›¹æœæ¢æ£—æ§½æ¼•æ½®ç…§ç‡¥çˆªç’ªçœºç¥–ç¥šç§Ÿç¨ çª•ç²—ç³Ÿçµ„ç¹°è‚‡è—»èš¤è©”èª¿è¶™èºé€ é­é‡£é˜»é›•é³¥æ—ç°‡è¶³éƒå­˜å°Šå’æ‹™çŒå€§å®—å¾žæ‚°æ…«æ£•æ·™ç®ç¨®çµ‚ç¶œç¸±è…«",
    ],
    [
      "f1a1",
      "è¸ªè¸µé¾é˜ä½åå·¦åº§æŒ«ç½ªä¸»ä½ä¾åšå§èƒ„å‘ªå‘¨å—¾å¥å®™å·žå»šæ™æœ±æŸ±æ ªæ³¨æ´²æ¹Šæ¾ç‚·ç ç–‡ç±Œç´‚ç´¬ç¶¢èˆŸè››è¨»èª…èµ°èºŠè¼³é€±é…Žé…’é‘„é§ç«¹ç²¥ä¿Šå„å‡†åŸˆå¯¯å³»æ™™æ¨½æµšæº–æ¿¬ç„Œç•¯ç«£è ¢é€¡éµé›‹é§¿èŒä¸­ä»²è¡†é‡å½æ«›æ¥«æ±è‘ºå¢žæ†Žæ›¾æ‹¯çƒç”‘ç—‡ç¹’è’¸è­‰è´ˆä¹‹åª",
    ],
    [
      "f2a1",
      "å’«åœ°å€å¿—æŒæŒ‡æ‘¯æ”¯æ—¨æ™ºæžæž³æ­¢æ± æ²šæ¼¬çŸ¥ç ¥ç¥‰ç¥—ç´™è‚¢è„‚è‡³èŠèŠ·èœ˜èªŒï§¼è´„è¶¾é²ç›´ç¨™ç¨·ç¹”è·å”‡å—”å¡µæŒ¯æ¢æ™‰æ™‹æ¡­æ¦›æ®„æ´¥æº±çç‘¨ç’¡ç•›ç–¹ç›¡çœžçž‹ç§¦ç¸‰ç¸è‡»è”¯è¢—è¨ºè³‘è»«è¾°é€²éŽ­é™£é™³éœ‡ä¾„å±å§ªå«‰å¸™æ¡Žç“†ç–¾ç§©çª’è†£è›­è³ªè·Œè¿­æ–Ÿæœ•ï§½åŸ·æ½—ç·è¼¯",
    ],
    [
      "f3a1",
      "é¶é›†å¾µæ‡²æ¾„ä¸”ä¾˜å€Ÿå‰å—Ÿåµ¯å·®æ¬¡æ­¤ç£‹ç®šï§¾è¹‰è»Šé®æ‰æ¾ç€çª„éŒ¯é‘¿é½ªæ’°æ¾¯ç‡¦ç’¨ç“šç«„ç°’çº‚ç²²çº˜è®šè´Šé‘½é¤é¥Œåˆ¹å¯Ÿæ“¦æœ­ç´®åƒ­åƒå¡¹æ…˜æ…™æ‡ºæ–¬ç«™è®’è®–å€‰å€¡å‰µå”±å¨¼å» å½°æ„´æ•žæ˜Œæ˜¶æš¢æ§æ»„æ¼²çŒ–ç˜¡çª“è„¹è‰™è–è’¼å‚µåŸ°å¯€å¯¨å½©æŽ¡ç ¦ç¶µèœè”¡é‡‡é‡µå†ŠæŸµç­–",
    ],
    [
      "f4a1",
      "è²¬å‡„å¦»æ‚½è™•å€œï§¿å‰”å°ºæ…½æˆšæ‹“æ“²æ–¥æ»Œç˜ è„Šè¹ é™Ÿéš»ä»Ÿåƒå–˜å¤©å·æ“…æ³‰æ·ºçŽ”ç©¿èˆ›è–¦è³¤è¸é·é‡§é—¡é˜¡éŸ†å‡¸å“²å–†å¾¹æ’¤æ¾ˆç¶´è¼Ÿè½éµåƒ‰å°–æ²¾æ·»ç”›çž»ç°½ç±¤è©¹è«‚å žå¦¾å¸–æ·ç‰’ç–Šç«è«œè²¼è¼’å»³æ™´æ·¸è½èè«‹é‘é¯–ï¨€å‰ƒæ›¿æ¶•æ»¯ç· è«¦é€®éžé«”åˆå‰¿å“¨æ†”æŠ„æ‹›æ¢¢",
    ],
    [
      "f5a1",
      "æ¤’æ¥šæ¨µç‚’ç„¦ç¡ç¤ç¤Žç§’ç¨è‚–è‰¸è‹•è‰è•‰è²‚è¶…é…¢é†‹é†®ä¿ƒå›‘ç‡­çŸ—èœ€è§¸å¯¸å¿–æ‘é‚¨å¢å¡šå¯µæ‚¤æ†æ‘ ç¸½è°è”¥éŠƒæ’®å‚¬å´”æœ€å¢œæŠ½æŽ¨æ¤Žæ¥¸æ¨žæ¹«çšºç§‹èŠ»è©è«è¶¨è¿½é„’é…‹é†œéŒéŒ˜éŽšé››é¨¶é°ä¸‘ç•œç¥ç«ºç­‘ç¯‰ç¸®è“„è¹™è¹´è»¸é€æ˜¥æ¤¿ç‘ƒå‡ºæœ®é»œå……å¿ æ²–èŸ²è¡è¡·æ‚´è†µèƒ",
    ],
    [
      "f6a1",
      "è´…å–å¹å˜´å¨¶å°±ç‚Šç¿ èšè„†è‡­è¶£é†‰é©Ÿé·²å´ä»„åŽ æƒ»æ¸¬å±¤ä¾ˆå€¤å—¤å³™å¹Ÿæ¥æ¢”æ²»æ·„ç†¾ç—”ç—´ç™¡ç¨šç©‰ç·‡ç·»ç½®è‡´èš©è¼œé›‰é¦³é½’å‰‡å‹…é£­è¦ªä¸ƒæŸ’æ¼†ä¾µå¯¢æž•æ²ˆæµ¸ç›ç §é‡é¼èŸ„ç§¤ç¨±å¿«ä»–å’¤å”¾å¢®å¦¥æƒ°æ‰“æ‹–æœ¶æ¥•èˆµé™€é¦±é§å€¬å“å•„å¼ï¨æ‰˜ï¨‚æ“¢æ™«æŸæ¿æ¿¯ç¢ç¸è¨—",
    ],
    [
      "f7a1",
      "é¸å‘‘å˜†å¦å½ˆæ†šæ­Žç˜ç‚­ç¶»èª•å¥ªè„«æŽ¢çœˆè€½è²ªå¡”æ­æ¦»å®•å¸‘æ¹¯ï¨ƒè•©å…Œå°å¤ªæ€ æ…‹æ®†æ±°æ³°ç¬žèƒŽè‹”è·†é‚°é¢±ï¨„æ“‡æ¾¤æ’‘æ”„å…ŽååœŸè¨Žæ…Ÿæ¡¶ï¨…ç—›ç­’çµ±é€šå †æ§Œè…¿è¤ªé€€é ¹å¸å¥—å¦¬æŠ•é€é¬ªæ…ç‰¹é—–å¡å©†å·´æŠŠæ’­æ“ºæ·æ³¢æ´¾çˆ¬ç¶ç ´ç½·èŠ­è·›é —åˆ¤å‚æ¿ç‰ˆç“£è²©è¾¦éˆ‘",
    ],
    [
      "f8a1",
      "é˜ªå…«å­æŒä½©å”„æ‚–æ•—æ²›æµ¿ç‰Œç‹½ç¨—è¦‡è²å½­æ¾Žçƒ¹è†¨æ„Žä¾¿åæ‰ç‰‡ç¯‡ç·¨ç¿©ééž­é¨™è²¶åªå¹³æž°èè©•å å¬–å¹£å»¢å¼Šæ–ƒè‚ºè”½é–‰é™›ä½ˆåŒ…åŒåŒå’†å“ºåœƒå¸ƒæ€–æŠ›æŠ±æ•ï¨†æ³¡æµ¦ç–±ç ²èƒžè„¯è‹žè‘¡è’²è¢è¤’é€‹é‹ªé£½é®‘å¹…æš´æ›ç€‘çˆ†ï¨‡ä¿µå‰½å½ªæ…“æ“æ¨™æ¼‚ç“¢ç¥¨è¡¨è±¹é£‡é£„é©ƒ",
    ],
    [
      "f9a1",
      "å“ç¨Ÿæ¥“è«·è±Šé¢¨é¦®å½¼æŠ«ç–²çš®è¢«é¿é™‚åŒ¹å¼¼å¿…æ³ŒçŒç•¢ç–‹ç­†è‹¾é¦ä¹é€¼ä¸‹ä½•åŽ¦å¤å»ˆæ˜°æ²³ç‘•è·è¦è³€ééœžé°•å£‘å­¸è™è¬”é¶´å¯’æ¨æ‚æ—±æ±—æ¼¢æ¾£ç€šç½•ç¿°é–‘é–’é™éŸ“å‰²è½„å‡½å«å’¸å•£å–Šæª»æ¶µç·˜è‰¦éŠœé™·é¹¹åˆå“ˆç›’è›¤é–¤é—”é™œäº¢ä¼‰å§®å«¦å··æ’æŠ—æ­æ¡æ²†æ¸¯ç¼¸è‚›èˆª",
    ],
    [
      "faa1",
      "ï¨ˆï¨‰é …äº¥å•å’³åž“å¥šå­©å®³æ‡ˆæ¥·æµ·ç€£èŸ¹è§£è©²è«§é‚‚é§­éª¸åŠ¾æ ¸å€–å¹¸æè‡è¡Œäº«å‘åš®ç¦é„•éŸ¿é¤‰é¥—é¦™å™“å¢Ÿè™›è¨±æ†²æ«¶ç»è»’æ­‡éšªé©—å¥•çˆ€èµ«é©ä¿”å³´å¼¦æ‡¸æ™›æ³«ç‚«çŽ„çŽ¹ç¾çœ©ççµƒçµ¢ç¸£èˆ·è¡’ï¨Šè³¢é‰‰é¡¯å­‘ç©´è¡€é å«Œä¿ å”å¤¾å³½æŒ¾æµ¹ç‹¹è„…è„‡èŽ¢é‹é °äº¨å…„åˆ‘åž‹",
    ],
    [
      "fba1",
      "å½¢æ³‚æ»Žç€…çç‚¯ç†’ç©ç‘©èŠèž¢è¡¡é€ˆé‚¢éŽ£é¦¨å…®å½—æƒ æ…§æš³è•™è¹Šé†¯éž‹ä¹Žäº’å‘¼å£•å£ºå¥½å²µå¼§æˆ¶æ‰ˆæ˜Šæ™§æ¯«æµ©æ·æ¹–æ»¸æ¾”æ¿ æ¿©çç‹ç¥ç‘šç“ çš“ç¥œç³Šç¸žèƒ¡èŠ¦è‘«è’¿è™Žè™Ÿè´è­·è±ªéŽ¬é €é¡¥æƒ‘æˆ–é…·å©šæ˜æ··æ¸¾ç¿é­‚å¿½æƒšç¬å“„å¼˜æ±žæ³“æ´ªçƒ˜ç´…è™¹è¨Œé´»åŒ–å’Œå¬…æ¨ºç«ç•µ",
    ],
    [
      "fca1",
      "ç¦ç¦¾èŠ±è¯è©±è­è²¨é´ï¨‹æ“´æ”«ç¢ºç¢»ç©«ä¸¸å–šå¥å®¦å¹»æ‚£æ›æ­¡æ™¥æ¡“æ¸™ç…¥ç’°ç´ˆé‚„é©©é°¥æ´»æ»‘çŒ¾è±é—Šå‡°å¹Œå¾¨ææƒ¶æ„°æ…Œæ™ƒæ™„æ¦¥æ³æ¹Ÿæ»‰æ½¢ç…Œç’œçš‡ç¯ç°§è’è—é‘éšé»ƒåŒ¯å›žå»»å¾Šæ¢æ‚”æ‡·æ™¦æœƒæªœæ·®æ¾®ç°çªç¹ªè†¾èŒ´è›”èª¨è³„åŠƒç²å®–æ©«é„å“®åš†å­æ•ˆæ–…æ›‰æ¢Ÿæ¶æ·†",
    ],
    [
      "fda1",
      "çˆ»è‚´é…µé©ä¾¯å€™åŽšåŽå¼å–‰å—…å¸¿å¾Œæœ½ç…¦çé€…å‹›å‹³å¡¤å£Žç„„ç†ç‡»è–°è¨“æšˆè–¨å–§æš„ç…Šè±å‰å–™æ¯å½™å¾½æ®æš‰ç…‡è«±è¼éº¾ä¼‘æºçƒ‹ç•¦è™§æ¤è­Žé·¸å…‡å‡¶åŒˆæ´¶èƒ¸é»‘æ˜•æ¬£ç‚˜ç—•åƒå±¹ç´‡è¨–æ¬ æ¬½æ­†å¸æ°æ´½ç¿•èˆˆåƒ–å‡žå–œå™«å›å§¬å¬‰å¸Œæ†™æ†˜æˆ±æ™žæ›¦ç†™ç†¹ç†ºçŠ§ç¦§ç¨€ç¾²è©°",
    ],
  ],
  M1 = [
    ["0", "\0", 127],
    [
      "a140",
      "ã€€ï¼Œã€ã€‚ï¼Žâ€§ï¼›ï¼šï¼Ÿï¼ï¸°â€¦â€¥ï¹ï¹‘ï¹’Â·ï¹”ï¹•ï¹–ï¹—ï½œâ€“ï¸±â€”ï¸³â•´ï¸´ï¹ï¼ˆï¼‰ï¸µï¸¶ï½›ï½ï¸·ï¸¸ã€”ã€•ï¸¹ï¸ºã€ã€‘ï¸»ï¸¼ã€Šã€‹ï¸½ï¸¾ã€ˆã€‰ï¸¿ï¹€ã€Œã€ï¹ï¹‚ã€Žã€ï¹ƒï¹„ï¹™ï¹š",
    ],
    [
      "a1a1",
      "ï¹›ï¹œï¹ï¹žâ€˜â€™â€œâ€ã€ã€žâ€µâ€²ï¼ƒï¼†ï¼Šâ€»Â§ã€ƒâ—‹â—â–³â–²â—Žâ˜†â˜…â—‡â—†â–¡â– â–½â–¼ãŠ£â„…Â¯ï¿£ï¼¿Ëï¹‰ï¹Šï¹ï¹Žï¹‹ï¹Œï¹Ÿï¹ ï¹¡ï¼‹ï¼Ã—Ã·Â±âˆšï¼œï¼žï¼â‰¦â‰§â‰ âˆžâ‰’â‰¡ï¹¢",
      4,
      "ï½žâˆ©âˆªâŠ¥âˆ âˆŸâŠ¿ã’ã‘âˆ«âˆ®âˆµâˆ´â™€â™‚âŠ•âŠ™â†‘â†“â†â†’â†–â†—â†™â†˜âˆ¥âˆ£ï¼",
    ],
    [
      "a240",
      "ï¼¼âˆ•ï¹¨ï¼„ï¿¥ã€’ï¿ ï¿¡ï¼…ï¼ â„ƒâ„‰ï¹©ï¹ªï¹«ã•ãŽœãŽãŽžãŽãŽ¡ãŽŽãŽã„Â°å…™å…›å…žå…å…¡å…£å—§ç“©ç³Žâ–",
      7,
      "â–â–Žâ–â–Œâ–‹â–Šâ–‰â”¼â”´â”¬â”¤â”œâ–”â”€â”‚â–•â”Œâ”â””â”˜â•­",
    ],
    ["a2a1", "â•®â•°â•¯â•â•žâ•ªâ•¡â—¢â—£â—¥â—¤â•±â•²â•³ï¼", 9, "â… ", 9, "ã€¡", 8, "åå„å…ï¼¡", 25, "ï½", 21],
    ["a340", "ï½—ï½˜ï½™ï½šÎ‘", 16, "Î£", 6, "Î±", 16, "Ïƒ", 6, "ã„…", 10],
    ["a3a1", "ã„", 25, "Ë™Ë‰ËŠË‡Ë‹"],
    ["a3e1", "â‚¬"],
    [
      "a440",
      "ä¸€ä¹™ä¸ä¸ƒä¹ƒä¹äº†äºŒäººå„¿å…¥å…«å‡ åˆ€åˆåŠ›åŒ•ååœåˆä¸‰ä¸‹ä¸ˆä¸Šä¸«ä¸¸å‡¡ä¹…ä¹ˆä¹Ÿä¹žäºŽäº¡å…€åˆƒå‹ºåƒå‰å£åœŸå£«å¤•å¤§å¥³å­å­‘å­“å¯¸å°å°¢å°¸å±±å·å·¥å·±å·²å·³å·¾å¹²å»¾å¼‹å¼“æ‰",
    ],
    [
      "a4a1",
      "ä¸‘ä¸ä¸ä¸­ä¸°ä¸¹ä¹‹å°¹äºˆäº‘äº•äº’äº”äº¢ä»ä»€ä»ƒä»†ä»‡ä»ä»Šä»‹ä»„å…ƒå…å…§å…­å…®å…¬å†—å‡¶åˆ†åˆ‡åˆˆå‹»å‹¾å‹¿åŒ–åŒ¹åˆå‡å…åžåŽ„å‹åŠåå£¬å¤©å¤«å¤ªå¤­å­”å°‘å°¤å°ºå±¯å·´å¹»å»¿å¼”å¼•å¿ƒæˆˆæˆ¶æ‰‹æ‰Žæ”¯æ–‡æ–—æ–¤æ–¹æ—¥æ›°æœˆæœ¨æ¬ æ­¢æ­¹æ¯‹æ¯”æ¯›æ°æ°´ç«çˆªçˆ¶çˆ»ç‰‡ç‰™ç‰›çŠ¬çŽ‹ä¸™",
    ],
    [
      "a540",
      "ä¸–ä¸•ä¸”ä¸˜ä¸»ä¹ä¹ä¹Žä»¥ä»˜ä»”ä»•ä»–ä»—ä»£ä»¤ä»™ä»žå……å…„å†‰å†Šå†¬å‡¹å‡ºå‡¸åˆŠåŠ åŠŸåŒ…åŒ†åŒ—åŒä»ŸåŠå‰å¡å å¯å®åŽ»å¯å¤å³å¬å®å©å¨å¼å¸åµå«å¦åªå²å±å°å¥å­å»å››å›šå¤–",
    ],
    [
      "a5a1",
      "å¤®å¤±å¥´å¥¶å­•å®ƒå°¼å·¨å·§å·¦å¸‚å¸ƒå¹³å¹¼å¼å¼˜å¼—å¿…æˆŠæ‰“æ‰”æ‰’æ‰‘æ–¥æ—¦æœ®æœ¬æœªæœ«æœ­æ­£æ¯æ°‘æ°æ°¸æ±æ±€æ°¾çŠ¯çŽ„çŽ‰ç“œç“¦ç”˜ç”Ÿç”¨ç”©ç”°ç”±ç”²ç”³ç–‹ç™½çš®çš¿ç›®çŸ›çŸ¢çŸ³ç¤ºç¦¾ç©´ç«‹ä¸žä¸Ÿä¹’ä¹“ä¹©äº™äº¤äº¦äº¥ä»¿ä¼‰ä¼™ä¼Šä¼•ä¼ä¼ä¼‘ä¼ä»²ä»¶ä»»ä»°ä»³ä»½ä¼ä¼‹å…‰å…‡å…†å…ˆå…¨",
    ],
    [
      "a640",
      "å…±å†å†°åˆ—åˆ‘åˆ’åˆŽåˆ–åŠ£åŒˆåŒ¡åŒ å°å±å‰ååŒåŠååå‹å„å‘ååˆåƒåŽå†å’å› å›žå›åœ³åœ°åœ¨åœ­åœ¬åœ¯åœ©å¤™å¤šå¤·å¤¸å¦„å¥¸å¦ƒå¥½å¥¹å¦‚å¦å­—å­˜å®‡å®ˆå®…å®‰å¯ºå°–å±¹å·žå¸†å¹¶å¹´",
    ],
    [
      "a6a1",
      "å¼å¼›å¿™å¿–æˆŽæˆŒæˆæˆæ‰£æ‰›æ‰˜æ”¶æ—©æ—¨æ—¬æ—­æ›²æ›³æœ‰æœ½æœ´æœ±æœµæ¬¡æ­¤æ­»æ°–æ±æ±—æ±™æ±Ÿæ± æ±æ±•æ±¡æ±›æ±æ±Žç°ç‰Ÿç‰ç™¾ç«¹ç±³ç³¸ç¼¶ç¾Šç¾½è€è€ƒè€Œè€’è€³è¿è‚‰è‚‹è‚Œè‡£è‡ªè‡³è‡¼èˆŒèˆ›èˆŸè‰®è‰²è‰¾è™«è¡€è¡Œè¡£è¥¿é˜¡ä¸²äº¨ä½ä½ä½‡ä½—ä½žä¼´ä½›ä½•ä¼°ä½ä½‘ä¼½ä¼ºä¼¸ä½ƒä½”ä¼¼ä½†ä½£",
    ],
    [
      "a740",
      "ä½œä½ ä¼¯ä½Žä¼¶ä½™ä½ä½ˆä½šå…Œå…‹å…å…µå†¶å†·åˆ¥åˆ¤åˆ©åˆªåˆ¨åŠ«åŠ©åŠªåŠ¬åŒ£å³åµåå­åžå¾å¦å‘Žå§å‘†å‘ƒå³å‘ˆå‘‚å›å©å‘Šå¹å»å¸å®åµå¶å å¼å‘€å±å«åŸå¬å›ªå›°å›¤å›«åŠå‘å€å",
    ],
    [
      "a7a1",
      "å‡åŽåœ¾åååœ»å£¯å¤¾å¦å¦’å¦¨å¦žå¦£å¦™å¦–å¦å¦¤å¦“å¦Šå¦¥å­å­œå­šå­›å®Œå®‹å®å°¬å±€å±å°¿å°¾å²å²‘å²”å²Œå·«å¸Œåºåº‡åºŠå»·å¼„å¼Ÿå½¤å½¢å½·å½¹å¿˜å¿Œå¿—å¿å¿±å¿«å¿¸å¿ªæˆ’æˆ‘æŠ„æŠ—æŠ–æŠ€æ‰¶æŠ‰æ‰­æŠŠæ‰¼æ‰¾æ‰¹æ‰³æŠ’æ‰¯æŠ˜æ‰®æŠ•æŠ“æŠ‘æŠ†æ”¹æ”»æ”¸æ—±æ›´æŸæŽæææ‘æœæ–æžæ‰æ†æ ",
    ],
    [
      "a840",
      "æ“æ—æ­¥æ¯æ±‚æ±žæ²™æ²æ²ˆæ²‰æ²…æ²›æ±ªæ±ºæ²æ±°æ²Œæ±¨æ²–æ²’æ±½æ²ƒæ±²æ±¾æ±´æ²†æ±¶æ²æ²”æ²˜æ²‚ç¶ç¼ç½ç¸ç‰¢ç‰¡ç‰ ç‹„ç‹‚çŽ–ç”¬ç”«ç”·ç”¸çš‚ç›¯çŸ£ç§ç§€ç¦¿ç©¶ç³»ç½•è‚–è‚“è‚è‚˜è‚›è‚šè‚²è‰¯èŠ’",
    ],
    [
      "a8a1",
      "èŠ‹èŠè¦‹è§’è¨€è°·è±†è±•è²èµ¤èµ°è¶³èº«è»Šè¾›è¾°è¿‚è¿†è¿…è¿„å·¡é‚‘é‚¢é‚ªé‚¦é‚£é…‰é‡†é‡Œé˜²é˜®é˜±é˜ªé˜¬ä¸¦ä¹–ä¹³äº‹äº›äºžäº«äº¬ä½¯ä¾ä¾ä½³ä½¿ä½¬ä¾›ä¾‹ä¾†ä¾ƒä½°ä½µä¾ˆä½©ä½»ä¾–ä½¾ä¾ä¾‘ä½ºå…”å…’å…•å…©å…·å…¶å…¸å†½å‡½åˆ»åˆ¸åˆ·åˆºåˆ°åˆ®åˆ¶å‰åŠ¾åŠ»å’å”å“å‘å¦å·å¸å¹å–å”å—å‘³å‘µ",
    ],
    [
      "a940",
      "å’–å‘¸å’•å’€å‘»å‘·å’„å’’å’†å‘¼å’å‘±å‘¶å’Œå’šå‘¢å‘¨å’‹å‘½å’Žå›ºåžƒå·åªå©å¡å¦å¤å¼å¤œå¥‰å¥‡å¥ˆå¥„å¥”å¦¾å¦»å§”å¦¹å¦®å§‘å§†å§å§å§‹å§“å§Šå¦¯å¦³å§’å§…å­Ÿå­¤å­£å®—å®šå®˜å®œå®™å®›å°šå±ˆå±…",
    ],
    [
      "a9a1",
      "å±†å²·å²¡å²¸å²©å²«å²±å²³å¸˜å¸šå¸–å¸•å¸›å¸‘å¹¸åºšåº—åºœåº•åº–å»¶å¼¦å¼§å¼©å¾€å¾å½¿å½¼å¿å¿ å¿½å¿µå¿¿æ€æ€”æ€¯æ€µæ€–æ€ªæ€•æ€¡æ€§æ€©æ€«æ€›æˆ–æˆ•æˆ¿æˆ¾æ‰€æ‰¿æ‹‰æ‹Œæ‹„æŠ¿æ‹‚æŠ¹æ‹’æ‹›æŠ«æ‹“æ‹”æ‹‹æ‹ˆæŠ¨æŠ½æŠ¼æ‹æ‹™æ‹‡æ‹æŠµæ‹šæŠ±æ‹˜æ‹–æ‹—æ‹†æŠ¬æ‹Žæ”¾æ–§æ–¼æ—ºæ˜”æ˜“æ˜Œæ˜†æ˜‚æ˜Žæ˜€æ˜æ˜•æ˜Š",
    ],
    [
      "aa40",
      "æ˜‡æœæœ‹æ­æž‹æž•æ±æžœæ³æ·æž‡æžæž—æ¯æ°æ¿æž‰æ¾æžæµæžšæž“æ¼æªæ²æ¬£æ­¦æ­§æ­¿æ°“æ°›æ³£æ³¨æ³³æ²±æ³Œæ³¥æ²³æ²½æ²¾æ²¼æ³¢æ²«æ³•æ³“æ²¸æ³„æ²¹æ³æ²®æ³—æ³…æ³±æ²¿æ²»æ³¡æ³›æ³Šæ²¬æ³¯æ³œæ³–æ³ ",
    ],
    [
      "aaa1",
      "ç‚•ç‚Žç‚’ç‚Šç‚™çˆ¬çˆ­çˆ¸ç‰ˆç‰§ç‰©ç‹€ç‹Žç‹™ç‹—ç‹çŽ©çŽ¨çŽŸçŽ«çŽ¥ç”½ç–ç–™ç–šçš„ç›‚ç›²ç›´çŸ¥çŸ½ç¤¾ç¥€ç¥ç§‰ç§ˆç©ºç©¹ç«ºç³¾ç½”ç¾Œç¾‹è€…è‚ºè‚¥è‚¢è‚±è‚¡è‚«è‚©è‚´è‚ªè‚¯è‡¥è‡¾èˆèŠ³èŠèŠ™èŠ­èŠ½èŠŸèŠ¹èŠ±èŠ¬èŠ¥èŠ¯èŠ¸èŠ£èŠ°èŠ¾èŠ·è™Žè™±åˆè¡¨è»‹è¿Žè¿”è¿‘é‚µé‚¸é‚±é‚¶é‡‡é‡‘é•·é–€é˜œé™€é˜¿é˜»é™„",
    ],
    [
      "ab40",
      "é™‚éš¹é›¨é’éžäºŸäº­äº®ä¿¡ä¾µä¾¯ä¾¿ä¿ ä¿‘ä¿ä¿ä¿ƒä¾¶ä¿˜ä¿Ÿä¿Šä¿—ä¾®ä¿ä¿„ä¿‚ä¿šä¿Žä¿žä¾·å…—å†’å†‘å† å‰Žå‰ƒå‰Šå‰å‰Œå‰‹å‰‡å‹‡å‹‰å‹ƒå‹åŒå—å»åŽšå›å’¬å“€å’¨å“Žå“‰å’¸å’¦å’³å“‡å“‚å’½å’ªå“",
    ],
    [
      "aba1",
      "å“„å“ˆå’¯å’«å’±å’»å’©å’§å’¿å›¿åž‚åž‹åž åž£åž¢åŸŽåž®åž“å¥•å¥‘å¥å¥Žå¥å§œå§˜å§¿å§£å§¨å¨ƒå§¥å§ªå§šå§¦å¨å§»å­©å®£å®¦å®¤å®¢å®¥å°å±Žå±å±å±‹å³™å³’å··å¸å¸¥å¸Ÿå¹½åº åº¦å»ºå¼ˆå¼­å½¥å¾ˆå¾…å¾Šå¾‹å¾‡å¾Œå¾‰æ€’æ€æ€ æ€¥æ€Žæ€¨ææ°æ¨æ¢æ†æƒæ¬æ«æªæ¤æ‰æ‹œæŒ–æŒ‰æ‹¼æ‹­æŒæ‹®æ‹½æŒ‡æ‹±æ‹·",
    ],
    [
      "ac40",
      "æ‹¯æ‹¬æ‹¾æ‹´æŒ‘æŒ‚æ”¿æ•…æ–«æ–½æ—¢æ˜¥æ˜­æ˜ æ˜§æ˜¯æ˜Ÿæ˜¨æ˜±æ˜¤æ›·æŸ¿æŸ“æŸ±æŸ”æŸæŸ¬æž¶æž¯æŸµæŸ©æŸ¯æŸ„æŸ‘æž´æŸšæŸ¥æž¸æŸæŸžæŸ³æž°æŸ™æŸ¢æŸæŸ’æ­ªæ®ƒæ®†æ®µæ¯’æ¯—æ°Ÿæ³‰æ´‹æ´²æ´ªæµæ´¥æ´Œæ´±æ´žæ´—",
    ],
    [
      "aca1",
      "æ´»æ´½æ´¾æ´¶æ´›æ³µæ´¹æ´§æ´¸æ´©æ´®æ´µæ´Žæ´«ç‚«ç‚ºç‚³ç‚¬ç‚¯ç‚­ç‚¸ç‚®ç‚¤çˆ°ç‰²ç‰¯ç‰´ç‹©ç‹ ç‹¡çŽ·çŠçŽ»çŽ²çç€çŽ³ç”šç”­ç•ç•Œç•Žç•‹ç–«ç–¤ç–¥ç–¢ç–£ç™¸çš†çš‡çšˆç›ˆç›†ç›ƒç›…çœç›¹ç›¸çœ‰çœ‹ç›¾ç›¼çœ‡çŸœç ‚ç ”ç Œç ç¥†ç¥‰ç¥ˆç¥‡ç¦¹ç¦ºç§‘ç§’ç§‹ç©¿çªç«¿ç«½ç±½ç´‚ç´…ç´€ç´‰ç´‡ç´„ç´†ç¼¸ç¾Žç¾¿è€„",
    ],
    [
      "ad40",
      "è€è€è€‘è€¶èƒ–èƒ¥èƒšèƒƒèƒ„èƒŒèƒ¡èƒ›èƒŽèƒžèƒ¤èƒè‡´èˆ¢è‹§èŒƒèŒ…è‹£è‹›è‹¦èŒ„è‹¥èŒ‚èŒ‰è‹’è‹—è‹±èŒè‹œè‹”è‹‘è‹žè‹“è‹Ÿè‹¯èŒ†è™è™¹è™»è™ºè¡è¡«è¦è§”è¨ˆè¨‚è¨ƒè²žè² èµ´èµ³è¶´è»è»Œè¿°è¿¦è¿¢è¿ªè¿¥",
    ],
    [
      "ada1",
      "è¿­è¿«è¿¤è¿¨éƒŠéƒŽéƒéƒƒé…‹é…Šé‡é–‚é™é™‹é™Œé™é¢é©éŸ‹éŸ­éŸ³é é¢¨é£›é£Ÿé¦–é¦™ä¹˜äº³å€Œå€å€£ä¿¯å€¦å€¥ä¿¸å€©å€–å€†å€¼å€Ÿå€šå€’å€‘ä¿ºå€€å€”å€¨ä¿±å€¡å€‹å€™å€˜ä¿³ä¿®å€­å€ªä¿¾å€«å€‰å…¼å†¤å†¥å†¢å‡å‡Œå‡†å‡‹å‰–å‰œå‰”å‰›å‰åŒªå¿åŽŸåŽåŸå“¨å”å”å”·å“¼å“¥å“²å”†å“ºå””å“©å“­å“¡å”‰å“®å“ª",
    ],
    [
      "ae40",
      "å“¦å”§å”‡å“½å”åœƒåœ„åŸ‚åŸ”åŸ‹åŸƒå ‰å¤å¥—å¥˜å¥šå¨‘å¨˜å¨œå¨Ÿå¨›å¨“å§¬å¨ å¨£å¨©å¨¥å¨Œå¨‰å­«å±˜å®°å®³å®¶å®´å®®å®µå®¹å®¸å°„å±‘å±•å±å³­å³½å³»å³ªå³¨å³°å³¶å´å³´å·®å¸­å¸«åº«åº­åº§å¼±å¾’å¾‘å¾æ™",
    ],
    [
      "aea1",
      "æ£æ¥ææ•æ­æ©æ¯æ‚„æ‚Ÿæ‚šæ‚æ‚”æ‚Œæ‚…æ‚–æ‰‡æ‹³æŒˆæ‹¿æŽæŒ¾æŒ¯æ•æ‚æ†ææ‰æŒºææŒ½æŒªæŒ«æŒ¨ææŒæ•ˆæ•‰æ–™æ—æ—…æ™‚æ™‰æ™æ™ƒæ™’æ™Œæ™…æ™æ›¸æœ”æœ•æœ—æ ¡æ ¸æ¡ˆæ¡†æ¡“æ ¹æ¡‚æ¡”æ ©æ¢³æ —æ¡Œæ¡‘æ ½æŸ´æ¡æ¡€æ ¼æ¡ƒæ ªæ¡…æ “æ ˜æ¡æ®Šæ®‰æ®·æ°£æ°§æ°¨æ°¦æ°¤æ³°æµªæ¶•æ¶ˆæ¶‡æµ¦æµ¸æµ·æµ™æ¶“",
    ],
    [
      "af40",
      "æµ¬æ¶‰æµ®æµšæµ´æµ©æ¶Œæ¶Šæµ¹æ¶…æµ¥æ¶”çƒŠçƒ˜çƒ¤çƒ™çƒˆçƒçˆ¹ç‰¹ç‹¼ç‹¹ç‹½ç‹¸ç‹·çŽ†ç­ç‰ç®ç çªçžç•”ç•ç•œç•šç•™ç–¾ç—…ç—‡ç–²ç–³ç–½ç–¼ç–¹ç—‚ç–¸çš‹çš°ç›Šç›ç›Žçœ©çœŸçœ çœ¨çŸ©ç °ç §ç ¸ç ç ´ç ·",
    ],
    [
      "afa1",
      "ç ¥ç ­ç  ç Ÿç ²ç¥•ç¥ç¥ ç¥Ÿç¥–ç¥žç¥ç¥—ç¥šç§¤ç§£ç§§ç§Ÿç§¦ç§©ç§˜çª„çªˆç«™ç¬†ç¬‘ç²‰ç´¡ç´—ç´‹ç´Šç´ ç´¢ç´”ç´ç´•ç´šç´œç´ç´™ç´›ç¼ºç½Ÿç¾”ç¿…ç¿è€†è€˜è€•è€™è€—è€½è€¿èƒ±è„‚èƒ°è„…èƒ­èƒ´è„†èƒ¸èƒ³è„ˆèƒ½è„Šèƒ¼èƒ¯è‡­è‡¬èˆ€èˆèˆªèˆ«èˆ¨èˆ¬èŠ»èŒ«è’è”èŠèŒ¸èè‰èŒµèŒ´èèŒ²èŒ¹èŒ¶èŒ—è€èŒ±èŒ¨èƒ",
    ],
    [
      "b040",
      "è™”èšŠèšªèš“èš¤èš©èšŒèš£èšœè¡°è¡·è¢è¢‚è¡½è¡¹è¨˜è¨è¨Žè¨Œè¨•è¨Šè¨—è¨“è¨–è¨è¨‘è±ˆè±ºè±¹è²¡è²¢èµ·èº¬è»’è»”è»è¾±é€é€†è¿·é€€è¿ºè¿´é€ƒè¿½é€…è¿¸é‚•éƒ¡éƒéƒ¢é…’é…é…Œé‡˜é‡é‡—é‡œé‡™é–ƒé™¢é™£é™¡",
    ],
    [
      "b0a1",
      "é™›é™é™¤é™˜é™žéš»é£¢é¦¬éª¨é«˜é¬¥é¬²é¬¼ä¹¾åºå½åœå‡åƒåŒåšå‰å¥å¶åŽå•åµå´å·åå€å¯å­å…œå†•å‡°å‰ªå‰¯å‹’å‹™å‹˜å‹•åŒåŒåŒ™åŒ¿å€åŒ¾åƒæ›¼å•†å•ªå•¦å•„å•žå•¡å•ƒå•Šå”±å•–å•å••å”¯å•¤å”¸å”®å•œå”¬å•£å”³å•å•—åœˆåœ‹åœ‰åŸŸå …å Šå †åŸ åŸ¤åŸºå ‚å µåŸ·åŸ¹å¤ å¥¢å¨¶å©å©‰å©¦å©ªå©€",
    ],
    [
      "b140",
      "å¨¼å©¢å©šå©†å©Šå­°å¯‡å¯…å¯„å¯‚å®¿å¯†å°‰å°ˆå°‡å± å±œå±å´‡å´†å´Žå´›å´–å´¢å´‘å´©å´”å´™å´¤å´§å´—å·¢å¸¸å¸¶å¸³å¸·åº·åº¸åº¶åºµåº¾å¼µå¼·å½—å½¬å½©å½«å¾—å¾™å¾žå¾˜å¾¡å¾ å¾œæ¿æ‚£æ‚‰æ‚ æ‚¨æƒ‹æ‚´æƒ¦æ‚½",
    ],
    [
      "b1a1",
      "æƒ…æ‚»æ‚µæƒœæ‚¼æƒ˜æƒ•æƒ†æƒŸæ‚¸æƒšæƒ‡æˆšæˆ›æ‰ˆæŽ æŽ§æ²æŽ–æŽ¢æŽ¥æ·æ§æŽ˜æŽªæ±æŽ©æŽ‰æŽƒæŽ›æ«æŽ¨æŽ„æŽˆæŽ™æŽ¡æŽ¬æŽ’æŽæŽ€æ»æ©æ¨æºæ•æ•–æ•‘æ•™æ•—å•Ÿæ•æ•˜æ••æ•”æ–œæ–›æ–¬æ—æ—‹æ—Œæ—Žæ™æ™šæ™¤æ™¨æ™¦æ™žæ›¹å‹—æœ›æ¢æ¢¯æ¢¢æ¢“æ¢µæ¡¿æ¡¶æ¢±æ¢§æ¢—æ¢°æ¢ƒæ£„æ¢­æ¢†æ¢…æ¢”æ¢æ¢¨æ¢Ÿæ¢¡æ¢‚æ¬²æ®º",
    ],
    [
      "b240",
      "æ¯«æ¯¬æ°«æ¶Žæ¶¼æ·³æ·™æ¶²æ·¡æ·Œæ·¤æ·»æ·ºæ¸…æ·‡æ·‹æ¶¯æ·‘æ¶®æ·žæ·¹æ¶¸æ··æ·µæ·…æ·’æ¸šæ¶µæ·šæ·«æ·˜æ·ªæ·±æ·®æ·¨æ·†æ·„æ¶ªæ·¬æ¶¿æ·¦çƒ¹ç„‰ç„Šçƒ½çƒ¯çˆ½ç‰½çŠçŒœçŒ›çŒ–çŒ“çŒ™çŽ‡ç…çŠçƒç†ç¾çç“ ç“¶",
    ],
    [
      "b2a1",
      "ç“·ç”œç”¢ç•¥ç•¦ç•¢ç•°ç–ç—”ç—•ç–µç—Šç—çšŽç›”ç›’ç››çœ·çœ¾çœ¼çœ¶çœ¸çœºç¡«ç¡ƒç¡Žç¥¥ç¥¨ç¥­ç§»çª’çª•ç¬ ç¬¨ç¬›ç¬¬ç¬¦ç¬™ç¬žç¬®ç²’ç²—ç²•çµ†çµƒçµ±ç´®ç´¹ç´¼çµ€ç´°ç´³çµ„ç´¯çµ‚ç´²ç´±ç¼½ç¾žç¾šç¿Œç¿Žç¿’è€œèŠè†è„¯è„–è„£è„«è„©è„°è„¤èˆ‚èˆµèˆ·èˆ¶èˆ¹èŽŽèŽžèŽ˜è¸èŽ¢èŽ–èŽ½èŽ«èŽ’èŽŠèŽ“èŽ‰èŽ è·è»è¼",
    ],
    [
      "b340",
      "èŽ†èŽ§è™•å½ªè›‡è›€èš¶è›„èšµè›†è›‹èš±èš¯è›‰è¡“è¢žè¢ˆè¢«è¢’è¢–è¢è¢‹è¦“è¦è¨ªè¨è¨£è¨¥è¨±è¨­è¨Ÿè¨›è¨¢è±‰è±šè²©è²¬è²«è²¨è²ªè²§èµ§èµ¦è¶¾è¶ºè»›è»Ÿé€™é€é€šé€—é€£é€Ÿé€é€é€•é€žé€ é€é€¢é€–é€›é€”",
    ],
    [
      "b3a1",
      "éƒ¨éƒ­éƒ½é…—é‡Žé‡µé‡¦é‡£é‡§é‡­é‡©é–‰é™ªé™µé™³é™¸é™°é™´é™¶é™·é™¬é›€é›ªé›©ç« ç«Ÿé ‚é ƒé­šé³¥é¹µé¹¿éº¥éº»å‚¢å‚å‚…å‚™å‚‘å‚€å‚–å‚˜å‚šæœ€å‡±å‰²å‰´å‰µå‰©å‹žå‹å‹›åšåŽ¥å•»å–€å–§å•¼å–Šå–å–˜å–‚å–œå–ªå–”å–‡å–‹å–ƒå–³å–®å–Ÿå”¾å–²å–šå–»å–¬å–±å•¾å–‰å–«å–™åœå ¯å ªå ´å ¤å °å ±å ¡å å  å£¹å£ºå¥ ",
    ],
    [
      "b440",
      "å©·åªšå©¿åª’åª›åª§å­³å­±å¯’å¯Œå¯“å¯å°Šå°‹å°±åµŒåµå´´åµ‡å·½å¹…å¸½å¹€å¹ƒå¹¾å»Šå»å»‚å»„å¼¼å½­å¾©å¾ªå¾¨æƒ‘æƒ¡æ‚²æ‚¶æƒ æ„œæ„£æƒºæ„•æƒ°æƒ»æƒ´æ…¨æƒ±æ„Žæƒ¶æ„‰æ„€æ„’æˆŸæ‰‰æŽ£æŽŒææ€æ©æ‰æ†æ",
    ],
    [
      "b4a1",
      "æ’æ£ææ¡æ–æ­æ®æ¶æ´æªæ›æ‘’æšæ¹æ•žæ•¦æ•¢æ•£æ–‘æ–æ–¯æ™®æ™°æ™´æ™¶æ™¯æš‘æ™ºæ™¾æ™·æ›¾æ›¿æœŸæœæ£ºæ£•æ£ æ£˜æ£—æ¤…æ£Ÿæ£µæ£®æ£§æ£¹æ£’æ£²æ££æ£‹æ£æ¤æ¤’æ¤Žæ£‰æ£šæ¥®æ£»æ¬¾æ¬ºæ¬½æ®˜æ®–æ®¼æ¯¯æ°®æ°¯æ°¬æ¸¯æ¸¸æ¹”æ¸¡æ¸²æ¹§æ¹Šæ¸ æ¸¥æ¸£æ¸›æ¹›æ¹˜æ¸¤æ¹–æ¹®æ¸­æ¸¦æ¹¯æ¸´æ¹æ¸ºæ¸¬æ¹ƒæ¸æ¸¾æ»‹",
    ],
    [
      "b540",
      "æº‰æ¸™æ¹Žæ¹£æ¹„æ¹²æ¹©æ¹Ÿç„™ç„šç„¦ç„°ç„¡ç„¶ç…®ç„œç‰ŒçŠ„çŠ€çŒ¶çŒ¥çŒ´çŒ©çºçªç³ç¢ç¥çµç¶ç´ç¯ç›ç¦ç¨ç”¥ç”¦ç•«ç•ªç—¢ç—›ç—£ç—™ç—˜ç—žç— ç™»ç™¼çš–çš“çš´ç›œççŸ­ç¡ç¡¬ç¡¯ç¨ç¨ˆç¨‹ç¨…ç¨€çª˜",
    ],
    [
      "b5a1",
      "çª—çª–ç«¥ç«£ç­‰ç­–ç­†ç­ç­’ç­”ç­ç­‹ç­ç­‘ç²Ÿç²¥çµžçµçµ¨çµ•ç´«çµ®çµ²çµ¡çµ¦çµ¢çµ°çµ³å–„ç¿”ç¿•è€‹è’è‚…è…•è…”è…‹è…‘è…Žè„¹è…†è„¾è…Œè…“è…´èˆ’èˆœè©èƒè¸èè è…è‹èè¯è±è´è‘—èŠè°èŒèŒè½è²èŠè¸èŽè„èœè‡è”èŸè™›è›Ÿè›™è›­è›”è››è›¤è›è›žè¡—è£è£‚è¢±è¦ƒè¦–è¨»è© è©•è©žè¨¼è©",
    ],
    [
      "b640",
      "è©”è©›è©è©†è¨´è¨ºè¨¶è©–è±¡è²‚è²¯è²¼è²³è²½è³è²»è³€è²´è²·è²¶è²¿è²¸è¶Šè¶…è¶è·Žè·è·‹è·šè·‘è·Œè·›è·†è»»è»¸è»¼è¾œé€®é€µé€±é€¸é€²é€¶é„‚éƒµé„‰éƒ¾é…£é…¥é‡éˆ”éˆ•éˆ£éˆ‰éˆžéˆéˆéˆ‡éˆ‘é–”é–é–‹é–‘",
    ],
    [
      "b6a1",
      "é–“é–’é–ŽéšŠéšŽéš‹é™½éš…éš†éšé™²éš„é›é›…é›„é›†é›‡é›¯é›²éŸŒé …é †é ˆé£§é£ªé£¯é£©é£²é£­é¦®é¦­é»ƒé»é»‘äº‚å‚­å‚µå‚²å‚³åƒ…å‚¾å‚¬å‚·å‚»å‚¯åƒ‡å‰¿å‰·å‰½å‹Ÿå‹¦å‹¤å‹¢å‹£åŒ¯å—Ÿå—¨å—“å—¦å—Žå—œå—‡å—‘å—£å—¤å—¯å—šå—¡å—…å—†å—¥å—‰åœ’åœ“å¡žå¡‘å¡˜å¡—å¡šå¡”å¡«å¡Œå¡­å¡Šå¡¢å¡’å¡‹å¥§å«å«‰å«Œåª¾åª½åª¼",
    ],
    [
      "b740",
      "åª³å«‚åª²åµ©åµ¯å¹Œå¹¹å»‰å»ˆå¼’å½™å¾¬å¾®æ„šæ„æ…ˆæ„Ÿæƒ³æ„›æƒ¹æ„æ„ˆæ…Žæ…Œæ…„æ…æ„¾æ„´æ„§æ„æ„†æ„·æˆ¡æˆ¢æ“æ¾æžæªæ­æ½æ¬ææœæ”ææ¶æ–æ—æ†æ•¬æ–Ÿæ–°æš—æš‰æš‡æšˆæš–æš„æš˜æšæœƒæ¦”æ¥­",
    ],
    [
      "b7a1",
      "æ¥šæ¥·æ¥ æ¥”æ¥µæ¤°æ¦‚æ¥Šæ¥¨æ¥«æ¥žæ¥“æ¥¹æ¦†æ¥æ¥£æ¥›æ­‡æ­²æ¯€æ®¿æ¯“æ¯½æº¢æº¯æ»“æº¶æ»‚æºæºæ»‡æ»…æº¥æº˜æº¼æººæº«æ»‘æº–æºœæ»„æ»”æºªæº§æº´ç…Žç…™ç…©ç…¤ç…‰ç…§ç…œç…¬ç…¦ç…Œç…¥ç…žç…†ç…¨ç…–çˆºç‰’çŒ·ç…çŒ¿çŒ¾ç‘¯ç‘šç‘•ç‘Ÿç‘žç‘ç¿ç‘™ç‘›ç‘œç•¶ç•¸ç˜€ç—°ç˜ç—²ç—±ç—ºç—¿ç—´ç—³ç›žç›Ÿç›ç«ç¦çžç£",
    ],
    [
      "b840",
      "ç¹çªç¬çœç¥ç¨ç¢çŸ®ç¢Žç¢°ç¢—ç¢˜ç¢Œç¢‰ç¡¼ç¢‘ç¢“ç¡¿ç¥ºç¥¿ç¦è¬ç¦½ç¨œç¨šç¨ ç¨”ç¨Ÿç¨žçªŸçª ç­·ç¯€ç­ ç­®ç­§ç²±ç²³ç²µç¶“çµ¹ç¶‘ç¶ç¶çµ›ç½®ç½©ç½ªç½²ç¾©ç¾¨ç¾¤è–è˜è‚†è‚„è…±è…°è…¸è…¥è…®è…³è…«",
    ],
    [
      "b8a1",
      "è…¹è…ºè…¦èˆ…è‰‡è’‚è‘·è½è±è‘µè‘¦è‘«è‘‰è‘¬è‘›è¼èµè‘¡è‘£è‘©è‘­è‘†è™žè™œè™Ÿè›¹èœ“èœˆèœ‡èœ€è›¾è›»èœ‚èœƒèœ†èœŠè¡™è£Ÿè£”è£™è£œè£˜è£è£¡è£Šè£•è£’è¦œè§£è©«è©²è©³è©¦è©©è©°èª‡è©¼è©£èª è©±èª…è©­è©¢è©®è©¬è©¹è©»è¨¾è©¨è±¢è²Šè²‰è³Šè³‡è³ˆè³„è²²è³ƒè³‚è³…è·¡è·Ÿè·¨è·¯è·³è·ºè·ªè·¤è·¦èº²è¼ƒè¼‰è»¾è¼Š",
    ],
    [
      "b940",
      "è¾Ÿè¾²é‹éŠé“é‚é”é€¼é•éé‡ééŽéé‘é€¾éé„’é„—é…¬é…ªé…©é‡‰éˆ·é‰—éˆ¸éˆ½é‰€éˆ¾é‰›é‰‹é‰¤é‰‘éˆ´é‰‰é‰é‰…éˆ¹éˆ¿é‰šé–˜éš˜éš”éš•é›é›‹é›‰é›Šé›·é›»é›¹é›¶é–é´é¶é é ‘é “é Šé ’é Œé£¼é£´",
    ],
    [
      "b9a1",
      "é£½é£¾é¦³é¦±é¦´é«¡é³©éº‚é¼Žé¼“é¼ åƒ§åƒ®åƒ¥åƒ–åƒ­åƒšåƒ•åƒåƒ‘åƒ±åƒŽåƒ©å…¢å‡³åŠƒåŠ‚åŒ±åŽ­å—¾å˜€å˜›å˜—å—½å˜”å˜†å˜‰å˜å˜Žå—·å˜–å˜Ÿå˜ˆå˜å—¶åœ˜åœ–å¡µå¡¾å¢ƒå¢“å¢Šå¡¹å¢…å¡½å£½å¤¥å¤¢å¤¤å¥ªå¥©å«¡å«¦å«©å«—å«–å«˜å«£å­µå¯žå¯§å¯¡å¯¥å¯¦å¯¨å¯¢å¯¤å¯Ÿå°å±¢å¶„å¶‡å¹›å¹£å¹•å¹—å¹”å»“å»–å¼Šå½†å½°å¾¹æ…‡",
    ],
    [
      "ba40",
      "æ„¿æ…‹æ…·æ…¢æ…£æ…Ÿæ…šæ…˜æ…µæˆªæ’‡æ‘˜æ‘”æ’¤æ‘¸æ‘Ÿæ‘ºæ‘‘æ‘§æ´æ‘­æ‘»æ•²æ–¡æ——æ—–æš¢æš¨æšæ¦œæ¦¨æ¦•æ§æ¦®æ§“æ§‹æ¦›æ¦·æ¦»æ¦«æ¦´æ§æ§æ¦­æ§Œæ¦¦æ§ƒæ¦£æ­‰æ­Œæ°³æ¼³æ¼”æ»¾æ¼“æ»´æ¼©æ¼¾æ¼ æ¼¬æ¼æ¼‚æ¼¢",
    ],
    [
      "baa1",
      "æ»¿æ»¯æ¼†æ¼±æ¼¸æ¼²æ¼£æ¼•æ¼«æ¼¯æ¾ˆæ¼ªæ»¬æ¼æ»²æ»Œæ»·ç†”ç†™ç…½ç†Šç†„ç†’çˆ¾çŠ’çŠ–ç„çç‘¤ç‘£ç‘ªç‘°ç‘­ç”„ç–‘ç˜§ç˜ç˜‹ç˜‰ç˜“ç›¡ç›£çž„ç½ç¿ç¡ç£ç¢Ÿç¢§ç¢³ç¢©ç¢£ç¦Žç¦ç¦ç¨®ç¨±çªªçª©ç«­ç«¯ç®¡ç®•ç®‹ç­µç®—ç®ç®”ç®ç®¸ç®‡ç®„ç²¹ç²½ç²¾ç¶»ç¶°ç¶œç¶½ç¶¾ç¶ ç·Šç¶´ç¶²ç¶±ç¶ºç¶¢ç¶¿ç¶µç¶¸ç¶­ç·’ç·‡ç¶¬",
    ],
    [
      "bb40",
      "ç½°ç¿ ç¿¡ç¿Ÿèžèšè‚‡è…è†€è†è†ˆè†Šè…¿è†‚è‡§è‡ºèˆ‡èˆ”èˆžè‰‹è“‰è’¿è“†è“„è’™è’žè’²è’œè“‹è’¸è“€è““è’è’¼è“‘è“Šèœ¿èœœèœ»èœ¢èœ¥èœ´èœ˜è•èœ·èœ©è£³è¤‚è£´è£¹è£¸è£½è£¨è¤šè£¯èª¦èªŒèªžèª£èªèª¡èª“èª¤",
    ],
    [
      "bba1",
      "èªªèª¥èª¨èª˜èª‘èªšèª§è±ªè²è²Œè³“è³‘è³’èµ«è¶™è¶•è·¼è¼”è¼’è¼•è¼“è¾£é é˜éœé£é™éžé¢éé›é„™é„˜é„žé…µé…¸é…·é…´é‰¸éŠ€éŠ…éŠ˜éŠ–é‰»éŠ“éŠœéŠ¨é‰¼éŠ‘é–¡é–¨é–©é–£é–¥é–¤éš™éšœéš›é›Œé›’éœ€é¼éž…éŸ¶é —é ˜é¢¯é¢±é¤ƒé¤…é¤Œé¤‰é§éª¯éª°é«¦é­é­‚é³´é³¶é³³éº¼é¼»é½Šå„„å„€åƒ»åƒµåƒ¹å„‚å„ˆå„‰å„…å‡œ",
    ],
    [
      "bc40",
      "åŠ‡åŠˆåŠ‰åŠåŠŠå‹°åŽ²å˜®å˜»å˜¹å˜²å˜¿å˜´å˜©å™“å™Žå™—å™´å˜¶å˜¯å˜°å¢€å¢Ÿå¢žå¢³å¢œå¢®å¢©å¢¦å¥­å¬‰å«»å¬‹å«µå¬Œå¬ˆå¯®å¯¬å¯©å¯«å±¤å±¥å¶å¶”å¹¢å¹Ÿå¹¡å»¢å»šå»Ÿå»å»£å» å½ˆå½±å¾·å¾µæ…¶æ…§æ…®æ…æ…•æ†‚",
    ],
    [
      "bca1",
      "æ…¼æ…°æ…«æ…¾æ†§æ†æ†«æ†Žæ†¬æ†šæ†¤æ†”æ†®æˆ®æ‘©æ‘¯æ‘¹æ’žæ’²æ’ˆæ’æ’°æ’¥æ’“æ’•æ’©æ’’æ’®æ’­æ’«æ’šæ’¬æ’™æ’¢æ’³æ•µæ•·æ•¸æš®æš«æš´æš±æ¨£æ¨Ÿæ§¨æ¨æ¨žæ¨™æ§½æ¨¡æ¨“æ¨Šæ§³æ¨‚æ¨…æ§­æ¨‘æ­æ­Žæ®¤æ¯…æ¯†æ¼¿æ½¼æ¾„æ½‘æ½¦æ½”æ¾†æ½­æ½›æ½¸æ½®æ¾Žæ½ºæ½°æ½¤æ¾—æ½˜æ»•æ½¯æ½ æ½Ÿç†Ÿç†¬ç†±ç†¨ç‰–çŠ›çŽç—ç‘©ç’‹ç’ƒ",
    ],
    [
      "bd40",
      "ç‘¾ç’€ç•¿ç˜ ç˜©ç˜Ÿç˜¤ç˜¦ç˜¡ç˜¢çššçšºç›¤çžŽçž‡çžŒçž‘çž‹ç£‹ç£…ç¢ºç£Šç¢¾ç£•ç¢¼ç£ç¨¿ç¨¼ç©€ç¨½ç¨·ç¨»çª¯çª®ç®­ç®±ç¯„ç®´ç¯†ç¯‡ç¯ç® ç¯Œç³Šç· ç·´ç·¯ç·»ç·˜ç·¬ç·ç·¨ç·£ç·šç·žç·©ç¶žç·™ç·²ç·¹ç½µç½·ç¾¯",
    ],
    [
      "bda1",
      "ç¿©è€¦è†›è†œè†è† è†šè†˜è”—è”½è”šè“®è”¬è”­è”“è”‘è”£è”¡è””è“¬è”¥è“¿è”†èž‚è´è¶è è¦è¸è¨è™è—èŒè“è¡›è¡è¤è¤‡è¤’è¤“è¤•è¤Šèª¼è«’è«‡è«„èª•è«‹è«¸èª²è«‰è«‚èª¿èª°è«–è«èª¶èª¹è«›è±Œè±Žè±¬è³ è³žè³¦è³¤è³¬è³­è³¢è³£è³œè³ªè³¡èµ­è¶Ÿè¶£è¸«è¸è¸è¸¢è¸è¸©è¸Ÿè¸¡è¸žèººè¼è¼›è¼Ÿè¼©è¼¦è¼ªè¼œè¼ž",
    ],
    [
      "be40",
      "è¼¥é©é®é¨é­é·é„°é„­é„§é„±é†‡é†‰é†‹é†ƒé‹…éŠ»éŠ·é‹ªéŠ¬é‹¤é‹éŠ³éŠ¼é‹’é‹‡é‹°éŠ²é–­é–±éœ„éœ†éœ‡éœ‰é éžéž‹éžé ¡é «é œé¢³é¤Šé¤“é¤’é¤˜é§é§é§Ÿé§›é§‘é§•é§’é§™éª·é«®é«¯é¬§é­…é­„é­·é­¯é´†é´‰",
    ],
    [
      "bea1",
      "é´ƒéº©éº¾é»Žå¢¨é½’å„’å„˜å„”å„å„•å†€å†ªå‡åŠ‘åŠ“å‹³å™™å™«å™¹å™©å™¤å™¸å™ªå™¨å™¥å™±å™¯å™¬å™¢å™¶å£å¢¾å£‡å£…å¥®å¬å¬´å­¸å¯°å°Žå½Šæ†²æ†‘æ†©æ†Šæ‡æ†¶æ†¾æ‡Šæ‡ˆæˆ°æ“…æ“æ“‹æ’»æ’¼æ“šæ“„æ“‡æ“‚æ“æ’¿æ“’æ“”æ’¾æ•´æ›†æ›‰æš¹æ›„æ›‡æš¸æ¨½æ¨¸æ¨ºæ©™æ©«æ©˜æ¨¹æ©„æ©¢æ©¡æ©‹æ©‡æ¨µæ©Ÿæ©ˆæ­™æ­·æ°…æ¿‚æ¾±æ¾¡",
    ],
    [
      "bf40",
      "æ¿ƒæ¾¤æ¿æ¾§æ¾³æ¿€æ¾¹æ¾¶æ¾¦æ¾ æ¾´ç†¾ç‡‰ç‡ç‡’ç‡ˆç‡•ç†¹ç‡Žç‡™ç‡œç‡ƒç‡„ç¨ç’œç’£ç’˜ç’Ÿç’žç“¢ç”Œç”ç˜´ç˜¸ç˜ºç›§ç›¥çž çžžçžŸçž¥ç£¨ç£šç£¬ç£§ç¦¦ç©ç©Žç©†ç©Œç©‹çªºç¯™ç°‘ç¯‰ç¯¤ç¯›ç¯¡ç¯©ç¯¦ç³•ç³–ç¸Š",
    ],
    [
      "bfa1",
      "ç¸‘ç¸ˆç¸›ç¸£ç¸žç¸ç¸‰ç¸ç½¹ç¾²ç¿°ç¿±ç¿®è€¨è†³è†©è†¨è‡»èˆˆè‰˜è‰™è•Šè•™è•ˆè•¨è•©è•ƒè•‰è•­è•ªè•žèžƒèžŸèžžèž¢èžè¡¡è¤ªè¤²è¤¥è¤«è¤¡è¦ªè¦¦è«¦è«ºè««è«±è¬€è«œè«§è«®è«¾è¬è¬‚è«·è«­è«³è«¶è«¼è±«è±­è²“è³´è¹„è¸±è¸´è¹‚è¸¹è¸µè¼»è¼¯è¼¸è¼³è¾¨è¾¦éµé´é¸é²é¼éºé„´é†’éŒ éŒ¶é‹¸éŒ³éŒ¯éŒ¢é‹¼éŒ«éŒ„éŒš",
    ],
    [
      "c040",
      "éŒéŒ¦éŒ¡éŒ•éŒ®éŒ™é–»éš§éš¨éšªé›•éœŽéœ‘éœ–éœéœ“éœé›éœé¦éž˜é °é ¸é »é ·é ­é ¹é ¤é¤é¤¨é¤žé¤›é¤¡é¤šé§­é§¢é§±éª¸éª¼é«»é«­é¬¨é®‘é´•é´£é´¦é´¨é´’é´›é»˜é»”é¾é¾œå„ªå„Ÿå„¡å„²å‹µåšŽåš€åšåš…åš‡",
    ],
    [
      "c0a1",
      "åšå£•å£“å£‘å£Žå¬°å¬ªå¬¤å­ºå°·å±¨å¶¼å¶ºå¶½å¶¸å¹«å½Œå¾½æ‡‰æ‡‚æ‡‡æ‡¦æ‡‹æˆ²æˆ´æ“Žæ“Šæ“˜æ“ æ“°æ“¦æ“¬æ“±æ“¢æ“­æ–‚æ–ƒæ›™æ›–æª€æª”æª„æª¢æªœæ«›æª£æ©¾æª—æªæª æ­œæ®®æ¯šæ°ˆæ¿˜æ¿±æ¿Ÿæ¿ æ¿›æ¿¤æ¿«æ¿¯æ¾€æ¿¬æ¿¡æ¿©æ¿•æ¿®æ¿°ç‡§ç‡Ÿç‡®ç‡¦ç‡¥ç‡­ç‡¬ç‡´ç‡ çˆµç‰†ç°ç²ç’©ç’°ç’¦ç’¨ç™†ç™‚ç™Œç›ªçž³çžªçž°çž¬",
    ],
    [
      "c140",
      "çž§çž­çŸ¯ç£·ç£ºç£´ç£¯ç¤ç¦§ç¦ªç©—çª¿ç°‡ç°ç¯¾ç¯·ç°Œç¯ ç³ ç³œç³žç³¢ç³Ÿç³™ç³ç¸®ç¸¾ç¹†ç¸·ç¸²ç¹ƒç¸«ç¸½ç¸±ç¹…ç¹ç¸´ç¸¹ç¹ˆç¸µç¸¿ç¸¯ç½„ç¿³ç¿¼è±è²è°è¯è³è‡†è‡ƒè†ºè‡‚è‡€è†¿è†½è‡‰è†¾è‡¨èˆ‰è‰±è–ª",
    ],
    [
      "c1a1",
      "è–„è•¾è–œè–‘è–”è–¯è–›è–‡è–¨è–Šè™§èŸ€èŸ‘èž³èŸ’èŸ†èž«èž»èžºèŸˆèŸ‹è¤»è¤¶è¥„è¤¸è¤½è¦¬è¬Žè¬—è¬™è¬›è¬Šè¬ è¬è¬„è¬è±è°¿è±³è³ºè³½è³¼è³¸è³»è¶¨è¹‰è¹‹è¹ˆè¹Šè½„è¼¾è½‚è½…è¼¿é¿é½é‚„é‚é‚‚é‚€é„¹é†£é†žé†œééŽ‚éŒ¨éµéŠé¥é‹éŒ˜é¾é¬é›é°éšé”é—Šé—‹é—Œé—ˆé—†éš±éš¸é›–éœœéœžéž éŸ“é¡†é¢¶é¤µé¨",
    ],
    [
      "c240",
      "é§¿é®®é®«é®ªé®­é´»é´¿éº‹é»é»žé»œé»é»›é¼¾é½‹å¢åš•åš®å£™å£˜å¬¸å½æ‡£æˆ³æ“´æ“²æ“¾æ”†æ“ºæ“»æ“·æ–·æ›œæœ¦æª³æª¬æ«ƒæª»æª¸æ«‚æª®æª¯æ­Ÿæ­¸æ®¯ç€‰ç€‹æ¿¾ç€†æ¿ºç€‘ç€ç‡»ç‡¼ç‡¾ç‡¸ç·çµç’§ç’¿ç”•ç™–ç™˜",
    ],
    [
      "c2a1",
      "ç™’çž½çž¿çž»çž¼ç¤Žç¦®ç©¡ç©¢ç© ç«„ç«…ç°«ç°§ç°ªç°žç°£ç°¡ç³§ç¹”ç¹•ç¹žç¹šç¹¡ç¹’ç¹™ç½ˆç¿¹ç¿»è·è¶è‡è‡èˆŠè—è–©è—è—è—‰è–°è–ºè–¹è–¦èŸ¯èŸ¬èŸ²èŸ è¦†è¦²è§´è¬¨è¬¹è¬¬è¬«è±è´…è¹™è¹£è¹¦è¹¤è¹Ÿè¹•è»€è½‰è½é‚‡é‚ƒé‚ˆé†«é†¬é‡éŽ”éŽŠéŽ–éŽ¢éŽ³éŽ®éŽ¬éŽ°éŽ˜éŽšéŽ—é—”é—–é—é—•é›¢é›œé›™é››é›žéœ¤éž£éž¦",
    ],
    [
      "c340",
      "éž­éŸ¹é¡é¡é¡Œé¡Žé¡“é¢ºé¤¾é¤¿é¤½é¤®é¦¥é¨Žé«é¬ƒé¬†é­é­Žé­é¯Šé¯‰é¯½é¯ˆé¯€éµ‘éµéµ é» é¼•é¼¬å„³åš¥å£žå£Ÿå£¢å¯µé¾å»¬æ‡²æ‡·æ‡¶æ‡µæ”€æ”æ› æ›æ«¥æ«æ«šæ«“ç€›ç€Ÿç€¨ç€šç€ç€•ç€˜çˆ†çˆç‰˜çŠ¢ç¸",
    ],
    [
      "c3a1",
      "çºç’½ç“Šç“£ç–‡ç–†ç™Ÿç™¡çŸ‡ç¤™ç¦±ç©«ç©©ç°¾ç°¿ç°¸ç°½ç°·ç±€ç¹«ç¹­ç¹¹ç¹©ç¹ªç¾…ç¹³ç¾¶ç¾¹ç¾¸è‡˜è—©è—è—ªè—•è—¤è—¥è—·èŸ»è …è èŸ¹èŸ¾è¥ è¥Ÿè¥–è¥žè­è­œè­˜è­‰è­šè­Žè­è­†è­™è´ˆè´Šè¹¼è¹²èº‡è¹¶è¹¬è¹ºè¹´è½”è½Žè¾­é‚Šé‚‹é†±é†®é¡é‘éŸéƒéˆéœéé–é¢éé˜é¤é—é¨é—œéš´é›£éœªéœ§é¡éŸœéŸ»é¡ž",
    ],
    [
      "c440",
      "é¡˜é¡›é¢¼é¥…é¥‰é¨–é¨™é¬é¯¨é¯§é¯–é¯›é¶‰éµ¡éµ²éµªéµ¬éº’éº—éº“éº´å‹¸åš¨åš·åš¶åš´åš¼å£¤å­€å­ƒå­½å¯¶å·‰æ‡¸æ‡ºæ”˜æ””æ”™æ›¦æœ§æ«¬ç€¾ç€°ç€²çˆç»ç“ç™¢ç™¥ç¤¦ç¤ªç¤¬ç¤«ç«‡ç«¶ç±Œç±ƒç±ç³¯ç³°è¾®ç¹½ç¹¼",
    ],
    [
      "c4a1",
      "çº‚ç½Œè€€è‡šè‰¦è—»è—¹è˜‘è—ºè˜†è˜‹è˜‡è˜Šè ”è •è¥¤è¦ºè§¸è­°è­¬è­¦è­¯è­Ÿè­«è´è´èº‰èºèº…èº‚é†´é‡‹é˜éƒé½é—¡éœ°é£„é¥’é¥‘é¦¨é¨«é¨°é¨·é¨µé°“é°é¹¹éºµé»¨é¼¯é½Ÿé½£é½¡å„·å„¸å›å›€å›‚å¤”å±¬å·æ‡¼æ‡¾æ”æ”œæ–•æ›©æ«»æ¬„æ«ºæ®²çŒçˆ›çŠ§ç“–ç“”ç™©çŸ“ç±çºçºŒç¾¼è˜—è˜­è˜šè £è ¢è ¡è Ÿè¥ªè¥¬è¦½è­´",
    ],
    [
      "c540",
      "è­·è­½è´“èºŠèºèº‹è½Ÿè¾¯é†ºé®é³éµéºé¸é²é«é—¢éœ¸éœ¹éœ²éŸ¿é¡§é¡¥é¥—é©…é©ƒé©€é¨¾é«é­”é­‘é°­é°¥é¶¯é¶´é·‚é¶¸éºé»¯é¼™é½œé½¦é½§å„¼å„»å›ˆå›Šå›‰å­¿å·”å·’å½Žæ‡¿æ”¤æ¬Šæ­¡ç‘ç˜çŽ€ç“¤ç–Šç™®ç™¬",
    ],
    [
      "c5a1",
      "ç¦³ç± ç±Ÿè¾è½è‡Ÿè¥²è¥¯è§¼è®€è´–è´—èº‘èº“è½¡é…ˆé‘„é‘‘é‘’éœ½éœ¾éŸƒéŸé¡«é¥•é©•é©é«’é¬šé±‰é°±é°¾é°»é·“é·—é¼´é½¬é½ªé¾”å›Œå·–æˆ€æ”£æ”«æ”ªæ›¬æ¬ç“šç«Šç±¤ç±£ç±¥çº“çº–çº”è‡¢è˜¸è˜¿è ±è®Šé‚é‚é‘£é‘ é‘¤é¨é¡¯é¥œé©šé©›é©—é«“é«”é«‘é±”é±—é±–é·¥éºŸé»´å›‘å£©æ”¬çžç™±ç™²çŸ—ç½ç¾ˆè ¶è ¹è¡¢è®“è®’",
    ],
    [
      "c640",
      "è®–è‰·è´›é‡€é‘ªé‚éˆé„éŸ†é¡°é©Ÿé¬¢é­˜é±Ÿé·¹é·ºé¹¼é¹½é¼‡é½·é½²å»³æ¬–ç£ç±¬ç±®è »è§€èº¡é‡é‘²é‘°é¡±é¥žé«–é¬£é»Œç¤çŸšè®šé‘·éŸ‰é©¢é©¥çºœè®œèºªé‡…é‘½é‘¾é‘¼é±·é±¸é»·è±”é‘¿é¸šçˆ¨é©ªé¬±é¸›é¸žç±²",
    ],
    [
      "c940",
      "ä¹‚ä¹œå‡µåŒšåŽ‚ä¸‡ä¸Œä¹‡äºå›—ï¨Œå±®å½³ä¸å†‡ä¸Žä¸®äº“ä»‚ä»‰ä»ˆå†˜å‹¼å¬åŽ¹åœ å¤ƒå¤¬å°å·¿æ—¡æ®³æ¯Œæ°”çˆ¿ä¸±ä¸¼ä»¨ä»œä»©ä»¡ä»ä»šåˆŒåŒœåŒåœ¢åœ£å¤—å¤¯å®å®„å°’å°»å±´å±³å¸„åº€åº‚å¿‰æˆ‰æ‰æ°•",
    ],
    [
      "c9a1",
      "æ°¶æ±ƒæ°¿æ°»çŠ®çŠ°çŽŠç¦¸è‚Šé˜žä¼Žä¼˜ä¼¬ä»µä¼”ä»±ä¼€ä»·ä¼ˆä¼ä¼‚ä¼…ä¼¢ä¼“ä¼„ä»´ä¼’å†±åˆ“åˆ‰åˆåŠ¦åŒ¢åŒŸååŽŠå‡å›¡å›Ÿåœ®åœªåœ´å¤¼å¦€å¥¼å¦…å¥»å¥¾å¥·å¥¿å­–å°•å°¥å±¼å±ºå±»å±¾å·Ÿå¹µåº„å¼‚å¼šå½´å¿•å¿”å¿æ‰œæ‰žæ‰¤æ‰¡æ‰¦æ‰¢æ‰™æ‰ æ‰šæ‰¥æ—¯æ—®æœ¾æœ¹æœ¸æœ»æœºæœ¿æœ¼æœ³æ°˜æ±†æ±’æ±œæ±æ±Šæ±”æ±‹",
    ],
    [
      "ca40",
      "æ±Œç±ç‰žçŠ´çŠµçŽŽç”ªç™¿ç©µç½‘è‰¸è‰¼èŠ€è‰½è‰¿è™è¥¾é‚™é‚—é‚˜é‚›é‚”é˜¢é˜¤é˜ é˜£ä½–ä¼»ä½¢ä½‰ä½“ä½¤ä¼¾ä½§ä½’ä½Ÿä½ä½˜ä¼­ä¼³ä¼¿ä½¡å†å†¹åˆœåˆžåˆ¡åŠ­åŠ®åŒ‰å£å²åŽŽåŽå°å·åªå‘”å‘…å™åœå¥å˜",
    ],
    [
      "caa1",
      "å½å‘å‘å¨å¤å‘‡å›®å›§å›¥åå…åŒå‰å‹å’å¤†å¥€å¦¦å¦˜å¦ å¦—å¦Žå¦¢å¦å¦å¦§å¦¡å®Žå®’å°¨å°ªå²å²å²ˆå²‹å²‰å²’å²Šå²†å²“å²•å· å¸Šå¸Žåº‹åº‰åºŒåºˆåºå¼…å¼å½¸å½¶å¿’å¿‘å¿å¿­å¿¨å¿®å¿³å¿¡å¿¤å¿£å¿ºå¿¯å¿·å¿»æ€€å¿´æˆºæŠƒæŠŒæŠŽæŠæŠ”æŠ‡æ‰±æ‰»æ‰ºæ‰°æŠæŠˆæ‰·æ‰½æ‰²æ‰´æ”·æ—°æ—´æ—³æ—²æ—µæ…æ‡",
    ],
    [
      "cb40",
      "æ™æ•æŒæˆæææšæ‹æ¯æ°™æ°šæ±¸æ±§æ±«æ²„æ²‹æ²æ±±æ±¯æ±©æ²šæ±­æ²‡æ²•æ²œæ±¦æ±³æ±¥æ±»æ²Žç´çºç‰£çŠ¿çŠ½ç‹ƒç‹†ç‹çŠºç‹…çŽ•çŽ—çŽ“çŽ”çŽ’ç”ºç”¹ç–”ç–•çšç¤½è€´è‚•è‚™è‚è‚’è‚œèŠèŠèŠ…èŠŽèŠ‘èŠ“",
    ],
    [
      "cba1",
      "èŠŠèŠƒèŠ„è±¸è¿‰è¾¿é‚Ÿé‚¡é‚¥é‚žé‚§é‚ é˜°é˜¨é˜¯é˜­ä¸³ä¾˜ä½¼ä¾…ä½½ä¾€ä¾‡ä½¶ä½´ä¾‰ä¾„ä½·ä½Œä¾—ä½ªä¾šä½¹ä¾ä½¸ä¾ä¾œä¾”ä¾žä¾’ä¾‚ä¾•ä½«ä½®å†žå†¼å†¾åˆµåˆ²åˆ³å‰†åˆ±åŠ¼åŒŠåŒ‹åŒ¼åŽ’åŽ”å’‡å‘¿å’å’‘å’‚å’ˆå‘«å‘ºå‘¾å‘¥å‘¬å‘´å‘¦å’å‘¯å‘¡å‘ å’˜å‘£å‘§å‘¤å›·å›¹å¯å²å­å«å±å°å¶åž€åµå»å³å´å¢",
    ],
    [
      "cc40",
      "å¨å½å¤Œå¥…å¦µå¦ºå§å§Žå¦²å§Œå§å¦¶å¦¼å§ƒå§–å¦±å¦½å§€å§ˆå¦´å§‡å­¢å­¥å®“å®•å±„å±‡å²®å²¤å² å²µå²¯å²¨å²¬å²Ÿå²£å²­å²¢å²ªå²§å²å²¥å²¶å²°å²¦å¸—å¸”å¸™å¼¨å¼¢å¼£å¼¤å½”å¾‚å½¾å½½å¿žå¿¥æ€­æ€¦æ€™æ€²æ€‹",
    ],
    [
      "cca1",
      "æ€´æ€Šæ€—æ€³æ€šæ€žæ€¬æ€¢æ€æ€æ€®æ€“æ€‘æ€Œæ€‰æ€œæˆ”æˆ½æŠ­æŠ´æ‹‘æŠ¾æŠªæŠ¶æ‹ŠæŠ®æŠ³æŠ¯æŠ»æŠ©æŠ°æŠ¸æ”½æ–¨æ–»æ˜‰æ—¼æ˜„æ˜’æ˜ˆæ—»æ˜ƒæ˜‹æ˜æ˜…æ—½æ˜‘æ˜æ›¶æœŠæž…æ¬æžŽæž’æ¶æ»æž˜æž†æž„æ´æžæžŒæºæžŸæž‘æž™æžƒæ½æžæ¸æ¹æž”æ¬¥æ®€æ­¾æ¯žæ°æ²“æ³¬æ³«æ³®æ³™æ²¶æ³”æ²­æ³§æ²·æ³æ³‚æ²ºæ³ƒæ³†æ³­æ³²",
    ],
    [
      "cd40",
      "æ³’æ³æ²´æ²Šæ²æ²€æ³žæ³€æ´°æ³æ³‡æ²°æ³¹æ³æ³©æ³‘ç‚”ç‚˜ç‚…ç‚“ç‚†ç‚„ç‚‘ç‚–ç‚‚ç‚šç‚ƒç‰ªç‹–ç‹‹ç‹˜ç‹‰ç‹œç‹’ç‹”ç‹šç‹Œç‹‘çŽ¤çŽ¡çŽ­çŽ¦çŽ¢çŽ çŽ¬çŽç“ç“¨ç”¿ç•€ç”¾ç–Œç–˜çš¯ç›³ç›±ç›°ç›µçŸ¸çŸ¼çŸ¹çŸ»çŸº",
    ],
    [
      "cda1",
      "çŸ·ç¥‚ç¤¿ç§…ç©¸ç©»ç«»ç±µç³½è€µè‚è‚®è‚£è‚¸è‚µè‚­èˆ èŠ è‹€èŠ«èŠšèŠ˜èŠ›èŠµèŠ§èŠ®èŠ¼èŠžèŠºèŠ´èŠ¨èŠ¡èŠ©è‹‚èŠ¤è‹ƒèŠ¶èŠ¢è™°è™¯è™­è™®è±–è¿’è¿‹è¿“è¿è¿–è¿•è¿—é‚²é‚´é‚¯é‚³é‚°é˜¹é˜½é˜¼é˜ºé™ƒä¿ä¿…ä¿“ä¾²ä¿‰ä¿‹ä¿ä¿”ä¿œä¿™ä¾»ä¾³ä¿›ä¿‡ä¿–ä¾ºä¿€ä¾¹ä¿¬å‰„å‰‰å‹€å‹‚åŒ½å¼åŽ—åŽ–åŽ™åŽ˜å’ºå’¡å’­å’¥å“",
    ],
    [
      "ce40",
      "å“ƒèŒå’·å’®å“–å’¶å“…å“†å’ å‘°å’¼å’¢å’¾å‘²å“žå’°åžµåžžåžŸåž¤åžŒåž—åžåž›åž”åž˜åžåž™åž¥åžšåž•å£´å¤å¥“å§¡å§žå§®å¨€å§±å§å§ºå§½å§¼å§¶å§¤å§²å§·å§›å§©å§³å§µå§ å§¾å§´å§­å®¨å±Œå³å³˜å³Œå³—å³‹å³›",
    ],
    [
      "cea1",
      "å³žå³šå³‰å³‡å³Šå³–å³“å³”å³å³ˆå³†å³Žå³Ÿå³¸å·¹å¸¡å¸¢å¸£å¸ å¸¤åº°åº¤åº¢åº›åº£åº¥å¼‡å¼®å½–å¾†æ€·æ€¹æ”æ²æžæ…æ“æ‡æ‰æ›æŒæ€æ‚æŸæ€¤æ„æ˜æ¦æ®æ‰‚æ‰ƒæ‹æŒæŒ‹æ‹µæŒŽæŒƒæ‹«æ‹¹æŒæŒŒæ‹¸æ‹¶æŒ€æŒ“æŒ”æ‹ºæŒ•æ‹»æ‹°æ•æ•ƒæ–ªæ–¿æ˜¶æ˜¡æ˜²æ˜µæ˜œæ˜¦æ˜¢æ˜³æ˜«æ˜ºæ˜æ˜´æ˜¹æ˜®æœæœæŸæŸ²æŸˆæžº",
    ],
    [
      "cf40",
      "æŸœæž»æŸ¸æŸ˜æŸ€æž·æŸ…æŸ«æŸ¤æŸŸæžµæŸæž³æŸ·æŸ¶æŸ®æŸ£æŸ‚æž¹æŸŽæŸ§æŸ°æž²æŸ¼æŸ†æŸ­æŸŒæž®æŸ¦æŸ›æŸºæŸ‰æŸŠæŸƒæŸªæŸ‹æ¬¨æ®‚æ®„æ®¶æ¯–æ¯˜æ¯ æ° æ°¡æ´¨æ´´æ´­æ´Ÿæ´¼æ´¿æ´’æ´Šæ³šæ´³æ´„æ´™æ´ºæ´šæ´‘æ´€æ´æµ‚",
    ],
    [
      "cfa1",
      "æ´æ´˜æ´·æ´ƒæ´æµ€æ´‡æ´ æ´¬æ´ˆæ´¢æ´‰æ´ç‚·ç‚Ÿç‚¾ç‚±ç‚°ç‚¡ç‚´ç‚µç‚©ç‰ç‰‰ç‰Šç‰¬ç‰°ç‰³ç‰®ç‹Šç‹¤ç‹¨ç‹«ç‹Ÿç‹ªç‹¦ç‹£çŽ…çŒç‚çˆç…çŽ¹çŽ¶çŽµçŽ´ç«çŽ¿ç‡çŽ¾çƒç†çŽ¸ç‹ç“¬ç“®ç”®ç•‡ç•ˆç–§ç–ªç™¹ç›„çœˆçœƒçœ„çœ…çœŠç›·ç›»ç›ºçŸ§çŸ¨ç †ç ‘ç ’ç …ç ç ç Žç ‰ç ƒç “ç¥Šç¥Œç¥‹ç¥…ç¥„ç§•ç§ç§ç§–ç§Žçª€",
    ],
    [
      "d040",
      "ç©¾ç«‘ç¬€ç¬ç±ºç±¸ç±¹ç±¿ç²€ç²ç´ƒç´ˆç´ç½˜ç¾‘ç¾ç¾¾è€‡è€Žè€è€”è€·èƒ˜èƒ‡èƒ èƒ‘èƒˆèƒ‚èƒèƒ…èƒ£èƒ™èƒœèƒŠèƒ•èƒ‰èƒèƒ—èƒ¦èƒè‡¿èˆ¡èŠ”è‹™è‹¾è‹¹èŒ‡è‹¨èŒ€è‹•èŒºè‹«è‹–è‹´è‹¬è‹¡è‹²è‹µèŒŒè‹»è‹¶è‹°è‹ª",
    ],
    [
      "d0a1",
      "è‹¤è‹ è‹ºè‹³è‹­è™·è™´è™¼è™³è¡è¡Žè¡§è¡ªè¡©è§“è¨„è¨‡èµ²è¿£è¿¡è¿®è¿ éƒ±é‚½é‚¿éƒ•éƒ…é‚¾éƒ‡éƒ‹éƒˆé‡”é‡“é™”é™é™‘é™“é™Šé™Žå€žå€…å€‡å€“å€¢å€°å€›ä¿µä¿´å€³å€·å€¬ä¿¶ä¿·å€—å€œå€ å€§å€µå€¯å€±å€Žå…šå†”å†“å‡Šå‡„å‡…å‡ˆå‡Žå‰¡å‰šå‰’å‰žå‰Ÿå‰•å‰¢å‹åŒŽåŽžå”¦å“¢å”—å”’å“§å“³å“¤å”šå“¿å”„å”ˆå“«å”‘å”…å“±",
    ],
    [
      "d140",
      "å”Šå“»å“·å“¸å“ å”Žå”ƒå”‹åœåœ‚åŸŒå ²åŸ•åŸ’åžºåŸ†åž½åž¼åž¸åž¶åž¿åŸ‡åŸåž¹åŸå¤Žå¥Šå¨™å¨–å¨­å¨®å¨•å¨å¨—å¨Šå¨žå¨³å­¬å®§å®­å®¬å°ƒå±–å±”å³¬å³¿å³®å³±å³·å´€å³¹å¸©å¸¨åº¨åº®åºªåº¬å¼³å¼°å½§ææšæ§",
    ],
    [
      "d1a1",
      "ææ‚¢æ‚ˆæ‚€æ‚’æ‚æ‚æ‚ƒæ‚•æ‚›æ‚—æ‚‡æ‚œæ‚Žæˆ™æ‰†æ‹²æŒæ–æŒ¬æ„æ…æŒ¶æƒæ¤æŒ¹æ‹æŠæŒ¼æŒ©ææŒ´æ˜æ”æ™æŒ­æ‡æŒ³æšæ‘æŒ¸æ—æ€æˆæ•Šæ•†æ—†æ—ƒæ—„æ—‚æ™Šæ™Ÿæ™‡æ™‘æœ’æœ“æ Ÿæ šæ¡‰æ ²æ ³æ »æ¡‹æ¡æ –æ ±æ œæ µæ «æ ­æ ¯æ¡Žæ¡„æ ´æ æ ’æ ”æ ¦æ ¨æ ®æ¡æ ºæ ¥æ  æ¬¬æ¬¯æ¬­æ¬±æ¬´æ­­è‚‚æ®ˆæ¯¦æ¯¤",
    ],
    [
      "d240",
      "æ¯¨æ¯£æ¯¢æ¯§æ°¥æµºæµ£æµ¤æµ¶æ´æµ¡æ¶’æµ˜æµ¢æµ­æµ¯æ¶‘æ¶æ·¯æµ¿æ¶†æµžæµ§æµ æ¶—æµ°æµ¼æµŸæ¶‚æ¶˜æ´¯æµ¨æ¶‹æµ¾æ¶€æ¶„æ´–æ¶ƒæµ»æµ½æµµæ¶çƒœçƒ“çƒ‘çƒçƒ‹ç¼¹çƒ¢çƒ—çƒ’çƒžçƒ çƒ”çƒçƒ…çƒ†çƒ‡çƒšçƒŽçƒ¡ç‰‚ç‰¸",
    ],
    [
      "d2a1",
      "ç‰·ç‰¶çŒ€ç‹ºç‹´ç‹¾ç‹¶ç‹³ç‹»çŒç“ç™ç¥ç–çŽ¼ç§ç£ç©çœç’ç›ç”ççšç—ç˜ç¨ç“žç“Ÿç“´ç“µç”¡ç•›ç•Ÿç–°ç—ç–»ç—„ç—€ç–¿ç–¶ç–ºçšŠç›‰çœçœ›çœçœ“çœ’çœ£çœ‘çœ•çœ™çœšçœ¢çœ§ç £ç ¬ç ¢ç µç ¯ç ¨ç ®ç «ç ¡ç ©ç ³ç ªç ±ç¥”ç¥›ç¥ç¥œç¥“ç¥’ç¥‘ç§«ç§¬ç§ ç§®ç§­ç§ªç§œç§žç§çª†çª‰çª…çª‹çªŒçªŠçª‡ç«˜ç¬",
    ],
    [
      "d340",
      "ç¬„ç¬“ç¬…ç¬ç¬ˆç¬Šç¬Žç¬‰ç¬’ç²„ç²‘ç²Šç²Œç²ˆç²ç²…ç´žç´ç´‘ç´Žç´˜ç´–ç´“ç´Ÿç´’ç´ç´Œç½œç½¡ç½žç½ ç½ç½›ç¾–ç¾’ç¿ƒç¿‚ç¿€è€–è€¾è€¹èƒºèƒ²èƒ¹èƒµè„èƒ»è„€èˆèˆ¯èˆ¥èŒ³èŒ­è„èŒ™è‘èŒ¥è–èŒ¿èèŒ¦èŒœèŒ¢",
    ],
    [
      "d3a1",
      "è‚èŽèŒ›èŒªèŒˆèŒ¼èèŒ–èŒ¤èŒ èŒ·èŒ¯èŒ©è‡è…èŒè“èŒžèŒ¬è‹èŒ§èˆè™“è™’èš¢èš¨èš–èšèš‘èšžèš‡èš—èš†èš‹èššèš…èš¥èš™èš¡èš§èš•èš˜èšŽèšèšèš”è¡ƒè¡„è¡­è¡µè¡¶è¡²è¢€è¡±è¡¿è¡¯è¢ƒè¡¾è¡´è¡¼è¨’è±‡è±—è±»è²¤è²£èµ¶èµ¸è¶µè¶·è¶¶è»‘è»“è¿¾è¿µé€‚è¿¿è¿»é€„è¿¼è¿¶éƒ–éƒ éƒ™éƒšéƒ£éƒŸéƒ¥éƒ˜éƒ›éƒ—éƒœéƒ¤é…",
    ],
    [
      "d440",
      "é…Žé…é‡•é‡¢é‡šé™œé™Ÿéš¼é££é«Ÿé¬¯ä¹¿å°åªå¡åžå å“å‹åå²åˆååå›åŠå¢å€•å…åŸå©å«å£å¤å†å€å®å³å—å‘å‡å‰«å‰­å‰¬å‰®å‹–å‹“åŒ­åŽœå•µå•¶å”¼å•å•å”´å”ªå•‘å•¢å”¶å”µå”°å•’å•…",
    ],
    [
      "d4a1",
      "å”Œå”²å•¥å•Žå”¹å•ˆå”­å”»å•€å•‹åœŠåœ‡åŸ»å ”åŸ¢åŸ¶åŸœåŸ´å €åŸ­åŸ½å ˆåŸ¸å ‹åŸ³åŸå ‡åŸ®åŸ£åŸ²åŸ¥åŸ¬åŸ¡å ŽåŸ¼å åŸ§å å ŒåŸ±åŸ©åŸ°å å „å¥œå© å©˜å©•å©§å©žå¨¸å¨µå©­å©å©Ÿå©¥å©¬å©“å©¤å©—å©ƒå©å©’å©„å©›å©ˆåªŽå¨¾å©å¨¹å©Œå©°å©©å©‡å©‘å©–å©‚å©œå­²å­®å¯å¯€å±™å´žå´‹å´å´šå´ å´Œå´¨å´å´¦å´¥å´",
    ],
    [
      "d540",
      "å´°å´’å´£å´Ÿå´®å¸¾å¸´åº±åº´åº¹åº²åº³å¼¶å¼¸å¾›å¾–å¾Ÿæ‚Šæ‚æ‚†æ‚¾æ‚°æ‚ºæƒ“æƒ”æƒæƒ¤æƒ™æƒæƒˆæ‚±æƒ›æ‚·æƒŠæ‚¿æƒƒæƒæƒ€æŒ²æ¥æŽŠæŽ‚æ½æŽ½æŽžæŽ­æŽæŽ—æŽ«æŽŽæ¯æŽ‡æŽæ®æŽ¯æµæŽœæ­æŽ®æ¼æŽ¤æŒ»æŽŸ",
    ],
    [
      "d5a1",
      "æ¸æŽ…æŽæŽ‘æŽæ°æ•“æ—æ™¥æ™¡æ™›æ™™æ™œæ™¢æœ˜æ¡¹æ¢‡æ¢æ¢œæ¡­æ¡®æ¢®æ¢«æ¥–æ¡¯æ¢£æ¢¬æ¢©æ¡µæ¡´æ¢²æ¢æ¡·æ¢’æ¡¼æ¡«æ¡²æ¢ªæ¢€æ¡±æ¡¾æ¢›æ¢–æ¢‹æ¢ æ¢‰æ¢¤æ¡¸æ¡»æ¢‘æ¢Œæ¢Šæ¡½æ¬¶æ¬³æ¬·æ¬¸æ®‘æ®æ®æ®Žæ®Œæ°ªæ·€æ¶«æ¶´æ¶³æ¹´æ¶¬æ·©æ·¢æ¶·æ·¶æ·”æ¸€æ·ˆæ· æ·Ÿæ·–æ¶¾æ·¥æ·œæ·æ·›æ·´æ·Šæ¶½æ·­æ·°æ¶ºæ·•æ·‚æ·æ·‰",
    ],
    [
      "d640",
      "æ·æ·²æ·“æ·½æ·—æ·æ·£æ¶»çƒºç„çƒ·ç„—çƒ´ç„Œçƒ°ç„„çƒ³ç„çƒ¼çƒ¿ç„†ç„“ç„€çƒ¸çƒ¶ç„‹ç„‚ç„Žç‰¾ç‰»ç‰¼ç‰¿çŒçŒ—çŒ‡çŒ‘çŒ˜çŒŠçŒˆç‹¿çŒçŒžçŽˆç¶ç¸çµç„çç½ç‡ç€çºç¼ç¿çŒç‹ç´çˆç•¤ç•£ç—Žç—’ç—",
    ],
    [
      "d6a1",
      "ç—‹ç—Œç—‘ç—çšçš‰ç›“çœ¹çœ¯çœ­çœ±çœ²çœ´çœ³çœ½çœ¥çœ»çœµç¡ˆç¡’ç¡‰ç¡ç¡Šç¡Œç ¦ç¡…ç¡ç¥¤ç¥§ç¥©ç¥ªç¥£ç¥«ç¥¡ç¦»ç§ºç§¸ç§¶ç§·çªçª”çªç¬µç­‡ç¬´ç¬¥ç¬°ç¬¢ç¬¤ç¬³ç¬˜ç¬ªç¬ç¬±ç¬«ç¬­ç¬¯ç¬²ç¬¸ç¬šç¬£ç²”ç²˜ç²–ç²£ç´µç´½ç´¸ç´¶ç´ºçµ…ç´¬ç´©çµçµ‡ç´¾ç´¿çµŠç´»ç´¨ç½£ç¾•ç¾œç¾ç¾›ç¿Šç¿‹ç¿ç¿ç¿‘ç¿‡ç¿ç¿‰è€Ÿ",
    ],
    [
      "d740",
      "è€žè€›è‡èƒèˆè„˜è„¥è„™è„›è„­è„Ÿè„¬è„žè„¡è„•è„§è„è„¢èˆ‘èˆ¸èˆ³èˆºèˆ´èˆ²è‰´èŽèŽ£èŽ¨èŽèºè³èŽ¤è´èŽèŽèŽ•èŽ™èµèŽ”èŽ©è½èŽƒèŽŒèŽèŽ›èŽªèŽ‹è¾èŽ¥èŽ¯èŽˆèŽ—èŽ°è¿èŽ¦èŽ‡èŽ®è¶èŽšè™™è™–èš¿èš·",
    ],
    [
      "d7a1",
      "è›‚è›è›…èšºèš°è›ˆèš¹èš³èš¸è›Œèš´èš»èš¼è›ƒèš½èš¾è¡’è¢‰è¢•è¢¨è¢¢è¢ªè¢šè¢‘è¢¡è¢Ÿè¢˜è¢§è¢™è¢›è¢—è¢¤è¢¬è¢Œè¢“è¢Žè¦‚è§–è§™è§•è¨°è¨§è¨¬è¨žè°¹è°»è±œè±è±½è²¥èµ½èµ»èµ¹è¶¼è·‚è¶¹è¶¿è·è»˜è»žè»è»œè»—è» è»¡é€¤é€‹é€‘é€œé€Œé€¡éƒ¯éƒªéƒ°éƒ´éƒ²éƒ³éƒ”éƒ«éƒ¬éƒ©é…–é…˜é…šé…“é…•é‡¬é‡´é‡±é‡³é‡¸é‡¤é‡¹é‡ª",
    ],
    [
      "d840",
      "é‡«é‡·é‡¨é‡®é•ºé–†é–ˆé™¼é™­é™«é™±é™¯éš¿éªé „é£¥é¦—å‚›å‚•å‚”å‚žå‚‹å‚£å‚ƒå‚Œå‚Žå‚å¨å‚œå‚’å‚‚å‚‡å…Ÿå‡”åŒ’åŒ‘åŽ¤åŽ§å–‘å–¨å–¥å–­å•·å™…å–¢å–“å–ˆå–å–µå–å–£å–’å–¤å•½å–Œå–¦å•¿å–•å–¡å–ŽåœŒå ©å ·",
    ],
    [
      "d8a1",
      "å ™å žå §å £å ¨åŸµå¡ˆå ¥å œå ›å ³å ¿å ¶å ®å ¹å ¸å ­å ¬å »å¥¡åª¯åª”åªŸå©ºåª¢åªžå©¸åª¦å©¼åª¥åª¬åª•åª®å¨·åª„åªŠåª—åªƒåª‹åª©å©»å©½åªŒåªœåªåª“åªå¯ªå¯å¯‹å¯”å¯‘å¯Šå¯Žå°Œå°°å´·åµƒåµ«åµåµ‹å´¿å´µåµ‘åµŽåµ•å´³å´ºåµ’å´½å´±åµ™åµ‚å´¹åµ‰å´¸å´¼å´²å´¶åµ€åµ…å¹„å¹å½˜å¾¦å¾¥å¾«æƒ‰æ‚¹æƒŒæƒ¢æƒŽæƒ„æ„”",
    ],
    [
      "d940",
      "æƒ²æ„Šæ„–æ„…æƒµæ„“æƒ¸æƒ¼æƒ¾æƒæ„ƒæ„˜æ„æ„æƒ¿æ„„æ„‹æ‰ŠæŽ”æŽ±æŽ°æŽæ¥æ¨æ¯æƒæ’æ³æŠæ æ¶æ•æ²æµæ‘¡æŸæŽ¾ææœæ„æ˜æ“æ‚æ‡æŒæ‹æˆæ°æ—æ™æ”²æ•§æ•ªæ•¤æ•œæ•¨æ•¥æ–Œæ–æ–žæ–®æ—æ—’",
    ],
    [
      "d9a1",
      "æ™¼æ™¬æ™»æš€æ™±æ™¹æ™ªæ™²æœæ¤Œæ£“æ¤„æ£œæ¤ªæ£¬æ£ªæ£±æ¤æ£–æ£·æ£«æ£¤æ£¶æ¤“æ¤æ£³æ£¡æ¤‡æ£Œæ¤ˆæ¥°æ¢´æ¤‘æ£¯æ£†æ¤”æ£¸æ£æ£½æ£¼æ£¨æ¤‹æ¤Šæ¤—æ£Žæ£ˆæ£æ£žæ£¦æ£´æ£‘æ¤†æ£”æ£©æ¤•æ¤¥æ£‡æ¬¹æ¬»æ¬¿æ¬¼æ®”æ®—æ®™æ®•æ®½æ¯°æ¯²æ¯³æ°°æ·¼æ¹†æ¹‡æ¸Ÿæ¹‰æºˆæ¸¼æ¸½æ¹…æ¹¢æ¸«æ¸¿æ¹æ¹æ¹³æ¸œæ¸³æ¹‹æ¹€æ¹‘æ¸»æ¸ƒæ¸®æ¹ž",
    ],
    [
      "da40",
      "æ¹¨æ¹œæ¹¡æ¸±æ¸¨æ¹ æ¹±æ¹«æ¸¹æ¸¢æ¸°æ¹“æ¹¥æ¸§æ¹¸æ¹¤æ¹·æ¹•æ¹¹æ¹’æ¹¦æ¸µæ¸¶æ¹šç„ ç„žç„¯çƒ»ç„®ç„±ç„£ç„¥ç„¢ç„²ç„Ÿç„¨ç„ºç„›ç‰‹ç‰šçŠˆçŠ‰çŠ†çŠ…çŠ‹çŒ’çŒ‹çŒ°çŒ¢çŒ±çŒ³çŒ§çŒ²çŒ­çŒ¦çŒ£çŒµçŒŒç®ç¬ç°ç«ç–",
    ],
    [
      "daa1",
      "çšç¡ç­ç±ç¤ç£çç©ç ç²ç“»ç”¯ç•¯ç•¬ç—§ç—šç—¡ç—¦ç—ç—Ÿç—¤ç——çš•çš’ç›šç†ç‡ç„çç…çŠçŽç‹çŒçŸžçŸ¬ç¡ ç¡¤ç¡¥ç¡œç¡­ç¡±ç¡ªç¡®ç¡°ç¡©ç¡¨ç¡žç¡¢ç¥´ç¥³ç¥²ç¥°ç¨‚ç¨Šç¨ƒç¨Œç¨„çª™ç«¦ç«¤ç­Šç¬»ç­„ç­ˆç­Œç­Žç­€ç­˜ç­…ç²¢ç²žç²¨ç²¡çµ˜çµ¯çµ£çµ“çµ–çµ§çµªçµçµ­çµœçµ«çµ’çµ”çµ©çµ‘çµŸçµŽç¼¾ç¼¿ç½¥",
    ],
    [
      "db40",
      "ç½¦ç¾¢ç¾ ç¾¡ç¿—è‘èèèƒ¾èƒ”è…ƒè…Šè…’è…è…‡è„½è…è„ºè‡¦è‡®è‡·è‡¸è‡¹èˆ„èˆ¼èˆ½èˆ¿è‰µèŒ»èè¹è£è€è¨è’è§è¤è¼è¶èè†èˆè«è£èŽ¿èèè¥è˜è¿è¡è‹èŽè–èµè‰è‰èèžè‘è†è‚è³",
    ],
    [
      "dba1",
      "è•èºè‡è‘èªè“èƒè¬è®è„è»è—è¢è›è›è¾è›˜è›¢è›¦è›“è›£è›šè›ªè›è›«è›œè›¬è›©è›—è›¨è›‘è¡ˆè¡–è¡•è¢ºè£—è¢¹è¢¸è£€è¢¾è¢¶è¢¼è¢·è¢½è¢²è¤è£‰è¦•è¦˜è¦—è§è§šè§›è©Žè©è¨¹è©™è©€è©—è©˜è©„è©…è©’è©ˆè©‘è©Šè©Œè©è±Ÿè²è²€è²ºè²¾è²°è²¹è²µè¶„è¶€è¶‰è·˜è·“è·è·‡è·–è·œè·è·•è·™è·ˆè·—è·…è»¯è»·è»º",
    ],
    [
      "dc40",
      "è»¹è»¦è»®è»¥è»µè»§è»¨è»¶è»«è»±è»¬è»´è»©é€­é€´é€¯é„†é„¬é„„éƒ¿éƒ¼é„ˆéƒ¹éƒ»é„é„€é„‡é„…é„ƒé…¡é…¤é…Ÿé…¢é… éˆéˆŠéˆ¥éˆƒéˆšéˆ¦éˆéˆŒéˆ€éˆ’é‡¿é‡½éˆ†éˆ„éˆ§éˆ‚éˆœéˆ¤éˆ™éˆ—éˆ…éˆ–é•»é–é–Œé–éš‡é™¾éšˆ",
    ],
    [
      "dca1",
      "éš‰éšƒéš€é›‚é›ˆé›ƒé›±é›°é¬é°é®é ‡é¢©é£«é³¦é»¹äºƒäº„äº¶å‚½å‚¿åƒ†å‚®åƒ„åƒŠå‚´åƒˆåƒ‚å‚°åƒå‚ºå‚±åƒ‹åƒ‰å‚¶å‚¸å‡—å‰ºå‰¸å‰»å‰¼å—ƒå—›å—Œå—å—‹å—Šå—å—€å—”å—„å—©å–¿å—’å–å—å—•å—¢å—–å—ˆå—²å—å—™å—‚åœ”å¡“å¡¨å¡¤å¡å¡å¡‰å¡¯å¡•å¡Žå¡å¡™å¡¥å¡›å ½å¡£å¡±å£¼å«‡å«„å«‹åªºåª¸åª±åªµåª°åª¿å«ˆåª»å«†",
    ],
    [
      "dd40",
      "åª·å«€å«Šåª´åª¶å«åª¹åªå¯–å¯˜å¯™å°Ÿå°³åµ±åµ£åµŠåµ¥åµ²åµ¬åµžåµ¨åµ§åµ¢å·°å¹å¹Žå¹Šå¹å¹‹å»…å»Œå»†å»‹å»‡å½€å¾¯å¾­æƒ·æ…‰æ…Šæ„«æ……æ„¶æ„²æ„®æ…†æ„¯æ…æ„©æ…€æˆ é…¨æˆ£æˆ¥æˆ¤æ…æ±æ«ææ’æ‰æ æ¤",
    ],
    [
      "dda1",
      "æ³æ‘ƒæŸæ•æ˜æ¹æ·æ¢æ£æŒæ¦æ°æ¨æ‘æµæ¯æŠæšæ‘€æ¥æ§æ‹æ§æ›æ®æ¡æŽæ•¯æ–’æ—“æš†æšŒæš•æšæš‹æšŠæš™æš”æ™¸æœ æ¥¦æ¥Ÿæ¤¸æ¥Žæ¥¢æ¥±æ¤¿æ¥…æ¥ªæ¤¹æ¥‚æ¥—æ¥™æ¥ºæ¥ˆæ¥‰æ¤µæ¥¬æ¤³æ¤½æ¥¥æ£°æ¥¸æ¤´æ¥©æ¥€æ¥¯æ¥„æ¥¶æ¥˜æ¥æ¥´æ¥Œæ¤»æ¥‹æ¤·æ¥œæ¥æ¥‘æ¤²æ¥’æ¤¯æ¥»æ¤¼æ­†æ­…æ­ƒæ­‚æ­ˆæ­æ®›ï¨æ¯»æ¯¼",
    ],
    [
      "de40",
      "æ¯¹æ¯·æ¯¸æº›æ»–æ»ˆæºæ»€æºŸæº“æº”æº æº±æº¹æ»†æ»’æº½æ»æºžæ»‰æº·æº°æ»æº¦æ»æº²æº¾æ»ƒæ»œæ»˜æº™æº’æºŽæºæº¤æº¡æº¿æº³æ»æ»Šæº—æº®æº£ç…‡ç…”ç…’ç…£ç… ç…ç…ç…¢ç…²ç…¸ç…ªç…¡ç…‚ç…˜ç…ƒç…‹ç…°ç…Ÿç…ç…“",
    ],
    [
      "dea1",
      "ç…„ç…ç…šç‰çŠçŠŒçŠ‘çŠçŠŽçŒ¼ç‚çŒ»çŒºç€çŠç‰ç‘„ç‘Šç‘‹ç‘’ç‘‘ç‘—ç‘€ç‘ç‘ç‘Žç‘‚ç‘†ç‘ç‘”ç“¡ç“¿ç“¾ç“½ç”ç•¹ç•·æ¦ƒç—¯ç˜ç˜ƒç—·ç—¾ç—¼ç—¹ç—¸ç˜ç—»ç—¶ç—­ç—µç—½çš™çšµç›ç•çŸç ç’ç–çšç©ç§ç”ç™ç­çŸ ç¢‡ç¢šç¢”ç¢ç¢„ç¢•ç¢…ç¢†ç¢¡ç¢ƒç¡¹ç¢™ç¢€ç¢–ç¡»ç¥¼ç¦‚ç¥½ç¥¹ç¨‘ç¨˜ç¨™ç¨’ç¨—ç¨•ç¨¢ç¨“",
    ],
    [
      "df40",
      "ç¨›ç¨çª£çª¢çªžç««ç­¦ç­¤ç­­ç­´ç­©ç­²ç­¥ç­³ç­±ç­°ç­¡ç­¸ç­¶ç­£ç²²ç²´ç²¯ç¶ˆç¶†ç¶€ç¶çµ¿ç¶…çµºç¶Žçµ»ç¶ƒçµ¼ç¶Œç¶”ç¶„çµ½ç¶’ç½­ç½«ç½§ç½¨ç½¬ç¾¦ç¾¥ç¾§ç¿›ç¿œè€¡è…¤è… è…·è…œè…©è…›è…¢è…²æœ¡è…žè…¶è…§è…¯",
    ],
    [
      "dfa1",
      "è…„è…¡èˆè‰‰è‰„è‰€è‰‚è‰…è“±è¿è‘–è‘¶è‘¹è’è’è‘¥è‘‘è‘€è’†è‘§è°è‘è‘½è‘šè‘™è‘´è‘³è‘è”‡è‘žè·èºè´è‘ºè‘ƒè‘¸è²è‘…è©è™è‘‹è¯è‘‚è­è‘Ÿè‘°è¹è‘Žè‘Œè‘’è‘¯è“…è’Žè»è‘‡è¶è³è‘¨è‘¾è‘„è«è‘ è‘”è‘®è‘èœ‹èœ„è›·èœŒè›ºè›–è›µèè›¸èœŽèœ‰èœè›¶èœèœ…è£–è£‹è£è£Žè£žè£›è£šè£Œè£è¦…è¦›è§Ÿè§¥è§¤",
    ],
    [
      "e040",
      "è§¡è§ è§¢è§œè§¦è©¶èª†è©¿è©¡è¨¿è©·èª‚èª„è©µèªƒèªè©´è©ºè°¼è±‹è±Šè±¥è±¤è±¦è²†è²„è²…è³Œèµ¨èµ©è¶‘è¶Œè¶Žè¶è¶è¶“è¶”è¶è¶’è·°è· è·¬è·±è·®è·è·©è·£è·¢è·§è·²è·«è·´è¼†è»¿è¼è¼€è¼…è¼‡è¼ˆè¼‚è¼‹é’é€¿",
    ],
    [
      "e0a1",
      "é„é‰é€½é„é„é„é„‘é„–é„”é„‹é„Žé…®é…¯é‰ˆé‰’éˆ°éˆºé‰¦éˆ³é‰¥é‰žéŠƒéˆ®é‰Šé‰†é‰­é‰¬é‰é‰ é‰§é‰¯éˆ¶é‰¡é‰°éˆ±é‰”é‰£é‰é‰²é‰Žé‰“é‰Œé‰–éˆ²é–Ÿé–œé–žé–›éš’éš“éš‘éš—é›Žé›ºé›½é›¸é›µé³é·é¸é²é é é Žé¢¬é£¶é£¹é¦¯é¦²é¦°é¦µéª­éª«é­›é³ªé³­é³§éº€é»½åƒ¦åƒ”åƒ—åƒ¨åƒ³åƒ›åƒªåƒåƒ¤åƒ“åƒ¬åƒ°åƒ¯åƒ£åƒ ",
    ],
    [
      "e140",
      "å‡˜åŠ€åŠå‹©å‹«åŒ°åŽ¬å˜§å˜•å˜Œå˜’å—¼å˜å˜œå˜å˜“å˜‚å—ºå˜å˜„å—¿å—¹å¢‰å¡¼å¢å¢˜å¢†å¢å¡¿å¡´å¢‹å¡ºå¢‡å¢‘å¢Žå¡¶å¢‚å¢ˆå¡»å¢”å¢å£¾å¥«å«œå«®å«¥å«•å«ªå«šå«­å««å«³å«¢å« å«›å«¬å«žå«å«™å«¨å«Ÿå­·å¯ ",
    ],
    [
      "e1a1",
      "å¯£å±£å¶‚å¶€åµ½å¶†åµºå¶åµ·å¶Šå¶‰å¶ˆåµ¾åµ¼å¶åµ¹åµ¿å¹˜å¹™å¹“å»˜å»‘å»—å»Žå»œå»•å»™å»’å»”å½„å½ƒå½¯å¾¶æ„¬æ„¨æ…æ…žæ…±æ…³æ…’æ…“æ…²æ…¬æ†€æ…´æ…”æ…ºæ…›æ…¥æ„»æ…ªæ…¡æ…–æˆ©æˆ§æˆ«æ«æ‘æ‘›æ‘æ‘´æ‘¶æ‘²æ‘³æ‘½æ‘µæ‘¦æ’¦æ‘Žæ’‚æ‘žæ‘œæ‘‹æ‘“æ‘ æ‘æ‘¿æ¿æ‘¬æ‘«æ‘™æ‘¥æ‘·æ•³æ– æš¡æš æšŸæœ…æœ„æœ¢æ¦±æ¦¶æ§‰",
    ],
    [
      "e240",
      "æ¦ æ§Žæ¦–æ¦°æ¦¬æ¦¼æ¦‘æ¦™æ¦Žæ¦§æ¦æ¦©æ¦¾æ¦¯æ¦¿æ§„æ¦½æ¦¤æ§”æ¦¹æ§Šæ¦šæ§æ¦³æ¦“æ¦ªæ¦¡æ¦žæ§™æ¦—æ¦æ§‚æ¦µæ¦¥æ§†æ­Šæ­æ­‹æ®žæ®Ÿæ® æ¯ƒæ¯„æ¯¾æ»Žæ»µæ»±æ¼ƒæ¼¥æ»¸æ¼·æ»»æ¼®æ¼‰æ½Žæ¼™æ¼šæ¼§æ¼˜æ¼»æ¼’æ»­æ¼Š",
    ],
    [
      "e2a1",
      "æ¼¶æ½³æ»¹æ»®æ¼­æ½€æ¼°æ¼¼æ¼µæ»«æ¼‡æ¼Žæ½ƒæ¼…æ»½æ»¶æ¼¹æ¼œæ»¼æ¼ºæ¼Ÿæ¼æ¼žæ¼ˆæ¼¡ç†‡ç†ç†‰ç†€ç†…ç†‚ç†ç…»ç††ç†ç†—ç‰„ç‰“çŠ—çŠ•çŠ“çƒçç‘çŒç‘¢ç‘³ç‘±ç‘µç‘²ç‘§ç‘®ç”€ç”‚ç”ƒç•½ç–ç˜–ç˜ˆç˜Œç˜•ç˜‘ç˜Šç˜”çš¸çžç¼çž…çž‚ç®çž€ç¯ç¾çžƒç¢²ç¢ªç¢´ç¢­ç¢¨ç¡¾ç¢«ç¢žç¢¥ç¢ ç¢¬ç¢¢ç¢¤ç¦˜ç¦Šç¦‹ç¦–ç¦•ç¦”ç¦“",
    ],
    [
      "e340",
      "ç¦—ç¦ˆç¦’ç¦ç¨«ç©Šç¨°ç¨¯ç¨¨ç¨¦çª¨çª«çª¬ç«®ç®ˆç®œç®Šç®‘ç®ç®–ç®ç®Œç®›ç®Žç®…ç®˜åŠ„ç®™ç®¤ç®‚ç²»ç²¿ç²¼ç²ºç¶§ç¶·ç·‚ç¶£ç¶ªç·ç·€ç·…ç¶ç·Žç·„ç·†ç·‹ç·Œç¶¯ç¶¹ç¶–ç¶¼ç¶Ÿç¶¦ç¶®ç¶©ç¶¡ç·‰ç½³ç¿¢ç¿£ç¿¥ç¿ž",
    ],
    [
      "e3a1",
      "è€¤èèœè†‰è††è†ƒè†‡è†è†Œè†‹èˆ•è’—è’¤è’¡è’Ÿè’ºè“Žè“‚è’¬è’®è’«è’¹è’´è“è“è’ªè’šè’±è“è’è’§è’»è’¢è’”è“‡è“Œè’›è’©è’¯è’¨è“–è’˜è’¶è“è’ è“—è“”è“’è“›è’°è’‘è™¡èœ³èœ£èœ¨è«è€èœ®èœžèœ¡èœ™èœ›èƒèœ¬èèœ¾è†èœ èœ²èœªèœ­èœ¼èœ’èœºèœ±èœµè‚èœ¦èœ§èœ¸èœ¤èœšèœ°èœ‘è£·è£§è£±è£²è£ºè£¾è£®è£¼è£¶è£»",
    ],
    [
      "e440",
      "è£°è£¬è£«è¦è¦¡è¦Ÿè¦žè§©è§«è§¨èª«èª™èª‹èª’èªèª–è°½è±¨è±©è³•è³è³—è¶–è¸‰è¸‚è·¿è¸è·½è¸Šè¸ƒè¸‡è¸†è¸…è·¾è¸€è¸„è¼è¼‘è¼Žè¼é„£é„œé„ é„¢é„Ÿé„é„šé„¤é„¡é„›é…ºé…²é…¹é…³éŠ¥éŠ¤é‰¶éŠ›é‰ºéŠ éŠ”éŠªéŠ",
    ],
    [
      "e4a1",
      "éŠ¦éŠšéŠ«é‰¹éŠ—é‰¿éŠ£é‹®éŠŽéŠ‚éŠ•éŠ¢é‰½éŠˆéŠ¡éŠŠéŠ†éŠŒéŠ™éŠ§é‰¾éŠ‡éŠ©éŠéŠ‹éˆ­éšžéš¡é›¿é˜é½éºé¾éžƒéž€éž‚é»éž„éžé¿éŸŽéŸé –é¢­é¢®é¤‚é¤€é¤‡é¦é¦œé§ƒé¦¹é¦»é¦ºé§‚é¦½é§‡éª±é«£é«§é¬¾é¬¿é­ é­¡é­Ÿé³±é³²é³µéº§åƒ¿å„ƒå„°åƒ¸å„†å„‡åƒ¶åƒ¾å„‹å„Œåƒ½å„ŠåŠ‹åŠŒå‹±å‹¯å™ˆå™‚å™Œå˜µå™å™Šå™‰å™†å™˜",
    ],
    [
      "e540",
      "å™šå™€å˜³å˜½å˜¬å˜¾å˜¸å˜ªå˜ºåœšå¢«å¢å¢±å¢ å¢£å¢¯å¢¬å¢¥å¢¡å£¿å«¿å«´å«½å«·å«¶å¬ƒå«¸å¬‚å«¹å¬å¬‡å¬…å¬å±§å¶™å¶—å¶Ÿå¶’å¶¢å¶“å¶•å¶ å¶œå¶¡å¶šå¶žå¹©å¹å¹ å¹œç·³å»›å»žå»¡å½‰å¾²æ†‹æ†ƒæ…¹æ†±æ†°æ†¢æ†‰",
    ],
    [
      "e5a1",
      "æ†›æ†“æ†¯æ†­æ†Ÿæ†’æ†ªæ†¡æ†æ…¦æ†³æˆ­æ‘®æ‘°æ’–æ’ æ’…æ’—æ’œæ’æ’‹æ’Šæ’Œæ’£æ’Ÿæ‘¨æ’±æ’˜æ•¶æ•ºæ•¹æ•»æ–²æ–³æšµæš°æš©æš²æš·æšªæš¯æ¨€æ¨†æ¨—æ§¥æ§¸æ¨•æ§±æ§¤æ¨ æ§¿æ§¬æ§¢æ¨›æ¨æ§¾æ¨§æ§²æ§®æ¨”æ§·æ§§æ©€æ¨ˆæ§¦æ§»æ¨æ§¼æ§«æ¨‰æ¨„æ¨˜æ¨¥æ¨æ§¶æ¨¦æ¨‡æ§´æ¨–æ­‘æ®¥æ®£æ®¢æ®¦æ°æ°€æ¯¿æ°‚æ½æ¼¦æ½¾æ¾‡æ¿†æ¾’",
    ],
    [
      "e640",
      "æ¾æ¾‰æ¾Œæ½¢æ½æ¾…æ½šæ¾–æ½¶æ½¬æ¾‚æ½•æ½²æ½’æ½æ½—æ¾”æ¾“æ½æ¼€æ½¡æ½«æ½½æ½§æ¾æ½“æ¾‹æ½©æ½¿æ¾•æ½£æ½·æ½ªæ½»ç†²ç†¯ç†›ç†°ç† ç†šç†©ç†µç†ç†¥ç†žç†¤ç†¡ç†ªç†œç†§ç†³çŠ˜çŠšç˜ç’çžçŸç çç›ç¡çšç™",
    ],
    [
      "e6a1",
      "ç¢ç’‡ç’‰ç’Šç’†ç’ç‘½ç’…ç’ˆç‘¼ç‘¹ç”ˆç”‡ç•¾ç˜¥ç˜žç˜™ç˜ç˜œç˜£ç˜šç˜¨ç˜›çšœçšçšžçš›çžçžçž‰çžˆç£ç¢»ç£ç£Œç£‘ç£Žç£”ç£ˆç£ƒç£„ç£‰ç¦šç¦¡ç¦ ç¦œç¦¢ç¦›æ­¶ç¨¹çª²çª´çª³ç®·ç¯‹ç®¾ç®¬ç¯Žç®¯ç®¹ç¯Šç®µç³…ç³ˆç³Œç³‹ç··ç·›ç·ªç·§ç·—ç·¡ç¸ƒç·ºç·¦ç·¶ç·±ç·°ç·®ç·Ÿç½¶ç¾¬ç¾°ç¾­ç¿­ç¿«ç¿ªç¿¬ç¿¦ç¿¨è¤è§è†£è†Ÿ",
    ],
    [
      "e740",
      "è†žè†•è†¢è†™è†—èˆ–è‰è‰“è‰’è‰è‰Žè‰‘è”¤è”»è”è”€è”©è”Žè”‰è”è”Ÿè”Šè”§è”œè“»è”«è“ºè”ˆè”Œè“´è”ªè“²è”•è“·è“«è“³è“¼è”’è“ªè“©è”–è“¾è”¨è”è”®è”‚è“½è”žè“¶è”±è”¦è“§è“¨è“°è“¯è“¹è”˜è” è”°è”‹è”™è”¯è™¢",
    ],
    [
      "e7a1",
      "è–è£è¤è·èŸ¡è³è˜è”è›è’è¡èšè‘èžè­èªèèŽèŸèè¯è¬èºè®èœè¥èè»èµè¢è§è©è¡šè¤…è¤Œè¤”è¤‹è¤—è¤˜è¤™è¤†è¤–è¤‘è¤Žè¤‰è¦¢è¦¤è¦£è§­è§°è§¬è«è«†èª¸è«“è«‘è«”è«•èª»è«—èª¾è«€è«…è«˜è«ƒèªºèª½è«™è°¾è±è²è³¥è³Ÿè³™è³¨è³šè³è³§è¶ è¶œè¶¡è¶›è¸ è¸£è¸¥è¸¤è¸®è¸•è¸›è¸–è¸‘è¸™è¸¦è¸§",
    ],
    [
      "e840",
      "è¸”è¸’è¸˜è¸“è¸œè¸—è¸šè¼¬è¼¤è¼˜è¼šè¼ è¼£è¼–è¼—é³é°é¯é§é«é„¯é„«é„©é„ªé„²é„¦é„®é†…é††é†Šé†é†‚é†„é†€é‹é‹ƒé‹„é‹€é‹™éŠ¶é‹é‹±é‹Ÿé‹˜é‹©é‹—é‹é‹Œé‹¯é‹‚é‹¨é‹Šé‹ˆé‹Žé‹¦é‹é‹•é‹‰é‹ é‹žé‹§é‹‘é‹“",
    ],
    [
      "e8a1",
      "éŠµé‹¡é‹†éŠ´é•¼é–¬é–«é–®é–°éš¤éš¢é›“éœ…éœˆéœ‚éšéžŠéžŽéžˆéŸéŸé žé é ¦é ©é ¨é  é ›é §é¢²é¤ˆé£ºé¤‘é¤”é¤–é¤—é¤•é§œé§é§é§“é§”é§Žé§‰é§–é§˜é§‹é§—é§Œéª³é«¬é««é«³é«²é«±é­†é­ƒé­§é­´é­±é­¦é­¶é­µé­°é­¨é­¤é­¬é³¼é³ºé³½é³¿é³·é´‡é´€é³¹é³»é´ˆé´…é´„éºƒé»“é¼é¼å„œå„“å„—å„šå„‘å‡žåŒ´å¡å™°å™ å™®",
    ],
    [
      "e940",
      "å™³å™¦å™£å™­å™²å™žå™·åœœåœ›å£ˆå¢½å£‰å¢¿å¢ºå£‚å¢¼å£†å¬—å¬™å¬›å¬¡å¬”å¬“å¬å¬–å¬¨å¬šå¬ å¬žå¯¯å¶¬å¶±å¶©å¶§å¶µå¶°å¶®å¶ªå¶¨å¶²å¶­å¶¯å¶´å¹§å¹¨å¹¦å¹¯å»©å»§å»¦å»¨å»¥å½‹å¾¼æ†æ†¨æ†–æ‡…æ†´æ‡†æ‡æ‡Œæ†º",
    ],
    [
      "e9a1",
      "æ†¿æ†¸æ†Œæ“—æ“–æ“æ“æ“‰æ’½æ’‰æ“ƒæ“›æ“³æ“™æ”³æ•¿æ•¼æ–¢æ›ˆæš¾æ›€æ›Šæ›‹æ›æš½æš»æšºæ›Œæœ£æ¨´æ©¦æ©‰æ©§æ¨²æ©¨æ¨¾æ©æ©­æ©¶æ©›æ©‘æ¨¨æ©šæ¨»æ¨¿æ©æ©ªæ©¤æ©æ©æ©”æ©¯æ©©æ© æ¨¼æ©žæ©–æ©•æ©æ©Žæ©†æ­•æ­”æ­–æ®§æ®ªæ®«æ¯ˆæ¯‡æ°„æ°ƒæ°†æ¾­æ¿‹æ¾£æ¿‡æ¾¼æ¿Žæ¿ˆæ½žæ¿„æ¾½æ¾žæ¿Šæ¾¨ç€„æ¾¥æ¾®æ¾ºæ¾¬æ¾ªæ¿æ¾¿æ¾¸",
    ],
    [
      "ea40",
      "æ¾¢æ¿‰æ¾«æ¿æ¾¯æ¾²æ¾°ç‡…ç‡‚ç†¿ç†¸ç‡–ç‡€ç‡ç‡‹ç‡”ç‡Šç‡‡ç‡ç†½ç‡˜ç†¼ç‡†ç‡šç‡›çŠçŠžç©ç¦ç§ç¬ç¥ç«çªç‘¿ç’šç’ ç’”ç’’ç’•ç’¡ç”‹ç–€ç˜¯ç˜­ç˜±ç˜½ç˜³ç˜¼ç˜µç˜²ç˜°çš»ç›¦çžšçžçž¡çžœçž›çž¢çž£çž•çž™",
    ],
    [
      "eaa1",
      "çž—ç£ç£©ç£¥ç£ªç£žç££ç£›ç£¡ç£¢ç£­ç£Ÿç£ ç¦¤ç©„ç©ˆç©‡çª¶çª¸çªµçª±çª·ç¯žç¯£ç¯§ç¯ç¯•ç¯¥ç¯šç¯¨ç¯¹ç¯”ç¯ªç¯¢ç¯œç¯«ç¯˜ç¯Ÿç³’ç³”ç³—ç³ç³‘ç¸’ç¸¡ç¸—ç¸Œç¸Ÿç¸ ç¸“ç¸Žç¸œç¸•ç¸šç¸¢ç¸‹ç¸ç¸–ç¸ç¸”ç¸¥ç¸¤ç½ƒç½»ç½¼ç½ºç¾±ç¿¯è€ªè€©è¬è†±è†¦è†®è†¹è†µè†«è†°è†¬è†´è†²è†·è†§è‡²è‰•è‰–è‰—è•–è•…è•«è•è•“è•¡è•˜",
    ],
    [
      "eb40",
      "è•€è•†è•¤è•è•¢è•„è•‘è•‡è•£è”¾è•›è•±è•Žè•®è•µè••è•§è• è–Œè•¦è•è•”è•¥è•¬è™£è™¥è™¤èž›èžèž—èž“èž’èžˆèžèž–èž˜è¹èž‡èž£èž…èžèž‘èžèž„èž”èžœèžšèž‰è¤žè¤¦è¤°è¤­è¤®è¤§è¤±è¤¢è¤©è¤£è¤¯è¤¬è¤Ÿè§±è« ",
    ],
    [
      "eba1",
      "è«¢è«²è«´è«µè«è¬”è«¤è«Ÿè«°è«ˆè«žè«¡è«¨è«¿è«¯è«»è²‘è²’è²è³µè³®è³±è³°è³³èµ¬èµ®è¶¥è¶§è¸³è¸¾è¸¸è¹€è¹…è¸¶è¸¼è¸½è¹è¸°è¸¿èº½è¼¶è¼®è¼µè¼²è¼¹è¼·è¼´é¶é¹é»é‚†éƒºé„³é„µé„¶é†“é†é†‘é†é†éŒ§éŒžéŒˆéŒŸéŒ†éŒéºéŒ¸éŒ¼éŒ›éŒ£éŒ’éŒé†éŒ­éŒŽéŒé‹‹éŒé‹ºéŒ¥éŒ“é‹¹é‹·éŒ´éŒ‚éŒ¤é‹¿éŒ©éŒ¹éŒµéŒªéŒ”éŒŒ",
    ],
    [
      "ec40",
      "éŒ‹é‹¾éŒ‰éŒ€é‹»éŒ–é–¼é—é–¾é–¹é–ºé–¶é–¿é–µé–½éš©é›”éœ‹éœ’éœéž™éž—éž”éŸ°éŸ¸é µé ¯é ²é¤¤é¤Ÿé¤§é¤©é¦žé§®é§¬é§¥é§¤é§°é§£é§ªé§©é§§éª¹éª¿éª´éª»é«¶é«ºé«¹é«·é¬³é®€é®…é®‡é­¼é­¾é­»é®‚é®“é®’é®é­ºé®•",
    ],
    [
      "eca1",
      "é­½é®ˆé´¥é´—é´ é´žé´”é´©é´é´˜é´¢é´é´™é´Ÿéºˆéº†éº‡éº®éº­é»•é»–é»ºé¼’é¼½å„¦å„¥å„¢å„¤å„ å„©å‹´åš“åšŒåšåš†åš„åšƒå™¾åš‚å™¿åšå£–å£”å£å£’å¬­å¬¥å¬²å¬£å¬¬å¬§å¬¦å¬¯å¬®å­»å¯±å¯²å¶·å¹¬å¹ªå¾¾å¾»æ‡ƒæ†µæ†¼æ‡§æ‡ æ‡¥æ‡¤æ‡¨æ‡žæ“¯æ“©æ“£æ“«æ“¤æ“¨æ–æ–€æ–¶æ—šæ›’æªæª–æªæª¥æª‰æªŸæª›æª¡æªžæª‡æª“æªŽ",
    ],
    [
      "ed40",
      "æª•æªƒæª¨æª¤æª‘æ©¿æª¦æªšæª…æªŒæª’æ­›æ®­æ°‰æ¿Œæ¾©æ¿´æ¿”æ¿£æ¿œæ¿­æ¿§æ¿¦æ¿žæ¿²æ¿æ¿¢æ¿¨ç‡¡ç‡±ç‡¨ç‡²ç‡¤ç‡°ç‡¢ç³ç®ç¯ç’—ç’²ç’«ç’ç’ªç’­ç’±ç’¥ç’¯ç”ç”‘ç”’ç”ç–„ç™ƒç™ˆç™‰ç™‡çš¤ç›©çžµçž«çž²çž·çž¶",
    ],
    [
      "eda1",
      "çž´çž±çž¨çŸ°ç£³ç£½ç¤‚ç£»ç£¼ç£²ç¤…ç£¹ç£¾ç¤„ç¦«ç¦¨ç©œç©›ç©–ç©˜ç©”ç©šçª¾ç«€ç«ç°…ç°ç¯²ç°€ç¯¿ç¯»ç°Žç¯´ç°‹ç¯³ç°‚ç°‰ç°ƒç°ç¯¸ç¯½ç°†ç¯°ç¯±ç°ç°Šç³¨ç¸­ç¸¼ç¹‚ç¸³é¡ˆç¸¸ç¸ªç¹‰ç¹€ç¹‡ç¸©ç¹Œç¸°ç¸»ç¸¶ç¹„ç¸ºç½…ç½¿ç½¾ç½½ç¿´ç¿²è€¬è†»è‡„è‡Œè‡Šè‡…è‡‡è†¼è‡©è‰›è‰šè‰œè–ƒè–€è–è–§è–•è– è–‹è–£è•»è–¤è–šè–ž",
    ],
    [
      "ee40",
      "è•·è•¼è–‰è–¡è•ºè•¸è•—è–Žè––è–†è–è–™è–è–è–¢è–‚è–ˆè–…è•¹è•¶è–˜è–è–Ÿè™¨èž¾èžªèž­èŸ…èž°èž¬èž¹èžµèž¼èž®èŸ‰èŸƒèŸ‚èŸŒèž·èž¯èŸ„èŸŠèž´èž¶èž¿èž¸èž½èŸžèž²è¤µè¤³è¤¼è¤¾è¥è¥’è¤·è¥‚è¦­è¦¯è¦®è§²è§³è¬ž",
    ],
    [
      "eea1",
      "è¬˜è¬–è¬‘è¬…è¬‹è¬¢è¬è¬’è¬•è¬‡è¬è¬ˆè¬†è¬œè¬“è¬šè±è±°è±²è±±è±¯è²•è²”è³¹èµ¯è¹Žè¹è¹“è¹è¹Œè¹‡è½ƒè½€é‚…é¾é„¸é†šé†¢é†›é†™é†Ÿé†¡é†é† éŽ¡éŽƒéŽ¯é¤é–é‡é¼é˜éœé¶é‰éé‘é é­éŽéŒéªé¹é—é•é’éé±é·é»é¡éžé£é§éŽ€éŽé™é—‡é—€é—‰é—ƒé—…é–·éš®éš°éš¬éœ éœŸéœ˜éœéœ™éžšéž¡éžœ",
    ],
    [
      "ef40",
      "éžžéžéŸ•éŸ”éŸ±é¡é¡„é¡Šé¡‰é¡…é¡ƒé¤¥é¤«é¤¬é¤ªé¤³é¤²é¤¯é¤­é¤±é¤°é¦˜é¦£é¦¡é¨‚é§ºé§´é§·é§¹é§¸é§¶é§»é§½é§¾é§¼é¨ƒéª¾é«¾é«½é¬é«¼é­ˆé®šé®¨é®žé®›é®¦é®¡é®¥é®¤é®†é®¢é® é®¯é´³éµéµ§é´¶é´®é´¯é´±é´¸é´°",
    ],
    [
      "efa1",
      "éµ…éµ‚éµƒé´¾é´·éµ€é´½ç¿µé´­éºŠéº‰éºéº°é»ˆé»šé»»é»¿é¼¤é¼£é¼¢é½”é¾ å„±å„­å„®åš˜åšœåš—åššåšåš™å¥°å¬¼å±©å±ªå·€å¹­å¹®æ‡˜æ‡Ÿæ‡­æ‡®æ‡±æ‡ªæ‡°æ‡«æ‡–æ‡©æ“¿æ”„æ“½æ“¸æ”æ”ƒæ“¼æ–”æ—›æ›šæ››æ›˜æ«…æª¹æª½æ«¡æ«†æªºæª¶æª·æ«‡æª´æª­æ­žæ¯‰æ°‹ç€‡ç€Œç€ç€ç€…ç€”ç€Žæ¿¿ç€€æ¿»ç€¦æ¿¼æ¿·ç€Šçˆç‡¿ç‡¹çˆƒç‡½ç¶",
    ],
    [
      "f040",
      "ç’¸ç“€ç’µç“ç’¾ç’¶ç’»ç“‚ç””ç”“ç™œç™¤ç™™ç™ç™“ç™—ç™šçš¦çš½ç›¬çŸ‚çžºç£¿ç¤Œç¤“ç¤”ç¤‰ç¤ç¤’ç¤‘ç¦­ç¦¬ç©Ÿç°œç°©ç°™ç° ç°Ÿç°­ç°ç°¦ç°¨ç°¢ç°¥ç°°ç¹œç¹ç¹–ç¹£ç¹˜ç¹¢ç¹Ÿç¹‘ç¹ ç¹—ç¹“ç¾µç¾³ç¿·ç¿¸èµè‡‘è‡’",
    ],
    [
      "f0a1",
      "è‡è‰Ÿè‰žè–´è—†è—€è—ƒè—‚è–³è–µè–½è—‡è—„è–¿è—‹è—Žè—ˆè—…è–±è–¶è—’è˜¤è–¸è–·è–¾è™©èŸ§èŸ¦èŸ¢èŸ›èŸ«èŸªèŸ¥èŸŸèŸ³èŸ¤èŸ”èŸœèŸ“èŸ­èŸ˜èŸ£èž¤èŸ—èŸ™è èŸ´èŸ¨èŸè¥“è¥‹è¥è¥Œè¥†è¥è¥‘è¥‰è¬ªè¬§è¬£è¬³è¬°è¬µè­‡è¬¯è¬¼è¬¾è¬±è¬¥è¬·è¬¦è¬¶è¬®è¬¤è¬»è¬½è¬ºè±‚è±µè²™è²˜è²—è³¾è´„è´‚è´€è¹œè¹¢è¹ è¹—è¹–è¹žè¹¥è¹§",
    ],
    [
      "f140",
      "è¹›è¹šè¹¡è¹è¹©è¹”è½†è½‡è½ˆè½‹é„¨é„ºé„»é„¾é†¨é†¥é†§é†¯é†ªéŽµéŽŒéŽ’éŽ·éŽ›éŽéŽ‰éŽ§éŽŽéŽªéŽžéŽ¦éŽ•éŽˆéŽ™éŽŸéŽéŽ±éŽ‘éŽ²éŽ¤éŽ¨éŽ´éŽ£éŽ¥é—’é—“é—‘éš³é›—é›šå·‚é›Ÿé›˜é›éœ£éœ¢éœ¥éž¬éž®éž¨éž«éž¤éžª",
    ],
    [
      "f1a1",
      "éž¢éž¥éŸ—éŸ™éŸ–éŸ˜éŸºé¡é¡‘é¡’é¢¸é¥é¤¼é¤ºé¨é¨‹é¨‰é¨é¨„é¨‘é¨Šé¨…é¨‡é¨†é«€é«œé¬ˆé¬„é¬…é¬©é¬µé­Šé­Œé­‹é¯‡é¯†é¯ƒé®¿é¯é®µé®¸é¯“é®¶é¯„é®¹é®½éµœéµ“éµéµŠéµ›éµ‹éµ™éµ–éµŒéµ—éµ’éµ”éµŸéµ˜éµšéºŽéºŒé»Ÿé¼é¼€é¼–é¼¥é¼«é¼ªé¼©é¼¨é½Œé½•å„´å„µåŠ–å‹·åŽ´åš«åš­åš¦åš§åšªåš¬å£šå£å£›å¤’å¬½å¬¾å¬¿å·ƒå¹°",
    ],
    [
      "f240",
      "å¾¿æ‡»æ”‡æ”æ”æ”‰æ”Œæ”Žæ–„æ—žæ—æ›žæ«§æ« æ«Œæ«‘æ«™æ«‹æ«Ÿæ«œæ«æ««æ«æ«æ«žæ­ æ®°æ°Œç€™ç€§ç€ ç€–ç€«ç€¡ç€¢ç€£ç€©ç€—ç€¤ç€œç€ªçˆŒçˆŠçˆ‡çˆ‚çˆ…çŠ¥çŠ¦çŠ¤çŠ£çŠ¡ç“‹ç“…ç’·ç“ƒç”–ç™ çŸ‰çŸŠçŸ„çŸ±ç¤ç¤›",
    ],
    [
      "f2a1",
      "ç¤¡ç¤œç¤—ç¤žç¦°ç©§ç©¨ç°³ç°¼ç°¹ç°¬ç°»ç³¬ç³ªç¹¶ç¹µç¹¸ç¹°ç¹·ç¹¯ç¹ºç¹²ç¹´ç¹¨ç½‹ç½Šç¾ƒç¾†ç¾·ç¿½ç¿¾è¸è‡—è‡•è‰¤è‰¡è‰£è—«è—±è—­è—™è—¡è—¨è—šè——è—¬è—²è—¸è—˜è—Ÿè—£è—œè—‘è—°è—¦è—¯è—žè—¢è €èŸºè ƒèŸ¶èŸ·è ‰è Œè ‹è †èŸ¼è ˆèŸ¿è Šè ‚è¥¢è¥šè¥›è¥—è¥¡è¥œè¥˜è¥è¥™è¦ˆè¦·è¦¶è§¶è­è­ˆè­Šè­€è­“è­–è­”è­‹è­•",
    ],
    [
      "f340",
      "è­‘è­‚è­’è­—è±ƒè±·è±¶è²šè´†è´‡è´‰è¶¬è¶ªè¶­è¶«è¹­è¹¸è¹³è¹ªè¹¯è¹»è»‚è½’è½‘è½è½è½“è¾´é…€é„¿é†°é†­éžé‡éé‚éšéé¹é¬éŒé™éŽ©é¦éŠé”é®é£é•é„éŽé€é’é§é•½é—šé—›é›¡éœ©éœ«éœ¬éœ¨éœ¦",
    ],
    [
      "f3a1",
      "éž³éž·éž¶éŸéŸžéŸŸé¡œé¡™é¡é¡—é¢¿é¢½é¢»é¢¾é¥ˆé¥‡é¥ƒé¦¦é¦§é¨šé¨•é¨¥é¨é¨¤é¨›é¨¢é¨ é¨§é¨£é¨žé¨œé¨”é«‚é¬‹é¬Šé¬Žé¬Œé¬·é¯ªé¯«é¯ é¯žé¯¤é¯¦é¯¢é¯°é¯”é¯—é¯¬é¯œé¯™é¯¥é¯•é¯¡é¯šéµ·é¶é¶Šé¶„é¶ˆéµ±é¶€éµ¸é¶†é¶‹é¶Œéµ½éµ«éµ´éµµéµ°éµ©é¶…éµ³éµ»é¶‚éµ¯éµ¹éµ¿é¶‡éµ¨éº”éº‘é»€é»¼é¼­é½€é½é½é½–é½—é½˜åŒ·åš²",
    ],
    [
      "f440",
      "åšµåš³å££å­…å·†å·‡å»®å»¯å¿€å¿æ‡¹æ”—æ”–æ”•æ”“æ—Ÿæ›¨æ›£æ›¤æ«³æ«°æ«ªæ«¨æ«¹æ«±æ«®æ«¯ç€¼ç€µç€¯ç€·ç€´ç€±ç‚ç€¸ç€¿ç€ºç€¹ç€ç€»ç€³ççˆ“çˆ”çŠ¨ç½ç¼ç’ºçš«çšªçš¾ç›­çŸŒçŸŽçŸçŸçŸ²ç¤¥ç¤£ç¤§ç¤¨ç¤¤ç¤©",
    ],
    [
      "f4a1",
      "ç¦²ç©®ç©¬ç©­ç«·ç±‰ç±ˆç±Šç±‡ç±…ç³®ç¹»ç¹¾çºçº€ç¾ºç¿¿è¹è‡›è‡™èˆ‹è‰¨è‰©è˜¢è—¿è˜è—¾è˜›è˜€è—¶è˜„è˜‰è˜…è˜Œè—½è ™è è ‘è —è “è –è¥£è¥¦è¦¹è§·è­ è­ªè­è­¨è­£è­¥è­§è­­è¶®èº†èºˆèº„è½™è½–è½—è½•è½˜è½šé‚é…ƒé…é†·é†µé†²é†³é‹é“é»é éé”é¾é•éé¨é™ééµé€é·é‡éŽé–é’éºé‰é¸éŠé¿",
    ],
    [
      "f540",
      "é¼éŒé¶é‘é†é—žé— é—Ÿéœ®éœ¯éž¹éž»éŸ½éŸ¾é¡ é¡¢é¡£é¡Ÿé£é£‚é¥é¥Žé¥™é¥Œé¥‹é¥“é¨²é¨´é¨±é¨¬é¨ªé¨¶é¨©é¨®é¨¸é¨­é«‡é«Šé«†é¬é¬’é¬‘é°‹é°ˆé¯·é°…é°’é¯¸é±€é°‡é°Žé°†é°—é°”é°‰é¶Ÿé¶™é¶¤é¶é¶’é¶˜é¶é¶›",
    ],
    [
      "f5a1",
      "é¶ é¶”é¶œé¶ªé¶—é¶¡é¶šé¶¢é¶¨é¶žé¶£é¶¿é¶©é¶–é¶¦é¶§éº™éº›éºšé»¥é»¤é»§é»¦é¼°é¼®é½›é½ é½žé½é½™é¾‘å„ºå„¹åŠ˜åŠ—å›ƒåš½åš¾å­ˆå­‡å·‹å·å»±æ‡½æ”›æ¬‚æ«¼æ¬ƒæ«¸æ¬€çƒç„çŠçˆç‰ç…ç†çˆçˆšçˆ™ç¾ç”—ç™ªçŸç¤­ç¤±ç¤¯ç±”ç±“ç³²çºŠçº‡çºˆçº‹çº†çºç½ç¾»è€°è‡è˜˜è˜ªè˜¦è˜Ÿè˜£è˜œè˜™è˜§è˜®è˜¡è˜ è˜©è˜žè˜¥",
    ],
    [
      "f640",
      "è ©è è ›è  è ¤è œè «è¡Šè¥­è¥©è¥®è¥«è§ºè­¹è­¸è­…è­ºè­»è´è´”è¶¯èºŽèºŒè½žè½›è½é…†é…„é……é†¹é¿é»é¶é©é½é¼é°é¹éªé·é¬é‘€é±é—¥é—¤é—£éœµéœºéž¿éŸ¡é¡¤é£‰é£†é£€é¥˜é¥–é¨¹é¨½é©†é©„é©‚é©é¨º",
    ],
    [
      "f6a1",
      "é¨¿é«é¬•é¬—é¬˜é¬–é¬ºé­’é°«é°é°œé°¬é°£é°¨é°©é°¤é°¡é¶·é¶¶é¶¼é·é·‡é·Šé·é¶¾é·…é·ƒé¶»é¶µé·Žé¶¹é¶ºé¶¬é·ˆé¶±é¶­é·Œé¶³é·é¶²é¹ºéºœé»«é»®é»­é¼›é¼˜é¼šé¼±é½Žé½¥é½¤é¾’äº¹å›†å›…å›‹å¥±å­‹å­Œå·•å·‘å»²æ”¡æ” æ”¦æ”¢æ¬‹æ¬ˆæ¬‰æ°ç•ç–ç—ç’çˆžçˆŸçŠ©ç¿ç“˜ç“•ç“™ç“—ç™­çš­ç¤µç¦´ç©°ç©±ç±—ç±œç±™ç±›ç±š",
    ],
    [
      "f740",
      "ç³´ç³±çº‘ç½ç¾‡è‡žè‰«è˜´è˜µè˜³è˜¬è˜²è˜¶è ¬è ¨è ¦è ªè ¥è¥±è¦¿è¦¾è§»è­¾è®„è®‚è®†è®…è­¿è´•èº•èº”èºšèº’èºèº–èº—è½ è½¢é…‡é‘Œé‘é‘Šé‘‹é‘é‘‡é‘…é‘ˆé‘‰é‘†éœ¿éŸ£é¡ªé¡©é£‹é¥”é¥›é©Žé©“é©”é©Œé©é©ˆé©Š",
    ],
    [
      "f7a1",
      "é©‰é©’é©é«é¬™é¬«é¬»é­–é­•é±†é±ˆé°¿é±„é°¹é°³é±é°¼é°·é°´é°²é°½é°¶é·›é·’é·žé·šé·‹é·é·œé·‘é·Ÿé·©é·™é·˜é·–é·µé·•é·éº¶é»°é¼µé¼³é¼²é½‚é½«é¾•é¾¢å„½åŠ™å£¨å£§å¥²å­å·˜è ¯å½æˆæˆƒæˆ„æ”©æ”¥æ––æ›«æ¬‘æ¬’æ¬æ¯Šç›çšçˆ¢çŽ‚çŽçŽƒç™°çŸ”ç±§ç±¦çº•è‰¬è˜ºè™€è˜¹è˜¼è˜±è˜»è˜¾è °è ²è ®è ³è¥¶è¥´è¥³è§¾",
    ],
    [
      "f840",
      "è®Œè®Žè®‹è®ˆè±…è´™èº˜è½¤è½£é†¼é‘¢é‘•é‘é‘—é‘žéŸ„éŸ…é €é©–é©™é¬žé¬Ÿé¬ é±’é±˜é±é±Šé±é±‹é±•é±™é±Œé±Žé·»é··é·¯é·£é·«é·¸é·¤é·¶é·¡é·®é·¦é·²é·°é·¢é·¬é·´é·³é·¨é·­é»‚é»é»²é»³é¼†é¼œé¼¸é¼·é¼¶é½ƒé½",
    ],
    [
      "f8a1",
      "é½±é½°é½®é½¯å›“å›å­Žå±­æ”­æ›­æ›®æ¬“çŸç¡çç çˆ£ç“›ç“¥çŸ•ç¤¸ç¦·ç¦¶ç±ªçº—ç¾‰è‰­è™ƒè ¸è ·è µè¡‹è®”è®•èºžèºŸèº èºé†¾é†½é‡‚é‘«é‘¨é‘©é›¥é†éƒé‡éŸ‡éŸ¥é©žé«•é­™é±£é±§é±¦é±¢é±žé± é¸‚é·¾é¸‡é¸ƒé¸†é¸…é¸€é¸é¸‰é·¿é·½é¸„éº é¼žé½†é½´é½µé½¶å›”æ”®æ–¸æ¬˜æ¬™æ¬—æ¬šç¢çˆ¦çŠªçŸ˜çŸ™ç¤¹ç±©ç±«ç³¶çºš",
    ],
    [
      "f940",
      "çº˜çº›çº™è‡ è‡¡è™†è™‡è™ˆè¥¹è¥ºè¥¼è¥»è§¿è®˜è®™èº¥èº¤èº£é‘®é‘­é‘¯é‘±é‘³é‰é¡²é¥Ÿé±¨é±®é±­é¸‹é¸é¸é¸é¸’é¸‘éº¡é»µé¼‰é½‡é½¸é½»é½ºé½¹åœžç¦ç±¯è ¼è¶²èº¦é‡ƒé‘´é‘¸é‘¶é‘µé© é±´é±³é±±é±µé¸”é¸“é»¶é¼Š",
    ],
    [
      "f9a1",
      "é¾¤ç¨ç¥ç³·è™ªè ¾è ½è ¿è®žè²œèº©è»‰é‹é¡³é¡´é£Œé¥¡é¦«é©¤é©¦é©§é¬¤é¸•é¸—é½ˆæˆ‡æ¬žçˆ§è™Œèº¨é’‚é’€é’é©©é©¨é¬®é¸™çˆ©è™‹è®Ÿé’ƒé±¹éº·ç™µé©«é±ºé¸ç©çªéº¤é½¾é½‰é¾˜ç¢éŠ¹è£å¢»æ’ç²§å«ºâ•”â•¦â•—â• â•¬â•£â•šâ•©â•â•’â•¤â••â•žâ•ªâ•¡â•˜â•§â•›â•“â•¥â•–â•Ÿâ•«â•¢â•™â•¨â•œâ•‘â•â•­â•®â•°â•¯â–“",
    ],
  ],
  TN = [
    [
      "8740",
      "ä°ä°²ä˜ƒä–¦ä•¸ð§‰§äµ·ä–³ð§²±ä³¢ð§³…ã®•äœ¶ä„ä±‡ä±€ð¤Š¿ð£˜—ð§’ð¦º‹ð§ƒ’ä±—ðª‘ää—šä²…ð§±¬ä´‡äª¤äš¡ð¦¬£çˆ¥ð¥©”ð¡©£ð£¸†ð£½¡æ™å›»",
    ],
    ["8767", "ç¶•å¤ð¨®¹ã·´éœ´ð§¯¯å¯›ð¡µžåª¤ã˜¥ð©º°å«‘å®·å³¼æ®è–“ð©¥…ç‘¡ç’ã¡µð¡µ“ð£šžð¦€¡ã»¬"],
    [
      "87a1",
      "ð¥£žã«µç«¼é¾—ð¤…¡ð¨¤ð£‡ªð ªŠð£‰žäŒŠè’„é¾–é¯ä¤°è˜“å¢–éŠéˆ˜ç§ç¨²æ™ æ¨©è¢ç‘Œç¯…æž‚ç¨¬å‰é†ã“¦ç„ð¥¶¹ç“†é¿‡åž³ä¤¯å‘Œä„±ð£šŽå ˜ç©²ð§­¥è®äš®ð¦ºˆä†ð¥¶™ç®®ð¢’¼é¿ˆð¢“ð¢“‰ð¢“Œé¿‰è”„ð£–»ä‚´é¿Šä“¡ðª·¿æ‹ç®é¿‹",
    ],
    [
      "8840",
      "ã‡€",
      4,
      "ð „Œã‡…ð ƒ‘ð ƒã‡†ã‡‡ð ƒ‹ð¡¿¨ã‡ˆð ƒŠã‡‰ã‡Šã‡‹ã‡Œð „Žã‡ã‡ŽÄ€ÃÇÃ€Ä’Ã‰ÄšÃˆÅŒÃ“Ç‘Ã’à¿¿ÃŠÌ„áº¾à¿¿ÃŠÌŒá»€ÃŠÄÃ¡ÇŽÃ É‘Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜Çš",
    ],
    ["88a1", "ÇœÃ¼à¿¿ÃªÌ„áº¿à¿¿ÃªÌŒá»ÃªÉ¡âšâ›"],
    ["8940", "ðªŽ©ð¡……"],
    ["8943", "æ”Š"],
    ["8946", "ä¸½æ»éµŽé‡Ÿ"],
    [
      "894c",
      "ð§œµæ’‘ä¼šä¼¨ä¾¨å…–å…´å†œå‡¤åŠ¡åŠ¨åŒ»åŽå‘å˜å›¢å£°å¤„å¤‡å¤²å¤´å­¦å®žå®Ÿå²šåº†æ€»æ–‰æŸ¾æ „æ¡¥æµŽç‚¼ç”µçº¤çº¬çººç»‡ç»ç»Ÿç¼†ç¼·è‰ºè‹è¯è§†è®¾è¯¢è½¦è½§è½®",
    ],
    ["89a1", "ç‘ç³¼ç·æ¥†ç«‰åˆ§"],
    ["89ab", "é†Œç¢¸é…žè‚¼"],
    ["89b0", "è´‹èƒ¶ð §§"],
    ["89b5", "è‚Ÿé»‡ä³é·‰é¸Œä°¾ð©·¶ð§€Žé¸Šðª„³ã—"],
    ["89c1", "æºšèˆ¾ç”™"],
    [
      "89c5",
      "ä¤‘é©¬éªé¾™ç¦‡ð¨‘¬ð¡·Šð —ð¢«¦ä¸¤äºäº€äº‡äº¿ä»«ä¼·ã‘Œä¾½ã¹ˆå€ƒå‚ˆã‘½ã’“ã’¥å††å¤…å‡›å‡¼åˆ…äº‰å‰¹åŠåŒ§ã—‡åŽ©ã•‘åŽ°ã•“å‚å£ã•­ã•²ãšå’“å’£å’´å’¹å“å“¯å”˜å”£å”¨ã–˜å”¿ã–¥ã–¿å——ã—…",
    ],
    ["8a40", "ð§¶„å”¥"],
    [
      "8a43",
      "ð ±‚ð ´•ð¥„«å–ð¢³†ã§¬ð è¹†ð¤¶¸ð©“¥ä“ð¨‚¾çºð¢°¸ã¨´äŸ•ð¨…ð¦§²ð¤·ªæ“ð µ¼ð ¾´ð ³•ð¡ƒ´æ’è¹¾ð º–ð °‹ð ½¤ð¢²©ð¨‰–ð¤““",
    ],
    ["8a64", "ð µ†ð©©ð¨ƒ©äŸ´ð¤º§ð¢³‚éª²ã©§ð©—´ã¿­ã”†ð¥‹‡ð©Ÿ”ð§£ˆð¢µ„éµ®é •"],
    ["8a76", "ä™ð¦‚¥æ’´å“£ð¢µŒð¢¯Šð¡·ã§»ð¡¯"],
    ["8aa1", "ð¦›šð¦œ–ð§¦ æ“ªð¥’ð ±ƒè¹¨ð¢†¡ð¨­Œð œ±"],
    ["8aac", "ä ‹ð †©ã¿ºå¡³ð¢¶"],
    ["8ab2", "ð¤—ˆð “¼ð¦‚—ð ½Œð ¶–å•¹ä‚»äŽº"],
    ["8abb", "äª´ð¢©¦ð¡‚è†ªé£µð ¶œæ¹ã§¾ð¢µè·€åš¡æ‘¼ã¹ƒ"],
    ["8ac9", "ðª˜ð ¸‰ð¢«ð¢³‰"],
    ["8ace", "ð¡ƒˆð£§‚ã¦’ã¨†ð¨Š›ã•¸ð¥¹‰ð¢ƒ‡å™’ð ¼±ð¢²²ð©œ ã’¼æ°½ð¤¸»"],
    ["8adf", "ð§•´ð¢º‹ð¢ˆˆðª™›ð¨³ð ¹ºð °´ð¦ œç¾“ð¡ƒð¢ ƒð¢¤¹ã—»ð¥‡£ð ºŒð ¾ð ºªã¾“ð ¼°ð µ‡ð¡…ð ¹Œ"],
    ["8af6", "ð º«ð ®©ð µˆð¡ƒ€ð¡„½ã¿¹ð¢š–æ²ð ¾­"],
    ["8b40", "ð£´ð§˜¹ð¢¯Žð µ¾ð µ¿ð¢±‘ð¢±•ã¨˜ð º˜ð¡ƒ‡ð ¼®ðª˜²ð¦­ð¨³’ð¨¶™ð¨³Šé–ªå“Œè‹„å–¹"],
    [
      "8b55",
      "ð©»ƒé°¦éª¶ð§žð¢·®ç…€è…­èƒ¬å°œð¦•²è„´ãž—åŸð¨‚½é†¶ð »ºð ¸ð ¹·ð »»ã—ð¤·«ã˜‰ð ³–åš¯ð¢žµð¡ƒ‰ð ¸ð ¹¸ð¡¸ð¡…ˆð¨ˆ‡ð¡‘•ð ¹¹ð¤¹ð¢¶¤å©”ð¡€ð¡€žð¡ƒµð¡ƒ¶åžœð ¸‘",
    ],
    [
      "8ba1",
      "ð§š”ð¨‹ð ¾µð ¹»ð¥…¾ãœƒð ¾¶ð¡†€ð¥‹˜ðªŠ½ð¤§šð¡ ºð¤…·ð¨‰¼å¢™å‰¨ã˜šð¥œ½ç®²å­¨ä €ä¬¬é¼§ä§§é°Ÿé®ð¥­´ð£„½å—»ã—²åš‰ä¸¨å¤‚ð¡¯ð¯¡¸é‘ð ‚†ä¹›äº»ã”¾å°£å½‘å¿„ã£ºæ‰Œæ”µæ­ºæ°µæ°ºç¬çˆ«ä¸¬çŠ­ð¤£©ç½’ç¤»ç³¹ç½“ð¦‰ªã“",
    ],
    [
      "8bde",
      "ð¦‹è€‚è‚€ð¦˜’ð¦¥‘åè¡¤è§ð§¢²è® è´é’…é•¸é•¿é—¨ð¨¸éŸ¦é¡µé£Žé£žé¥£ð© é±¼é¸Ÿé»„æ­¯ï¤‡ä¸·ð ‚‡é˜æˆ·é’¢",
    ],
    [
      "8c40",
      "å€»æ·¾ð©±³é¾¦ã·‰è¢ð¤…Žç·å³µä¬ ð¥‡ã•™ð¥´°æ„¢ð¨¨²è¾§é‡¶ç†‘æœ™çŽºð£Šðª„‡ã²‹ð¡¦€ä¬ç£¤ç‚å†®ð¨œä€‰æ©£ðªŠºäˆ£è˜ð ©¯ç¨ªð©¥‡ð¨«ªé•çåŒ¤ð¢¾é´ç›™ð¨§£é¾§çŸäº£ä¿°å‚¼ä¸¯ä¼—é¾¨å´ç¶‹å¢’å£ð¡¶¶åº’åº™å¿‚ð¢œ’æ–‹",
    ],
    ["8ca1", "ð£¹æ¤™æ©ƒð£±£æ³¿"],
    ["8ca7", "çˆ€ð¤”…çŽŒã»›ð¤¨“å¬•ç’¹è®ƒð¥²¤ð¥š•çª“ç¯¬ç³ƒç¹¬è‹¸è–—é¾©è¢é¾ªèº¹é¾«è¿è•Ÿé§ éˆ¡é¾¬ð¨¶¹ð¡¿ä±äŠ¢å¨š"],
    ["8cc9", "é¡¨æ«ä‰¶åœ½"],
    ["8cce", "è—–ð¤¥»èŠ¿ð§„ä²ð¦µ´åµ»ð¦¬•ð¦¾¾é¾­é¾®å®–é¾¯æ›§ç¹›æ¹—ç§Šã¶ˆä“ƒð£‰–ð¢ž–äŽšä”¶"],
    ["8ce6", "å³•ð£¬šè«¹å±¸ã´’ð£•‘åµ¸é¾²ç…—ä•˜ð¤ƒ¬ð¡¸£ä±·ã¥¸ã‘Šð †¤ð¦±è«Œä¾´ð ˆ¹å¦¿è…¬é¡–ð©£ºå¼»"],
    ["8d40", "ð ®Ÿ"],
    [
      "8d42",
      "ð¢‡ð¨¥­ä„‚äš»ð©¹ã¼‡é¾³ðª†µäƒ¸ãŸ–ä›·ð¦±†ä…¼ð¨š²ð§¿ä•­ã£”ð¥’šä•¡ä”›ä¶‰ä±»äµ¶ä—ªã¿ˆð¤¬ã™¡ä“žä’½ä‡­å´¾åµˆåµ–ã·¼ã å¶¤å¶¹ã  ã ¸å¹‚åº½å¼¥å¾ƒã¤ˆã¤”ã¤¿ã¥æƒ—æ„½å³¥ã¦‰æ†·æ†¹æ‡ã¦¸æˆ¬æŠæ‹¥æŒ˜ã§¸åš±",
    ],
    [
      "8da1",
      "ã¨ƒæ¢æ»æ‡æ‘šã©‹æ“€å´•å˜¡é¾Ÿãª—æ–†ãª½æ—¿æ™“ã«²æš’ã¬¢æœ–ã­‚æž¤æ €ã­˜æ¡Šæ¢„ã­²ã­±ã­»æ¤‰æ¥ƒç‰œæ¥¤æ¦Ÿæ¦…ã®¼æ§–ã¯æ©¥æ©´æ©±æª‚ã¯¬æª™ã¯²æª«æªµæ«”æ«¶æ®æ¯æ¯ªæ±µæ²ªã³‹æ´‚æ´†æ´¦æ¶ã³¯æ¶¤æ¶±æ¸•æ¸˜æ¸©æº†ð¨§€æº»æ»¢æ»šé½¿æ»¨æ»©æ¼¤æ¼´ãµ†ð£½æ¾æ¾¾ãµªãµµç†·å²™ã¶Šç€¬ã¶‘çç”ç¯ç¿ç‚‰ð Œ¥äã—±ð »˜",
    ],
    [
      "8e40",
      "ð£»—åž¾ð¦»“ç„¾ð¥Ÿ ã™Žæ¦¢ð¨¯©å­´ç©‰ð¥£¡ð©“™ç©¥ç©½ð¥¦¬çª»çª°ç«‚ç«ƒç‡‘ð¦’ä‡Šç«šç«ç«ªä‡¯å’²ð¥°ç¬‹ç­•ç¬©ð¥ŒŽð¥³¾ç®¢ç­¯èŽœð¥®´ð¦±¿ç¯è¡ç®’ç®¸ð¥´ ã¶­ð¥±¥è’’ç¯ºç°†ç°µð¥³ç±„ç²ƒð¤¢‚ç²¦æ™½ð¤•¸ç³‰ç³‡ç³¦ç±´ç³³ç³µç³Ž",
    ],
    [
      "8ea1",
      "ç¹§ä”ð¦¹„çµð¦»–ç’ç¶‰ç¶«ç„µç¶³ç·’ð¤—ð¦€©ç·¤ã´“ç·µð¡Ÿ¹ç·¥ð¨­ç¸ð¦„¡ð¦…šç¹®çº’äŒ«é‘¬ç¸§ç½€ç½ç½‡ç¤¶ð¦‹é§¡ç¾—ð¦‘ç¾£ð¡™¡ð ¨ä•œð£¦ä”ƒð¨Œºç¿ºð¦’‰è€…è€ˆè€è€¨è€¯ðª‚‡ð¦³ƒè€»è€¼è¡ð¢œ”ä¦‰ð¦˜¦ð£·£ð¦›¨æœ¥è‚§ð¨©ˆè„‡è„šå¢°ð¢›¶æ±¿ð¦’˜ð¤¾¸æ“§ð¡’Šèˆ˜ð¡¡žæ©“ð¤©¥ð¤ª•ä‘ºèˆ©ð ¬ð¦©’ð£µ¾ä¿¹ð¡“½è“¢è¢ð¦¬Šð¤¦§ð£”°ð¡³ð£·¸èŠªæ¤›ð¯¦”ä‡›",
    ],
    [
      "8f40",
      "è•‹è‹èŒšð ¸–ð¡ž´ã›ð£…½ð£•šè‰»è‹¢èŒ˜ð£º‹ð¦¶£ð¦¬…ð¦®—ð£—Žã¶¿èŒå—¬èŽ…ä”‹ð¦¶¥èŽ¬èè“ã‘¾ð¦»”æ©—è•šã’–ð¦¹‚ð¢»¯è‘˜ð¥¯¤è‘±ã·“ä“¤æª§è‘Šð£²µç¥˜è’¨ð¦®–ð¦¹·ð¦¹ƒè“žèèŽ‘ä’ è’“è“¤ð¥²‘ä‰€ð¥³€ä•ƒè”´å«²ð¦º™ä”§è•³ä”–æž¿è˜–",
    ],
    [
      "8fa1",
      "ð¨˜¥ð¨˜»è—ð§‚ˆè˜‚ð¡–‚ð§ƒð¯¦²ä•ªè˜¨ã™ˆð¡¢¢å·ð§Žšè™¾è±ðªƒ¸èŸ®ð¢°§èž±èŸšè å™¡è™¬æ¡–ä˜è¡…è¡†ð§— ð£¶¹ð§—¤è¡žè¢œä™›è¢´è¢µæè£…ç·ð§œè¦‡è¦Šè¦¦è¦©è¦§è¦¼ð¨¨¥è§§ð§¤¤ð§ª½èªœçž“é‡¾èªð§©™ç«©ð§¬ºð£¾äœ“ð§¬¸ç…¼è¬Œè¬Ÿð¥°ð¥•¥è¬¿è­Œè­èª©ð¤©ºè®è®›èª¯ð¡›Ÿä˜•è¡è²›ð§µ”ð§¶ð¯§”ãœ¥ð§µ“è³–ð§¶˜ð§¶½è´’è´ƒð¡¤è³›çœè´‘ð¤³‰ã»èµ·",
    ],
    [
      "9040",
      "è¶©ð¨€‚ð¡€”ð¤¦Šã­¼ð¨†¼ð§„Œç«§èº­èº¶è»ƒé‹”è¼™è¼­ð¨¥ð¨’è¾¥éŒƒðªŠŸð ©è¾³ä¤ªð¨§žð¨”½ð£¶»å»¸ð£‰¢è¿¹ðª€”ð¨š¼ð¨”ð¢Œ¥ã¦€ð¦»—é€·ð¨”¼ð§ª¾é¡ð¨•¬ð¨˜‹é‚¨ð¨œ“éƒ„ð¨›¦é‚®éƒ½é…§ã«°é†©é‡„ç²¬ð¨¤³ð¡º‰éˆŽæ²Ÿé‰é‰¢ð¥–¹éŠ¹ð¨«†ð£²›ð¨¬Œð¥—›",
    ],
    [
      "90a1",
      "ð ´±éŒ¬é«ð¨«¡ð¨¯«ç‚å«ƒð¨«¢ð¨«¥ä¥¥é‰„ð¨¯¬ð¨°¹ð¨¯¿é³é‘›èº¼é–…é–¦é¦é– æ¿¶äŠ¹ð¢™ºð¨›˜ð¡‰¼ð£¸®ä§Ÿæ°œé™»éš–ä…¬éš£ð¦»•æ‡šéš¶ç£µð¨« éš½åŒä¦¡ð¦²¸ð ‰´ð¦ð©‚¯ð©ƒ¥ð¤«‘ð¡¤•ð£ŒŠéœ±è™‚éœ¶ä¨ä”½ä–…ð¤«©çµå­éœ›éœð©‡•é—å­Šð©‡«éŸé¥åƒð£‚·ð£‚¼éž‰éžŸéž±éž¾éŸ€éŸ’éŸ ð¥‘¬éŸ®çœð©³éŸ¿éŸµð©ð§¥ºä«‘é ´é ³é¡‹é¡¦ã¬Žð§…µãµ‘ð ˜°ð¤…œ",
    ],
    [
      "9140",
      "ð¥œ†é£Šé¢·é£ˆé£‡ä«¿ð¦´§ð¡›“å–°é£¡é£¦é£¬é¸é¤¹ð¤¨©ä­²ð©¡—ð©¤…é§µé¨Œé¨»é¨é©˜ð¥œ¥ã›„ð©‚±ð©¯•é« é«¢ð©¬…é«´ä°Žé¬”é¬­ð¨˜€å€´é¬´ð¦¦¨ã£ƒð£½é­é­€ð©´¾å©…ð¡¡£é®Žð¤‰‹é°‚é¯¿é°Œð©¹¨é·”ð©¾·ðª†’ðª†«ðªƒ¡ðª„£ðª‡Ÿéµ¾é¶ƒðª„´é¸Žæ¢ˆ",
    ],
    [
      "91a1",
      "é·„ð¢…›ðª†“ðªˆ ð¡¤»ðªˆ³é´¹ðª‚¹ðªŠ´éºéº•éºžéº¢ä´´éºªéº¯ð¤¤é»ã­ ã§¥ã´ä¼²ãž¾ð¨°«é¼‚é¼ˆä®–é¤ð¦¶¢é¼—é¼–é¼¹åšŸåšŠé½…é¦¸ð©‚‹éŸ²è‘¿é½¢é½©ç«œé¾Žçˆ–ä®¾ð¤¥µð¤¦»ç…·ð¤§¸ð¤ˆð¤©‘çŽžð¨¯šð¡£ºç¦Ÿð¨¥¾ð¨¸¶é©é³ð¨©„é‹¬éŽé‹ð¨¥¬ð¤’¹çˆ—ã»«ç²ç©ƒçƒð¤‘³ð¤¸ç…¾ð¡Ÿ¯ç‚£ð¡¢¾ð£–™ã»‡ð¡¢…ð¥¯ð¡Ÿ¸ãœ¢ð¡›»ð¡ ¹ã›¡ð¡´ð¡£‘ð¥½‹ãœ£ð¡›€å›ð¤¨¥ð¡¾ð¡Š¨",
    ],
    [
      "9240",
      "ð¡†ð¡’¶è”ƒð£š¦è”ƒè‘•ð¤¦”ð§…¥ð£¸±ð¥•œð£»»ð§’ä“´ð£›®ð©¦ð¦¼¦æŸ¹ãœ³ã°•ã·§å¡¬ð¡¤¢æ ä—ð£œ¿ð¤ƒ¡ð¤‚‹ð¤„ð¦°¡å“‹åšžð¦š±åš’ð ¿Ÿð ®¨ð ¸é†ð¨¬“éŽœä»¸å„«ã ™ð¤¶äº¼ð ‘¥ð ¿ä½‹ä¾Šð¥™‘å©¨ð †«ð ‹ã¦™ð ŒŠð ”ãµä¼©ð ‹€ð¨º³ð ‰µè«šð ˆŒäº˜",
    ],
    [
      "92a1",
      "åƒå„ä¾¢ä¼ƒð¤¨Žð£ºŠä½‚å€®å¬å‚ä¿Œä¿¥å˜åƒ¼å…™å…›å…å…žæ¹¶ð£–•ð£¸¹ð£º¿æµ²ð¡¢„ð£º‰å†¨å‡ƒð — ä“ð ’£ð ’’ð ’‘èµºð¨ªœð œŽå‰™åŠ¤ð ¡³å‹¡é®ä™ºç†Œð¤ŽŒð ° ð¤¦¬ð¡ƒ¤æ§‘ð ¸ç‘¹ã»žç’™ç”ç‘–çŽ˜ä®Žð¤ª¼ð¤‚åã–„çˆð¤ƒ‰å–´ð …å“ð ¯†åœé‰é›´é¦åŸåžå¿ã˜¾å£‹åª™ð¨©†ð¡›ºð¡¯ð¡œå¨¬å¦¸éŠå©¾å«å¨’ð¥¥†ð¡§³ð¡¡¡ð¤Š•ã›µæ´…ç‘ƒå¨¡ð¥ºƒ",
    ],
    [
      "9340",
      "åªð¨¯—ð “é ç’Œð¡Œƒç„…ä¥²éˆð¨§»éŽ½ãž å°žå²žå¹žå¹ˆð¡¦–ð¡¥¼ð£«®å»å­ð¡¤ƒð¡¤„ãœð¡¢ ã›ð¡›¾ã›“è„ªð¨©‡ð¡¶ºð£‘²ð¨¦¨å¼Œå¼Žð¡¤§ð¡ž«å©«ð¡œ»å­„è˜”ð§—½è¡ æ¾ð¢¡ ð¢˜«å¿›ãº¸ð¢–¯ð¢–¾ð©‚ˆð¦½³æ‡€ð €¾ð †ð¢˜›æ†™æ†˜æµð¢²›ð¢´‡ð¤›”ð©…",
    ],
    [
      "93a1",
      "æ‘±ð¤™¥ð¢­ªã¨©ð¢¬¢ð£‘ð©£ªð¢¹¸æŒ·ðª‘›æ’¶æŒ±æ‘ð¤§£ð¢µ§æŠ¤ð¢²¡æ»æ•«æ¥²ã¯´ð£‚Žð£Š­ð¤¦‰ð£Š«å”ð£‹ ð¡£™ð©¿æ›Žð£Š‰ð£†³ã« ä†ð¥–„ð¨¬¢ð¥–ð¡›¼ð¥•›ð¥¥ç£®ð£„ƒð¡ ªð£ˆ´ã‘¤ð£ˆð£†‚ð¤‹‰æšŽð¦´¤æ™«ä®“æ˜°ð§¡°ð¡·«æ™£ð£‹’ð£‹¡æ˜žð¥¡²ã£‘ð£ ºð£ž¼ã®™ð£ž¢ð£¾ç“ã®–æžð¤˜ªæ¢¶æ žã¯„æª¾ã¡£ð£Ÿ•ð¤’‡æ¨³æ©’æ«‰æ¬…ð¡¤’æ”‘æ¢˜æ©Œã¯—æ©ºæ­—ð£¿€ð£²šéŽ é‹²ð¨¯ªð¨«‹",
    ],
    [
      "9440",
      "éŠ‰ð¨€žð¨§œé‘§æ¶¥æ¼‹ð¤§¬æµ§ð£½¿ã¶æ¸„ð¤€¼å¨½æ¸Šå¡‡æ´¤ç¡‚ç„»ð¤Œšð¤‰¶çƒ±ç‰çŠ‡çŠ”ð¤žð¤œ¥å…¹ð¤ª¤ð —«ç‘ºð£»¸ð£™Ÿð¤©Šð¤¤—ð¥¿¡ã¼†ãº±ð¤«Ÿð¨°£ð£¼µæ‚§ã»³ç“Œç¼éŽ‡ç·ä’Ÿð¦·ªä•‘ç–ƒã½£ð¤³™ð¤´†ã½˜ç••ç™³ðª—†ã¬™ç‘¨ð¨«Œð¤¦«ð¤¦Žã«»",
    ],
    [
      "94a1",
      "ã·ð¤©Žã»¿ð¤§…ð¤£³é‡ºåœ²é‚ð¨«£ð¡¡¤åƒŸð¥ˆ¡ð¥‡§ç¸ð£ˆ²çœŽçœç»ð¤š—ð£žã©žð¤£°ç¸ç’›ãº¿ð¤ªºð¤«‡äƒˆð¤ª–ð¦†®éŒ‡ð¥–ç žç¢ç¢ˆç£’çç¥™ð§ð¥›£ä„Žç¦›è’–ç¦¥æ¨­ð£»ºç¨ºç§´ä…®ð¡›¦ä„²éˆµç§±ð µŒð¤¦Œð Š™ð£¶ºð¡®ã–—å•«ã•°ãšªð ‡”ð °ç«¢å©™ð¢›µð¥ª¯ð¥ªœå¨ð ‰›ç£°å¨ªð¥¯†ç«¾ä‡¹ç±ç±­äˆ‘ð¥®³ð¥º¼ð¥º¦ç³ð¤§¹ð¡ž°ç²Žç±¼ç²®æª²ç·œç¸‡ç·“ç½Žð¦‰¡",
    ],
    [
      "9540",
      "ð¦…œð§­ˆç¶—ð¥º‚ä‰ªð¦­µð ¤–æŸ–ð Žð£—åŸ„ð¦’ð¦¸ð¤¥¢ç¿ç¬§ð  ¬ð¥«©ð¥µƒç¬Œð¥¸Žé§¦è™…é©£æ¨œð£¿ã§¢ð¤§·ð¦–­é¨Ÿð¦– è’€ð§„§ð¦³‘ä“ªè„·ä‚èƒ†è„‰è…‚ð¦ž´é£ƒð¦©‚è‰¢è‰¥ð¦©‘è‘“ð¦¶§è˜ð§ˆ›åª†ä…¿ð¡¡€å¬«ð¡¢¡å«¤ð¡£˜èš ð¯¦¼ð£¶è ­ð§¢å¨‚",
    ],
    [
      "95a1",
      "è¡®ä½…è¢‡è¢¿è£¦è¥¥è¥ð¥šƒè¥”ð§ž…ð§ž„ð¨¯µð¨¯™ð¨®œð¨§¹ãº­è’£ä›µä›ãŸ²è¨½è¨œð©‘ˆå½éˆ«ð¤Š„æ—”ç„©çƒ„ð¡¡…éµ­è²Ÿè³©ð§·œå¦šçŸƒå§°ä®ã›”è¸ªèº§ð¤°‰è¼°è½Šä‹´æ±˜æ¾»ð¢Œ¡ä¢›æ½¹æº‹ð¡Ÿšé¯©ãšµð¤¤¯é‚»é‚—å•±ä¤†é†»é„ð¨©‹ä¢ð¨«¼é§ð¨°ð¨°»è“¥è¨«é–™é–§é–—é––ð¨´´ç‘…ã»‚ð¤£¿ð¤©‚ð¤ªã»§ð£ˆ¥éšð¨»§ð¨¹¦ð¨¹¥ã»Œð¤§­ð¤©¸ð£¿®ç’ç‘«ã»¼éð©‚°",
    ],
    [
      "9640",
      "æ¡‡ä¨ð©‚“ð¥ŸŸéé¨ð¨¦‰ð¨°¦ð¨¬¯ð¦Ž¾éŠºå¬‘è­©ä¤¼ç¹ð¤ˆ›éž›é±é¤¸ð ¼¦å·ð¨¯…ð¤ª²é Ÿð©“šé‹¶ð©——é‡¥ä“€ð¨­ð¤©§ð¨­¤é£œð¨©…ã¼€éˆªä¤¥è”é¤»é¥ð§¬†ã·½é¦›ä­¯é¦ªé©œð¨­¥ð¥£ˆæªé¨¡å«¾é¨¯ð©£±ä®ð©¥ˆé¦¼ä®½ä®—é½å¡²ð¡Œ‚å ¢ð¤¦¸",
    ],
    [
      "96a1",
      "ð¡“¨ç¡„ð¢œŸð£¶¸æ£…ãµ½é‘˜ã¤§æ…ð¢žð¢¥«æ„‡é±é±“é±»é°µé°é­¿é¯ð©¸­é®Ÿðª‡µðªƒ¾é´¡ä²®ð¤„„é¸˜ä²°é´Œðª†´ðªƒ­ðªƒ³ð©¤¯é¶¥è’½ð¦¸’ð¦¿Ÿð¦®‚è—¼ä”³ð¦¶¤ð¦º„ð¦·°è è—®ð¦¸€ð£Ÿ—ð¦¤ç§¢ð£–œð£™€ä¤­ð¤§žãµ¢é›éŠ¾éˆð Š¿ç¢¹é‰·é‘ä¿¤ã‘€é¤ð¥•ç ½ç¡”ç¢¶ç¡‹ð¡—ð£‡‰ð¤¥ãššä½²æ¿šæ¿™ç€žç€žå”ð¤†µåž»å£³åžŠé´–åŸ—ç„´ã’¯ð¤†¬ç‡«ð¦±€ð¤¾—å¬¨ð¡žµð¨©‰",
    ],
    [
      "9740",
      "æ„Œå«Žå¨‹äŠ¼ð¤’ˆãœ¬ä­»ð¨§¼éŽ»éŽ¸ð¡£–ð ¼è‘²ð¦³€ð¡“ð¤‹ºð¢°¦ð¤å¦”ð£¶·ð¦ç¶¨ð¦…›ð¦‚¤ð¤¦¹ð¤¦‹ð¨§ºé‹¥ç¢ã»©ç’´ð¨­£ð¡¢Ÿã»¡ð¤ª³æ«˜ç³ç»ã»–ð¤¨¾ð¤ª”ð¡Ÿ™ð¤©¦ð Ž§ð¡¤ð¤§¥ç‘ˆð¤¤–ç‚¥ð¤¥¶éŠ„ç¦éŸð “¾éŒ±ð¨«Žð¨¨–éŽ†ð¨¯§ð¥—•ä¤µð¨ª‚ç…«",
    ],
    [
      "97a1",
      "ð¤¥ƒð ³¿åš¤ð ˜šð ¯«ð ²¸å”‚ç§„ð¡Ÿºç·¾ð¡›‚ð¤©ð¡¡’ä”®éãœŠð¨«€ð¤¦­å¦°ð¡¢¿ð¡¢ƒð§’„åª¡ã›¢ð£µ›ãš°é‰Ÿå©¹ð¨ªð¡¡¢é´ã³ð ª´äª–ã¦Šåƒ´ãµ©ãµŒð¡Žœç…µä‹»ð¨ˆ˜æ¸ð©ƒ¤ä“«æµ—ð§¹ç§æ²¯ã³–ð£¿­ð£¸­æ¸‚æ¼Œãµ¯ð µç•‘ãš¼ã“ˆäš€ã»šä¡±å§„é‰®ä¤¾è½ð¨°œð¦¯€å ’åŸˆã›–ð¡‘’çƒ¾ð¤¢ð¤©±ð¢¿£ð¡Š°ð¢Ž½æ¢¹æ¥§ð¡Ž˜ð£“¥ð§¯´ð£›Ÿð¨ªƒð£Ÿ–ð£ºð¤²Ÿæ¨šð£š­ð¦²·è¾ä“Ÿä“Ž",
    ],
    [
      "9840",
      "ð¦´¦ð¦µ‘ð¦²‚ð¦¿žæ¼—ð§„‰èŒ½ð¡œºè­ð¦²€ð§“ð¡Ÿ›å¦‰åª‚ð¡ž³å©¡å©±ð¡¤…ð¤‡¼ãœ­å§¯ð¡œ¼ã›‡ç†ŽéŽæššð¤Š¥å©®å¨«ð¤Š“æ¨«ð£»¹ð§œ¶ð¤‘›ð¤‹Šç„ð¤‰™ð¨§¡ä¾°ð¦´¨å³‚ð¤“Žð§¹ð¤Ž½æ¨Œð¤‰–ð¡Œ„ç‚¦ç„³ð¤©ã¶¥æ³Ÿð¯ ¥ð¤©ç¹¥å§«å´¯ã·³å½œð¤©ð¡ŸŸç¶¤è¦",
    ],
    [
      "98a1",
      "å’…ð£«ºð£Œ€ð ˆ”å¾ð £•ð ˜™ã¿¥ð¡¾žðªŠ¶ç€ƒð©…›åµ°çŽç³“ð¨©™ð© ä¿ˆç¿§ç‹çŒð§«´çŒ¸çŒ¹ð¥›¶ççˆãº©ð§¬˜é¬ç‡µð¤£²ç¡è‡¶ã»ŠçœŒã»‘æ²¢å›½ç™çžçŸã»¢ã»°ã»´ã»ºç““ã¼Žã½“ç•‚ç•­ç•²ç–ã½¼ç—ˆç—œã¿€ç™ã¿—ç™´ã¿œç™ºð¤½œç†ˆå˜£è¦€å¡©ä€çƒä€¹æ¡ä…ã—›çž˜äªä¯å±žçž¾çŸ‹å£²ç ˜ç‚¹ç œä‚¨ç ¹ç¡‡ç¡‘ç¡¦è‘ˆð¥”µç¤³æ ƒç¤²ä„ƒ",
    ],
    [
      "9940",
      "ä„‰ç¦‘ç¦™è¾»ç¨†è¾¼ä…§çª‘ä†²çª¼è‰¹ä‡„ç«ç«›ä‡ä¸¡ç­¢ç­¬ç­»ç°’ç°›ä‰ ä‰ºç±»ç²œäŠŒç²¸äŠ”ç³­è¾“çƒ€ð ³ç·ç·”ç·ç·½ç¾®ç¾´çŠŸäŽ—è€ è€¥ç¬¹è€®è€±è”ã·Œåž´ç‚ è‚·èƒ©ä­è„ŒçŒªè„Žè„’ç• è„”äã¬¹è…–è…™è…š",
    ],
    [
      "99a1",
      "ä“å ºè…¼è†„ä¥è†“ä­è†¥åŸ¯è‡è‡¤è‰”ä’èŠ¦è‰¶è‹Šè‹˜è‹¿ä’°è—é™©æ¦Šè…çƒµè‘¤æƒ£è’ˆä”„è’¾è“¡è“¸è”è”¸è•’ä”»è•¯è•°è— ä•·è™²èš’èš²è›¯é™…èž‹ä˜†ä˜—è¢®è£¿è¤¤è¥‡è¦‘ð§¥§è¨©è¨¸èª”èª´è±‘è³”è³²è´œäž˜å¡Ÿè·ƒäŸ­ä»®è¸ºå—˜å”è¹±å—µèº°ä ·è»Žè»¢è»¤è»­è»²è¾·è¿è¿Šè¿Œé€³é§„ä¢­é£ éˆ“ä¤žéˆ¨é‰˜é‰«éŠ±éŠ®éŠ¿",
    ],
    [
      "9a40",
      "é‹£é‹«é‹³é‹´é‹½éƒéŽ„éŽ­ä¥…ä¥‘éº¿é—åŒéé­é¾ä¥ªé‘”é‘¹é”­é–¢ä¦§é—´é˜³ä§¥æž ä¨¤é€ä¨µéž²éŸ‚å™”ä«¤æƒ¨é¢¹ä¬™é£±å¡„é¤Žé¤™å†´é¤œé¤·é¥‚é¥é¥¢ä­°é§…ä®é¨¼é¬çªƒé­©é®é¯é¯±é¯´ä±­é° ã¯ð¡¯‚éµ‰é°º",
    ],
    [
      "9aa1",
      "é»¾å™é¶“é¶½é·€é·¼é“¶è¾¶é¹»éº¬éº±éº½é»†é“œé»¢é»±é»¸ç«ˆé½„ð ‚”ð Š·ð Ž æ¤šé“ƒå¦¬ð “—å¡€é“ãž¹ð —•ð ˜•ð ™¶ð¡šºå—ç…³ð «‚ð «ð ®¿å‘ªð¯ »ð ¯‹å’žð ¯»ð °»ð ±“ð ±¥ð ±¼æƒ§ð ²å™ºð ²µð ³ð ³­ð µ¯ð ¶²ð ·ˆæ¥•é°¯èž¥ð ¸„ð ¸Žð »—ð ¾ð ¼­ð ¹³å° ð ¾¼å¸‹ð¡œð¡ð¡¶æœžð¡»ð¡‚ˆð¡‚–ã™‡ð¡‚¿ð¡ƒ“ð¡„¯ð¡„»å¤è’­ð¡‹£ð¡µð¡Œ¶è®ð¡•·ð¡˜™ð¡Ÿƒð¡Ÿ‡ä¹¸ç‚»ð¡ ­ð¡¥ª",
    ],
    [
      "9b40",
      "ð¡¨­ð¡©…ð¡°ªð¡±°ð¡²¬ð¡»ˆæ‹ƒð¡»•ð¡¼•ç†˜æ¡•ð¢…æ§©ã›ˆð¢‰¼ð¢—ð¢ºð¢œªð¢¡±ð¢¥è‹½ð¢¥§ð¢¦“ð¢«•è¦¥ð¢«¨è¾ ð¢¬Žéž¸ð¢¬¿é¡‡éª½ð¢±Œ",
    ],
    ["9b62", "ð¢²ˆð¢²·ð¥¯¨ð¢´ˆð¢´’ð¢¶·ð¢¶•ð¢¹‚ð¢½´ð¢¿Œð£€³ð£¦ð£ŒŸð£žå¾±æ™ˆæš¿ð§©¹ð£•§ð£—³çˆð¤¦ºçŸ—ð£˜šð£œ–çº‡ð †å¢µæœŽ"],
    [
      "9ba1",
      "æ¤˜ð£ª§ð§™—ð¥¿¢ð£¸‘ð£º¹ð§—¾ð¢‚šä£äª¸ð¤„™ð¨ªšð¤‹®ð¤Œð¤€»ð¤Œ´ð¤Ž–ð¤©…ð —Šå‡’ð ˜‘å¦Ÿð¡º¨ã®¾ð£³¿ð¤„ð¤“–åžˆð¤™´ã¦›ð¤œ¯ð¨—¨ð©§‰ã¢ð¢‡ƒè­žð¨­Žé§–ð¤ ’ð¤£»ð¤¨•çˆ‰ð¤«€ð ±¸å¥¥ð¤º¥ð¤¾†ð ¹è»šð¥€¬åŠåœ¿ç…±ð¥Š™ð¥™ð£½Šð¤ª§å–¼ð¥‘†ð¥‘®ð¦­’é‡”ã‘³ð¥”¿ð§˜²ð¥•žäœ˜ð¥•¢ð¥•¦ð¥Ÿ‡ð¤¤¿ð¥¡å¦ã“»ð£Œæƒžð¥¤ƒä¼ð¨¥ˆð¥ª®ð¥®‰ð¥°†ð¡¶åž¡ç…‘æ¾¶ð¦„‚ð§°’é–ð¦†²ð¤¾šè­¢ð¦‚ð¦‘Š",
    ],
    [
      "9c40",
      "åµ›ð¦¯·è¼¶ð¦’„ð¡¤œè«ªð¤§¶ð¦’ˆð£¿¯ð¦”’ä¯€ð¦–¿ð¦šµð¢œ›é‘¥ð¥Ÿ¡æ†•å¨§ð¯£ä¾»åš¹ð¤”¡ð¦›¼ä¹ªð¤¤´é™–æ¶ð¦²½ã˜˜è¥·ð¦ž™ð¦¡®ð¦‘ð¦¡žç‡Ÿð¦£‡ç­‚ð©ƒ€ð ¨‘ð¦¤¦é„„ð¦¤¹ç©…é·°ð¦§ºé¨¦ð¦¨­ã™Ÿð¦‘©ð €¡ç¦ƒð¦¨´ð¦­›å´¬ð£”™èð¦®ä›ð¦²¤ç”»è¡¥ð¦¶®å¢¶",
    ],
    [
      "9ca1",
      "ãœœð¢–ð§‹ð§‡ã±”ð§Š€ð§Š…éŠð¢…ºð§Š‹éŒ°ð§‹¦ð¤§æ°¹é’Ÿð§‘ð »¸è §è£µð¢¤¦ð¨‘³ð¡ž±æº¸ð¤¨ªð¡  ã¦¤ãš¹å°ç§£ä”¿æš¶ð©²­ð©¢¤è¥ƒð§ŸŒð§¡˜å›–äƒŸð¡˜Šã¦¡ð£œ¯ð¨ƒ¨ð¡…ç†­è¦ð§§ð©†¨å©§ä²·ð§‚¯ð¨¦«ð§§½ð§¨Šð§¬‹ð§µ¦ð¤…ºç­ƒç¥¾ð¨€‰æ¾µðª‹Ÿæ¨ƒð¨Œ˜åŽ¢ð¦¸‡éŽ¿æ ¶éð¨…¯ð¨€£ð¦¦µð¡­ð£ˆ¯ð¨ˆå¶…ð¨°°ð¨‚ƒåœ•é £ð¨¥‰å¶«ð¤¦ˆæ–¾æ§•å’ð¤ª¥ð£¾ã°‘æœ¶ð¨‚ð¨ƒ´ð¨„®ð¡¾¡ð¨…",
    ],
    [
      "9d40",
      "ð¨†‰ð¨†¯ð¨ˆšð¨Œ†ð¨Œ¯ð¨ŽŠã—Šð¨‘¨ð¨šªä£ºæ¦ð¨¥–ç ˆé‰•ð¨¦¸ä²ð¨§§äŸð¨§¨ð¨­†ð¨¯”å§¸ð¨°‰è¼‹ð¨¿…ð©ƒ¬ç­‘ð©„ð©„¼ã··ð©…žð¤«Šè¿çŠåš‹ð©“§ð©—©ð©–°ð©–¸ð©œ²ð©£‘ð©¥‰ð©¥ªð©§ƒð©¨¨ð©¬Žð©µšð©¶›çºŸð©»¸ð©¼£ä²¤é•‡ðªŠ“ç†¢ðª‹¿ä¶‘é€’ðª—‹ä¶œð ²œè¾¾å—",
    ],
    [
      "9da1",
      "è¾ºð¢’°è¾¹ð¤ª“ä”‰ç¹¿æ½–æª±ä»ªã“¤ð¨¬¬ð§¢ãœºèº€ð¡Ÿµð¨€¤ð¨­¬ð¨®™ð§¨¾ð¦š¯ã·«ð§™•ð£²·ð¥˜µð¥¥–äºšð¥ºð¦‰˜åš¿ð ¹­è¸Žå­­ð£ºˆð¤²žæžæ‹ð¡Ÿ¶ð¡¡»æ”°å˜­ð¥±Šåšð¥Œ‘ã·†ð©¶˜ä±½å˜¢å˜žç½‰ð¥»˜å¥µð£µ€è°ä¸œð ¿ªð µ‰ð£šºè„—éµžè´˜ç˜»é±…ç™Žçž¹é…å²è…ˆè‹·å˜¥è„²è˜è‚½å—ªç¥¢å™ƒå–ð ºã—Žå˜…å—±æ›±ð¨‹¢ã˜­ç”´å—°å–ºå’—å•²ð ±ð ²–å»ð¥…ˆð ¹¶ð¢±¢",
    ],
    [
      "9e40",
      "ð º¢éº«çµšå—žð¡µæŠé­å’”è³ç‡¶é…¶æ¼æŽ¹æ¾å•©ð¢­ƒé±²ð¢º³å†šã“Ÿð ¶§å†§å‘å”žå”“ç™¦è¸­ð¦¢Šç–±è‚¶è „èž†è£‡è†¶èœð¡ƒä“¬çŒ„ð¤œ†å®èŒ‹ð¦¢“å™»ð¢›´ð§´¯ð¤†£ð§µ³ð¦»ð§Š¶é…°ð¡‡™éˆˆð£³¼ðªš©ð º¬ð »¹ç‰¦ð¡²¢äŽð¤¿‚ð§¿¹ð ¿«äƒº",
    ],
    ["9ea1", "é±æ”Ÿð¢¶ ä£³ð¤Ÿ ð©µ¼ð ¿¬ð ¸Šæ¢ð§–£ð ¿­"],
    ["9ead", "ð¦ˆð¡†‡ç†£çºŽéµä¸šä¸„ã•·å¬æ²²å§ãš¬ã§œå½ãš¥ð¤˜˜å¢šð¤­®èˆ­å‘‹åžªð¥ª•ð ¥¹"],
    [
      "9ec5",
      "ã©’ð¢‘¥ç´ð©º¬ä´‰é¯­ð£³¾ð©¼°ä±›ð¤¾©ð©–žð©¿žè‘œð£¶¶ð§Š²ð¦ž³ð£œ æŒ®ç´¥ð£»·ð£¸¬ã¨ªé€ˆå‹Œã¹´ã™ºä—©ð ’Žç™€å«°ð º¶ç¡ºð§¼®å¢§ä‚¿å™¼é®‹åµ´ç™”ðª´éº…ä³¡ç—¹ãŸ»æ„™ð£ƒšð¤²",
    ],
    ["9ef5", "å™ð¡Š©åž§ð¤¥£ð©¸†åˆ´ð§‚®ã–­æ±Šéµ¼"],
    ["9f40", "ç±–é¬¹åŸžð¡¬å±“æ““ð©“ð¦Œµð§…¤èš­ð ´¨ð¦´¢ð¤«¢ð µ±"],
    [
      "9f4f",
      "å‡¾ð¡¼å¶Žéœƒð¡·‘éºéŒç¬Ÿé¬‚å³‘ç®£æ‰¨æŒµé«¿ç¯é¬ªç±¾é¬®ç±‚ç²†é°•ç¯¼é¬‰é¼—é°›ð¤¤¾é½šå•³å¯ƒä¿½éº˜ä¿²å‰ ã¸†å‹‘å§å–å¦·å¸’éŸˆé¶«è½œå‘©éž´é¥€éžºåŒ¬æ„°",
    ],
    ["9fa1", "æ¤¬åšé°Šé´‚ä°»é™æ¦€å‚¦ç•†ð¡­é§šå‰³"],
    ["9fae", "é…™éšé…œ"],
    ["9fb2", "é…‘ð¨º—æ¿ð¦´£æ«Šå˜‘é†Žç•ºæŠ…ð ¼çç±°ð¥°¡ð£³½"],
    ["9fc1", "ð¤¤™ç›–é®ä¸ªð ³”èŽ¾è¡‚"],
    ["9fc9", "å±Šæ§€åƒ­åºåˆŸå·µä»Žæ°±ð ‡²ä¼¹å’œå“šåŠšè¶‚ã—¾å¼Œã—³"],
    ["9fdb", "æ­’é…¼é¾¥é®—é ®é¢´éªºéº¨éº„ç…ºç¬”"],
    ["9fe7", "æ¯ºè ˜ç½¸"],
    ["9feb", "å˜ ðª™Šè¹·é½“"],
    ["9ff0", "è·”è¹é¸œè¸æŠ‚ð¨½è¸¨è¹µç«“ð¤©·ç¨¾ç£˜æ³ªè©§ç˜‡"],
    ["a040", "ð¨©šé¼¦æ³ŽèŸ–ç—ƒðªŠ²ç¡“ð¯¡€è´Œç‹¢ç±è¬­çŒ‚ç“±è³«ð¤ª»è˜¯å¾ºè¢ ä’·"],
    ["a055", "ð¡ »ð¦¸…"],
    ["a058", "è©¾ð¢”›"],
    ["a05b", "æƒ½ç™§é«—éµ„é®é®èŸµ"],
    ["a063", "è è³·çŒ¬éœ¡é®°ã—–çŠ²ä°‡ç±‘é¥Šð¦…™æ…™ä°„éº–æ…½"],
    ["a073", "åŸæ…¯æŠ¦æˆ¹æ‹Žã©œæ‡¢åŽªð£µæ¤æ ‚ã—’"],
    ["a0a1", "åµ—ð¨¯‚è¿šð¨¸¹"],
    ["a0a6", "åƒ™ð¡µ†ç¤†åŒ²é˜¸ð ¼»ä¥"],
    ["a0ae", "çŸ¾"],
    [
      "a0b0",
      "ç³‚ð¥¼šç³šç¨­è¦è£çµç”…ç“²è¦”èˆšæœŒè¢ð§’†è›ç“°è„ƒçœ¤è¦‰ð¦ŸŒç•“ð¦»‘èž©èŸŽè‡ˆèžŒè©‰è²­è­ƒçœ«ç“¸è“šã˜µæ¦²è¶¦",
    ],
    ["a0d4", "è¦©ç‘¨æ¶¹èŸð¤€‘ç“§ã·›ç…¶æ‚¤æ†œã³‘ç…¢æ·"],
    ["a0e2", "ç½±ð¨¬­ç‰æƒ©ä­¾åˆ ã°˜ð£³‡ð¥»—ð§™–ð¥”±ð¡¥„ð¡‹¾ð©¤ƒð¦·œð§‚­å³ð¦†­ð¨¨ð£™·ð ƒ®ð¦¡†ð¤¼Žä•¢å¬Ÿð¦Œé½éº¦ð¦‰«"],
    ["a3c0", "â€", 31, "â¡"],
    [
      "c6a1",
      "â‘ ",
      9,
      "â‘´",
      9,
      "â…°",
      9,
      "ä¸¶ä¸¿äº…äº å†‚å†–å†«å‹¹åŒ¸å©åŽ¶å¤Šå®€å·›â¼³å¹¿å»´å½å½¡æ”´æ— ç–’ç™¶è¾µéš¶Â¨Ë†ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼ï¼»ï¼½âœ½ã",
      23,
    ],
    ["c740", "ã™", 58, "ã‚¡ã‚¢ã‚£ã‚¤"],
    ["c7a1", "ã‚¥", 81, "Ð", 5, "ÐÐ–", 4],
    ["c840", "Ð›", 26, "Ñ‘Ð¶", 25, "â‡§â†¸â†¹ã‡ð ƒŒä¹šð ‚Šåˆ‚ä’‘"],
    ["c8a1", "é¾°å†ˆé¾±ð§˜‡"],
    [
      "c8cd",
      "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡ã‚›ã‚œâº€âº„âº†âº‡âºˆâºŠâºŒâºâº•âºœâºâº¥âº§âºªâº¬âº®âº¶âº¼âº¾â»†â»Šâ»Œâ»â»â»–â»—â»žâ»£",
    ],
    ["c8f5", "ÊƒÉÉ›É”ÉµÅ“Ã¸Å‹ÊŠÉª"],
    ["f9fe", "ï¿­"],
    [
      "fa40",
      "ð •‡é‹›ð —Ÿð£¿…è•ŒäŠµç¯å†µã™‰ð¤¥‚ð¨§¤é„ð¡§›è‹®ð£³ˆç ¼æ„æ‹Ÿð¤¤³ð¨¦ªð Š ð¦®³ð¡Œ…ä¾«ð¢“­å€ˆð¦´©ð§ª„ð£˜€ð¤ª±ð¢”“å€©ð ¾å¾¤ð Ž€ð ‡æ»›ð Ÿå½å„ã‘ºå„Žé¡¬ãƒè–ð¤¦¤ð ’‡å… ð£Ž´å…ªð ¯¿ð¢ƒ¼ð ‹¥ð¢”°ð –Žð£ˆ³ð¡¦ƒå®‚è½ð –³ð£²™å†²å†¸",
    ],
    [
      "faa1",
      "é´´å‡‰å‡å‡‘ã³œå‡“ð¤ª¦å†³å‡¢å‚å‡­èæ¤¾ð£œ­å½»åˆ‹åˆ¦åˆ¼åŠµå‰—åŠ”åŠ¹å‹…ç°•è•‚å‹ è˜ð¦¬“åŒ…ð¨«žå•‰æ»™ð£¾€ð ¥”ð£¿¬åŒ³å„ð ¯¢æ³‹ð¡œ¦æ ›ç•æŠãºªã£Œð¡›¨ç‡ä’¢å­å´ð¨š«å¾å¿ð¡––ð¡˜“çŸ¦åŽ“ð¨ª›åŽ åŽ«åŽ®çŽ§ð¥²ã½™çŽœåå…æ±‰ä¹‰åŸ¾å™ãª«ð ®å ð£¿«ð¢¶£å¶ð ±·å“ç¹å”«æ™—æµ›å‘­ð¦­“ð µ´å•å’å’¤äž¦ð¡œð »ã¶´ð µ",
    ],
    [
      "fb40",
      "ð¨¦¼ð¢š˜å•‡ä³­å¯ç—å–†å–©å˜…ð¡£—ð¤€ºä•’ð¤µæš³ð¡‚´å˜·æ›ð£ŠŠæš¤æš­å™å™ç£±å›±éž‡å¾åœ€å›¯å›­ð¨­¦ã˜£ð¡‰å†ð¤†¥æ±®ç‚‹å‚ãš±ð¦±¾åŸ¦ð¡–å ƒð¡‘”ð¤£å ¦ð¤¯µå¡œå¢ªã•¡å£ å£œð¡ˆ¼å£»å¯¿åƒðª…ð¤‰¸é“ã–¡å¤Ÿæ¢¦ã›ƒæ¹™",
    ],
    [
      "fba1",
      "ð¡˜¾å¨¤å•“ð¡š’è”…å§‰ð µŽð¦²ð¦´ªð¡Ÿœå§™ð¡Ÿ»ð¡ž²ð¦¶¦æµ±ð¡ ¨ð¡›•å§¹ð¦¹…åª«å©£ã›¦ð¤¦©å©·ãœˆåª–ç‘¥å«“ð¦¾¡ð¢•”ã¶…ð¡¤‘ãœ²ð¡š¸åºƒå‹å­¶æ–ˆå­¼ð§¨Žä€„ä¡ð ˆ„å¯•æ… ð¡¨´ð¥§Œð –¥å¯³å®ä´å°…ð¡­„å°“çŽå°”ð¡²¥ð¦¬¨å±‰ä£å²…å³©å³¯å¶‹ð¡·¹ð¡¸·å´å´˜åµ†ð¡º¤å²ºå·—è‹¼ã ­ð¤¤ð¢‰ð¢…³èŠ‡ã ¶ã¯‚å¸®æªŠå¹µå¹ºð¤’¼ð ³“åŽ¦äº·å»åŽ¨ð¡±å¸‰å»´ð¨’‚",
    ],
    [
      "fc40",
      "å»¹å»»ã¢ å»¼æ ¾é›å¼ð ‡ð¯¢”ã«žä¢®ð¡Œºå¼ºð¦¢ˆð¢å½˜ð¢‘±å½£éž½ð¦¹®å½²é€ð¨¨¶å¾§å¶¶ãµŸð¥‰ð¡½ªð§ƒ¸ð¢™¨é‡–ð Šžð¨¨©æ€±æš…ð¡¡·ã¥£ã·‡ã˜¹åžð¢ž´ç¥±ã¹€æ‚žæ‚¤æ‚³ð¤¦‚ð¤¦ð§©“ç’¤åƒ¡åª æ…¤è¤æ…‚ð¯¢¦ð¦»’æ†å‡´ð ™–æ†‡å®ªð£¾·",
    ],
    [
      "fca1",
      "ð¢¡Ÿæ‡“ð¨®ð©¥æ‡ã¤²ð¢¦€ð¢£æ€£æ…œæ”žæŽ‹ð „˜æ‹…ð¡°æ‹•ð¢¸æ¬ð¤§Ÿã¨—æ¸æ¸ð¡ŽŽð¡Ÿ¼æ’æ¾Šð¢¸¶é ”ð¤‚Œð¥œæ“¡æ“¥é‘»ã©¦æºã©—æ•æ¼–ð¤¨¨ð¤¨£æ–…æ•­æ•Ÿð£¾æ–µð¤¥€ä¬·æ—‘äƒ˜ð¡ ©æ— æ—£å¿Ÿð£€æ˜˜ð£‡·ð£‡¸æ™„ð£†¤ð£†¥æ™‹ð ¹µæ™§ð¥‡¦æ™³æ™´ð¡¸½ð£ˆ±ð¨—´ð£‡ˆð¥Œ“çŸ…ð¢£·é¦¤æœ‚ð¤Žœð¤¨¡ã¬«æ§ºð£Ÿ‚æžæ§æ¢ð¤‡ð©ƒ­æŸ—ä“©æ ¢æ¹éˆ¼æ ð£¦ð¦¶ æ¡",
    ],
    [
      "fd40",
      "ð£‘¯æ§¡æ¨‹ð¨«Ÿæ¥³æ£ƒð£—æ¤æ¤€ã´²ã¨ð£˜¼ã®€æž¬æ¥¡ð¨©Šä‹¼æ¤¶æ¦˜ã®¡ð ‰è£å‚æ§¹ð£™™ð¢„ªæ©…ð£œƒæªã¯³æž±æ«ˆð©†œã°æ¬ð ¤£æƒžæ¬µæ­´ð¢Ÿæºµð£«›ð Žµð¡¥˜ã€å¡ð£­šæ¯¡ð£»¼æ¯œæ°·ð¢’‹ð¤£±ð¦­‘æ±šèˆ¦æ±¹ð£¶¼ä“…ð£¶½ð¤†¤ð¤¤Œð¤¤€",
    ],
    [
      "fda1",
      "ð£³‰ã›¥ã³«ð ´²é®ƒð£‡¹ð¢’‘ç¾æ ·ð¦´¥ð¦¶¡ð¦·«æ¶–æµœæ¹¼æ¼„ð¤¥¿ð¤‚…ð¦¹²è”³ð¦½´å‡‡æ²œæ¸è®ð¨¬¡æ¸¯ð£¸¯ç‘“ð£¾‚ç§Œæ¹åª‘ð£‹æ¿¸ãœæ¾ð£¸°æ»ºð¡’—ð¤€½ä••é°æ½„æ½œãµŽæ½´ð©…°ã´»æ¾Ÿð¤…„æ¿“ð¤‚‘ð¤…•ð¤€¹ð£¿°ð£¾´ð¤„¿å‡Ÿð¤…–ð¤…—ð¤…€ð¦‡ç‹ç¾ç‚§ç‚çƒŒçƒ•çƒ–çƒŸä„„ã·¨ç†´ç†–ð¤‰·ç„«ç……åªˆç…Šç…®å²œð¤¥ç…é¢ð¤‹ç„¬ð¤‘šð¤¨§ð¤¨¢ç†ºð¨¯¨ç‚½çˆŽ",
    ],
    [
      "fe40",
      "é‘‚çˆ•å¤‘é‘ƒçˆ¤éð¥˜…çˆ®ç‰€ð¤¥´æ¢½ç‰•ç‰—ã¹•ð£„æ æ¼½çŠ‚çŒªçŒ«ð¤ £ð¨ «ä£­ð¨ „çŒ¨çŒ®ççŽªð °ºð¦¨®ç‰ç‘‰ð¤‡¢ð¡›§ð¤¨¤æ˜£ã›…ð¤¦·ð¤¦ð¤§»ç·ç•æ¤ƒð¤¨¦ç¹ð —ƒã»—ç‘œð¢¢­ç‘ ð¨º²ç‘‡ç¤ç‘¶èŽ¹ç‘¬ãœ°ç‘´é±æ¨¬ç’‚ä¥“ð¤ªŒ",
    ],
    [
      "fea1",
      "ð¤…Ÿð¤©¹ð¨®å­†ð¨°ƒð¡¢žç“ˆð¡¦ˆç”Žç“©ç”žð¨»™ð¡©‹å¯—ð¨º¬éŽ…ç•ç•Šç•§ç•®ð¤¾‚ã¼„ð¤´“ç–Žç‘ç–žç–´ç˜‚ç˜¬ç™‘ç™ç™¯ç™¶ð¦µçšè‡¯ãŸ¸ð¦¤‘ð¦¤Žçš¡çš¥çš·ç›Œð¦¾Ÿè‘¢ð¥‚ð¥…½ð¡¸œçœžçœ¦ç€æ’¯ð¥ˆ ç˜ð£Š¬çž¯ð¨¥¤ð¨¥¨ð¡›çŸ´ç ‰ð¡¶ð¤¨’æ£Šç¢¯ç£‡ç£“éš¥ç¤®ð¥— ç£—ç¤´ç¢±ð§˜Œè¾¸è¢„ð¨¬«ð¦‚ƒð¢˜œç¦†è¤€æ¤‚ç¦€ð¥¡—ç¦ð§¬¹ç¤¼ç¦©æ¸ªð§„¦ãº¨ç§†ð©„ç§”",
    ],
  ];
var ph, H1;
function NN() {
  return (
    H1 ||
      ((H1 = 1),
      (ph = {
        shiftjis: {
          type: "_dbcs",
          table: function () {
            return SN;
          },
          encodeAdd: { "Â¥": 92, "â€¾": 126 },
          encodeSkipVals: [{ from: 60736, to: 63808 }],
        },
        csshiftjis: "shiftjis",
        mskanji: "shiftjis",
        sjis: "shiftjis",
        windows31j: "shiftjis",
        ms31j: "shiftjis",
        xsjis: "shiftjis",
        windows932: "shiftjis",
        ms932: "shiftjis",
        932: "shiftjis",
        cp932: "shiftjis",
        eucjp: {
          type: "_dbcs",
          table: function () {
            return IN;
          },
          encodeAdd: { "Â¥": 92, "â€¾": 126 },
        },
        gb2312: "cp936",
        gb231280: "cp936",
        gb23121980: "cp936",
        csgb2312: "cp936",
        csiso58gb231280: "cp936",
        euccn: "cp936",
        windows936: "cp936",
        ms936: "cp936",
        936: "cp936",
        cp936: {
          type: "_dbcs",
          table: function () {
            return dh;
          },
        },
        gbk: {
          type: "_dbcs",
          table: function () {
            return dh.concat(j1);
          },
        },
        xgbk: "gbk",
        isoir58: "gbk",
        gb18030: {
          type: "_dbcs",
          table: function () {
            return dh.concat(j1);
          },
          gb18030: function () {
            return RN;
          },
          encodeSkipVals: [128],
          encodeAdd: { "â‚¬": 41699 },
        },
        chinese: "gb18030",
        windows949: "cp949",
        ms949: "cp949",
        949: "cp949",
        cp949: {
          type: "_dbcs",
          table: function () {
            return kN;
          },
        },
        cseuckr: "cp949",
        csksc56011987: "cp949",
        euckr: "cp949",
        isoir149: "cp949",
        korean: "cp949",
        ksc56011987: "cp949",
        ksc56011989: "cp949",
        ksc5601: "cp949",
        windows950: "cp950",
        ms950: "cp950",
        950: "cp950",
        cp950: {
          type: "_dbcs",
          table: function () {
            return M1;
          },
        },
        big5: "big5hkscs",
        big5hkscs: {
          type: "_dbcs",
          table: function () {
            return M1.concat(TN);
          },
          encodeSkipVals: [41676],
        },
        cnbig5: "big5hkscs",
        csbig5: "big5hkscs",
        xxbig5: "big5hkscs",
      })),
    ph
  );
}
var q1;
function ON() {
  return (
    q1 ||
      ((q1 = 1),
      (function (e) {
        for (
          var t = [yN(), bN(), _N(), EN(), wN(), xN(), AN(), NN()], n = 0;
          n < t.length;
          n++
        ) {
          var r = t[n];
          for (var i in r)
            Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i]);
        }
      })(sh)),
    sh
  );
}
var hh, G1;
function PN() {
  if (G1) return hh;
  G1 = 1;
  var e = ks.Buffer,
    t = Kr.Transform;
  hh = function (i) {
    (i.encodeStream = function (s, o) {
      return new n(i.getEncoder(s, o), o);
    }),
      (i.decodeStream = function (s, o) {
        return new r(i.getDecoder(s, o), o);
      }),
      (i.supportsStreams = !0),
      (i.IconvLiteEncoderStream = n),
      (i.IconvLiteDecoderStream = r),
      (i._collect = r.prototype.collect);
  };
  function n(i, a) {
    (this.conv = i), (a = a || {}), (a.decodeStrings = !1), t.call(this, a);
  }
  (n.prototype = Object.create(t.prototype, { constructor: { value: n } })),
    (n.prototype._transform = function (i, a, s) {
      if (typeof i != "string")
        return s(
          new Error("Iconv encoding stream needs strings as its input."),
        );
      try {
        var o = this.conv.write(i);
        o && o.length && this.push(o), s();
      } catch (c) {
        s(c);
      }
    }),
    (n.prototype._flush = function (i) {
      try {
        var a = this.conv.end();
        a && a.length && this.push(a), i();
      } catch (s) {
        i(s);
      }
    }),
    (n.prototype.collect = function (i) {
      var a = [];
      return (
        this.on("error", i),
        this.on("data", function (s) {
          a.push(s);
        }),
        this.on("end", function () {
          i(null, e.concat(a));
        }),
        this
      );
    });
  function r(i, a) {
    (this.conv = i),
      (a = a || {}),
      (a.encoding = this.encoding = "utf8"),
      t.call(this, a);
  }
  return (
    (r.prototype = Object.create(t.prototype, { constructor: { value: r } })),
    (r.prototype._transform = function (i, a, s) {
      if (!e.isBuffer(i))
        return s(
          new Error("Iconv decoding stream needs buffers as its input."),
        );
      try {
        var o = this.conv.write(i);
        o && o.length && this.push(o, this.encoding), s();
      } catch (c) {
        s(c);
      }
    }),
    (r.prototype._flush = function (i) {
      try {
        var a = this.conv.end();
        a && a.length && this.push(a, this.encoding), i();
      } catch (s) {
        i(s);
      }
    }),
    (r.prototype.collect = function (i) {
      var a = "";
      return (
        this.on("error", i),
        this.on("data", function (s) {
          a += s;
        }),
        this.on("end", function () {
          i(null, a);
        }),
        this
      );
    }),
    hh
  );
}
var mh, Q1;
function DN() {
  if (Q1) return mh;
  Q1 = 1;
  var e = ks.Buffer;
  return (
    (mh = function (t) {
      var n = void 0;
      (t.supportsNodeEncodingsExtension = !(
        e.from || new e(0) instanceof Uint8Array
      )),
        (t.extendNodeEncodings = function () {
          if (!n) {
            if (((n = {}), !t.supportsNodeEncodingsExtension)) {
              console.error(
                "ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node",
              ),
                console.error(
                  "See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility",
                );
              return;
            }
            var i = {
              hex: !0,
              utf8: !0,
              "utf-8": !0,
              ascii: !0,
              binary: !0,
              base64: !0,
              ucs2: !0,
              "ucs-2": !0,
              utf16le: !0,
              "utf-16le": !0,
            };
            e.isNativeEncoding = function (o) {
              return o && i[o.toLowerCase()];
            };
            var a = ks.SlowBuffer;
            if (
              ((n.SlowBufferToString = a.prototype.toString),
              (a.prototype.toString = function (o, c, l) {
                return (
                  (o = String(o || "utf8").toLowerCase()),
                  e.isNativeEncoding(o)
                    ? n.SlowBufferToString.call(this, o, c, l)
                    : (typeof c > "u" && (c = 0),
                      typeof l > "u" && (l = this.length),
                      t.decode(this.slice(c, l), o))
                );
              }),
              (n.SlowBufferWrite = a.prototype.write),
              (a.prototype.write = function (o, c, l, f) {
                if (isFinite(c)) isFinite(l) || ((f = l), (l = void 0));
                else {
                  var u = f;
                  (f = c), (c = l), (l = u);
                }
                c = +c || 0;
                var d = this.length - c;
                if (
                  (l ? ((l = +l), l > d && (l = d)) : (l = d),
                  (f = String(f || "utf8").toLowerCase()),
                  e.isNativeEncoding(f))
                )
                  return n.SlowBufferWrite.call(this, o, c, l, f);
                if (o.length > 0 && (l < 0 || c < 0))
                  throw new RangeError("attempt to write beyond buffer bounds");
                var p = t.encode(o, f);
                return p.length < l && (l = p.length), p.copy(this, c, 0, l), l;
              }),
              (n.BufferIsEncoding = e.isEncoding),
              (e.isEncoding = function (o) {
                return e.isNativeEncoding(o) || t.encodingExists(o);
              }),
              (n.BufferByteLength = e.byteLength),
              (e.byteLength = a.byteLength =
                function (o, c) {
                  return (
                    (c = String(c || "utf8").toLowerCase()),
                    e.isNativeEncoding(c)
                      ? n.BufferByteLength.call(this, o, c)
                      : t.encode(o, c).length
                  );
                }),
              (n.BufferToString = e.prototype.toString),
              (e.prototype.toString = function (o, c, l) {
                return (
                  (o = String(o || "utf8").toLowerCase()),
                  e.isNativeEncoding(o)
                    ? n.BufferToString.call(this, o, c, l)
                    : (typeof c > "u" && (c = 0),
                      typeof l > "u" && (l = this.length),
                      t.decode(this.slice(c, l), o))
                );
              }),
              (n.BufferWrite = e.prototype.write),
              (e.prototype.write = function (o, c, l, f) {
                var u = c,
                  d = l,
                  p = f;
                if (isFinite(c)) isFinite(l) || ((f = l), (l = void 0));
                else {
                  var h = f;
                  (f = c), (c = l), (l = h);
                }
                if (
                  ((f = String(f || "utf8").toLowerCase()),
                  e.isNativeEncoding(f))
                )
                  return n.BufferWrite.call(this, o, u, d, p);
                c = +c || 0;
                var m = this.length - c;
                if (
                  (l ? ((l = +l), l > m && (l = m)) : (l = m),
                  o.length > 0 && (l < 0 || c < 0))
                )
                  throw new RangeError("attempt to write beyond buffer bounds");
                var g = t.encode(o, f);
                return g.length < l && (l = g.length), g.copy(this, c, 0, l), l;
              }),
              t.supportsStreams)
            ) {
              var s = Kr.Readable;
              (n.ReadableSetEncoding = s.prototype.setEncoding),
                (s.prototype.setEncoding = function (c, l) {
                  (this._readableState.decoder = t.getDecoder(c, l)),
                    (this._readableState.encoding = c);
                }),
                (s.prototype.collect = t._collect);
            }
          }
        }),
        (t.undoExtendNodeEncodings = function () {
          if (t.supportsNodeEncodingsExtension) {
            if (!n)
              throw new Error(
                "require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.",
              );
            delete e.isNativeEncoding;
            var i = ks.SlowBuffer;
            if (
              ((i.prototype.toString = n.SlowBufferToString),
              (i.prototype.write = n.SlowBufferWrite),
              (e.isEncoding = n.BufferIsEncoding),
              (e.byteLength = n.BufferByteLength),
              (e.prototype.toString = n.BufferToString),
              (e.prototype.write = n.BufferWrite),
              t.supportsStreams)
            ) {
              var a = Kr.Readable;
              (a.prototype.setEncoding = n.ReadableSetEncoding),
                delete a.prototype.collect;
            }
            n = void 0;
          }
        });
    }),
    mh
  );
}
var W1;
function qd() {
  return (
    W1 ||
      ((W1 = 1),
      (function (e) {
        var t = Xa().Buffer,
          n = vN(),
          r = e.exports;
        (r.encodings = null),
          (r.defaultCharUnicode = "ï¿½"),
          (r.defaultCharSingleByte = "?"),
          (r.encode = function (o, c, l) {
            o = "" + (o || "");
            var f = r.getEncoder(c, l),
              u = f.write(o),
              d = f.end();
            return d && d.length > 0 ? t.concat([u, d]) : u;
          }),
          (r.decode = function (o, c, l) {
            typeof o == "string" &&
              (r.skipDecodeWarning ||
                (console.error(
                  "Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding",
                ),
                (r.skipDecodeWarning = !0)),
              (o = t.from("" + (o || ""), "binary")));
            var f = r.getDecoder(c, l),
              u = f.write(o),
              d = f.end();
            return d ? u + d : u;
          }),
          (r.encodingExists = function (o) {
            try {
              return r.getCodec(o), !0;
            } catch {
              return !1;
            }
          }),
          (r.toEncoding = r.encode),
          (r.fromEncoding = r.decode),
          (r._codecDataCache = {}),
          (r.getCodec = function (o) {
            r.encodings || (r.encodings = ON());
            for (var c = r._canonicalizeEncoding(o), l = {}; ; ) {
              var f = r._codecDataCache[c];
              if (f) return f;
              var u = r.encodings[c];
              switch (typeof u) {
                case "string":
                  c = u;
                  break;
                case "object":
                  for (var d in u) l[d] = u[d];
                  l.encodingName || (l.encodingName = c), (c = u.type);
                  break;
                case "function":
                  return (
                    l.encodingName || (l.encodingName = c),
                    (f = new u(l, r)),
                    (r._codecDataCache[l.encodingName] = f),
                    f
                  );
                default:
                  throw new Error(
                    "Encoding not recognized: '" +
                      o +
                      "' (searched as: '" +
                      c +
                      "')",
                  );
              }
            }
          }),
          (r._canonicalizeEncoding = function (s) {
            return ("" + s).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
          }),
          (r.getEncoder = function (o, c) {
            var l = r.getCodec(o),
              f = new l.encoder(c, l);
            return (
              l.bomAware && c && c.addBOM && (f = new n.PrependBOM(f, c)), f
            );
          }),
          (r.getDecoder = function (o, c) {
            var l = r.getCodec(o),
              f = new l.decoder(c, l);
            return (
              l.bomAware &&
                !(c && c.stripBOM === !1) &&
                (f = new n.StripBOM(f, c)),
              f
            );
          });
        var i =
          typeof process < "u" && process.versions && process.versions.node;
        if (i) {
          var a = i.split(".").map(Number);
          (a[0] > 0 || a[1] >= 10) && PN()(r), DN()(r);
        }
      })(ih)),
    ih.exports
  );
}
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var zl = BN;
function LN(e) {
  for (var t = e.listeners("data"), n = 0; n < t.length; n++)
    if (t[n].name === "ondata") return !0;
  return !1;
}
function BN(e) {
  if (!e) throw new TypeError("argument stream is required");
  if (typeof e.unpipe == "function") {
    e.unpipe();
    return;
  }
  if (LN(e))
    for (var t, n = e.listeners("close"), r = 0; r < n.length; r++)
      (t = n[r]), !(t.name !== "cleanup" && t.name !== "onclose") && t.call(e);
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var gh, z1;
function UN() {
  if (z1) return gh;
  z1 = 1;
  var e = f(),
    t = qi(),
    n = Gi,
    r = qd(),
    i = zl;
  gh = o;
  var a = /^Encoding not recognized: /;
  function s(d) {
    if (!d) return null;
    try {
      return r.getDecoder(d);
    } catch (p) {
      throw a.test(p.message)
        ? n(415, "specified encoding unsupported", {
            encoding: d,
            type: "encoding.unsupported",
          })
        : p;
    }
  }
  function o(d, p, h) {
    var m = h,
      g = p || {};
    if (
      ((p === !0 || typeof p == "string") && (g = { encoding: p }),
      typeof p == "function" && ((m = p), (g = {})),
      m !== void 0 && typeof m != "function")
    )
      throw new TypeError("argument callback must be a function");
    if (!m && !Tn.Promise) throw new TypeError("argument callback is required");
    var v = g.encoding !== !0 ? g.encoding : "utf-8",
      y = t.parse(g.limit),
      _ = g.length != null && !isNaN(g.length) ? parseInt(g.length, 10) : null;
    return m
      ? l(d, v, _, y, u(m))
      : new Promise(function (R, A) {
          l(d, v, _, y, function (S, w) {
            if (S) return A(S);
            R(w);
          });
        });
  }
  function c(d) {
    i(d), typeof d.pause == "function" && d.pause();
  }
  function l(d, p, h, m, g) {
    var v = !1,
      y = !0;
    if (m !== null && h !== null && h > m)
      return I(
        n(413, "request entity too large", {
          expected: h,
          length: h,
          limit: m,
          type: "entity.too.large",
        }),
      );
    var _ = d._readableState;
    if (d._decoder || (_ && (_.encoding || _.decoder)))
      return I(
        n(500, "stream encoding should not be set", {
          type: "stream.encoding.set",
        }),
      );
    if (typeof d.readable < "u" && !d.readable)
      return I(
        n(500, "stream is not readable", { type: "stream.not.readable" }),
      );
    var E = 0,
      R;
    try {
      R = s(p);
    } catch (j) {
      return I(j);
    }
    var A = R ? "" : [];
    d.on("aborted", S),
      d.on("close", Q),
      d.on("data", w),
      d.on("end", O),
      d.on("error", O),
      (y = !1);
    function I() {
      for (var j = new Array(arguments.length), H = 0; H < j.length; H++)
        j[H] = arguments[H];
      (v = !0), y ? process.nextTick(q) : q();
      function q() {
        Q(), j[0] && c(d), g.apply(null, j);
      }
    }
    function S() {
      v ||
        I(
          n(400, "request aborted", {
            code: "ECONNABORTED",
            expected: h,
            length: h,
            received: E,
            type: "request.aborted",
          }),
        );
    }
    function w(j) {
      v ||
        ((E += j.length),
        m !== null && E > m
          ? I(
              n(413, "request entity too large", {
                limit: m,
                received: E,
                type: "entity.too.large",
              }),
            )
          : R
          ? (A += R.write(j))
          : A.push(j));
    }
    function O(j) {
      if (!v) {
        if (j) return I(j);
        if (h !== null && E !== h)
          I(
            n(400, "request size did not match content length", {
              expected: h,
              length: h,
              received: E,
              type: "request.size.invalid",
            }),
          );
        else {
          var H = R ? A + (R.end() || "") : Buffer.concat(A);
          I(null, H);
        }
      }
    }
    function Q() {
      (A = null),
        d.removeListener("aborted", S),
        d.removeListener("data", w),
        d.removeListener("end", O),
        d.removeListener("error", O),
        d.removeListener("close", Q);
    }
  }
  function f() {
    try {
      return require("async_hooks");
    } catch {
      return {};
    }
  }
  function u(d) {
    var p;
    return (
      e.AsyncResource &&
        (p = new e.AsyncResource(d.name || "bound-anonymous-fn")),
      !p || !p.runInAsyncScope ? d : p.runInAsyncScope.bind(p, d, null)
    );
  }
  return gh;
}
var tv = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */ var FN = jN;
function jN(e, t) {
  if (!Array.isArray(e))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  for (var n = [], r = 0; r < e.length; r++) {
    var i = e[r];
    if (!Array.isArray(i) || i.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    for (var a = i[0], s = 1; s < i.length; s++) {
      var o = i[s],
        c = MN(o, l);
      a.on(o, c), n.push({ ee: a, event: o, fn: c });
    }
  }
  function l() {
    f(), t.apply(null, arguments);
  }
  function f() {
    for (var d, p = 0; p < n.length; p++)
      (d = n[p]), d.ee.removeListener(d.event, d.fn);
  }
  function u(d) {
    t = d;
  }
  return (u.cancel = f), u;
}
function MN(e, t) {
  return function (r) {
    for (
      var i = new Array(arguments.length),
        a = this,
        s = e === "error" ? r : null,
        o = 0;
      o < i.length;
      o++
    )
      i[o] = arguments[o];
    t(s, a, e, i);
  };
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ tv.exports = qN;
tv.exports.isFinished = bI;
var K1 = KN(),
  V1 = FN,
  HN =
    typeof setImmediate == "function"
      ? setImmediate
      : function (e) {
          process.nextTick(e.bind.apply(e, arguments));
        };
function qN(e, t) {
  return bI(e) !== !1 ? (HN(t, null, e), e) : (QN(e, VN(t)), e);
}
function bI(e) {
  var t = e.socket;
  if (typeof e.finished == "boolean")
    return !!(e.finished || (t && !t.writable));
  if (typeof e.complete == "boolean")
    return !!(e.upgrade || !t || !t.readable || (e.complete && !e.readable));
}
function GN(e, t) {
  var n,
    r,
    i = !1;
  function a(o) {
    n.cancel(), r.cancel(), (i = !0), t(o);
  }
  n = r = V1([[e, "end", "finish"]], a);
  function s(o) {
    e.removeListener("socket", s),
      !i && n === r && (r = V1([[o, "error", "close"]], a));
  }
  if (e.socket) {
    s(e.socket);
    return;
  }
  e.on("socket", s), e.socket === void 0 && zN(e, s);
}
function QN(e, t) {
  var n = e.__onFinished;
  (!n || !n.queue) && ((n = e.__onFinished = WN(e)), GN(e, n)), n.queue.push(t);
}
function WN(e) {
  function t(n) {
    if ((e.__onFinished === t && (e.__onFinished = null), !!t.queue)) {
      var r = t.queue;
      t.queue = null;
      for (var i = 0; i < r.length; i++) r[i](n, e);
    }
  }
  return (t.queue = []), t;
}
function zN(e, t) {
  var n = e.assignSocket;
  typeof n == "function" &&
    (e.assignSocket = function (i) {
      n.call(this, i), t(i);
    });
}
function KN() {
  try {
    return require("async_hooks");
  } catch {
    return {};
  }
}
function VN(e) {
  var t;
  return (
    K1.AsyncResource &&
      (t = new K1.AsyncResource(e.name || "bound-anonymous-fn")),
    !t || !t.runInAsyncScope ? e : t.runInAsyncScope.bind(t, e, null)
  );
}
var Kl = tv.exports;
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var vh, Y1;
function Gd() {
  if (Y1) return vh;
  Y1 = 1;
  var e = Gi,
    t = ev,
    n = UN(),
    r = qd(),
    i = Kl,
    a = zl,
    s = mc;
  vh = o;
  function o(f, u, d, p, h, m) {
    var g,
      v = m,
      y;
    f._body = !0;
    var _ = v.encoding !== null ? v.encoding : null,
      E = v.verify;
    try {
      (y = c(f, h, v.inflate)), (g = y.length), (y.length = void 0);
    } catch (R) {
      return d(R);
    }
    if (
      ((v.length = g),
      (v.encoding = E ? null : _),
      v.encoding === null && _ !== null && !r.encodingExists(_))
    )
      return d(
        e(415, 'unsupported charset "' + _.toUpperCase() + '"', {
          charset: _.toLowerCase(),
          type: "charset.unsupported",
        }),
      );
    h("read body"),
      n(y, v, function (R, A) {
        if (R) {
          var I;
          R.type === "encoding.unsupported"
            ? (I = e(415, 'unsupported charset "' + _.toUpperCase() + '"', {
                charset: _.toLowerCase(),
                type: "charset.unsupported",
              }))
            : (I = e(400, R)),
            y !== f && (a(f), t(y, !0)),
            l(f, function () {
              d(e(400, I));
            });
          return;
        }
        if (E)
          try {
            h("verify body"), E(f, u, A, _);
          } catch (w) {
            d(e(403, w, { body: A, type: w.type || "entity.verify.failed" }));
            return;
          }
        var S = A;
        try {
          h("parse body"),
            (S = typeof A != "string" && _ !== null ? r.decode(A, _) : A),
            (f.body = p(S));
        } catch (w) {
          d(e(400, w, { body: S, type: w.type || "entity.parse.failed" }));
          return;
        }
        d();
      });
  }
  function c(f, u, d) {
    var p = (f.headers["content-encoding"] || "identity").toLowerCase(),
      h = f.headers["content-length"],
      m;
    if ((u('content-encoding "%s"', p), d === !1 && p !== "identity"))
      throw e(415, "content encoding unsupported", {
        encoding: p,
        type: "encoding.unsupported",
      });
    switch (p) {
      case "deflate":
        (m = s.createInflate()), u("inflate body"), f.pipe(m);
        break;
      case "gzip":
        (m = s.createGunzip()), u("gunzip body"), f.pipe(m);
        break;
      case "identity":
        (m = f), (m.length = h);
        break;
      default:
        throw e(415, 'unsupported content encoding "' + p + '"', {
          encoding: p,
          type: "encoding.unsupported",
        });
    }
    return m;
  }
  function l(f, u) {
    i.isFinished(f) ? u(null) : (i(f, u), f.resume());
  }
  return vh;
}
var vc = { exports: {} },
  nv = {};
/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */ var X1 =
    /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g,
  YN = /^[\u0020-\u007e\u0080-\u00ff]+$/,
  _I = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/,
  XN = /\\([\u0000-\u007f])/g,
  JN = /([\\"])/g,
  ZN = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/,
  J1 = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/,
  eO =
    /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
nv.format = tO;
nv.parse = nO;
function tO(e) {
  if (!e || typeof e != "object")
    throw new TypeError("argument obj is required");
  var t = e.parameters,
    n = e.subtype,
    r = e.suffix,
    i = e.type;
  if (!i || !J1.test(i)) throw new TypeError("invalid type");
  if (!n || !ZN.test(n)) throw new TypeError("invalid subtype");
  var a = i + "/" + n;
  if (r) {
    if (!J1.test(r)) throw new TypeError("invalid suffix");
    a += "+" + r;
  }
  if (t && typeof t == "object")
    for (var s, o = Object.keys(t).sort(), c = 0; c < o.length; c++) {
      if (((s = o[c]), !_I.test(s)))
        throw new TypeError("invalid parameter name");
      a += "; " + s + "=" + iO(t[s]);
    }
  return a;
}
function nO(e) {
  if (!e) throw new TypeError("argument string is required");
  if ((typeof e == "object" && (e = rO(e)), typeof e != "string"))
    throw new TypeError("argument string is required to be a string");
  var t = e.indexOf(";"),
    n = t !== -1 ? e.substr(0, t) : e,
    r,
    i,
    a = aO(n),
    s = {},
    o;
  for (X1.lastIndex = t; (i = X1.exec(e)); ) {
    if (i.index !== t) throw new TypeError("invalid parameter format");
    (t += i[0].length),
      (r = i[1].toLowerCase()),
      (o = i[2]),
      o[0] === '"' && (o = o.substr(1, o.length - 2).replace(XN, "$1")),
      (s[r] = o);
  }
  if (t !== -1 && t !== e.length)
    throw new TypeError("invalid parameter format");
  return (a.parameters = s), a;
}
function rO(e) {
  if (typeof e.getHeader == "function") return e.getHeader("content-type");
  if (typeof e.headers == "object")
    return e.headers && e.headers["content-type"];
}
function iO(e) {
  var t = String(e);
  if (_I.test(t)) return t;
  if (t.length > 0 && !YN.test(t))
    throw new TypeError("invalid parameter value");
  return '"' + t.replace(JN, "\\$1") + '"';
}
function aO(e) {
  var t = eO.exec(e.toLowerCase());
  if (!t) throw new TypeError("invalid media type");
  var n = t[1],
    r = t[2],
    i,
    a = r.lastIndexOf("+");
  a !== -1 && ((i = r.substr(a + 1)), (r = r.substr(0, a)));
  var s = { type: n, subtype: r, suffix: i };
  return s;
}
var rv = {};
const sO = {
  "application/1d-interleaved-parityfec": { source: "iana" },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/3gpp-ims+xml": { source: "iana", compressible: !0 },
  "application/3gpphal+json": { source: "iana", compressible: !0 },
  "application/3gpphalforms+json": { source: "iana", compressible: !0 },
  "application/a2l": { source: "iana" },
  "application/ace+cbor": { source: "iana" },
  "application/activemessage": { source: "iana" },
  "application/activity+json": { source: "iana", compressible: !0 },
  "application/alto-costmap+json": { source: "iana", compressible: !0 },
  "application/alto-costmapfilter+json": { source: "iana", compressible: !0 },
  "application/alto-directory+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcost+json": { source: "iana", compressible: !0 },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-endpointprop+json": { source: "iana", compressible: !0 },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-error+json": { source: "iana", compressible: !0 },
  "application/alto-networkmap+json": { source: "iana", compressible: !0 },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: !0,
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: !0,
  },
  "application/aml": { source: "iana" },
  "application/andrew-inset": { source: "iana", extensions: ["ez"] },
  "application/applefile": { source: "iana" },
  "application/applixware": { source: "apache", extensions: ["aw"] },
  "application/at+jwt": { source: "iana" },
  "application/atf": { source: "iana" },
  "application/atfx": { source: "iana" },
  "application/atom+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atom"],
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomcat"],
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomdeleted"],
  },
  "application/atomicmail": { source: "iana" },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["atomsvc"],
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dwd"],
  },
  "application/atsc-dynamic-event-message": { source: "iana" },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["held"],
  },
  "application/atsc-rdt+json": { source: "iana", compressible: !0 },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rsat"],
  },
  "application/atxml": { source: "iana" },
  "application/auth-policy+xml": { source: "iana", compressible: !0 },
  "application/bacnet-xdd+zip": { source: "iana", compressible: !1 },
  "application/batch-smtp": { source: "iana" },
  "application/bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/calendar+json": { source: "iana", compressible: !0 },
  "application/calendar+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xcs"],
  },
  "application/call-completion": { source: "iana" },
  "application/cals-1840": { source: "iana" },
  "application/captive+json": { source: "iana", compressible: !0 },
  "application/cbor": { source: "iana" },
  "application/cbor-seq": { source: "iana" },
  "application/cccex": { source: "iana" },
  "application/ccmp+xml": { source: "iana", compressible: !0 },
  "application/ccxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ccxml"],
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cdfx"],
  },
  "application/cdmi-capability": { source: "iana", extensions: ["cdmia"] },
  "application/cdmi-container": { source: "iana", extensions: ["cdmic"] },
  "application/cdmi-domain": { source: "iana", extensions: ["cdmid"] },
  "application/cdmi-object": { source: "iana", extensions: ["cdmio"] },
  "application/cdmi-queue": { source: "iana", extensions: ["cdmiq"] },
  "application/cdni": { source: "iana" },
  "application/cea": { source: "iana" },
  "application/cea-2018+xml": { source: "iana", compressible: !0 },
  "application/cellml+xml": { source: "iana", compressible: !0 },
  "application/cfw": { source: "iana" },
  "application/city+json": { source: "iana", compressible: !0 },
  "application/clr": { source: "iana" },
  "application/clue+xml": { source: "iana", compressible: !0 },
  "application/clue_info+xml": { source: "iana", compressible: !0 },
  "application/cms": { source: "iana" },
  "application/cnrp+xml": { source: "iana", compressible: !0 },
  "application/coap-group+json": { source: "iana", compressible: !0 },
  "application/coap-payload": { source: "iana" },
  "application/commonground": { source: "iana" },
  "application/conference-info+xml": { source: "iana", compressible: !0 },
  "application/cose": { source: "iana" },
  "application/cose-key": { source: "iana" },
  "application/cose-key-set": { source: "iana" },
  "application/cpl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cpl"],
  },
  "application/csrattrs": { source: "iana" },
  "application/csta+xml": { source: "iana", compressible: !0 },
  "application/cstadata+xml": { source: "iana", compressible: !0 },
  "application/csvm+json": { source: "iana", compressible: !0 },
  "application/cu-seeme": { source: "apache", extensions: ["cu"] },
  "application/cwt": { source: "iana" },
  "application/cybercash": { source: "iana" },
  "application/dart": { compressible: !0 },
  "application/dash+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpd"],
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpp"],
  },
  "application/dashdelta": { source: "iana" },
  "application/davmount+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["davmount"],
  },
  "application/dca-rft": { source: "iana" },
  "application/dcd": { source: "iana" },
  "application/dec-dx": { source: "iana" },
  "application/dialog-info+xml": { source: "iana", compressible: !0 },
  "application/dicom": { source: "iana" },
  "application/dicom+json": { source: "iana", compressible: !0 },
  "application/dicom+xml": { source: "iana", compressible: !0 },
  "application/dii": { source: "iana" },
  "application/dit": { source: "iana" },
  "application/dns": { source: "iana" },
  "application/dns+json": { source: "iana", compressible: !0 },
  "application/dns-message": { source: "iana" },
  "application/docbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["dbk"],
  },
  "application/dots+cbor": { source: "iana" },
  "application/dskpp+xml": { source: "iana", compressible: !0 },
  "application/dssc+der": { source: "iana", extensions: ["dssc"] },
  "application/dssc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdssc"],
  },
  "application/dvcs": { source: "iana" },
  "application/ecmascript": {
    source: "iana",
    compressible: !0,
    extensions: ["es", "ecma"],
  },
  "application/edi-consent": { source: "iana" },
  "application/edi-x12": { source: "iana", compressible: !1 },
  "application/edifact": { source: "iana", compressible: !1 },
  "application/efi": { source: "iana" },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/elm+xml": { source: "iana", compressible: !0 },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.ecall.msd": { source: "iana" },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/emma+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["emma"],
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["emotionml"],
  },
  "application/encaprtp": { source: "iana" },
  "application/epp+xml": { source: "iana", compressible: !0 },
  "application/epub+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["epub"],
  },
  "application/eshop": { source: "iana" },
  "application/exi": { source: "iana", extensions: ["exi"] },
  "application/expect-ct-report+json": { source: "iana", compressible: !0 },
  "application/express": { source: "iana", extensions: ["exp"] },
  "application/fastinfoset": { source: "iana" },
  "application/fastsoap": { source: "iana" },
  "application/fdt+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["fdt"],
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/fido.trusted-apps+json": { compressible: !0 },
  "application/fits": { source: "iana" },
  "application/flexfec": { source: "iana" },
  "application/font-sfnt": { source: "iana" },
  "application/font-tdpfr": { source: "iana", extensions: ["pfr"] },
  "application/font-woff": { source: "iana", compressible: !1 },
  "application/framework-attributes+xml": { source: "iana", compressible: !0 },
  "application/geo+json": {
    source: "iana",
    compressible: !0,
    extensions: ["geojson"],
  },
  "application/geo+json-seq": { source: "iana" },
  "application/geopackage+sqlite3": { source: "iana" },
  "application/geoxacml+xml": { source: "iana", compressible: !0 },
  "application/gltf-buffer": { source: "iana" },
  "application/gml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["gml"],
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["gpx"],
  },
  "application/gxf": { source: "apache", extensions: ["gxf"] },
  "application/gzip": { source: "iana", compressible: !1, extensions: ["gz"] },
  "application/h224": { source: "iana" },
  "application/held+xml": { source: "iana", compressible: !0 },
  "application/hjson": { extensions: ["hjson"] },
  "application/http": { source: "iana" },
  "application/hyperstudio": { source: "iana", extensions: ["stk"] },
  "application/ibe-key-request+xml": { source: "iana", compressible: !0 },
  "application/ibe-pkg-reply+xml": { source: "iana", compressible: !0 },
  "application/ibe-pp-data": { source: "iana" },
  "application/iges": { source: "iana" },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/index": { source: "iana" },
  "application/index.cmd": { source: "iana" },
  "application/index.obj": { source: "iana" },
  "application/index.response": { source: "iana" },
  "application/index.vnd": { source: "iana" },
  "application/inkml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ink", "inkml"],
  },
  "application/iotp": { source: "iana" },
  "application/ipfix": { source: "iana", extensions: ["ipfix"] },
  "application/ipp": { source: "iana" },
  "application/isup": { source: "iana" },
  "application/its+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["its"],
  },
  "application/java-archive": {
    source: "apache",
    compressible: !1,
    extensions: ["jar", "war", "ear"],
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: !1,
    extensions: ["ser"],
  },
  "application/java-vm": {
    source: "apache",
    compressible: !1,
    extensions: ["class"],
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["js", "mjs"],
  },
  "application/jf2feed+json": { source: "iana", compressible: !0 },
  "application/jose": { source: "iana" },
  "application/jose+json": { source: "iana", compressible: !0 },
  "application/jrd+json": { source: "iana", compressible: !0 },
  "application/jscalendar+json": { source: "iana", compressible: !0 },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["json", "map"],
  },
  "application/json-patch+json": { source: "iana", compressible: !0 },
  "application/json-seq": { source: "iana" },
  "application/json5": { extensions: ["json5"] },
  "application/jsonml+json": {
    source: "apache",
    compressible: !0,
    extensions: ["jsonml"],
  },
  "application/jwk+json": { source: "iana", compressible: !0 },
  "application/jwk-set+json": { source: "iana", compressible: !0 },
  "application/jwt": { source: "iana" },
  "application/kpml-request+xml": { source: "iana", compressible: !0 },
  "application/kpml-response+xml": { source: "iana", compressible: !0 },
  "application/ld+json": {
    source: "iana",
    compressible: !0,
    extensions: ["jsonld"],
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lgr"],
  },
  "application/link-format": { source: "iana" },
  "application/load-control+xml": { source: "iana", compressible: !0 },
  "application/lost+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lostxml"],
  },
  "application/lostsync+xml": { source: "iana", compressible: !0 },
  "application/lpf+zip": { source: "iana", compressible: !1 },
  "application/lxf": { source: "iana" },
  "application/mac-binhex40": { source: "iana", extensions: ["hqx"] },
  "application/mac-compactpro": { source: "apache", extensions: ["cpt"] },
  "application/macwriteii": { source: "iana" },
  "application/mads+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mads"],
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["webmanifest"],
  },
  "application/marc": { source: "iana", extensions: ["mrc"] },
  "application/marcxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mrcx"],
  },
  "application/mathematica": { source: "iana", extensions: ["ma", "nb", "mb"] },
  "application/mathml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mathml"],
  },
  "application/mathml-content+xml": { source: "iana", compressible: !0 },
  "application/mathml-presentation+xml": { source: "iana", compressible: !0 },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-deregister+xml": { source: "iana", compressible: !0 },
  "application/mbms-envelope+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk+xml": { source: "iana", compressible: !0 },
  "application/mbms-msk-response+xml": { source: "iana", compressible: !0 },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-reception-report+xml": { source: "iana", compressible: !0 },
  "application/mbms-register+xml": { source: "iana", compressible: !0 },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbms-schedule+xml": { source: "iana", compressible: !0 },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/mbox": { source: "iana", extensions: ["mbox"] },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpf"],
  },
  "application/media_control+xml": { source: "iana", compressible: !0 },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mscml"],
  },
  "application/merge-patch+json": { source: "iana", compressible: !0 },
  "application/metalink+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["metalink"],
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["meta4"],
  },
  "application/mets+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mets"],
  },
  "application/mf4": { source: "iana" },
  "application/mikey": { source: "iana" },
  "application/mipc": { source: "iana" },
  "application/missing-blocks+cbor-seq": { source: "iana" },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["maei"],
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["musd"],
  },
  "application/mods+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mods"],
  },
  "application/moss-keys": { source: "iana" },
  "application/moss-signature": { source: "iana" },
  "application/mosskey-data": { source: "iana" },
  "application/mosskey-request": { source: "iana" },
  "application/mp21": { source: "iana", extensions: ["m21", "mp21"] },
  "application/mp4": { source: "iana", extensions: ["mp4s", "m4p"] },
  "application/mpeg4-generic": { source: "iana" },
  "application/mpeg4-iod": { source: "iana" },
  "application/mpeg4-iod-xmt": { source: "iana" },
  "application/mrb-consumer+xml": { source: "iana", compressible: !0 },
  "application/mrb-publish+xml": { source: "iana", compressible: !0 },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/msword": {
    source: "iana",
    compressible: !1,
    extensions: ["doc", "dot"],
  },
  "application/mud+json": { source: "iana", compressible: !0 },
  "application/multipart-core": { source: "iana" },
  "application/mxf": { source: "iana", extensions: ["mxf"] },
  "application/n-quads": { source: "iana", extensions: ["nq"] },
  "application/n-triples": { source: "iana", extensions: ["nt"] },
  "application/nasdata": { source: "iana" },
  "application/news-checkgroups": { source: "iana", charset: "US-ASCII" },
  "application/news-groupinfo": { source: "iana", charset: "US-ASCII" },
  "application/news-transmission": { source: "iana" },
  "application/nlsml+xml": { source: "iana", compressible: !0 },
  "application/node": { source: "iana", extensions: ["cjs"] },
  "application/nss": { source: "iana" },
  "application/oauth-authz-req+jwt": { source: "iana" },
  "application/oblivious-dns-message": { source: "iana" },
  "application/ocsp-request": { source: "iana" },
  "application/ocsp-response": { source: "iana" },
  "application/octet-stream": {
    source: "iana",
    compressible: !1,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer",
    ],
  },
  "application/oda": { source: "iana", extensions: ["oda"] },
  "application/odm+xml": { source: "iana", compressible: !0 },
  "application/odx": { source: "iana" },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["opf"],
  },
  "application/ogg": { source: "iana", compressible: !1, extensions: ["ogx"] },
  "application/omdoc+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["omdoc"],
  },
  "application/onenote": {
    source: "apache",
    extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"],
  },
  "application/opc-nodeset+xml": { source: "iana", compressible: !0 },
  "application/oscore": { source: "iana" },
  "application/oxps": { source: "iana", extensions: ["oxps"] },
  "application/p21": { source: "iana" },
  "application/p21+zip": { source: "iana", compressible: !1 },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["relo"],
  },
  "application/parityfec": { source: "iana" },
  "application/passport": { source: "iana" },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xer"],
  },
  "application/pdf": { source: "iana", compressible: !1, extensions: ["pdf"] },
  "application/pdx": { source: "iana" },
  "application/pem-certificate-chain": { source: "iana" },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: !1,
    extensions: ["pgp"],
  },
  "application/pgp-keys": { source: "iana", extensions: ["asc"] },
  "application/pgp-signature": { source: "iana", extensions: ["asc", "sig"] },
  "application/pics-rules": { source: "apache", extensions: ["prf"] },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/pkcs10": { source: "iana", extensions: ["p10"] },
  "application/pkcs12": { source: "iana" },
  "application/pkcs7-mime": { source: "iana", extensions: ["p7m", "p7c"] },
  "application/pkcs7-signature": { source: "iana", extensions: ["p7s"] },
  "application/pkcs8": { source: "iana", extensions: ["p8"] },
  "application/pkcs8-encrypted": { source: "iana" },
  "application/pkix-attr-cert": { source: "iana", extensions: ["ac"] },
  "application/pkix-cert": { source: "iana", extensions: ["cer"] },
  "application/pkix-crl": { source: "iana", extensions: ["crl"] },
  "application/pkix-pkipath": { source: "iana", extensions: ["pkipath"] },
  "application/pkixcmp": { source: "iana", extensions: ["pki"] },
  "application/pls+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["pls"],
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/postscript": {
    source: "iana",
    compressible: !0,
    extensions: ["ai", "eps", "ps"],
  },
  "application/ppsp-tracker+json": { source: "iana", compressible: !0 },
  "application/problem+json": { source: "iana", compressible: !0 },
  "application/problem+xml": { source: "iana", compressible: !0 },
  "application/provenance+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["provx"],
  },
  "application/prs.alvestrand.titrax-sheet": { source: "iana" },
  "application/prs.cww": { source: "iana", extensions: ["cww"] },
  "application/prs.cyn": { source: "iana", charset: "7-BIT" },
  "application/prs.hpub+zip": { source: "iana", compressible: !1 },
  "application/prs.nprend": { source: "iana" },
  "application/prs.plucker": { source: "iana" },
  "application/prs.rdf-xml-crypt": { source: "iana" },
  "application/prs.xsf+xml": { source: "iana", compressible: !0 },
  "application/pskc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["pskcxml"],
  },
  "application/pvd+json": { source: "iana", compressible: !0 },
  "application/qsig": { source: "iana" },
  "application/raml+yaml": { compressible: !0, extensions: ["raml"] },
  "application/raptorfec": { source: "iana" },
  "application/rdap+json": { source: "iana", compressible: !0 },
  "application/rdf+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rdf", "owl"],
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rif"],
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: ["rnc"],
  },
  "application/remote-printing": { source: "iana" },
  "application/reputon+json": { source: "iana", compressible: !0 },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rl"],
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rld"],
  },
  "application/rfc+xml": { source: "iana", compressible: !0 },
  "application/riscos": { source: "iana" },
  "application/rlmi+xml": { source: "iana", compressible: !0 },
  "application/rls-services+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rs"],
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rapd"],
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sls"],
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rusd"],
  },
  "application/rpki-ghostbusters": { source: "iana", extensions: ["gbr"] },
  "application/rpki-manifest": { source: "iana", extensions: ["mft"] },
  "application/rpki-publication": { source: "iana" },
  "application/rpki-roa": { source: "iana", extensions: ["roa"] },
  "application/rpki-updown": { source: "iana" },
  "application/rsd+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["rsd"],
  },
  "application/rss+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["rss"],
  },
  "application/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "application/rtploopback": { source: "iana" },
  "application/rtx": { source: "iana" },
  "application/samlassertion+xml": { source: "iana", compressible: !0 },
  "application/samlmetadata+xml": { source: "iana", compressible: !0 },
  "application/sarif+json": { source: "iana", compressible: !0 },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: !0,
  },
  "application/sbe": { source: "iana" },
  "application/sbml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sbml"],
  },
  "application/scaip+xml": { source: "iana", compressible: !0 },
  "application/scim+json": { source: "iana", compressible: !0 },
  "application/scvp-cv-request": { source: "iana", extensions: ["scq"] },
  "application/scvp-cv-response": { source: "iana", extensions: ["scs"] },
  "application/scvp-vp-request": { source: "iana", extensions: ["spq"] },
  "application/scvp-vp-response": { source: "iana", extensions: ["spp"] },
  "application/sdp": { source: "iana", extensions: ["sdp"] },
  "application/secevent+jwt": { source: "iana" },
  "application/senml+cbor": { source: "iana" },
  "application/senml+json": { source: "iana", compressible: !0 },
  "application/senml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["senmlx"],
  },
  "application/senml-etch+cbor": { source: "iana" },
  "application/senml-etch+json": { source: "iana", compressible: !0 },
  "application/senml-exi": { source: "iana" },
  "application/sensml+cbor": { source: "iana" },
  "application/sensml+json": { source: "iana", compressible: !0 },
  "application/sensml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sensmlx"],
  },
  "application/sensml-exi": { source: "iana" },
  "application/sep+xml": { source: "iana", compressible: !0 },
  "application/sep-exi": { source: "iana" },
  "application/session-info": { source: "iana" },
  "application/set-payment": { source: "iana" },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: ["setpay"],
  },
  "application/set-registration": { source: "iana" },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: ["setreg"],
  },
  "application/sgml": { source: "iana" },
  "application/sgml-open-catalog": { source: "iana" },
  "application/shf+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["shf"],
  },
  "application/sieve": { source: "iana", extensions: ["siv", "sieve"] },
  "application/simple-filter+xml": { source: "iana", compressible: !0 },
  "application/simple-message-summary": { source: "iana" },
  "application/simplesymbolcontainer": { source: "iana" },
  "application/sipc": { source: "iana" },
  "application/slate": { source: "iana" },
  "application/smil": { source: "iana" },
  "application/smil+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["smi", "smil"],
  },
  "application/smpte336m": { source: "iana" },
  "application/soap+fastinfoset": { source: "iana" },
  "application/soap+xml": { source: "iana", compressible: !0 },
  "application/sparql-query": { source: "iana", extensions: ["rq"] },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["srx"],
  },
  "application/spdx+json": { source: "iana", compressible: !0 },
  "application/spirits-event+xml": { source: "iana", compressible: !0 },
  "application/sql": { source: "iana" },
  "application/srgs": { source: "iana", extensions: ["gram"] },
  "application/srgs+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["grxml"],
  },
  "application/sru+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sru"],
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["ssdl"],
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ssml"],
  },
  "application/stix+json": { source: "iana", compressible: !0 },
  "application/swid+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["swidtag"],
  },
  "application/tamp-apex-update": { source: "iana" },
  "application/tamp-apex-update-confirm": { source: "iana" },
  "application/tamp-community-update": { source: "iana" },
  "application/tamp-community-update-confirm": { source: "iana" },
  "application/tamp-error": { source: "iana" },
  "application/tamp-sequence-adjust": { source: "iana" },
  "application/tamp-sequence-adjust-confirm": { source: "iana" },
  "application/tamp-status-query": { source: "iana" },
  "application/tamp-status-response": { source: "iana" },
  "application/tamp-update": { source: "iana" },
  "application/tamp-update-confirm": { source: "iana" },
  "application/tar": { compressible: !0 },
  "application/taxii+json": { source: "iana", compressible: !0 },
  "application/td+json": { source: "iana", compressible: !0 },
  "application/tei+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["tei", "teicorpus"],
  },
  "application/tetra_isi": { source: "iana" },
  "application/thraud+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["tfi"],
  },
  "application/timestamp-query": { source: "iana" },
  "application/timestamp-reply": { source: "iana" },
  "application/timestamped-data": { source: "iana", extensions: ["tsd"] },
  "application/tlsrpt+gzip": { source: "iana" },
  "application/tlsrpt+json": { source: "iana", compressible: !0 },
  "application/tnauthlist": { source: "iana" },
  "application/token-introspection+jwt": { source: "iana" },
  "application/toml": { compressible: !0, extensions: ["toml"] },
  "application/trickle-ice-sdpfrag": { source: "iana" },
  "application/trig": { source: "iana", extensions: ["trig"] },
  "application/ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ttml"],
  },
  "application/tve-trigger": { source: "iana" },
  "application/tzif": { source: "iana" },
  "application/tzif-leap": { source: "iana" },
  "application/ubjson": { compressible: !1, extensions: ["ubj"] },
  "application/ulpfec": { source: "iana" },
  "application/urc-grpsheet+xml": { source: "iana", compressible: !0 },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["rsheet"],
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["td"],
  },
  "application/urc-uisocketdesc+xml": { source: "iana", compressible: !0 },
  "application/vcard+json": { source: "iana", compressible: !0 },
  "application/vcard+xml": { source: "iana", compressible: !0 },
  "application/vemmi": { source: "iana" },
  "application/vividence.scriptfile": { source: "apache" },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["1km"],
  },
  "application/vnd.3gpp-prose+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-prose-pc3ch+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp-v2x-local-service-information": { source: "iana" },
  "application/vnd.3gpp.5gnas": { source: "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.bsf+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gmop+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.gtpc": { source: "iana" },
  "application/vnd.3gpp.interworking-data": { source: "iana" },
  "application/vnd.3gpp.lpp": { source: "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { source: "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcdata-payload": { source: "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-signalling": { source: "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-signed+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.mid-call+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.ngap": { source: "iana" },
  "application/vnd.3gpp.pfcp": { source: "iana" },
  "application/vnd.3gpp.pic-bw-large": { source: "iana", extensions: ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { source: "iana", extensions: ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { source: "iana", extensions: ["pvb"] },
  "application/vnd.3gpp.s1ap": { source: "iana" },
  "application/vnd.3gpp.sms": { source: "iana" },
  "application/vnd.3gpp.sms+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-ext+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.srvcc-info+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.3gpp.ussd+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.bcmcsinfo+xml": { source: "iana", compressible: !0 },
  "application/vnd.3gpp2.sms": { source: "iana" },
  "application/vnd.3gpp2.tcap": { source: "iana", extensions: ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { source: "iana" },
  "application/vnd.3m.post-it-notes": { source: "iana", extensions: ["pwn"] },
  "application/vnd.accpac.simply.aso": { source: "iana", extensions: ["aso"] },
  "application/vnd.accpac.simply.imp": { source: "iana", extensions: ["imp"] },
  "application/vnd.acucobol": { source: "iana", extensions: ["acu"] },
  "application/vnd.acucorp": { source: "iana", extensions: ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: !1,
    extensions: ["air"],
  },
  "application/vnd.adobe.flash.movie": { source: "iana" },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: ["fcdt"],
  },
  "application/vnd.adobe.fxp": { source: "iana", extensions: ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { source: "iana" },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdp"],
  },
  "application/vnd.adobe.xfdf": { source: "iana", extensions: ["xfdf"] },
  "application/vnd.aether.imp": { source: "iana" },
  "application/vnd.afpc.afplinedata": { source: "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { source: "iana" },
  "application/vnd.afpc.cmoca-cmresource": { source: "iana" },
  "application/vnd.afpc.foca-charset": { source: "iana" },
  "application/vnd.afpc.foca-codedfont": { source: "iana" },
  "application/vnd.afpc.foca-codepage": { source: "iana" },
  "application/vnd.afpc.modca": { source: "iana" },
  "application/vnd.afpc.modca-cmtable": { source: "iana" },
  "application/vnd.afpc.modca-formdef": { source: "iana" },
  "application/vnd.afpc.modca-mediummap": { source: "iana" },
  "application/vnd.afpc.modca-objectcontainer": { source: "iana" },
  "application/vnd.afpc.modca-overlay": { source: "iana" },
  "application/vnd.afpc.modca-pagesegment": { source: "iana" },
  "application/vnd.age": { source: "iana", extensions: ["age"] },
  "application/vnd.ah-barcode": { source: "iana" },
  "application/vnd.ahead.space": { source: "iana", extensions: ["ahead"] },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: ["azf"],
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: ["azs"],
  },
  "application/vnd.amadeus+json": { source: "iana", compressible: !0 },
  "application/vnd.amazon.ebook": { source: "apache", extensions: ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { source: "iana" },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: ["acc"],
  },
  "application/vnd.amiga.ami": { source: "iana", extensions: ["ami"] },
  "application/vnd.amundsen.maze+xml": { source: "iana", compressible: !0 },
  "application/vnd.android.ota": { source: "iana" },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: !1,
    extensions: ["apk"],
  },
  "application/vnd.anki": { source: "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: ["cii"],
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: ["fti"],
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: ["atx"],
  },
  "application/vnd.apache.arrow.file": { source: "iana" },
  "application/vnd.apache.arrow.stream": { source: "iana" },
  "application/vnd.apache.thrift.binary": { source: "iana" },
  "application/vnd.apache.thrift.compact": { source: "iana" },
  "application/vnd.apache.thrift.json": { source: "iana" },
  "application/vnd.api+json": { source: "iana", compressible: !0 },
  "application/vnd.aplextor.warrp+json": { source: "iana", compressible: !0 },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mpkg"],
  },
  "application/vnd.apple.keynote": { source: "iana", extensions: ["key"] },
  "application/vnd.apple.mpegurl": { source: "iana", extensions: ["m3u8"] },
  "application/vnd.apple.numbers": { source: "iana", extensions: ["numbers"] },
  "application/vnd.apple.pages": { source: "iana", extensions: ["pages"] },
  "application/vnd.apple.pkpass": { compressible: !1, extensions: ["pkpass"] },
  "application/vnd.arastra.swi": { source: "iana" },
  "application/vnd.aristanetworks.swi": { source: "iana", extensions: ["swi"] },
  "application/vnd.artisan+json": { source: "iana", compressible: !0 },
  "application/vnd.artsquare": { source: "iana" },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: ["iota"],
  },
  "application/vnd.audiograph": { source: "iana", extensions: ["aep"] },
  "application/vnd.autopackage": { source: "iana" },
  "application/vnd.avalon+json": { source: "iana", compressible: !0 },
  "application/vnd.avistar+xml": { source: "iana", compressible: !0 },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["bmml"],
  },
  "application/vnd.balsamiq.bmpr": { source: "iana" },
  "application/vnd.banana-accounting": { source: "iana" },
  "application/vnd.bbf.usp.error": { source: "iana" },
  "application/vnd.bbf.usp.msg": { source: "iana" },
  "application/vnd.bbf.usp.msg+json": { source: "iana", compressible: !0 },
  "application/vnd.bekitzur-stech+json": { source: "iana", compressible: !0 },
  "application/vnd.bint.med-content": { source: "iana" },
  "application/vnd.biopax.rdf+xml": { source: "iana", compressible: !0 },
  "application/vnd.blink-idb-value-wrapper": { source: "iana" },
  "application/vnd.blueice.multipass": { source: "iana", extensions: ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { source: "iana" },
  "application/vnd.bluetooth.le.oob": { source: "iana" },
  "application/vnd.bmi": { source: "iana", extensions: ["bmi"] },
  "application/vnd.bpf": { source: "iana" },
  "application/vnd.bpf3": { source: "iana" },
  "application/vnd.businessobjects": { source: "iana", extensions: ["rep"] },
  "application/vnd.byu.uapi+json": { source: "iana", compressible: !0 },
  "application/vnd.cab-jscript": { source: "iana" },
  "application/vnd.canon-cpdl": { source: "iana" },
  "application/vnd.canon-lips": { source: "iana" },
  "application/vnd.capasystems-pg+json": { source: "iana", compressible: !0 },
  "application/vnd.cendio.thinlinc.clientconf": { source: "iana" },
  "application/vnd.century-systems.tcp_stream": { source: "iana" },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["cdxml"],
  },
  "application/vnd.chess-pgn": { source: "iana" },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: ["mmd"],
  },
  "application/vnd.ciedi": { source: "iana" },
  "application/vnd.cinderella": { source: "iana", extensions: ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { source: "iana" },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["csl"],
  },
  "application/vnd.claymore": { source: "iana", extensions: ["cla"] },
  "application/vnd.cloanto.rp9": { source: "iana", extensions: ["rp9"] },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"],
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: ["c11amc"],
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: ["c11amz"],
  },
  "application/vnd.coffeescript": { source: "iana" },
  "application/vnd.collabio.xodocuments.document": { source: "iana" },
  "application/vnd.collabio.xodocuments.document-template": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation": { source: "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana",
  },
  "application/vnd.collabio.xodocuments.spreadsheet": { source: "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana",
  },
  "application/vnd.collection+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.doc+json": { source: "iana", compressible: !0 },
  "application/vnd.collection.next+json": { source: "iana", compressible: !0 },
  "application/vnd.comicbook+zip": { source: "iana", compressible: !1 },
  "application/vnd.comicbook-rar": { source: "iana" },
  "application/vnd.commerce-battelle": { source: "iana" },
  "application/vnd.commonspace": { source: "iana", extensions: ["csp"] },
  "application/vnd.contact.cmsg": { source: "iana", extensions: ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { source: "iana", compressible: !0 },
  "application/vnd.cosmocaller": { source: "iana", extensions: ["cmc"] },
  "application/vnd.crick.clicker": { source: "iana", extensions: ["clkx"] },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: ["clkk"],
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: ["clkp"],
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: ["clkt"],
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: ["clkw"],
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wbs"],
  },
  "application/vnd.cryptii.pipe+json": { source: "iana", compressible: !0 },
  "application/vnd.crypto-shade-file": { source: "iana" },
  "application/vnd.cryptomator.encrypted": { source: "iana" },
  "application/vnd.cryptomator.vault": { source: "iana" },
  "application/vnd.ctc-posml": { source: "iana", extensions: ["pml"] },
  "application/vnd.ctct.ws+xml": { source: "iana", compressible: !0 },
  "application/vnd.cups-pdf": { source: "iana" },
  "application/vnd.cups-postscript": { source: "iana" },
  "application/vnd.cups-ppd": { source: "iana", extensions: ["ppd"] },
  "application/vnd.cups-raster": { source: "iana" },
  "application/vnd.cups-raw": { source: "iana" },
  "application/vnd.curl": { source: "iana" },
  "application/vnd.curl.car": { source: "apache", extensions: ["car"] },
  "application/vnd.curl.pcurl": { source: "apache", extensions: ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { source: "iana", compressible: !0 },
  "application/vnd.cybank": { source: "iana" },
  "application/vnd.cyclonedx+json": { source: "iana", compressible: !0 },
  "application/vnd.cyclonedx+xml": { source: "iana", compressible: !0 },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: !1,
  },
  "application/vnd.d3m-dataset": { source: "iana" },
  "application/vnd.d3m-problem": { source: "iana" },
  "application/vnd.dart": {
    source: "iana",
    compressible: !0,
    extensions: ["dart"],
  },
  "application/vnd.data-vision.rdz": { source: "iana", extensions: ["rdz"] },
  "application/vnd.datapackage+json": { source: "iana", compressible: !0 },
  "application/vnd.dataresource+json": { source: "iana", compressible: !0 },
  "application/vnd.dbf": { source: "iana", extensions: ["dbf"] },
  "application/vnd.debian.binary-package": { source: "iana" },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: ["uvf", "uvvf", "uvd", "uvvd"],
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["uvt", "uvvt"],
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: ["uvx", "uvvx"],
  },
  "application/vnd.dece.zip": { source: "iana", extensions: ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: ["fe_launch"],
  },
  "application/vnd.desmume.movie": { source: "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { source: "iana" },
  "application/vnd.dm.delegation+xml": { source: "iana", compressible: !0 },
  "application/vnd.dna": { source: "iana", extensions: ["dna"] },
  "application/vnd.document+json": { source: "iana", compressible: !0 },
  "application/vnd.dolby.mlp": { source: "apache", extensions: ["mlp"] },
  "application/vnd.dolby.mobile.1": { source: "iana" },
  "application/vnd.dolby.mobile.2": { source: "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { source: "iana" },
  "application/vnd.dpgraph": { source: "iana", extensions: ["dpg"] },
  "application/vnd.dreamfactory": { source: "iana", extensions: ["dfac"] },
  "application/vnd.drive+json": { source: "iana", compressible: !0 },
  "application/vnd.ds-keypoint": { source: "apache", extensions: ["kpxx"] },
  "application/vnd.dtg.local": { source: "iana" },
  "application/vnd.dtg.local.flash": { source: "iana" },
  "application/vnd.dtg.local.html": { source: "iana" },
  "application/vnd.dvb.ait": { source: "iana", extensions: ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.dvbj": { source: "iana" },
  "application/vnd.dvb.esgcontainer": { source: "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess": { source: "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { source: "iana" },
  "application/vnd.dvb.ipdcesgpdd": { source: "iana" },
  "application/vnd.dvb.ipdcroaming": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-base": { source: "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { source: "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-generic+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.dvb.notif-init+xml": { source: "iana", compressible: !0 },
  "application/vnd.dvb.pfr": { source: "iana" },
  "application/vnd.dvb.service": { source: "iana", extensions: ["svc"] },
  "application/vnd.dxr": { source: "iana" },
  "application/vnd.dynageo": { source: "iana", extensions: ["geo"] },
  "application/vnd.dzr": { source: "iana" },
  "application/vnd.easykaraoke.cdgdownload": { source: "iana" },
  "application/vnd.ecdis-update": { source: "iana" },
  "application/vnd.ecip.rlp": { source: "iana" },
  "application/vnd.eclipse.ditto+json": { source: "iana", compressible: !0 },
  "application/vnd.ecowin.chart": { source: "iana", extensions: ["mag"] },
  "application/vnd.ecowin.filerequest": { source: "iana" },
  "application/vnd.ecowin.fileupdate": { source: "iana" },
  "application/vnd.ecowin.series": { source: "iana" },
  "application/vnd.ecowin.seriesrequest": { source: "iana" },
  "application/vnd.ecowin.seriesupdate": { source: "iana" },
  "application/vnd.efi.img": { source: "iana" },
  "application/vnd.efi.iso": { source: "iana" },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.enliven": { source: "iana", extensions: ["nml"] },
  "application/vnd.enphase.envoy": { source: "iana" },
  "application/vnd.eprints.data+xml": { source: "iana", compressible: !0 },
  "application/vnd.epson.esf": { source: "iana", extensions: ["esf"] },
  "application/vnd.epson.msf": { source: "iana", extensions: ["msf"] },
  "application/vnd.epson.quickanime": { source: "iana", extensions: ["qam"] },
  "application/vnd.epson.salt": { source: "iana", extensions: ["slt"] },
  "application/vnd.epson.ssf": { source: "iana", extensions: ["ssf"] },
  "application/vnd.ericsson.quickcall": { source: "iana" },
  "application/vnd.espass-espass+zip": { source: "iana", compressible: !1 },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["es3", "et3"],
  },
  "application/vnd.etsi.aoc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.asic-e+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.asic-s+zip": { source: "iana", compressible: !1 },
  "application/vnd.etsi.cug+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvcommand+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.iptvprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-bc+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-cod+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsad-npvr+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvservice+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvsync+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.mcid+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.mheg5": { source: "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.etsi.pstn+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.sci+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.simservs+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.timestamp-token": { source: "iana" },
  "application/vnd.etsi.tsl+xml": { source: "iana", compressible: !0 },
  "application/vnd.etsi.tsl.der": { source: "iana" },
  "application/vnd.eu.kasparian.car+json": { source: "iana", compressible: !0 },
  "application/vnd.eudora.data": { source: "iana" },
  "application/vnd.evolv.ecig.profile": { source: "iana" },
  "application/vnd.evolv.ecig.settings": { source: "iana" },
  "application/vnd.evolv.ecig.theme": { source: "iana" },
  "application/vnd.exstream-empower+zip": { source: "iana", compressible: !1 },
  "application/vnd.exstream-package": { source: "iana" },
  "application/vnd.ezpix-album": { source: "iana", extensions: ["ez2"] },
  "application/vnd.ezpix-package": { source: "iana", extensions: ["ez3"] },
  "application/vnd.f-secure.mobile": { source: "iana" },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: !1,
  },
  "application/vnd.fastcopy-disk-image": { source: "iana" },
  "application/vnd.fdf": { source: "iana", extensions: ["fdf"] },
  "application/vnd.fdsn.mseed": { source: "iana", extensions: ["mseed"] },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: ["seed", "dataless"],
  },
  "application/vnd.ffsns": { source: "iana" },
  "application/vnd.ficlab.flb+zip": { source: "iana", compressible: !1 },
  "application/vnd.filmit.zfc": { source: "iana" },
  "application/vnd.fints": { source: "iana" },
  "application/vnd.firemonkeys.cloudcell": { source: "iana" },
  "application/vnd.flographit": { source: "iana", extensions: ["gph"] },
  "application/vnd.fluxtime.clip": { source: "iana", extensions: ["ftc"] },
  "application/vnd.font-fontforge-sfd": { source: "iana" },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: ["fm", "frame", "maker", "book"],
  },
  "application/vnd.frogans.fnc": { source: "iana", extensions: ["fnc"] },
  "application/vnd.frogans.ltf": { source: "iana", extensions: ["ltf"] },
  "application/vnd.fsc.weblaunch": { source: "iana", extensions: ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { source: "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { source: "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { source: "iana", compressible: !0 },
  "application/vnd.fujitsu.oasys": { source: "iana", extensions: ["oas"] },
  "application/vnd.fujitsu.oasys2": { source: "iana", extensions: ["oa2"] },
  "application/vnd.fujitsu.oasys3": { source: "iana", extensions: ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { source: "iana", extensions: ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { source: "iana", extensions: ["bh2"] },
  "application/vnd.fujixerox.art-ex": { source: "iana" },
  "application/vnd.fujixerox.art4": { source: "iana" },
  "application/vnd.fujixerox.ddd": { source: "iana", extensions: ["ddd"] },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: ["xdw"],
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: ["xbd"],
  },
  "application/vnd.fujixerox.docuworks.container": { source: "iana" },
  "application/vnd.fujixerox.hbpl": { source: "iana" },
  "application/vnd.fut-misnet": { source: "iana" },
  "application/vnd.futoin+cbor": { source: "iana" },
  "application/vnd.futoin+json": { source: "iana", compressible: !0 },
  "application/vnd.fuzzysheet": { source: "iana", extensions: ["fzs"] },
  "application/vnd.genomatix.tuxedo": { source: "iana", extensions: ["txd"] },
  "application/vnd.gentics.grd+json": { source: "iana", compressible: !0 },
  "application/vnd.geo+json": { source: "iana", compressible: !0 },
  "application/vnd.geocube+xml": { source: "iana", compressible: !0 },
  "application/vnd.geogebra.file": { source: "iana", extensions: ["ggb"] },
  "application/vnd.geogebra.slides": { source: "iana" },
  "application/vnd.geogebra.tool": { source: "iana", extensions: ["ggt"] },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: ["gex", "gre"],
  },
  "application/vnd.geonext": { source: "iana", extensions: ["gxt"] },
  "application/vnd.geoplan": { source: "iana", extensions: ["g2w"] },
  "application/vnd.geospace": { source: "iana", extensions: ["g3w"] },
  "application/vnd.gerber": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt": { source: "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana",
  },
  "application/vnd.gmx": { source: "iana", extensions: ["gmx"] },
  "application/vnd.google-apps.document": {
    compressible: !1,
    extensions: ["gdoc"],
  },
  "application/vnd.google-apps.presentation": {
    compressible: !1,
    extensions: ["gslides"],
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: !1,
    extensions: ["gsheet"],
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["kml"],
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: !1,
    extensions: ["kmz"],
  },
  "application/vnd.gov.sk.e-form+xml": { source: "iana", compressible: !0 },
  "application/vnd.gov.sk.e-form+zip": { source: "iana", compressible: !1 },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.grafeq": { source: "iana", extensions: ["gqf", "gqs"] },
  "application/vnd.gridmp": { source: "iana" },
  "application/vnd.groove-account": { source: "iana", extensions: ["gac"] },
  "application/vnd.groove-help": { source: "iana", extensions: ["ghf"] },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: ["gim"],
  },
  "application/vnd.groove-injector": { source: "iana", extensions: ["grv"] },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: ["gtm"],
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: ["tpl"],
  },
  "application/vnd.groove-vcard": { source: "iana", extensions: ["vcg"] },
  "application/vnd.hal+json": { source: "iana", compressible: !0 },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["hal"],
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["zmm"],
  },
  "application/vnd.hbci": { source: "iana", extensions: ["hbci"] },
  "application/vnd.hc+json": { source: "iana", compressible: !0 },
  "application/vnd.hcl-bireports": { source: "iana" },
  "application/vnd.hdt": { source: "iana" },
  "application/vnd.heroku+json": { source: "iana", compressible: !0 },
  "application/vnd.hhe.lesson-player": { source: "iana", extensions: ["les"] },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.hp-hpgl": { source: "iana", extensions: ["hpgl"] },
  "application/vnd.hp-hpid": { source: "iana", extensions: ["hpid"] },
  "application/vnd.hp-hps": { source: "iana", extensions: ["hps"] },
  "application/vnd.hp-jlyt": { source: "iana", extensions: ["jlt"] },
  "application/vnd.hp-pcl": { source: "iana", extensions: ["pcl"] },
  "application/vnd.hp-pclxl": { source: "iana", extensions: ["pclxl"] },
  "application/vnd.httphone": { source: "iana" },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: ["sfd-hdstx"],
  },
  "application/vnd.hyper+json": { source: "iana", compressible: !0 },
  "application/vnd.hyper-item+json": { source: "iana", compressible: !0 },
  "application/vnd.hyperdrive+json": { source: "iana", compressible: !0 },
  "application/vnd.hzn-3d-crossword": { source: "iana" },
  "application/vnd.ibm.afplinedata": { source: "iana" },
  "application/vnd.ibm.electronic-media": { source: "iana" },
  "application/vnd.ibm.minipay": { source: "iana", extensions: ["mpy"] },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: ["afp", "listafp", "list3820"],
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: ["irm"],
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: ["sc"],
  },
  "application/vnd.iccprofile": { source: "iana", extensions: ["icc", "icm"] },
  "application/vnd.ieee.1905": { source: "iana" },
  "application/vnd.igloader": { source: "iana", extensions: ["igl"] },
  "application/vnd.imagemeter.folder+zip": { source: "iana", compressible: !1 },
  "application/vnd.imagemeter.image+zip": { source: "iana", compressible: !1 },
  "application/vnd.immervision-ivp": { source: "iana", extensions: ["ivp"] },
  "application/vnd.immervision-ivu": { source: "iana", extensions: ["ivu"] },
  "application/vnd.ims.imsccv1p1": { source: "iana" },
  "application/vnd.ims.imsccv1p2": { source: "iana" },
  "application/vnd.ims.imsccv1p3": { source: "iana" },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.informix-visionary": { source: "iana" },
  "application/vnd.infotech.project": { source: "iana" },
  "application/vnd.infotech.project+xml": { source: "iana", compressible: !0 },
  "application/vnd.innopath.wamp.notification": { source: "iana" },
  "application/vnd.insors.igm": { source: "iana", extensions: ["igm"] },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: ["xpw", "xpx"],
  },
  "application/vnd.intergeo": { source: "iana", extensions: ["i2g"] },
  "application/vnd.intertrust.digibox": { source: "iana" },
  "application/vnd.intertrust.nncp": { source: "iana" },
  "application/vnd.intu.qbo": { source: "iana", extensions: ["qbo"] },
  "application/vnd.intu.qfx": { source: "iana", extensions: ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.newsitem+xml": { source: "iana", compressible: !0 },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: ["rcprofile"],
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["irp"],
  },
  "application/vnd.is-xpr": { source: "iana", extensions: ["xpr"] },
  "application/vnd.isac.fcs": { source: "iana", extensions: ["fcs"] },
  "application/vnd.iso11783-10+zip": { source: "iana", compressible: !1 },
  "application/vnd.jam": { source: "iana", extensions: ["jam"] },
  "application/vnd.japannet-directory-service": { source: "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { source: "iana" },
  "application/vnd.japannet-payment-wakeup": { source: "iana" },
  "application/vnd.japannet-registration": { source: "iana" },
  "application/vnd.japannet-registration-wakeup": { source: "iana" },
  "application/vnd.japannet-setstore-wakeup": { source: "iana" },
  "application/vnd.japannet-verification": { source: "iana" },
  "application/vnd.japannet-verification-wakeup": { source: "iana" },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: ["rms"],
  },
  "application/vnd.jisp": { source: "iana", extensions: ["jisp"] },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: ["joda"],
  },
  "application/vnd.jsk.isdn-ngn": { source: "iana" },
  "application/vnd.kahootz": { source: "iana", extensions: ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { source: "iana", extensions: ["karbon"] },
  "application/vnd.kde.kchart": { source: "iana", extensions: ["chrt"] },
  "application/vnd.kde.kformula": { source: "iana", extensions: ["kfo"] },
  "application/vnd.kde.kivio": { source: "iana", extensions: ["flw"] },
  "application/vnd.kde.kontour": { source: "iana", extensions: ["kon"] },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: ["kpr", "kpt"],
  },
  "application/vnd.kde.kspread": { source: "iana", extensions: ["ksp"] },
  "application/vnd.kde.kword": { source: "iana", extensions: ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { source: "iana", extensions: ["htke"] },
  "application/vnd.kidspiration": { source: "iana", extensions: ["kia"] },
  "application/vnd.kinar": { source: "iana", extensions: ["kne", "knp"] },
  "application/vnd.koan": {
    source: "iana",
    extensions: ["skp", "skd", "skt", "skm"],
  },
  "application/vnd.kodak-descriptor": { source: "iana", extensions: ["sse"] },
  "application/vnd.las": { source: "iana" },
  "application/vnd.las.las+json": { source: "iana", compressible: !0 },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lasxml"],
  },
  "application/vnd.laszip": { source: "iana" },
  "application/vnd.leap+json": { source: "iana", compressible: !0 },
  "application/vnd.liberty-request+xml": { source: "iana", compressible: !0 },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: ["lbd"],
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["lbe"],
  },
  "application/vnd.logipipe.circuit+zip": { source: "iana", compressible: !1 },
  "application/vnd.loom": { source: "iana" },
  "application/vnd.lotus-1-2-3": { source: "iana", extensions: ["123"] },
  "application/vnd.lotus-approach": { source: "iana", extensions: ["apr"] },
  "application/vnd.lotus-freelance": { source: "iana", extensions: ["pre"] },
  "application/vnd.lotus-notes": { source: "iana", extensions: ["nsf"] },
  "application/vnd.lotus-organizer": { source: "iana", extensions: ["org"] },
  "application/vnd.lotus-screencam": { source: "iana", extensions: ["scm"] },
  "application/vnd.lotus-wordpro": { source: "iana", extensions: ["lwp"] },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: ["portpkg"],
  },
  "application/vnd.mapbox-vector-tile": { source: "iana", extensions: ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.marlin.drm.mdcf": { source: "iana" },
  "application/vnd.mason+json": { source: "iana", compressible: !0 },
  "application/vnd.maxar.archive.3tz+zip": { source: "iana", compressible: !1 },
  "application/vnd.maxmind.maxmind-db": { source: "iana" },
  "application/vnd.mcd": { source: "iana", extensions: ["mcd"] },
  "application/vnd.medcalcdata": { source: "iana", extensions: ["mc1"] },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: ["cdkey"],
  },
  "application/vnd.meridian-slingshot": { source: "iana" },
  "application/vnd.mfer": { source: "iana", extensions: ["mwf"] },
  "application/vnd.mfmp": { source: "iana", extensions: ["mfm"] },
  "application/vnd.micro+json": { source: "iana", compressible: !0 },
  "application/vnd.micrografx.flo": { source: "iana", extensions: ["flo"] },
  "application/vnd.micrografx.igx": { source: "iana", extensions: ["igx"] },
  "application/vnd.microsoft.portable-executable": { source: "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { source: "iana" },
  "application/vnd.miele+json": { source: "iana", compressible: !0 },
  "application/vnd.mif": { source: "iana", extensions: ["mif"] },
  "application/vnd.minisoft-hp3000-save": { source: "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { source: "iana" },
  "application/vnd.mobius.daf": { source: "iana", extensions: ["daf"] },
  "application/vnd.mobius.dis": { source: "iana", extensions: ["dis"] },
  "application/vnd.mobius.mbk": { source: "iana", extensions: ["mbk"] },
  "application/vnd.mobius.mqy": { source: "iana", extensions: ["mqy"] },
  "application/vnd.mobius.msl": { source: "iana", extensions: ["msl"] },
  "application/vnd.mobius.plc": { source: "iana", extensions: ["plc"] },
  "application/vnd.mobius.txf": { source: "iana", extensions: ["txf"] },
  "application/vnd.mophun.application": { source: "iana", extensions: ["mpn"] },
  "application/vnd.mophun.certificate": { source: "iana", extensions: ["mpc"] },
  "application/vnd.motorola.flexsuite": { source: "iana" },
  "application/vnd.motorola.flexsuite.adsi": { source: "iana" },
  "application/vnd.motorola.flexsuite.fis": { source: "iana" },
  "application/vnd.motorola.flexsuite.gotap": { source: "iana" },
  "application/vnd.motorola.flexsuite.kmr": { source: "iana" },
  "application/vnd.motorola.flexsuite.ttc": { source: "iana" },
  "application/vnd.motorola.flexsuite.wem": { source: "iana" },
  "application/vnd.motorola.iprm": { source: "iana" },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xul"],
  },
  "application/vnd.ms-3mfdocument": { source: "iana" },
  "application/vnd.ms-artgalry": { source: "iana", extensions: ["cil"] },
  "application/vnd.ms-asf": { source: "iana" },
  "application/vnd.ms-cab-compressed": { source: "iana", extensions: ["cab"] },
  "application/vnd.ms-color.iccprofile": { source: "apache" },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: !1,
    extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: ["xlam"],
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: ["xlsb"],
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: ["xlsm"],
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: ["xltm"],
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: !0,
    extensions: ["eot"],
  },
  "application/vnd.ms-htmlhelp": { source: "iana", extensions: ["chm"] },
  "application/vnd.ms-ims": { source: "iana", extensions: ["ims"] },
  "application/vnd.ms-lrm": { source: "iana", extensions: ["lrm"] },
  "application/vnd.ms-office.activex+xml": { source: "iana", compressible: !0 },
  "application/vnd.ms-officetheme": { source: "iana", extensions: ["thmx"] },
  "application/vnd.ms-opentype": { source: "apache", compressible: !0 },
  "application/vnd.ms-outlook": { compressible: !1, extensions: ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { source: "apache" },
  "application/vnd.ms-pki.seccat": { source: "apache", extensions: ["cat"] },
  "application/vnd.ms-pki.stl": { source: "apache", extensions: ["stl"] },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: !1,
    extensions: ["ppt", "pps", "pot"],
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: ["ppam"],
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: ["pptm"],
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: ["sldm"],
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: ["ppsm"],
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: ["potm"],
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: !0,
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.ms-project": { source: "iana", extensions: ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { source: "iana" },
  "application/vnd.ms-windows.devicepairing": { source: "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { source: "iana" },
  "application/vnd.ms-windows.printerpairing": { source: "iana" },
  "application/vnd.ms-windows.wsd.oob": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { source: "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { source: "iana" },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: ["docm"],
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: ["dotm"],
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: ["wps", "wks", "wcm", "wdb"],
  },
  "application/vnd.ms-wpl": { source: "iana", extensions: ["wpl"] },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: !1,
    extensions: ["xps"],
  },
  "application/vnd.msa-disk-image": { source: "iana" },
  "application/vnd.mseq": { source: "iana", extensions: ["mseq"] },
  "application/vnd.msign": { source: "iana" },
  "application/vnd.multiad.creator": { source: "iana" },
  "application/vnd.multiad.creator.cif": { source: "iana" },
  "application/vnd.music-niff": { source: "iana" },
  "application/vnd.musician": { source: "iana", extensions: ["mus"] },
  "application/vnd.muvee.style": { source: "iana", extensions: ["msty"] },
  "application/vnd.mynfc": { source: "iana", extensions: ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { source: "iana", compressible: !0 },
  "application/vnd.ncd.control": { source: "iana" },
  "application/vnd.ncd.reference": { source: "iana" },
  "application/vnd.nearst.inv+json": { source: "iana", compressible: !0 },
  "application/vnd.nebumind.line": { source: "iana" },
  "application/vnd.nervana": { source: "iana" },
  "application/vnd.netfpx": { source: "iana" },
  "application/vnd.neurolanguage.nlu": { source: "iana", extensions: ["nlu"] },
  "application/vnd.nimn": { source: "iana" },
  "application/vnd.nintendo.nitro.rom": { source: "iana" },
  "application/vnd.nintendo.snes.rom": { source: "iana" },
  "application/vnd.nitf": { source: "iana", extensions: ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { source: "iana", extensions: ["nnd"] },
  "application/vnd.noblenet-sealer": { source: "iana", extensions: ["nns"] },
  "application/vnd.noblenet-web": { source: "iana", extensions: ["nnw"] },
  "application/vnd.nokia.catalogs": { source: "iana" },
  "application/vnd.nokia.conml+wbxml": { source: "iana" },
  "application/vnd.nokia.conml+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.iptv.config+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.isds-radio-presets": { source: "iana" },
  "application/vnd.nokia.landmark+wbxml": { source: "iana" },
  "application/vnd.nokia.landmark+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["ac"],
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: ["ngdat"],
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: ["n-gage"],
  },
  "application/vnd.nokia.ncd": { source: "iana" },
  "application/vnd.nokia.pcd+wbxml": { source: "iana" },
  "application/vnd.nokia.pcd+xml": { source: "iana", compressible: !0 },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: ["rpst"],
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: ["rpss"],
  },
  "application/vnd.novadigm.edm": { source: "iana", extensions: ["edm"] },
  "application/vnd.novadigm.edx": { source: "iana", extensions: ["edx"] },
  "application/vnd.novadigm.ext": { source: "iana", extensions: ["ext"] },
  "application/vnd.ntt-local.content-share": { source: "iana" },
  "application/vnd.ntt-local.file-transfer": { source: "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { source: "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { source: "iana" },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: ["odc"],
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: ["otc"],
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: ["odb"],
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: ["odf"],
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: ["odft"],
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: !1,
    extensions: ["odg"],
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: ["otg"],
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: ["odi"],
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: ["oti"],
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: !1,
    extensions: ["odp"],
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: ["otp"],
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: !1,
    extensions: ["ods"],
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: ["ots"],
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: !1,
    extensions: ["odt"],
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: ["odm"],
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: ["ott"],
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: ["oth"],
  },
  "application/vnd.obn": { source: "iana" },
  "application/vnd.ocf+cbor": { source: "iana" },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oftn.l10n+json": { source: "iana", compressible: !0 },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.cspg-hexbinary": { source: "iana" },
  "application/vnd.oipf.dae.svg+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.dae.xhtml+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oipf.pae.gem": { source: "iana" },
  "application/vnd.oipf.spdiscovery+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.spdlist+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.ueprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.oipf.userprofile+xml": { source: "iana", compressible: !0 },
  "application/vnd.olpc-sugar": { source: "iana", extensions: ["xo"] },
  "application/vnd.oma-scws-config": { source: "iana" },
  "application/vnd.oma-scws-http-request": { source: "iana" },
  "application/vnd.oma-scws-http-response": { source: "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.imd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.ltkm": { source: "iana" },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.provisioningtrigger": { source: "iana" },
  "application/vnd.oma.bcast.sgboot": { source: "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.sgdu": { source: "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { source: "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.bcast.sprov+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.bcast.stkm": { source: "iana" },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-pcc+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.dcd": { source: "iana" },
  "application/vnd.oma.dcdc": { source: "iana" },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dd2"],
  },
  "application/vnd.oma.drm.risd+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.lwm2m+cbor": { source: "iana" },
  "application/vnd.oma.lwm2m+json": { source: "iana", compressible: !0 },
  "application/vnd.oma.lwm2m+tlv": { source: "iana" },
  "application/vnd.oma.pal+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.groups+xml": { source: "iana", compressible: !0 },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.push": { source: "iana" },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.omaloc-supl-init": { source: "iana" },
  "application/vnd.onepager": { source: "iana" },
  "application/vnd.onepagertamp": { source: "iana" },
  "application/vnd.onepagertamx": { source: "iana" },
  "application/vnd.onepagertat": { source: "iana" },
  "application/vnd.onepagertatp": { source: "iana" },
  "application/vnd.onepagertatx": { source: "iana" },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["obgx"],
  },
  "application/vnd.openblox.game-binary": { source: "iana" },
  "application/vnd.openeye.oeb": { source: "iana" },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: ["oxt"],
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["osm"],
  },
  "application/vnd.opentimestamps.ots": { source: "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: !1,
    extensions: ["pptx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: ["sldx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: ["ppsx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: ["potx"],
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: !1,
    extensions: ["xlsx"],
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: ["xltx"],
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana",
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: !1,
    extensions: ["docx"],
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: ["dotx"],
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":
    { source: "iana", compressible: !0 },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.oracle.resource+json": { source: "iana", compressible: !0 },
  "application/vnd.orange.indata": { source: "iana" },
  "application/vnd.osa.netdeploy": { source: "iana" },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: ["mgp"],
  },
  "application/vnd.osgi.bundle": { source: "iana" },
  "application/vnd.osgi.dp": { source: "iana", extensions: ["dp"] },
  "application/vnd.osgi.subsystem": { source: "iana", extensions: ["esa"] },
  "application/vnd.otps.ct-kip+xml": { source: "iana", compressible: !0 },
  "application/vnd.oxli.countgraph": { source: "iana" },
  "application/vnd.pagerduty+json": { source: "iana", compressible: !0 },
  "application/vnd.palm": {
    source: "iana",
    extensions: ["pdb", "pqa", "oprc"],
  },
  "application/vnd.panoply": { source: "iana" },
  "application/vnd.paos.xml": { source: "iana" },
  "application/vnd.patentdive": { source: "iana" },
  "application/vnd.patientecommsdoc": { source: "iana" },
  "application/vnd.pawaafile": { source: "iana", extensions: ["paw"] },
  "application/vnd.pcos": { source: "iana" },
  "application/vnd.pg.format": { source: "iana", extensions: ["str"] },
  "application/vnd.pg.osasli": { source: "iana", extensions: ["ei6"] },
  "application/vnd.piaccess.application-licence": { source: "iana" },
  "application/vnd.picsel": { source: "iana", extensions: ["efif"] },
  "application/vnd.pmi.widget": { source: "iana", extensions: ["wg"] },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.pocketlearn": { source: "iana", extensions: ["plf"] },
  "application/vnd.powerbuilder6": { source: "iana", extensions: ["pbd"] },
  "application/vnd.powerbuilder6-s": { source: "iana" },
  "application/vnd.powerbuilder7": { source: "iana" },
  "application/vnd.powerbuilder7-s": { source: "iana" },
  "application/vnd.powerbuilder75": { source: "iana" },
  "application/vnd.powerbuilder75-s": { source: "iana" },
  "application/vnd.preminet": { source: "iana" },
  "application/vnd.previewsystems.box": { source: "iana", extensions: ["box"] },
  "application/vnd.proteus.magazine": { source: "iana", extensions: ["mgz"] },
  "application/vnd.psfs": { source: "iana" },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: ["qps"],
  },
  "application/vnd.pvi.ptid1": { source: "iana", extensions: ["ptid"] },
  "application/vnd.pwg-multiplexed": { source: "iana" },
  "application/vnd.pwg-xhtml-print+xml": { source: "iana", compressible: !0 },
  "application/vnd.qualcomm.brew-app-res": { source: "iana" },
  "application/vnd.quarantainenet": { source: "iana" },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
  },
  "application/vnd.quobject-quoxdocument": { source: "iana" },
  "application/vnd.radisys.moml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-conf+xml": { source: "iana", compressible: !0 },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/vnd.rainstor.data": { source: "iana" },
  "application/vnd.rapid": { source: "iana" },
  "application/vnd.rar": { source: "iana", extensions: ["rar"] },
  "application/vnd.realvnc.bed": { source: "iana", extensions: ["bed"] },
  "application/vnd.recordare.musicxml": { source: "iana", extensions: ["mxl"] },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["musicxml"],
  },
  "application/vnd.renlearn.rlprint": { source: "iana" },
  "application/vnd.resilient.logic": { source: "iana" },
  "application/vnd.restful+json": { source: "iana", compressible: !0 },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: ["cryptonote"],
  },
  "application/vnd.rim.cod": { source: "apache", extensions: ["cod"] },
  "application/vnd.rn-realmedia": { source: "apache", extensions: ["rm"] },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: ["rmvb"],
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["link66"],
  },
  "application/vnd.rs-274x": { source: "iana" },
  "application/vnd.ruckus.download": { source: "iana" },
  "application/vnd.s3sms": { source: "iana" },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: ["st"],
  },
  "application/vnd.sar": { source: "iana" },
  "application/vnd.sbm.cid": { source: "iana" },
  "application/vnd.sbm.mid2": { source: "iana" },
  "application/vnd.scribus": { source: "iana" },
  "application/vnd.sealed.3df": { source: "iana" },
  "application/vnd.sealed.csf": { source: "iana" },
  "application/vnd.sealed.doc": { source: "iana" },
  "application/vnd.sealed.eml": { source: "iana" },
  "application/vnd.sealed.mht": { source: "iana" },
  "application/vnd.sealed.net": { source: "iana" },
  "application/vnd.sealed.ppt": { source: "iana" },
  "application/vnd.sealed.tiff": { source: "iana" },
  "application/vnd.sealed.xls": { source: "iana" },
  "application/vnd.sealedmedia.softseal.html": { source: "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { source: "iana" },
  "application/vnd.seemail": { source: "iana", extensions: ["see"] },
  "application/vnd.seis+json": { source: "iana", compressible: !0 },
  "application/vnd.sema": { source: "iana", extensions: ["sema"] },
  "application/vnd.semd": { source: "iana", extensions: ["semd"] },
  "application/vnd.semf": { source: "iana", extensions: ["semf"] },
  "application/vnd.shade-save-file": { source: "iana" },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: ["ifm"],
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: ["itp"],
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: ["iif"],
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: ["ipk"],
  },
  "application/vnd.shootproof+json": { source: "iana", compressible: !0 },
  "application/vnd.shopkick+json": { source: "iana", compressible: !0 },
  "application/vnd.shp": { source: "iana" },
  "application/vnd.shx": { source: "iana" },
  "application/vnd.sigrok.session": { source: "iana" },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: ["twd", "twds"],
  },
  "application/vnd.siren+json": { source: "iana", compressible: !0 },
  "application/vnd.smaf": { source: "iana", extensions: ["mmf"] },
  "application/vnd.smart.notebook": { source: "iana" },
  "application/vnd.smart.teacher": { source: "iana", extensions: ["teacher"] },
  "application/vnd.snesdev-page-table": { source: "iana" },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["fo"],
  },
  "application/vnd.software602.filler.form-xml-zip": { source: "iana" },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["sdkm", "sdkd"],
  },
  "application/vnd.spotfire.dxp": { source: "iana", extensions: ["dxp"] },
  "application/vnd.spotfire.sfs": { source: "iana", extensions: ["sfs"] },
  "application/vnd.sqlite3": { source: "iana" },
  "application/vnd.sss-cod": { source: "iana" },
  "application/vnd.sss-dtf": { source: "iana" },
  "application/vnd.sss-ntf": { source: "iana" },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: ["sdc"],
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: ["sda"],
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: ["sdd"],
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: ["smf"],
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: ["sdw", "vor"],
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: ["sgl"],
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: ["smzip"],
  },
  "application/vnd.stepmania.stepchart": { source: "iana", extensions: ["sm"] },
  "application/vnd.street-stream": { source: "iana" },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wadl"],
  },
  "application/vnd.sun.xml.calc": { source: "apache", extensions: ["sxc"] },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: ["stc"],
  },
  "application/vnd.sun.xml.draw": { source: "apache", extensions: ["sxd"] },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: ["std"],
  },
  "application/vnd.sun.xml.impress": { source: "apache", extensions: ["sxi"] },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: ["sti"],
  },
  "application/vnd.sun.xml.math": { source: "apache", extensions: ["sxm"] },
  "application/vnd.sun.xml.writer": { source: "apache", extensions: ["sxw"] },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: ["sxg"],
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: ["stw"],
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: ["sus", "susp"],
  },
  "application/vnd.svd": { source: "iana", extensions: ["svd"] },
  "application/vnd.swiftview-ics": { source: "iana" },
  "application/vnd.sycle+xml": { source: "iana", compressible: !0 },
  "application/vnd.syft+json": { source: "iana", compressible: !0 },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: ["sis", "sisx"],
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["xsm"],
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["bdm"],
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["xdm"],
  },
  "application/vnd.syncml.dm.notification": { source: "iana" },
  "application/vnd.syncml.dmddf+wbxml": { source: "iana" },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["ddf"],
  },
  "application/vnd.syncml.dmtnds+wbxml": { source: "iana" },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
  },
  "application/vnd.syncml.ds.notification": { source: "iana" },
  "application/vnd.tableschema+json": { source: "iana", compressible: !0 },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: ["tao"],
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: ["pcap", "cap", "dmp"],
  },
  "application/vnd.think-cell.ppttc+json": { source: "iana", compressible: !0 },
  "application/vnd.tmd.mediaflex.api+xml": { source: "iana", compressible: !0 },
  "application/vnd.tml": { source: "iana" },
  "application/vnd.tmobile-livetv": { source: "iana", extensions: ["tmo"] },
  "application/vnd.tri.onesource": { source: "iana" },
  "application/vnd.trid.tpt": { source: "iana", extensions: ["tpt"] },
  "application/vnd.triscape.mxs": { source: "iana", extensions: ["mxs"] },
  "application/vnd.trueapp": { source: "iana", extensions: ["tra"] },
  "application/vnd.truedoc": { source: "iana" },
  "application/vnd.ubisoft.webplayer": { source: "iana" },
  "application/vnd.ufdl": { source: "iana", extensions: ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { source: "iana", extensions: ["utz"] },
  "application/vnd.umajin": { source: "iana", extensions: ["umj"] },
  "application/vnd.unity": { source: "iana", extensions: ["unityweb"] },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["uoml"],
  },
  "application/vnd.uplanet.alert": { source: "iana" },
  "application/vnd.uplanet.alert-wbxml": { source: "iana" },
  "application/vnd.uplanet.bearer-choice": { source: "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { source: "iana" },
  "application/vnd.uplanet.cacheop": { source: "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { source: "iana" },
  "application/vnd.uplanet.channel": { source: "iana" },
  "application/vnd.uplanet.channel-wbxml": { source: "iana" },
  "application/vnd.uplanet.list": { source: "iana" },
  "application/vnd.uplanet.list-wbxml": { source: "iana" },
  "application/vnd.uplanet.listcmd": { source: "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { source: "iana" },
  "application/vnd.uplanet.signal": { source: "iana" },
  "application/vnd.uri-map": { source: "iana" },
  "application/vnd.valve.source.material": { source: "iana" },
  "application/vnd.vcx": { source: "iana", extensions: ["vcx"] },
  "application/vnd.vd-study": { source: "iana" },
  "application/vnd.vectorworks": { source: "iana" },
  "application/vnd.vel+json": { source: "iana", compressible: !0 },
  "application/vnd.verimatrix.vcas": { source: "iana" },
  "application/vnd.veritone.aion+json": { source: "iana", compressible: !0 },
  "application/vnd.veryant.thin": { source: "iana" },
  "application/vnd.ves.encrypted": { source: "iana" },
  "application/vnd.vidsoft.vidconference": { source: "iana" },
  "application/vnd.visio": {
    source: "iana",
    extensions: ["vsd", "vst", "vss", "vsw"],
  },
  "application/vnd.visionary": { source: "iana", extensions: ["vis"] },
  "application/vnd.vividence.scriptfile": { source: "iana" },
  "application/vnd.vsf": { source: "iana", extensions: ["vsf"] },
  "application/vnd.wap.sic": { source: "iana" },
  "application/vnd.wap.slc": { source: "iana" },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["wbxml"],
  },
  "application/vnd.wap.wmlc": { source: "iana", extensions: ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { source: "iana", extensions: ["wmlsc"] },
  "application/vnd.webturbo": { source: "iana", extensions: ["wtb"] },
  "application/vnd.wfa.dpp": { source: "iana" },
  "application/vnd.wfa.p2p": { source: "iana" },
  "application/vnd.wfa.wsc": { source: "iana" },
  "application/vnd.windows.devicepairing": { source: "iana" },
  "application/vnd.wmc": { source: "iana" },
  "application/vnd.wmf.bootstrap": { source: "iana" },
  "application/vnd.wolfram.mathematica": { source: "iana" },
  "application/vnd.wolfram.mathematica.package": { source: "iana" },
  "application/vnd.wolfram.player": { source: "iana", extensions: ["nbp"] },
  "application/vnd.wordperfect": { source: "iana", extensions: ["wpd"] },
  "application/vnd.wqd": { source: "iana", extensions: ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { source: "iana" },
  "application/vnd.wt.stf": { source: "iana", extensions: ["stf"] },
  "application/vnd.wv.csp+wbxml": { source: "iana" },
  "application/vnd.wv.csp+xml": { source: "iana", compressible: !0 },
  "application/vnd.wv.ssp+xml": { source: "iana", compressible: !0 },
  "application/vnd.xacml+json": { source: "iana", compressible: !0 },
  "application/vnd.xara": { source: "iana", extensions: ["xar"] },
  "application/vnd.xfdl": { source: "iana", extensions: ["xfdl"] },
  "application/vnd.xfdl.webform": { source: "iana" },
  "application/vnd.xmi+xml": { source: "iana", compressible: !0 },
  "application/vnd.xmpie.cpkg": { source: "iana" },
  "application/vnd.xmpie.dpkg": { source: "iana" },
  "application/vnd.xmpie.plan": { source: "iana" },
  "application/vnd.xmpie.ppkg": { source: "iana" },
  "application/vnd.xmpie.xlim": { source: "iana" },
  "application/vnd.yamaha.hv-dic": { source: "iana", extensions: ["hvd"] },
  "application/vnd.yamaha.hv-script": { source: "iana", extensions: ["hvs"] },
  "application/vnd.yamaha.hv-voice": { source: "iana", extensions: ["hvp"] },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: ["osf"],
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["osfpvg"],
  },
  "application/vnd.yamaha.remote-setup": { source: "iana" },
  "application/vnd.yamaha.smaf-audio": { source: "iana", extensions: ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { source: "iana", extensions: ["spf"] },
  "application/vnd.yamaha.through-ngn": { source: "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { source: "iana" },
  "application/vnd.yaoweme": { source: "iana" },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: ["cmp"],
  },
  "application/vnd.youtube.yt": { source: "iana" },
  "application/vnd.zul": { source: "iana", extensions: ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["zaz"],
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["vxml"],
  },
  "application/voucher-cms+json": { source: "iana", compressible: !0 },
  "application/vq-rtcpxr": { source: "iana" },
  "application/wasm": {
    source: "iana",
    compressible: !0,
    extensions: ["wasm"],
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wif"],
  },
  "application/webpush-options+json": { source: "iana", compressible: !0 },
  "application/whoispp-query": { source: "iana" },
  "application/whoispp-response": { source: "iana" },
  "application/widget": { source: "iana", extensions: ["wgt"] },
  "application/winhlp": { source: "apache", extensions: ["hlp"] },
  "application/wita": { source: "iana" },
  "application/wordperfect5.1": { source: "iana" },
  "application/wsdl+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wsdl"],
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["wspolicy"],
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: !1,
    extensions: ["7z"],
  },
  "application/x-abiword": { source: "apache", extensions: ["abw"] },
  "application/x-ace-compressed": { source: "apache", extensions: ["ace"] },
  "application/x-amf": { source: "apache" },
  "application/x-apple-diskimage": { source: "apache", extensions: ["dmg"] },
  "application/x-arj": { compressible: !1, extensions: ["arj"] },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: ["aab", "x32", "u32", "vox"],
  },
  "application/x-authorware-map": { source: "apache", extensions: ["aam"] },
  "application/x-authorware-seg": { source: "apache", extensions: ["aas"] },
  "application/x-bcpio": { source: "apache", extensions: ["bcpio"] },
  "application/x-bdoc": { compressible: !1, extensions: ["bdoc"] },
  "application/x-bittorrent": { source: "apache", extensions: ["torrent"] },
  "application/x-blorb": { source: "apache", extensions: ["blb", "blorb"] },
  "application/x-bzip": {
    source: "apache",
    compressible: !1,
    extensions: ["bz"],
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: !1,
    extensions: ["bz2", "boz"],
  },
  "application/x-cbr": {
    source: "apache",
    extensions: ["cbr", "cba", "cbt", "cbz", "cb7"],
  },
  "application/x-cdlink": { source: "apache", extensions: ["vcd"] },
  "application/x-cfs-compressed": { source: "apache", extensions: ["cfs"] },
  "application/x-chat": { source: "apache", extensions: ["chat"] },
  "application/x-chess-pgn": { source: "apache", extensions: ["pgn"] },
  "application/x-chrome-extension": { extensions: ["crx"] },
  "application/x-cocoa": { source: "nginx", extensions: ["cco"] },
  "application/x-compress": { source: "apache" },
  "application/x-conference": { source: "apache", extensions: ["nsc"] },
  "application/x-cpio": { source: "apache", extensions: ["cpio"] },
  "application/x-csh": { source: "apache", extensions: ["csh"] },
  "application/x-deb": { compressible: !1 },
  "application/x-debian-package": {
    source: "apache",
    extensions: ["deb", "udeb"],
  },
  "application/x-dgc-compressed": { source: "apache", extensions: ["dgc"] },
  "application/x-director": {
    source: "apache",
    extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
  },
  "application/x-doom": { source: "apache", extensions: ["wad"] },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["ncx"],
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["dtb"],
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["res"],
  },
  "application/x-dvi": {
    source: "apache",
    compressible: !1,
    extensions: ["dvi"],
  },
  "application/x-envoy": { source: "apache", extensions: ["evy"] },
  "application/x-eva": { source: "apache", extensions: ["eva"] },
  "application/x-font-bdf": { source: "apache", extensions: ["bdf"] },
  "application/x-font-dos": { source: "apache" },
  "application/x-font-framemaker": { source: "apache" },
  "application/x-font-ghostscript": { source: "apache", extensions: ["gsf"] },
  "application/x-font-libgrx": { source: "apache" },
  "application/x-font-linux-psf": { source: "apache", extensions: ["psf"] },
  "application/x-font-pcf": { source: "apache", extensions: ["pcf"] },
  "application/x-font-snf": { source: "apache", extensions: ["snf"] },
  "application/x-font-speedo": { source: "apache" },
  "application/x-font-sunos-news": { source: "apache" },
  "application/x-font-type1": {
    source: "apache",
    extensions: ["pfa", "pfb", "pfm", "afm"],
  },
  "application/x-font-vfont": { source: "apache" },
  "application/x-freearc": { source: "apache", extensions: ["arc"] },
  "application/x-futuresplash": { source: "apache", extensions: ["spl"] },
  "application/x-gca-compressed": { source: "apache", extensions: ["gca"] },
  "application/x-glulx": { source: "apache", extensions: ["ulx"] },
  "application/x-gnumeric": { source: "apache", extensions: ["gnumeric"] },
  "application/x-gramps-xml": { source: "apache", extensions: ["gramps"] },
  "application/x-gtar": { source: "apache", extensions: ["gtar"] },
  "application/x-gzip": { source: "apache" },
  "application/x-hdf": { source: "apache", extensions: ["hdf"] },
  "application/x-httpd-php": { compressible: !0, extensions: ["php"] },
  "application/x-install-instructions": {
    source: "apache",
    extensions: ["install"],
  },
  "application/x-iso9660-image": { source: "apache", extensions: ["iso"] },
  "application/x-iwork-keynote-sffkey": { extensions: ["key"] },
  "application/x-iwork-numbers-sffnumbers": { extensions: ["numbers"] },
  "application/x-iwork-pages-sffpages": { extensions: ["pages"] },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: ["jardiff"],
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: !1,
    extensions: ["jnlp"],
  },
  "application/x-javascript": { compressible: !0 },
  "application/x-keepass2": { extensions: ["kdbx"] },
  "application/x-latex": {
    source: "apache",
    compressible: !1,
    extensions: ["latex"],
  },
  "application/x-lua-bytecode": { extensions: ["luac"] },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: ["lzh", "lha"],
  },
  "application/x-makeself": { source: "nginx", extensions: ["run"] },
  "application/x-mie": { source: "apache", extensions: ["mie"] },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: ["prc", "mobi"],
  },
  "application/x-mpegurl": { compressible: !1 },
  "application/x-ms-application": {
    source: "apache",
    extensions: ["application"],
  },
  "application/x-ms-shortcut": { source: "apache", extensions: ["lnk"] },
  "application/x-ms-wmd": { source: "apache", extensions: ["wmd"] },
  "application/x-ms-wmz": { source: "apache", extensions: ["wmz"] },
  "application/x-ms-xbap": { source: "apache", extensions: ["xbap"] },
  "application/x-msaccess": { source: "apache", extensions: ["mdb"] },
  "application/x-msbinder": { source: "apache", extensions: ["obd"] },
  "application/x-mscardfile": { source: "apache", extensions: ["crd"] },
  "application/x-msclip": { source: "apache", extensions: ["clp"] },
  "application/x-msdos-program": { extensions: ["exe"] },
  "application/x-msdownload": {
    source: "apache",
    extensions: ["exe", "dll", "com", "bat", "msi"],
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: ["mvb", "m13", "m14"],
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: ["wmf", "wmz", "emf", "emz"],
  },
  "application/x-msmoney": { source: "apache", extensions: ["mny"] },
  "application/x-mspublisher": { source: "apache", extensions: ["pub"] },
  "application/x-msschedule": { source: "apache", extensions: ["scd"] },
  "application/x-msterminal": { source: "apache", extensions: ["trm"] },
  "application/x-mswrite": { source: "apache", extensions: ["wri"] },
  "application/x-netcdf": { source: "apache", extensions: ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": {
    compressible: !0,
    extensions: ["pac"],
  },
  "application/x-nzb": { source: "apache", extensions: ["nzb"] },
  "application/x-perl": { source: "nginx", extensions: ["pl", "pm"] },
  "application/x-pilot": { source: "nginx", extensions: ["prc", "pdb"] },
  "application/x-pkcs12": {
    source: "apache",
    compressible: !1,
    extensions: ["p12", "pfx"],
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: ["p7b", "spc"],
  },
  "application/x-pkcs7-certreqresp": { source: "apache", extensions: ["p7r"] },
  "application/x-pki-message": { source: "iana" },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: !1,
    extensions: ["rar"],
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: ["rpm"],
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: ["ris"],
  },
  "application/x-sea": { source: "nginx", extensions: ["sea"] },
  "application/x-sh": {
    source: "apache",
    compressible: !0,
    extensions: ["sh"],
  },
  "application/x-shar": { source: "apache", extensions: ["shar"] },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: !1,
    extensions: ["swf"],
  },
  "application/x-silverlight-app": { source: "apache", extensions: ["xap"] },
  "application/x-sql": { source: "apache", extensions: ["sql"] },
  "application/x-stuffit": {
    source: "apache",
    compressible: !1,
    extensions: ["sit"],
  },
  "application/x-stuffitx": { source: "apache", extensions: ["sitx"] },
  "application/x-subrip": { source: "apache", extensions: ["srt"] },
  "application/x-sv4cpio": { source: "apache", extensions: ["sv4cpio"] },
  "application/x-sv4crc": { source: "apache", extensions: ["sv4crc"] },
  "application/x-t3vm-image": { source: "apache", extensions: ["t3"] },
  "application/x-tads": { source: "apache", extensions: ["gam"] },
  "application/x-tar": {
    source: "apache",
    compressible: !0,
    extensions: ["tar"],
  },
  "application/x-tcl": { source: "apache", extensions: ["tcl", "tk"] },
  "application/x-tex": { source: "apache", extensions: ["tex"] },
  "application/x-tex-tfm": { source: "apache", extensions: ["tfm"] },
  "application/x-texinfo": {
    source: "apache",
    extensions: ["texinfo", "texi"],
  },
  "application/x-tgif": { source: "apache", extensions: ["obj"] },
  "application/x-ustar": { source: "apache", extensions: ["ustar"] },
  "application/x-virtualbox-hdd": { compressible: !0, extensions: ["hdd"] },
  "application/x-virtualbox-ova": { compressible: !0, extensions: ["ova"] },
  "application/x-virtualbox-ovf": { compressible: !0, extensions: ["ovf"] },
  "application/x-virtualbox-vbox": { compressible: !0, extensions: ["vbox"] },
  "application/x-virtualbox-vbox-extpack": {
    compressible: !1,
    extensions: ["vbox-extpack"],
  },
  "application/x-virtualbox-vdi": { compressible: !0, extensions: ["vdi"] },
  "application/x-virtualbox-vhd": { compressible: !0, extensions: ["vhd"] },
  "application/x-virtualbox-vmdk": { compressible: !0, extensions: ["vmdk"] },
  "application/x-wais-source": { source: "apache", extensions: ["src"] },
  "application/x-web-app-manifest+json": {
    compressible: !0,
    extensions: ["webapp"],
  },
  "application/x-www-form-urlencoded": { source: "iana", compressible: !0 },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: ["der", "crt", "pem"],
  },
  "application/x-x509-ca-ra-cert": { source: "iana" },
  "application/x-x509-next-ca-cert": { source: "iana" },
  "application/x-xfig": { source: "apache", extensions: ["fig"] },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xlf"],
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: !1,
    extensions: ["xpi"],
  },
  "application/x-xz": { source: "apache", extensions: ["xz"] },
  "application/x-zmachine": {
    source: "apache",
    extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
  },
  "application/x400-bp": { source: "iana" },
  "application/xacml+xml": { source: "iana", compressible: !0 },
  "application/xaml+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xaml"],
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xav"],
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xca"],
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xdf"],
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xel"],
  },
  "application/xcap-error+xml": { source: "iana", compressible: !0 },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xns"],
  },
  "application/xcon-conference-info+xml": { source: "iana", compressible: !0 },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: !0,
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xenc"],
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xhtml", "xht"],
  },
  "application/xhtml-voice+xml": { source: "apache", compressible: !0 },
  "application/xliff+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xlf"],
  },
  "application/xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xml", "xsl", "xsd", "rng"],
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: !0,
    extensions: ["dtd"],
  },
  "application/xml-external-parsed-entity": { source: "iana" },
  "application/xml-patch+xml": { source: "iana", compressible: !0 },
  "application/xmpp+xml": { source: "iana", compressible: !0 },
  "application/xop+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xop"],
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xpl"],
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["xsl", "xslt"],
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: !0,
    extensions: ["xspf"],
  },
  "application/xv+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["mxml", "xhvml", "xvml", "xvm"],
  },
  "application/yang": { source: "iana", extensions: ["yang"] },
  "application/yang-data+json": { source: "iana", compressible: !0 },
  "application/yang-data+xml": { source: "iana", compressible: !0 },
  "application/yang-patch+json": { source: "iana", compressible: !0 },
  "application/yang-patch+xml": { source: "iana", compressible: !0 },
  "application/yin+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["yin"],
  },
  "application/zip": { source: "iana", compressible: !1, extensions: ["zip"] },
  "application/zlib": { source: "iana" },
  "application/zstd": { source: "iana" },
  "audio/1d-interleaved-parityfec": { source: "iana" },
  "audio/32kadpcm": { source: "iana" },
  "audio/3gpp": { source: "iana", compressible: !1, extensions: ["3gpp"] },
  "audio/3gpp2": { source: "iana" },
  "audio/aac": { source: "iana" },
  "audio/ac3": { source: "iana" },
  "audio/adpcm": { source: "apache", extensions: ["adp"] },
  "audio/amr": { source: "iana", extensions: ["amr"] },
  "audio/amr-wb": { source: "iana" },
  "audio/amr-wb+": { source: "iana" },
  "audio/aptx": { source: "iana" },
  "audio/asc": { source: "iana" },
  "audio/atrac-advanced-lossless": { source: "iana" },
  "audio/atrac-x": { source: "iana" },
  "audio/atrac3": { source: "iana" },
  "audio/basic": {
    source: "iana",
    compressible: !1,
    extensions: ["au", "snd"],
  },
  "audio/bv16": { source: "iana" },
  "audio/bv32": { source: "iana" },
  "audio/clearmode": { source: "iana" },
  "audio/cn": { source: "iana" },
  "audio/dat12": { source: "iana" },
  "audio/dls": { source: "iana" },
  "audio/dsr-es201108": { source: "iana" },
  "audio/dsr-es202050": { source: "iana" },
  "audio/dsr-es202211": { source: "iana" },
  "audio/dsr-es202212": { source: "iana" },
  "audio/dv": { source: "iana" },
  "audio/dvi4": { source: "iana" },
  "audio/eac3": { source: "iana" },
  "audio/encaprtp": { source: "iana" },
  "audio/evrc": { source: "iana" },
  "audio/evrc-qcp": { source: "iana" },
  "audio/evrc0": { source: "iana" },
  "audio/evrc1": { source: "iana" },
  "audio/evrcb": { source: "iana" },
  "audio/evrcb0": { source: "iana" },
  "audio/evrcb1": { source: "iana" },
  "audio/evrcnw": { source: "iana" },
  "audio/evrcnw0": { source: "iana" },
  "audio/evrcnw1": { source: "iana" },
  "audio/evrcwb": { source: "iana" },
  "audio/evrcwb0": { source: "iana" },
  "audio/evrcwb1": { source: "iana" },
  "audio/evs": { source: "iana" },
  "audio/flexfec": { source: "iana" },
  "audio/fwdred": { source: "iana" },
  "audio/g711-0": { source: "iana" },
  "audio/g719": { source: "iana" },
  "audio/g722": { source: "iana" },
  "audio/g7221": { source: "iana" },
  "audio/g723": { source: "iana" },
  "audio/g726-16": { source: "iana" },
  "audio/g726-24": { source: "iana" },
  "audio/g726-32": { source: "iana" },
  "audio/g726-40": { source: "iana" },
  "audio/g728": { source: "iana" },
  "audio/g729": { source: "iana" },
  "audio/g7291": { source: "iana" },
  "audio/g729d": { source: "iana" },
  "audio/g729e": { source: "iana" },
  "audio/gsm": { source: "iana" },
  "audio/gsm-efr": { source: "iana" },
  "audio/gsm-hr-08": { source: "iana" },
  "audio/ilbc": { source: "iana" },
  "audio/ip-mr_v2.5": { source: "iana" },
  "audio/isac": { source: "apache" },
  "audio/l16": { source: "iana" },
  "audio/l20": { source: "iana" },
  "audio/l24": { source: "iana", compressible: !1 },
  "audio/l8": { source: "iana" },
  "audio/lpc": { source: "iana" },
  "audio/melp": { source: "iana" },
  "audio/melp1200": { source: "iana" },
  "audio/melp2400": { source: "iana" },
  "audio/melp600": { source: "iana" },
  "audio/mhas": { source: "iana" },
  "audio/midi": { source: "apache", extensions: ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { source: "iana", extensions: ["mxmf"] },
  "audio/mp3": { compressible: !1, extensions: ["mp3"] },
  "audio/mp4": {
    source: "iana",
    compressible: !1,
    extensions: ["m4a", "mp4a"],
  },
  "audio/mp4a-latm": { source: "iana" },
  "audio/mpa": { source: "iana" },
  "audio/mpa-robust": { source: "iana" },
  "audio/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  },
  "audio/mpeg4-generic": { source: "iana" },
  "audio/musepack": { source: "apache" },
  "audio/ogg": {
    source: "iana",
    compressible: !1,
    extensions: ["oga", "ogg", "spx", "opus"],
  },
  "audio/opus": { source: "iana" },
  "audio/parityfec": { source: "iana" },
  "audio/pcma": { source: "iana" },
  "audio/pcma-wb": { source: "iana" },
  "audio/pcmu": { source: "iana" },
  "audio/pcmu-wb": { source: "iana" },
  "audio/prs.sid": { source: "iana" },
  "audio/qcelp": { source: "iana" },
  "audio/raptorfec": { source: "iana" },
  "audio/red": { source: "iana" },
  "audio/rtp-enc-aescm128": { source: "iana" },
  "audio/rtp-midi": { source: "iana" },
  "audio/rtploopback": { source: "iana" },
  "audio/rtx": { source: "iana" },
  "audio/s3m": { source: "apache", extensions: ["s3m"] },
  "audio/scip": { source: "iana" },
  "audio/silk": { source: "apache", extensions: ["sil"] },
  "audio/smv": { source: "iana" },
  "audio/smv-qcp": { source: "iana" },
  "audio/smv0": { source: "iana" },
  "audio/sofa": { source: "iana" },
  "audio/sp-midi": { source: "iana" },
  "audio/speex": { source: "iana" },
  "audio/t140c": { source: "iana" },
  "audio/t38": { source: "iana" },
  "audio/telephone-event": { source: "iana" },
  "audio/tetra_acelp": { source: "iana" },
  "audio/tetra_acelp_bb": { source: "iana" },
  "audio/tone": { source: "iana" },
  "audio/tsvcis": { source: "iana" },
  "audio/uemclip": { source: "iana" },
  "audio/ulpfec": { source: "iana" },
  "audio/usac": { source: "iana" },
  "audio/vdvi": { source: "iana" },
  "audio/vmr-wb": { source: "iana" },
  "audio/vnd.3gpp.iufp": { source: "iana" },
  "audio/vnd.4sb": { source: "iana" },
  "audio/vnd.audiokoz": { source: "iana" },
  "audio/vnd.celp": { source: "iana" },
  "audio/vnd.cisco.nse": { source: "iana" },
  "audio/vnd.cmles.radio-events": { source: "iana" },
  "audio/vnd.cns.anp1": { source: "iana" },
  "audio/vnd.cns.inf1": { source: "iana" },
  "audio/vnd.dece.audio": { source: "iana", extensions: ["uva", "uvva"] },
  "audio/vnd.digital-winds": { source: "iana", extensions: ["eol"] },
  "audio/vnd.dlna.adts": { source: "iana" },
  "audio/vnd.dolby.heaac.1": { source: "iana" },
  "audio/vnd.dolby.heaac.2": { source: "iana" },
  "audio/vnd.dolby.mlp": { source: "iana" },
  "audio/vnd.dolby.mps": { source: "iana" },
  "audio/vnd.dolby.pl2": { source: "iana" },
  "audio/vnd.dolby.pl2x": { source: "iana" },
  "audio/vnd.dolby.pl2z": { source: "iana" },
  "audio/vnd.dolby.pulse.1": { source: "iana" },
  "audio/vnd.dra": { source: "iana", extensions: ["dra"] },
  "audio/vnd.dts": { source: "iana", extensions: ["dts"] },
  "audio/vnd.dts.hd": { source: "iana", extensions: ["dtshd"] },
  "audio/vnd.dts.uhd": { source: "iana" },
  "audio/vnd.dvb.file": { source: "iana" },
  "audio/vnd.everad.plj": { source: "iana" },
  "audio/vnd.hns.audio": { source: "iana" },
  "audio/vnd.lucent.voice": { source: "iana", extensions: ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { source: "iana", extensions: ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { source: "iana" },
  "audio/vnd.nortel.vbk": { source: "iana" },
  "audio/vnd.nuera.ecelp4800": { source: "iana", extensions: ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { source: "iana", extensions: ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { source: "iana", extensions: ["ecelp9600"] },
  "audio/vnd.octel.sbc": { source: "iana" },
  "audio/vnd.presonus.multitrack": { source: "iana" },
  "audio/vnd.qcelp": { source: "iana" },
  "audio/vnd.rhetorex.32kadpcm": { source: "iana" },
  "audio/vnd.rip": { source: "iana", extensions: ["rip"] },
  "audio/vnd.rn-realaudio": { compressible: !1 },
  "audio/vnd.sealedmedia.softseal.mpeg": { source: "iana" },
  "audio/vnd.vmx.cvsd": { source: "iana" },
  "audio/vnd.wave": { compressible: !1 },
  "audio/vorbis": { source: "iana", compressible: !1 },
  "audio/vorbis-config": { source: "iana" },
  "audio/wav": { compressible: !1, extensions: ["wav"] },
  "audio/wave": { compressible: !1, extensions: ["wav"] },
  "audio/webm": { source: "apache", compressible: !1, extensions: ["weba"] },
  "audio/x-aac": { source: "apache", compressible: !1, extensions: ["aac"] },
  "audio/x-aiff": { source: "apache", extensions: ["aif", "aiff", "aifc"] },
  "audio/x-caf": { source: "apache", compressible: !1, extensions: ["caf"] },
  "audio/x-flac": { source: "apache", extensions: ["flac"] },
  "audio/x-m4a": { source: "nginx", extensions: ["m4a"] },
  "audio/x-matroska": { source: "apache", extensions: ["mka"] },
  "audio/x-mpegurl": { source: "apache", extensions: ["m3u"] },
  "audio/x-ms-wax": { source: "apache", extensions: ["wax"] },
  "audio/x-ms-wma": { source: "apache", extensions: ["wma"] },
  "audio/x-pn-realaudio": { source: "apache", extensions: ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { source: "apache", extensions: ["rmp"] },
  "audio/x-realaudio": { source: "nginx", extensions: ["ra"] },
  "audio/x-tta": { source: "apache" },
  "audio/x-wav": { source: "apache", extensions: ["wav"] },
  "audio/xm": { source: "apache", extensions: ["xm"] },
  "chemical/x-cdx": { source: "apache", extensions: ["cdx"] },
  "chemical/x-cif": { source: "apache", extensions: ["cif"] },
  "chemical/x-cmdf": { source: "apache", extensions: ["cmdf"] },
  "chemical/x-cml": { source: "apache", extensions: ["cml"] },
  "chemical/x-csml": { source: "apache", extensions: ["csml"] },
  "chemical/x-pdb": { source: "apache" },
  "chemical/x-xyz": { source: "apache", extensions: ["xyz"] },
  "font/collection": { source: "iana", extensions: ["ttc"] },
  "font/otf": { source: "iana", compressible: !0, extensions: ["otf"] },
  "font/sfnt": { source: "iana" },
  "font/ttf": { source: "iana", compressible: !0, extensions: ["ttf"] },
  "font/woff": { source: "iana", extensions: ["woff"] },
  "font/woff2": { source: "iana", extensions: ["woff2"] },
  "image/aces": { source: "iana", extensions: ["exr"] },
  "image/apng": { compressible: !1, extensions: ["apng"] },
  "image/avci": { source: "iana", extensions: ["avci"] },
  "image/avcs": { source: "iana", extensions: ["avcs"] },
  "image/avif": { source: "iana", compressible: !1, extensions: ["avif"] },
  "image/bmp": { source: "iana", compressible: !0, extensions: ["bmp"] },
  "image/cgm": { source: "iana", extensions: ["cgm"] },
  "image/dicom-rle": { source: "iana", extensions: ["drle"] },
  "image/emf": { source: "iana", extensions: ["emf"] },
  "image/fits": { source: "iana", extensions: ["fits"] },
  "image/g3fax": { source: "iana", extensions: ["g3"] },
  "image/gif": { source: "iana", compressible: !1, extensions: ["gif"] },
  "image/heic": { source: "iana", extensions: ["heic"] },
  "image/heic-sequence": { source: "iana", extensions: ["heics"] },
  "image/heif": { source: "iana", extensions: ["heif"] },
  "image/heif-sequence": { source: "iana", extensions: ["heifs"] },
  "image/hej2k": { source: "iana", extensions: ["hej2"] },
  "image/hsj2": { source: "iana", extensions: ["hsj2"] },
  "image/ief": { source: "iana", extensions: ["ief"] },
  "image/jls": { source: "iana", extensions: ["jls"] },
  "image/jp2": {
    source: "iana",
    compressible: !1,
    extensions: ["jp2", "jpg2"],
  },
  "image/jpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["jpeg", "jpg", "jpe"],
  },
  "image/jph": { source: "iana", extensions: ["jph"] },
  "image/jphc": { source: "iana", extensions: ["jhc"] },
  "image/jpm": { source: "iana", compressible: !1, extensions: ["jpm"] },
  "image/jpx": { source: "iana", compressible: !1, extensions: ["jpx", "jpf"] },
  "image/jxr": { source: "iana", extensions: ["jxr"] },
  "image/jxra": { source: "iana", extensions: ["jxra"] },
  "image/jxrs": { source: "iana", extensions: ["jxrs"] },
  "image/jxs": { source: "iana", extensions: ["jxs"] },
  "image/jxsc": { source: "iana", extensions: ["jxsc"] },
  "image/jxsi": { source: "iana", extensions: ["jxsi"] },
  "image/jxss": { source: "iana", extensions: ["jxss"] },
  "image/ktx": { source: "iana", extensions: ["ktx"] },
  "image/ktx2": { source: "iana", extensions: ["ktx2"] },
  "image/naplps": { source: "iana" },
  "image/pjpeg": { compressible: !1 },
  "image/png": { source: "iana", compressible: !1, extensions: ["png"] },
  "image/prs.btif": { source: "iana", extensions: ["btif"] },
  "image/prs.pti": { source: "iana", extensions: ["pti"] },
  "image/pwg-raster": { source: "iana" },
  "image/sgi": { source: "apache", extensions: ["sgi"] },
  "image/svg+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["svg", "svgz"],
  },
  "image/t38": { source: "iana", extensions: ["t38"] },
  "image/tiff": {
    source: "iana",
    compressible: !1,
    extensions: ["tif", "tiff"],
  },
  "image/tiff-fx": { source: "iana", extensions: ["tfx"] },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: !0,
    extensions: ["psd"],
  },
  "image/vnd.airzip.accelerator.azv": { source: "iana", extensions: ["azv"] },
  "image/vnd.cns.inf2": { source: "iana" },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: ["uvi", "uvvi", "uvg", "uvvg"],
  },
  "image/vnd.djvu": { source: "iana", extensions: ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "image/vnd.dwg": { source: "iana", extensions: ["dwg"] },
  "image/vnd.dxf": { source: "iana", extensions: ["dxf"] },
  "image/vnd.fastbidsheet": { source: "iana", extensions: ["fbs"] },
  "image/vnd.fpx": { source: "iana", extensions: ["fpx"] },
  "image/vnd.fst": { source: "iana", extensions: ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { source: "iana", extensions: ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { source: "iana", extensions: ["rlc"] },
  "image/vnd.globalgraphics.pgb": { source: "iana" },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: !0,
    extensions: ["ico"],
  },
  "image/vnd.mix": { source: "iana" },
  "image/vnd.mozilla.apng": { source: "iana" },
  "image/vnd.ms-dds": { compressible: !0, extensions: ["dds"] },
  "image/vnd.ms-modi": { source: "iana", extensions: ["mdi"] },
  "image/vnd.ms-photo": { source: "apache", extensions: ["wdp"] },
  "image/vnd.net-fpx": { source: "iana", extensions: ["npx"] },
  "image/vnd.pco.b16": { source: "iana", extensions: ["b16"] },
  "image/vnd.radiance": { source: "iana" },
  "image/vnd.sealed.png": { source: "iana" },
  "image/vnd.sealedmedia.softseal.gif": { source: "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { source: "iana" },
  "image/vnd.svf": { source: "iana" },
  "image/vnd.tencent.tap": { source: "iana", extensions: ["tap"] },
  "image/vnd.valve.source.texture": { source: "iana", extensions: ["vtf"] },
  "image/vnd.wap.wbmp": { source: "iana", extensions: ["wbmp"] },
  "image/vnd.xiff": { source: "iana", extensions: ["xif"] },
  "image/vnd.zbrush.pcx": { source: "iana", extensions: ["pcx"] },
  "image/webp": { source: "apache", extensions: ["webp"] },
  "image/wmf": { source: "iana", extensions: ["wmf"] },
  "image/x-3ds": { source: "apache", extensions: ["3ds"] },
  "image/x-cmu-raster": { source: "apache", extensions: ["ras"] },
  "image/x-cmx": { source: "apache", extensions: ["cmx"] },
  "image/x-freehand": {
    source: "apache",
    extensions: ["fh", "fhc", "fh4", "fh5", "fh7"],
  },
  "image/x-icon": { source: "apache", compressible: !0, extensions: ["ico"] },
  "image/x-jng": { source: "nginx", extensions: ["jng"] },
  "image/x-mrsid-image": { source: "apache", extensions: ["sid"] },
  "image/x-ms-bmp": { source: "nginx", compressible: !0, extensions: ["bmp"] },
  "image/x-pcx": { source: "apache", extensions: ["pcx"] },
  "image/x-pict": { source: "apache", extensions: ["pic", "pct"] },
  "image/x-portable-anymap": { source: "apache", extensions: ["pnm"] },
  "image/x-portable-bitmap": { source: "apache", extensions: ["pbm"] },
  "image/x-portable-graymap": { source: "apache", extensions: ["pgm"] },
  "image/x-portable-pixmap": { source: "apache", extensions: ["ppm"] },
  "image/x-rgb": { source: "apache", extensions: ["rgb"] },
  "image/x-tga": { source: "apache", extensions: ["tga"] },
  "image/x-xbitmap": { source: "apache", extensions: ["xbm"] },
  "image/x-xcf": { compressible: !1 },
  "image/x-xpixmap": { source: "apache", extensions: ["xpm"] },
  "image/x-xwindowdump": { source: "apache", extensions: ["xwd"] },
  "message/cpim": { source: "iana" },
  "message/delivery-status": { source: "iana" },
  "message/disposition-notification": {
    source: "iana",
    extensions: ["disposition-notification"],
  },
  "message/external-body": { source: "iana" },
  "message/feedback-report": { source: "iana" },
  "message/global": { source: "iana", extensions: ["u8msg"] },
  "message/global-delivery-status": { source: "iana", extensions: ["u8dsn"] },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: ["u8mdn"],
  },
  "message/global-headers": { source: "iana", extensions: ["u8hdr"] },
  "message/http": { source: "iana", compressible: !1 },
  "message/imdn+xml": { source: "iana", compressible: !0 },
  "message/news": { source: "iana" },
  "message/partial": { source: "iana", compressible: !1 },
  "message/rfc822": {
    source: "iana",
    compressible: !0,
    extensions: ["eml", "mime"],
  },
  "message/s-http": { source: "iana" },
  "message/sip": { source: "iana" },
  "message/sipfrag": { source: "iana" },
  "message/tracking-status": { source: "iana" },
  "message/vnd.si.simp": { source: "iana" },
  "message/vnd.wfa.wsc": { source: "iana", extensions: ["wsc"] },
  "model/3mf": { source: "iana", extensions: ["3mf"] },
  "model/e57": { source: "iana" },
  "model/gltf+json": { source: "iana", compressible: !0, extensions: ["gltf"] },
  "model/gltf-binary": {
    source: "iana",
    compressible: !0,
    extensions: ["glb"],
  },
  "model/iges": {
    source: "iana",
    compressible: !1,
    extensions: ["igs", "iges"],
  },
  "model/mesh": {
    source: "iana",
    compressible: !1,
    extensions: ["msh", "mesh", "silo"],
  },
  "model/mtl": { source: "iana", extensions: ["mtl"] },
  "model/obj": { source: "iana", extensions: ["obj"] },
  "model/step": { source: "iana" },
  "model/step+xml": { source: "iana", compressible: !0, extensions: ["stpx"] },
  "model/step+zip": { source: "iana", compressible: !1, extensions: ["stpz"] },
  "model/step-xml+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["stpxz"],
  },
  "model/stl": { source: "iana", extensions: ["stl"] },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["dae"],
  },
  "model/vnd.dwf": { source: "iana", extensions: ["dwf"] },
  "model/vnd.flatland.3dml": { source: "iana" },
  "model/vnd.gdl": { source: "iana", extensions: ["gdl"] },
  "model/vnd.gs-gdl": { source: "apache" },
  "model/vnd.gs.gdl": { source: "iana" },
  "model/vnd.gtw": { source: "iana", extensions: ["gtw"] },
  "model/vnd.moml+xml": { source: "iana", compressible: !0 },
  "model/vnd.mts": { source: "iana", extensions: ["mts"] },
  "model/vnd.opengex": { source: "iana", extensions: ["ogex"] },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: ["x_b"],
  },
  "model/vnd.parasolid.transmit.text": { source: "iana", extensions: ["x_t"] },
  "model/vnd.pytha.pyox": { source: "iana" },
  "model/vnd.rosette.annotated-data-model": { source: "iana" },
  "model/vnd.sap.vds": { source: "iana", extensions: ["vds"] },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: !1,
    extensions: ["usdz"],
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: ["bsp"],
  },
  "model/vnd.vtu": { source: "iana", extensions: ["vtu"] },
  "model/vrml": {
    source: "iana",
    compressible: !1,
    extensions: ["wrl", "vrml"],
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: !1,
    extensions: ["x3db", "x3dbz"],
  },
  "model/x3d+fastinfoset": { source: "iana", extensions: ["x3db"] },
  "model/x3d+vrml": {
    source: "apache",
    compressible: !1,
    extensions: ["x3dv", "x3dvz"],
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: !0,
    extensions: ["x3d", "x3dz"],
  },
  "model/x3d-vrml": { source: "iana", extensions: ["x3dv"] },
  "multipart/alternative": { source: "iana", compressible: !1 },
  "multipart/appledouble": { source: "iana" },
  "multipart/byteranges": { source: "iana" },
  "multipart/digest": { source: "iana" },
  "multipart/encrypted": { source: "iana", compressible: !1 },
  "multipart/form-data": { source: "iana", compressible: !1 },
  "multipart/header-set": { source: "iana" },
  "multipart/mixed": { source: "iana" },
  "multipart/multilingual": { source: "iana" },
  "multipart/parallel": { source: "iana" },
  "multipart/related": { source: "iana", compressible: !1 },
  "multipart/report": { source: "iana" },
  "multipart/signed": { source: "iana", compressible: !1 },
  "multipart/vnd.bint.med-plus": { source: "iana" },
  "multipart/voice-message": { source: "iana" },
  "multipart/x-mixed-replace": { source: "iana" },
  "text/1d-interleaved-parityfec": { source: "iana" },
  "text/cache-manifest": {
    source: "iana",
    compressible: !0,
    extensions: ["appcache", "manifest"],
  },
  "text/calendar": { source: "iana", extensions: ["ics", "ifb"] },
  "text/calender": { compressible: !0 },
  "text/cmd": { compressible: !0 },
  "text/coffeescript": { extensions: ["coffee", "litcoffee"] },
  "text/cql": { source: "iana" },
  "text/cql-expression": { source: "iana" },
  "text/cql-identifier": { source: "iana" },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["css"],
  },
  "text/csv": { source: "iana", compressible: !0, extensions: ["csv"] },
  "text/csv-schema": { source: "iana" },
  "text/directory": { source: "iana" },
  "text/dns": { source: "iana" },
  "text/ecmascript": { source: "iana" },
  "text/encaprtp": { source: "iana" },
  "text/enriched": { source: "iana" },
  "text/fhirpath": { source: "iana" },
  "text/flexfec": { source: "iana" },
  "text/fwdred": { source: "iana" },
  "text/gff3": { source: "iana" },
  "text/grammar-ref-list": { source: "iana" },
  "text/html": {
    source: "iana",
    compressible: !0,
    extensions: ["html", "htm", "shtml"],
  },
  "text/jade": { extensions: ["jade"] },
  "text/javascript": { source: "iana", compressible: !0 },
  "text/jcr-cnd": { source: "iana" },
  "text/jsx": { compressible: !0, extensions: ["jsx"] },
  "text/less": { compressible: !0, extensions: ["less"] },
  "text/markdown": {
    source: "iana",
    compressible: !0,
    extensions: ["markdown", "md"],
  },
  "text/mathml": { source: "nginx", extensions: ["mml"] },
  "text/mdx": { compressible: !0, extensions: ["mdx"] },
  "text/mizar": { source: "iana" },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["n3"],
  },
  "text/parameters": { source: "iana", charset: "UTF-8" },
  "text/parityfec": { source: "iana" },
  "text/plain": {
    source: "iana",
    compressible: !0,
    extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  },
  "text/provenance-notation": { source: "iana", charset: "UTF-8" },
  "text/prs.fallenstein.rst": { source: "iana" },
  "text/prs.lines.tag": { source: "iana", extensions: ["dsc"] },
  "text/prs.prop.logic": { source: "iana" },
  "text/raptorfec": { source: "iana" },
  "text/red": { source: "iana" },
  "text/rfc822-headers": { source: "iana" },
  "text/richtext": { source: "iana", compressible: !0, extensions: ["rtx"] },
  "text/rtf": { source: "iana", compressible: !0, extensions: ["rtf"] },
  "text/rtp-enc-aescm128": { source: "iana" },
  "text/rtploopback": { source: "iana" },
  "text/rtx": { source: "iana" },
  "text/sgml": { source: "iana", extensions: ["sgml", "sgm"] },
  "text/shaclc": { source: "iana" },
  "text/shex": { source: "iana", extensions: ["shex"] },
  "text/slim": { extensions: ["slim", "slm"] },
  "text/spdx": { source: "iana", extensions: ["spdx"] },
  "text/strings": { source: "iana" },
  "text/stylus": { extensions: ["stylus", "styl"] },
  "text/t140": { source: "iana" },
  "text/tab-separated-values": {
    source: "iana",
    compressible: !0,
    extensions: ["tsv"],
  },
  "text/troff": {
    source: "iana",
    extensions: ["t", "tr", "roff", "man", "me", "ms"],
  },
  "text/turtle": { source: "iana", charset: "UTF-8", extensions: ["ttl"] },
  "text/ulpfec": { source: "iana" },
  "text/uri-list": {
    source: "iana",
    compressible: !0,
    extensions: ["uri", "uris", "urls"],
  },
  "text/vcard": { source: "iana", compressible: !0, extensions: ["vcard"] },
  "text/vnd.a": { source: "iana" },
  "text/vnd.abc": { source: "iana" },
  "text/vnd.ascii-art": { source: "iana" },
  "text/vnd.curl": { source: "iana", extensions: ["curl"] },
  "text/vnd.curl.dcurl": { source: "apache", extensions: ["dcurl"] },
  "text/vnd.curl.mcurl": { source: "apache", extensions: ["mcurl"] },
  "text/vnd.curl.scurl": { source: "apache", extensions: ["scurl"] },
  "text/vnd.debian.copyright": { source: "iana", charset: "UTF-8" },
  "text/vnd.dmclientscript": { source: "iana" },
  "text/vnd.dvb.subtitle": { source: "iana", extensions: ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { source: "iana", charset: "UTF-8" },
  "text/vnd.familysearch.gedcom": { source: "iana", extensions: ["ged"] },
  "text/vnd.ficlab.flt": { source: "iana" },
  "text/vnd.fly": { source: "iana", extensions: ["fly"] },
  "text/vnd.fmi.flexstor": { source: "iana", extensions: ["flx"] },
  "text/vnd.gml": { source: "iana" },
  "text/vnd.graphviz": { source: "iana", extensions: ["gv"] },
  "text/vnd.hans": { source: "iana" },
  "text/vnd.hgl": { source: "iana" },
  "text/vnd.in3d.3dml": { source: "iana", extensions: ["3dml"] },
  "text/vnd.in3d.spot": { source: "iana", extensions: ["spot"] },
  "text/vnd.iptc.newsml": { source: "iana" },
  "text/vnd.iptc.nitf": { source: "iana" },
  "text/vnd.latex-z": { source: "iana" },
  "text/vnd.motorola.reflex": { source: "iana" },
  "text/vnd.ms-mediapackage": { source: "iana" },
  "text/vnd.net2phone.commcenter.command": { source: "iana" },
  "text/vnd.radisys.msml-basic-layout": { source: "iana" },
  "text/vnd.senx.warpscript": { source: "iana" },
  "text/vnd.si.uricatalogue": { source: "iana" },
  "text/vnd.sosi": { source: "iana" },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: ["jad"],
  },
  "text/vnd.trolltech.linguist": { source: "iana", charset: "UTF-8" },
  "text/vnd.wap.si": { source: "iana" },
  "text/vnd.wap.sl": { source: "iana" },
  "text/vnd.wap.wml": { source: "iana", extensions: ["wml"] },
  "text/vnd.wap.wmlscript": { source: "iana", extensions: ["wmls"] },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: !0,
    extensions: ["vtt"],
  },
  "text/x-asm": { source: "apache", extensions: ["s", "asm"] },
  "text/x-c": {
    source: "apache",
    extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
  },
  "text/x-component": { source: "nginx", extensions: ["htc"] },
  "text/x-fortran": {
    source: "apache",
    extensions: ["f", "for", "f77", "f90"],
  },
  "text/x-gwt-rpc": { compressible: !0 },
  "text/x-handlebars-template": { extensions: ["hbs"] },
  "text/x-java-source": { source: "apache", extensions: ["java"] },
  "text/x-jquery-tmpl": { compressible: !0 },
  "text/x-lua": { extensions: ["lua"] },
  "text/x-markdown": { compressible: !0, extensions: ["mkd"] },
  "text/x-nfo": { source: "apache", extensions: ["nfo"] },
  "text/x-opml": { source: "apache", extensions: ["opml"] },
  "text/x-org": { compressible: !0, extensions: ["org"] },
  "text/x-pascal": { source: "apache", extensions: ["p", "pas"] },
  "text/x-processing": { compressible: !0, extensions: ["pde"] },
  "text/x-sass": { extensions: ["sass"] },
  "text/x-scss": { extensions: ["scss"] },
  "text/x-setext": { source: "apache", extensions: ["etx"] },
  "text/x-sfv": { source: "apache", extensions: ["sfv"] },
  "text/x-suse-ymp": { compressible: !0, extensions: ["ymp"] },
  "text/x-uuencode": { source: "apache", extensions: ["uu"] },
  "text/x-vcalendar": { source: "apache", extensions: ["vcs"] },
  "text/x-vcard": { source: "apache", extensions: ["vcf"] },
  "text/xml": { source: "iana", compressible: !0, extensions: ["xml"] },
  "text/xml-external-parsed-entity": { source: "iana" },
  "text/yaml": { compressible: !0, extensions: ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { source: "iana" },
  "video/3gpp": { source: "iana", extensions: ["3gp", "3gpp"] },
  "video/3gpp-tt": { source: "iana" },
  "video/3gpp2": { source: "iana", extensions: ["3g2"] },
  "video/av1": { source: "iana" },
  "video/bmpeg": { source: "iana" },
  "video/bt656": { source: "iana" },
  "video/celb": { source: "iana" },
  "video/dv": { source: "iana" },
  "video/encaprtp": { source: "iana" },
  "video/ffv1": { source: "iana" },
  "video/flexfec": { source: "iana" },
  "video/h261": { source: "iana", extensions: ["h261"] },
  "video/h263": { source: "iana", extensions: ["h263"] },
  "video/h263-1998": { source: "iana" },
  "video/h263-2000": { source: "iana" },
  "video/h264": { source: "iana", extensions: ["h264"] },
  "video/h264-rcdo": { source: "iana" },
  "video/h264-svc": { source: "iana" },
  "video/h265": { source: "iana" },
  "video/iso.segment": { source: "iana", extensions: ["m4s"] },
  "video/jpeg": { source: "iana", extensions: ["jpgv"] },
  "video/jpeg2000": { source: "iana" },
  "video/jpm": { source: "apache", extensions: ["jpm", "jpgm"] },
  "video/jxsv": { source: "iana" },
  "video/mj2": { source: "iana", extensions: ["mj2", "mjp2"] },
  "video/mp1s": { source: "iana" },
  "video/mp2p": { source: "iana" },
  "video/mp2t": { source: "iana", extensions: ["ts"] },
  "video/mp4": {
    source: "iana",
    compressible: !1,
    extensions: ["mp4", "mp4v", "mpg4"],
  },
  "video/mp4v-es": { source: "iana" },
  "video/mpeg": {
    source: "iana",
    compressible: !1,
    extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  },
  "video/mpeg4-generic": { source: "iana" },
  "video/mpv": { source: "iana" },
  "video/nv": { source: "iana" },
  "video/ogg": { source: "iana", compressible: !1, extensions: ["ogv"] },
  "video/parityfec": { source: "iana" },
  "video/pointer": { source: "iana" },
  "video/quicktime": {
    source: "iana",
    compressible: !1,
    extensions: ["qt", "mov"],
  },
  "video/raptorfec": { source: "iana" },
  "video/raw": { source: "iana" },
  "video/rtp-enc-aescm128": { source: "iana" },
  "video/rtploopback": { source: "iana" },
  "video/rtx": { source: "iana" },
  "video/scip": { source: "iana" },
  "video/smpte291": { source: "iana" },
  "video/smpte292m": { source: "iana" },
  "video/ulpfec": { source: "iana" },
  "video/vc1": { source: "iana" },
  "video/vc2": { source: "iana" },
  "video/vnd.cctv": { source: "iana" },
  "video/vnd.dece.hd": { source: "iana", extensions: ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { source: "iana", extensions: ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { source: "iana" },
  "video/vnd.dece.pd": { source: "iana", extensions: ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { source: "iana", extensions: ["uvs", "uvvs"] },
  "video/vnd.dece.video": { source: "iana", extensions: ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { source: "iana" },
  "video/vnd.directv.mpeg-tts": { source: "iana" },
  "video/vnd.dlna.mpeg-tts": { source: "iana" },
  "video/vnd.dvb.file": { source: "iana", extensions: ["dvb"] },
  "video/vnd.fvt": { source: "iana", extensions: ["fvt"] },
  "video/vnd.hns.video": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { source: "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { source: "iana" },
  "video/vnd.iptvforum.ttsavc": { source: "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { source: "iana" },
  "video/vnd.motorola.video": { source: "iana" },
  "video/vnd.motorola.videop": { source: "iana" },
  "video/vnd.mpegurl": { source: "iana", extensions: ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { source: "iana", extensions: ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { source: "iana" },
  "video/vnd.nokia.mp4vr": { source: "iana" },
  "video/vnd.nokia.videovoip": { source: "iana" },
  "video/vnd.objectvideo": { source: "iana" },
  "video/vnd.radgamettools.bink": { source: "iana" },
  "video/vnd.radgamettools.smacker": { source: "iana" },
  "video/vnd.sealed.mpeg1": { source: "iana" },
  "video/vnd.sealed.mpeg4": { source: "iana" },
  "video/vnd.sealed.swf": { source: "iana" },
  "video/vnd.sealedmedia.softseal.mov": { source: "iana" },
  "video/vnd.uvvu.mp4": { source: "iana", extensions: ["uvu", "uvvu"] },
  "video/vnd.vivo": { source: "iana", extensions: ["viv"] },
  "video/vnd.youtube.yt": { source: "iana" },
  "video/vp8": { source: "iana" },
  "video/vp9": { source: "iana" },
  "video/webm": { source: "apache", compressible: !1, extensions: ["webm"] },
  "video/x-f4v": { source: "apache", extensions: ["f4v"] },
  "video/x-fli": { source: "apache", extensions: ["fli"] },
  "video/x-flv": { source: "apache", compressible: !1, extensions: ["flv"] },
  "video/x-m4v": { source: "apache", extensions: ["m4v"] },
  "video/x-matroska": {
    source: "apache",
    compressible: !1,
    extensions: ["mkv", "mk3d", "mks"],
  },
  "video/x-mng": { source: "apache", extensions: ["mng"] },
  "video/x-ms-asf": { source: "apache", extensions: ["asf", "asx"] },
  "video/x-ms-vob": { source: "apache", extensions: ["vob"] },
  "video/x-ms-wm": { source: "apache", extensions: ["wm"] },
  "video/x-ms-wmv": { source: "apache", compressible: !1, extensions: ["wmv"] },
  "video/x-ms-wmx": { source: "apache", extensions: ["wmx"] },
  "video/x-ms-wvx": { source: "apache", extensions: ["wvx"] },
  "video/x-msvideo": { source: "apache", extensions: ["avi"] },
  "video/x-sgi-movie": { source: "apache", extensions: ["movie"] },
  "video/x-smv": { source: "apache", extensions: ["smv"] },
  "x-conference/x-cooltalk": { source: "apache", extensions: ["ice"] },
  "x-shader/x-fragment": { compressible: !0 },
  "x-shader/x-vertex": { compressible: !0 },
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var oO = sO;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e) {
  var t = oO,
    n = pt.extname,
    r = /^\s*([^;\s]*)(?:;|\s|$)/,
    i = /^text\//i;
  (e.charset = a),
    (e.charsets = { lookup: a }),
    (e.contentType = s),
    (e.extension = o),
    (e.extensions = Object.create(null)),
    (e.lookup = c),
    (e.types = Object.create(null)),
    l(e.extensions, e.types);
  function a(f) {
    if (!f || typeof f != "string") return !1;
    var u = r.exec(f),
      d = u && t[u[1].toLowerCase()];
    return d && d.charset ? d.charset : u && i.test(u[1]) ? "UTF-8" : !1;
  }
  function s(f) {
    if (!f || typeof f != "string") return !1;
    var u = f.indexOf("/") === -1 ? e.lookup(f) : f;
    if (!u) return !1;
    if (u.indexOf("charset") === -1) {
      var d = e.charset(u);
      d && (u += "; charset=" + d.toLowerCase());
    }
    return u;
  }
  function o(f) {
    if (!f || typeof f != "string") return !1;
    var u = r.exec(f),
      d = u && e.extensions[u[1].toLowerCase()];
    return !d || !d.length ? !1 : d[0];
  }
  function c(f) {
    if (!f || typeof f != "string") return !1;
    var u = n("x." + f)
      .toLowerCase()
      .substr(1);
    return (u && e.types[u]) || !1;
  }
  function l(f, u) {
    var d = ["nginx", "apache", void 0, "iana"];
    Object.keys(t).forEach(function (h) {
      var m = t[h],
        g = m.extensions;
      if (!(!g || !g.length)) {
        f[h] = g;
        for (var v = 0; v < g.length; v++) {
          var y = g[v];
          if (u[y]) {
            var _ = d.indexOf(t[u[y]].source),
              E = d.indexOf(m.source);
            if (
              u[y] !== "application/octet-stream" &&
              (_ > E || (_ === E && u[y].substr(0, 12) === "application/"))
            )
              continue;
          }
          u[y] = h;
        }
      }
    });
  }
})(rv);
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Z1 = nv,
  cO = rv;
vc.exports = lO;
vc.exports.is = EI;
vc.exports.hasBody = wI;
vc.exports.normalize = xI;
vc.exports.match = AI;
function EI(e, t) {
  var n,
    r = t,
    i = fO(e);
  if (!i) return !1;
  if (r && !Array.isArray(r))
    for (r = new Array(arguments.length - 1), n = 0; n < r.length; n++)
      r[n] = arguments[n + 1];
  if (!r || !r.length) return i;
  var a;
  for (n = 0; n < r.length; n++)
    if (AI(xI((a = r[n])), i))
      return a[0] === "+" || a.indexOf("*") !== -1 ? i : a;
  return !1;
}
function wI(e) {
  return (
    e.headers["transfer-encoding"] !== void 0 ||
    !isNaN(e.headers["content-length"])
  );
}
function lO(e, t) {
  var n = t;
  if (!wI(e)) return null;
  if (arguments.length > 2) {
    n = new Array(arguments.length - 1);
    for (var r = 0; r < n.length; r++) n[r] = arguments[r + 1];
  }
  var i = e.headers["content-type"];
  return EI(i, n);
}
function xI(e) {
  if (typeof e != "string") return !1;
  switch (e) {
    case "urlencoded":
      return "application/x-www-form-urlencoded";
    case "multipart":
      return "multipart/*";
  }
  return e[0] === "+" ? "*/*" + e : e.indexOf("/") === -1 ? cO.lookup(e) : e;
}
function AI(e, t) {
  if (e === !1) return !1;
  var n = t.split("/"),
    r = e.split("/");
  return n.length !== 2 || r.length !== 2 || (r[0] !== "*" && r[0] !== n[0])
    ? !1
    : r[1].substr(0, 2) === "*+"
    ? r[1].length <= n[1].length + 1 &&
      r[1].substr(1) === n[1].substr(1 - r[1].length)
    : !(r[1] !== "*" && r[1] !== n[1]);
}
function uO(e) {
  var t = Z1.parse(e);
  return (t.parameters = void 0), Z1.format(t);
}
function fO(e) {
  if (!e) return null;
  try {
    return uO(e);
  } catch {
    return null;
  }
}
var ga = vc.exports;
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var yh, e_;
function dO() {
  if (e_) return yh;
  e_ = 1;
  var e = qi(),
    t = zs(),
    n = Gi,
    r = ma("body-parser:json"),
    i = Gd(),
    a = ga;
  yh = o;
  var s = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  function o(p) {
    var h = p || {},
      m = typeof h.limit != "number" ? e.parse(h.limit || "100kb") : h.limit,
      g = h.inflate !== !1,
      v = h.reviver,
      y = h.strict !== !1,
      _ = h.type || "application/json",
      E = h.verify || !1;
    if (E !== !1 && typeof E != "function")
      throw new TypeError("option verify must be function");
    var R = typeof _ != "function" ? d(_) : _;
    function A(I) {
      if (I.length === 0) return {};
      if (y) {
        var S = l(I);
        if (S !== "{" && S !== "[") throw (r("strict violation"), c(I, S));
      }
      try {
        return r("parse json"), JSON.parse(I, v);
      } catch (w) {
        throw u(w, { message: w.message, stack: w.stack });
      }
    }
    return function (S, w, O) {
      if (S._body) {
        r("body already parsed"), O();
        return;
      }
      if (((S.body = S.body || {}), !a.hasBody(S))) {
        r("skip empty body"), O();
        return;
      }
      if ((r("content-type %j", S.headers["content-type"]), !R(S))) {
        r("skip parsing"), O();
        return;
      }
      var Q = f(S) || "utf-8";
      if (Q.slice(0, 4) !== "utf-") {
        r("invalid charset"),
          O(
            n(415, 'unsupported charset "' + Q.toUpperCase() + '"', {
              charset: Q,
              type: "charset.unsupported",
            }),
          );
        return;
      }
      i(S, w, O, A, r, { encoding: Q, inflate: g, limit: m, verify: E });
    };
  }
  function c(p, h) {
    var m = p.indexOf(h),
      g = m !== -1 ? p.substring(0, m) + "#" : "";
    try {
      throw (JSON.parse(g), new SyntaxError("strict violation"));
    } catch (v) {
      return u(v, { message: v.message.replace("#", h), stack: v.stack });
    }
  }
  function l(p) {
    var h = s.exec(p);
    return h ? h[1] : void 0;
  }
  function f(p) {
    try {
      return (t.parse(p).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function u(p, h) {
    for (var m = Object.getOwnPropertyNames(p), g = 0; g < m.length; g++) {
      var v = m[g];
      v !== "stack" && v !== "message" && delete p[v];
    }
    return (
      (p.stack = h.stack.replace(p.message, h.message)),
      (p.message = h.message),
      p
    );
  }
  function d(p) {
    return function (m) {
      return !!a(m, p);
    };
  }
  return yh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var bh, t_;
function pO() {
  if (t_) return bh;
  t_ = 1;
  var e = qi(),
    t = ma("body-parser:raw"),
    n = Gd(),
    r = ga;
  bh = i;
  function i(s) {
    var o = s || {},
      c = o.inflate !== !1,
      l = typeof o.limit != "number" ? e.parse(o.limit || "100kb") : o.limit,
      f = o.type || "application/octet-stream",
      u = o.verify || !1;
    if (u !== !1 && typeof u != "function")
      throw new TypeError("option verify must be function");
    var d = typeof f != "function" ? a(f) : f;
    function p(h) {
      return h;
    }
    return function (m, g, v) {
      if (m._body) {
        t("body already parsed"), v();
        return;
      }
      if (((m.body = m.body || {}), !r.hasBody(m))) {
        t("skip empty body"), v();
        return;
      }
      if ((t("content-type %j", m.headers["content-type"]), !d(m))) {
        t("skip parsing"), v();
        return;
      }
      n(m, g, v, p, t, { encoding: null, inflate: c, limit: l, verify: u });
    };
  }
  function a(s) {
    return function (c) {
      return !!r(c, s);
    };
  }
  return bh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var _h, n_;
function hO() {
  if (n_) return _h;
  n_ = 1;
  var e = qi(),
    t = zs(),
    n = ma("body-parser:text"),
    r = Gd(),
    i = ga;
  _h = a;
  function a(c) {
    var l = c || {},
      f = l.defaultCharset || "utf-8",
      u = l.inflate !== !1,
      d = typeof l.limit != "number" ? e.parse(l.limit || "100kb") : l.limit,
      p = l.type || "text/plain",
      h = l.verify || !1;
    if (h !== !1 && typeof h != "function")
      throw new TypeError("option verify must be function");
    var m = typeof p != "function" ? o(p) : p;
    function g(v) {
      return v;
    }
    return function (y, _, E) {
      if (y._body) {
        n("body already parsed"), E();
        return;
      }
      if (((y.body = y.body || {}), !i.hasBody(y))) {
        n("skip empty body"), E();
        return;
      }
      if ((n("content-type %j", y.headers["content-type"]), !m(y))) {
        n("skip parsing"), E();
        return;
      }
      var R = s(y) || f;
      r(y, _, E, g, n, { encoding: R, inflate: u, limit: d, verify: h });
    };
  }
  function s(c) {
    try {
      return (t.parse(c).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function o(c) {
    return function (f) {
      return !!i(f, c);
    };
  }
  return _h;
}
var mO = function () {
    if (
      typeof Symbol != "function" ||
      typeof Object.getOwnPropertySymbols != "function"
    )
      return !1;
    if (typeof Symbol.iterator == "symbol") return !0;
    var t = {},
      n = Symbol("test"),
      r = Object(n);
    if (
      typeof n == "string" ||
      Object.prototype.toString.call(n) !== "[object Symbol]" ||
      Object.prototype.toString.call(r) !== "[object Symbol]"
    )
      return !1;
    var i = 42;
    t[n] = i;
    for (n in t) return !1;
    if (
      (typeof Object.keys == "function" && Object.keys(t).length !== 0) ||
      (typeof Object.getOwnPropertyNames == "function" &&
        Object.getOwnPropertyNames(t).length !== 0)
    )
      return !1;
    var a = Object.getOwnPropertySymbols(t);
    if (
      a.length !== 1 ||
      a[0] !== n ||
      !Object.prototype.propertyIsEnumerable.call(t, n)
    )
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var s = Object.getOwnPropertyDescriptor(t, n);
      if (s.value !== i || s.enumerable !== !0) return !1;
    }
    return !0;
  },
  r_ = typeof Symbol < "u" && Symbol,
  gO = mO,
  vO = function () {
    return typeof r_ != "function" ||
      typeof Symbol != "function" ||
      typeof r_("foo") != "symbol" ||
      typeof Symbol("bar") != "symbol"
      ? !1
      : gO();
  },
  i_ = { foo: {} },
  yO = Object,
  bO = function () {
    return (
      { __proto__: i_ }.foo === i_.foo && !({ __proto__: null } instanceof yO)
    );
  },
  _O = "Function.prototype.bind called on incompatible ",
  Eh = Array.prototype.slice,
  EO = Object.prototype.toString,
  wO = "[object Function]",
  xO = function (t) {
    var n = this;
    if (typeof n != "function" || EO.call(n) !== wO)
      throw new TypeError(_O + n);
    for (
      var r = Eh.call(arguments, 1),
        i,
        a = function () {
          if (this instanceof i) {
            var f = n.apply(this, r.concat(Eh.call(arguments)));
            return Object(f) === f ? f : this;
          } else return n.apply(t, r.concat(Eh.call(arguments)));
        },
        s = Math.max(0, n.length - r.length),
        o = [],
        c = 0;
      c < s;
      c++
    )
      o.push("$" + c);
    if (
      ((i = Function(
        "binder",
        "return function (" +
          o.join(",") +
          "){ return binder.apply(this,arguments); }",
      )(a)),
      n.prototype)
    ) {
      var l = function () {};
      (l.prototype = n.prototype),
        (i.prototype = new l()),
        (l.prototype = null);
    }
    return i;
  },
  AO = xO,
  iv = Function.prototype.bind || AO,
  SO = iv,
  IO = SO.call(Function.call, Object.prototype.hasOwnProperty),
  kt,
  Ho = SyntaxError,
  SI = Function,
  Po = TypeError,
  wh = function (e) {
    try {
      return SI('"use strict"; return (' + e + ").constructor;")();
    } catch {}
  },
  Ts = Object.getOwnPropertyDescriptor;
if (Ts)
  try {
    Ts({}, "");
  } catch {
    Ts = null;
  }
var xh = function () {
    throw new Po();
  },
  $O = Ts
    ? (function () {
        try {
          return arguments.callee, xh;
        } catch {
          try {
            return Ts(arguments, "callee").get;
          } catch {
            return xh;
          }
        }
      })()
    : xh,
  ro = vO(),
  CO = bO(),
  Wn =
    Object.getPrototypeOf ||
    (CO
      ? function (e) {
          return e.__proto__;
        }
      : null),
  wo = {},
  RO = typeof Uint8Array > "u" || !Wn ? kt : Wn(Uint8Array),
  Ns = {
    "%AggregateError%": typeof AggregateError > "u" ? kt : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? kt : ArrayBuffer,
    "%ArrayIteratorPrototype%": ro && Wn ? Wn([][Symbol.iterator]()) : kt,
    "%AsyncFromSyncIteratorPrototype%": kt,
    "%AsyncFunction%": wo,
    "%AsyncGenerator%": wo,
    "%AsyncGeneratorFunction%": wo,
    "%AsyncIteratorPrototype%": wo,
    "%Atomics%": typeof Atomics > "u" ? kt : Atomics,
    "%BigInt%": typeof BigInt > "u" ? kt : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? kt : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? kt : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? kt : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? kt : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? kt : Float64Array,
    "%FinalizationRegistry%":
      typeof FinalizationRegistry > "u" ? kt : FinalizationRegistry,
    "%Function%": SI,
    "%GeneratorFunction%": wo,
    "%Int8Array%": typeof Int8Array > "u" ? kt : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? kt : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? kt : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": ro && Wn ? Wn(Wn([][Symbol.iterator]())) : kt,
    "%JSON%": typeof JSON == "object" ? JSON : kt,
    "%Map%": typeof Map > "u" ? kt : Map,
    "%MapIteratorPrototype%":
      typeof Map > "u" || !ro || !Wn ? kt : Wn(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? kt : Promise,
    "%Proxy%": typeof Proxy > "u" ? kt : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? kt : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? kt : Set,
    "%SetIteratorPrototype%":
      typeof Set > "u" || !ro || !Wn ? kt : Wn(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%":
      typeof SharedArrayBuffer > "u" ? kt : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": ro && Wn ? Wn(""[Symbol.iterator]()) : kt,
    "%Symbol%": ro ? Symbol : kt,
    "%SyntaxError%": Ho,
    "%ThrowTypeError%": $O,
    "%TypedArray%": RO,
    "%TypeError%": Po,
    "%Uint8Array%": typeof Uint8Array > "u" ? kt : Uint8Array,
    "%Uint8ClampedArray%":
      typeof Uint8ClampedArray > "u" ? kt : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? kt : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? kt : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? kt : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? kt : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? kt : WeakSet,
  };
if (Wn)
  try {
    null.error;
  } catch (e) {
    var kO = Wn(Wn(e));
    Ns["%Error.prototype%"] = kO;
  }
var TO = function e(t) {
    var n;
    if (t === "%AsyncFunction%") n = wh("async function () {}");
    else if (t === "%GeneratorFunction%") n = wh("function* () {}");
    else if (t === "%AsyncGeneratorFunction%") n = wh("async function* () {}");
    else if (t === "%AsyncGenerator%") {
      var r = e("%AsyncGeneratorFunction%");
      r && (n = r.prototype);
    } else if (t === "%AsyncIteratorPrototype%") {
      var i = e("%AsyncGenerator%");
      i && Wn && (n = Wn(i.prototype));
    }
    return (Ns[t] = n), n;
  },
  a_ = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": [
      "AsyncGeneratorFunction",
      "prototype",
      "prototype",
    ],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"],
  },
  Vl = iv,
  ed = IO,
  NO = Vl.call(Function.call, Array.prototype.concat),
  OO = Vl.call(Function.apply, Array.prototype.splice),
  s_ = Vl.call(Function.call, String.prototype.replace),
  td = Vl.call(Function.call, String.prototype.slice),
  PO = Vl.call(Function.call, RegExp.prototype.exec),
  DO =
    /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
  LO = /\\(\\)?/g,
  BO = function (t) {
    var n = td(t, 0, 1),
      r = td(t, -1);
    if (n === "%" && r !== "%")
      throw new Ho("invalid intrinsic syntax, expected closing `%`");
    if (r === "%" && n !== "%")
      throw new Ho("invalid intrinsic syntax, expected opening `%`");
    var i = [];
    return (
      s_(t, DO, function (a, s, o, c) {
        i[i.length] = o ? s_(c, LO, "$1") : s || a;
      }),
      i
    );
  },
  UO = function (t, n) {
    var r = t,
      i;
    if ((ed(a_, r) && ((i = a_[r]), (r = "%" + i[0] + "%")), ed(Ns, r))) {
      var a = Ns[r];
      if ((a === wo && (a = TO(r)), typeof a > "u" && !n))
        throw new Po(
          "intrinsic " +
            t +
            " exists, but is not available. Please file an issue!",
        );
      return { alias: i, name: r, value: a };
    }
    throw new Ho("intrinsic " + t + " does not exist!");
  },
  av = function (t, n) {
    if (typeof t != "string" || t.length === 0)
      throw new Po("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof n != "boolean")
      throw new Po('"allowMissing" argument must be a boolean');
    if (PO(/^%?[^%]*%?$/, t) === null)
      throw new Ho(
        "`%` may not be present anywhere but at the beginning and end of the intrinsic name",
      );
    var r = BO(t),
      i = r.length > 0 ? r[0] : "",
      a = UO("%" + i + "%", n),
      s = a.name,
      o = a.value,
      c = !1,
      l = a.alias;
    l && ((i = l[0]), OO(r, NO([0, 1], l)));
    for (var f = 1, u = !0; f < r.length; f += 1) {
      var d = r[f],
        p = td(d, 0, 1),
        h = td(d, -1);
      if (
        (p === '"' ||
          p === "'" ||
          p === "`" ||
          h === '"' ||
          h === "'" ||
          h === "`") &&
        p !== h
      )
        throw new Ho("property names with quotes must have matching quotes");
      if (
        ((d === "constructor" || !u) && (c = !0),
        (i += "." + d),
        (s = "%" + i + "%"),
        ed(Ns, s))
      )
        o = Ns[s];
      else if (o != null) {
        if (!(d in o)) {
          if (!n)
            throw new Po(
              "base intrinsic for " +
                t +
                " exists, but the property is not available.",
            );
          return;
        }
        if (Ts && f + 1 >= r.length) {
          var m = Ts(o, d);
          (u = !!m),
            u && "get" in m && !("originalValue" in m.get)
              ? (o = m.get)
              : (o = o[d]);
        } else (u = ed(o, d)), (o = o[d]);
        u && !c && (Ns[s] = o);
      }
    }
    return o;
  },
  II = { exports: {} };
(function (e) {
  var t = iv,
    n = av,
    r = n("%Function.prototype.apply%"),
    i = n("%Function.prototype.call%"),
    a = n("%Reflect.apply%", !0) || t.call(i, r),
    s = n("%Object.getOwnPropertyDescriptor%", !0),
    o = n("%Object.defineProperty%", !0),
    c = n("%Math.max%");
  if (o)
    try {
      o({}, "a", { value: 1 });
    } catch {
      o = null;
    }
  e.exports = function (u) {
    var d = a(t, i, arguments);
    if (s && o) {
      var p = s(d, "length");
      p.configurable &&
        o(d, "length", { value: 1 + c(0, u.length - (arguments.length - 1)) });
    }
    return d;
  };
  var l = function () {
    return a(t, r, arguments);
  };
  o ? o(e.exports, "apply", { value: l }) : (e.exports.apply = l);
})(II);
var FO = II.exports,
  $I = av,
  CI = FO,
  jO = CI($I("String.prototype.indexOf")),
  MO = function (t, n) {
    var r = $I(t, !!n);
    return typeof r == "function" && jO(t, ".prototype.") > -1 ? CI(r) : r;
  },
  HO = wr.inspect,
  sv = typeof Map == "function" && Map.prototype,
  Ah =
    Object.getOwnPropertyDescriptor && sv
      ? Object.getOwnPropertyDescriptor(Map.prototype, "size")
      : null,
  nd = sv && Ah && typeof Ah.get == "function" ? Ah.get : null,
  o_ = sv && Map.prototype.forEach,
  ov = typeof Set == "function" && Set.prototype,
  Sh =
    Object.getOwnPropertyDescriptor && ov
      ? Object.getOwnPropertyDescriptor(Set.prototype, "size")
      : null,
  rd = ov && Sh && typeof Sh.get == "function" ? Sh.get : null,
  c_ = ov && Set.prototype.forEach,
  qO = typeof WeakMap == "function" && WeakMap.prototype,
  ll = qO ? WeakMap.prototype.has : null,
  GO = typeof WeakSet == "function" && WeakSet.prototype,
  ul = GO ? WeakSet.prototype.has : null,
  QO = typeof WeakRef == "function" && WeakRef.prototype,
  l_ = QO ? WeakRef.prototype.deref : null,
  WO = Boolean.prototype.valueOf,
  zO = Object.prototype.toString,
  KO = Function.prototype.toString,
  VO = String.prototype.match,
  cv = String.prototype.slice,
  Pa = String.prototype.replace,
  YO = String.prototype.toUpperCase,
  u_ = String.prototype.toLowerCase,
  RI = RegExp.prototype.test,
  f_ = Array.prototype.concat,
  Pi = Array.prototype.join,
  XO = Array.prototype.slice,
  d_ = Math.floor,
  Hg = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
  Ih = Object.getOwnPropertySymbols,
  qg =
    typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
      ? Symbol.prototype.toString
      : null,
  qo = typeof Symbol == "function" && typeof Symbol.iterator == "object",
  dr =
    typeof Symbol == "function" &&
    Symbol.toStringTag &&
    (typeof Symbol.toStringTag === qo || "symbol")
      ? Symbol.toStringTag
      : null,
  kI = Object.prototype.propertyIsEnumerable,
  p_ =
    (typeof Reflect == "function"
      ? Reflect.getPrototypeOf
      : Object.getPrototypeOf) ||
    ([].__proto__ === Array.prototype
      ? function (e) {
          return e.__proto__;
        }
      : null);
function h_(e, t) {
  if (
    e === 1 / 0 ||
    e === -1 / 0 ||
    e !== e ||
    (e && e > -1e3 && e < 1e3) ||
    RI.call(/e/, t)
  )
    return t;
  var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof e == "number") {
    var r = e < 0 ? -d_(-e) : d_(e);
    if (r !== e) {
      var i = String(r),
        a = cv.call(t, i.length + 1);
      return (
        Pa.call(i, n, "$&_") +
        "." +
        Pa.call(Pa.call(a, /([0-9]{3})/g, "$&_"), /_$/, "")
      );
    }
  }
  return Pa.call(t, n, "$&_");
}
var Gg = HO,
  m_ = Gg.custom,
  g_ = NI(m_) ? m_ : null,
  JO = function e(t, n, r, i) {
    var a = n || {};
    if (
      $a(a, "quoteStyle") &&
      a.quoteStyle !== "single" &&
      a.quoteStyle !== "double"
    )
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (
      $a(a, "maxStringLength") &&
      (typeof a.maxStringLength == "number"
        ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0
        : a.maxStringLength !== null)
    )
      throw new TypeError(
        'option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`',
      );
    var s = $a(a, "customInspect") ? a.customInspect : !0;
    if (typeof s != "boolean" && s !== "symbol")
      throw new TypeError(
        "option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`",
      );
    if (
      $a(a, "indent") &&
      a.indent !== null &&
      a.indent !== "	" &&
      !(parseInt(a.indent, 10) === a.indent && a.indent > 0)
    )
      throw new TypeError(
        'option "indent" must be "\\t", an integer > 0, or `null`',
      );
    if ($a(a, "numericSeparator") && typeof a.numericSeparator != "boolean")
      throw new TypeError(
        'option "numericSeparator", if provided, must be `true` or `false`',
      );
    var o = a.numericSeparator;
    if (typeof t > "u") return "undefined";
    if (t === null) return "null";
    if (typeof t == "boolean") return t ? "true" : "false";
    if (typeof t == "string") return PI(t, a);
    if (typeof t == "number") {
      if (t === 0) return 1 / 0 / t > 0 ? "0" : "-0";
      var c = String(t);
      return o ? h_(t, c) : c;
    }
    if (typeof t == "bigint") {
      var l = String(t) + "n";
      return o ? h_(t, l) : l;
    }
    var f = typeof a.depth > "u" ? 5 : a.depth;
    if ((typeof r > "u" && (r = 0), r >= f && f > 0 && typeof t == "object"))
      return Qg(t) ? "[Array]" : "[Object]";
    var u = gP(a, r);
    if (typeof i > "u") i = [];
    else if (OI(i, t) >= 0) return "[Circular]";
    function d(H, q, J) {
      if ((q && ((i = XO.call(i)), i.push(q)), J)) {
        var Z = { depth: a.depth };
        return (
          $a(a, "quoteStyle") && (Z.quoteStyle = a.quoteStyle),
          e(H, Z, r + 1, i)
        );
      }
      return e(H, a, r + 1, i);
    }
    if (typeof t == "function" && !v_(t)) {
      var p = oP(t),
        h = Fu(t, d);
      return (
        "[Function" +
        (p ? ": " + p : " (anonymous)") +
        "]" +
        (h.length > 0 ? " { " + Pi.call(h, ", ") + " }" : "")
      );
    }
    if (NI(t)) {
      var m = qo
        ? Pa.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1")
        : qg.call(t);
      return typeof t == "object" && !qo ? Pc(m) : m;
    }
    if (pP(t)) {
      for (
        var g = "<" + u_.call(String(t.nodeName)),
          v = t.attributes || [],
          y = 0;
        y < v.length;
        y++
      )
        g += " " + v[y].name + "=" + TI(ZO(v[y].value), "double", a);
      return (
        (g += ">"),
        t.childNodes && t.childNodes.length && (g += "..."),
        (g += "</" + u_.call(String(t.nodeName)) + ">"),
        g
      );
    }
    if (Qg(t)) {
      if (t.length === 0) return "[]";
      var _ = Fu(t, d);
      return u && !mP(_)
        ? "[" + Wg(_, u) + "]"
        : "[ " + Pi.call(_, ", ") + " ]";
    }
    if (tP(t)) {
      var E = Fu(t, d);
      return !("cause" in Error.prototype) &&
        "cause" in t &&
        !kI.call(t, "cause")
        ? "{ [" +
            String(t) +
            "] " +
            Pi.call(f_.call("[cause]: " + d(t.cause), E), ", ") +
            " }"
        : E.length === 0
        ? "[" + String(t) + "]"
        : "{ [" + String(t) + "] " + Pi.call(E, ", ") + " }";
    }
    if (typeof t == "object" && s) {
      if (g_ && typeof t[g_] == "function" && Gg)
        return Gg(t, { depth: f - r });
      if (s !== "symbol" && typeof t.inspect == "function") return t.inspect();
    }
    if (cP(t)) {
      var R = [];
      return (
        o_ &&
          o_.call(t, function (H, q) {
            R.push(d(q, t, !0) + " => " + d(H, t));
          }),
        y_("Map", nd.call(t), R, u)
      );
    }
    if (fP(t)) {
      var A = [];
      return (
        c_ &&
          c_.call(t, function (H) {
            A.push(d(H, t));
          }),
        y_("Set", rd.call(t), A, u)
      );
    }
    if (lP(t)) return $h("WeakMap");
    if (dP(t)) return $h("WeakSet");
    if (uP(t)) return $h("WeakRef");
    if (rP(t)) return Pc(d(Number(t)));
    if (aP(t)) return Pc(d(Hg.call(t)));
    if (iP(t)) return Pc(WO.call(t));
    if (nP(t)) return Pc(d(String(t)));
    if (!eP(t) && !v_(t)) {
      var I = Fu(t, d),
        S = p_
          ? p_(t) === Object.prototype
          : t instanceof Object || t.constructor === Object,
        w = t instanceof Object ? "" : "null prototype",
        O =
          !S && dr && Object(t) === t && dr in t
            ? cv.call(Ja(t), 8, -1)
            : w
            ? "Object"
            : "",
        Q =
          S || typeof t.constructor != "function"
            ? ""
            : t.constructor.name
            ? t.constructor.name + " "
            : "",
        j =
          Q +
          (O || w
            ? "[" + Pi.call(f_.call([], O || [], w || []), ": ") + "] "
            : "");
      return I.length === 0
        ? j + "{}"
        : u
        ? j + "{" + Wg(I, u) + "}"
        : j + "{ " + Pi.call(I, ", ") + " }";
    }
    return String(t);
  };
function TI(e, t, n) {
  var r = (n.quoteStyle || t) === "double" ? '"' : "'";
  return r + e + r;
}
function ZO(e) {
  return Pa.call(String(e), /"/g, "&quot;");
}
function Qg(e) {
  return (
    Ja(e) === "[object Array]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function eP(e) {
  return (
    Ja(e) === "[object Date]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function v_(e) {
  return (
    Ja(e) === "[object RegExp]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function tP(e) {
  return (
    Ja(e) === "[object Error]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function nP(e) {
  return (
    Ja(e) === "[object String]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function rP(e) {
  return (
    Ja(e) === "[object Number]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function iP(e) {
  return (
    Ja(e) === "[object Boolean]" && (!dr || !(typeof e == "object" && dr in e))
  );
}
function NI(e) {
  if (qo) return e && typeof e == "object" && e instanceof Symbol;
  if (typeof e == "symbol") return !0;
  if (!e || typeof e != "object" || !qg) return !1;
  try {
    return qg.call(e), !0;
  } catch {}
  return !1;
}
function aP(e) {
  if (!e || typeof e != "object" || !Hg) return !1;
  try {
    return Hg.call(e), !0;
  } catch {}
  return !1;
}
var sP =
  Object.prototype.hasOwnProperty ||
  function (e) {
    return e in this;
  };
function $a(e, t) {
  return sP.call(e, t);
}
function Ja(e) {
  return zO.call(e);
}
function oP(e) {
  if (e.name) return e.name;
  var t = VO.call(KO.call(e), /^function\s*([\w$]+)/);
  return t ? t[1] : null;
}
function OI(e, t) {
  if (e.indexOf) return e.indexOf(t);
  for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
  return -1;
}
function cP(e) {
  if (!nd || !e || typeof e != "object") return !1;
  try {
    nd.call(e);
    try {
      rd.call(e);
    } catch {
      return !0;
    }
    return e instanceof Map;
  } catch {}
  return !1;
}
function lP(e) {
  if (!ll || !e || typeof e != "object") return !1;
  try {
    ll.call(e, ll);
    try {
      ul.call(e, ul);
    } catch {
      return !0;
    }
    return e instanceof WeakMap;
  } catch {}
  return !1;
}
function uP(e) {
  if (!l_ || !e || typeof e != "object") return !1;
  try {
    return l_.call(e), !0;
  } catch {}
  return !1;
}
function fP(e) {
  if (!rd || !e || typeof e != "object") return !1;
  try {
    rd.call(e);
    try {
      nd.call(e);
    } catch {
      return !0;
    }
    return e instanceof Set;
  } catch {}
  return !1;
}
function dP(e) {
  if (!ul || !e || typeof e != "object") return !1;
  try {
    ul.call(e, ul);
    try {
      ll.call(e, ll);
    } catch {
      return !0;
    }
    return e instanceof WeakSet;
  } catch {}
  return !1;
}
function pP(e) {
  return !e || typeof e != "object"
    ? !1
    : typeof HTMLElement < "u" && e instanceof HTMLElement
    ? !0
    : typeof e.nodeName == "string" && typeof e.getAttribute == "function";
}
function PI(e, t) {
  if (e.length > t.maxStringLength) {
    var n = e.length - t.maxStringLength,
      r = "... " + n + " more character" + (n > 1 ? "s" : "");
    return PI(cv.call(e, 0, t.maxStringLength), t) + r;
  }
  var i = Pa.call(Pa.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, hP);
  return TI(i, "single", t);
}
function hP(e) {
  var t = e.charCodeAt(0),
    n = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[t];
  return n ? "\\" + n : "\\x" + (t < 16 ? "0" : "") + YO.call(t.toString(16));
}
function Pc(e) {
  return "Object(" + e + ")";
}
function $h(e) {
  return e + " { ? }";
}
function y_(e, t, n, r) {
  var i = r ? Wg(n, r) : Pi.call(n, ", ");
  return e + " (" + t + ") {" + i + "}";
}
function mP(e) {
  for (var t = 0; t < e.length; t++)
    if (
      OI(
        e[t],
        `
`,
      ) >= 0
    )
      return !1;
  return !0;
}
function gP(e, t) {
  var n;
  if (e.indent === "	") n = "	";
  else if (typeof e.indent == "number" && e.indent > 0)
    n = Pi.call(Array(e.indent + 1), " ");
  else return null;
  return { base: n, prev: Pi.call(Array(t + 1), n) };
}
function Wg(e, t) {
  if (e.length === 0) return "";
  var n =
    `
` +
    t.prev +
    t.base;
  return (
    n +
    Pi.call(e, "," + n) +
    `
` +
    t.prev
  );
}
function Fu(e, t) {
  var n = Qg(e),
    r = [];
  if (n) {
    r.length = e.length;
    for (var i = 0; i < e.length; i++) r[i] = $a(e, i) ? t(e[i], e) : "";
  }
  var a = typeof Ih == "function" ? Ih(e) : [],
    s;
  if (qo) {
    s = {};
    for (var o = 0; o < a.length; o++) s["$" + a[o]] = a[o];
  }
  for (var c in e)
    $a(e, c) &&
      ((n && String(Number(c)) === c && c < e.length) ||
        (qo && s["$" + c] instanceof Symbol) ||
        (RI.call(/[^\w$]/, c)
          ? r.push(t(c, e) + ": " + t(e[c], e))
          : r.push(c + ": " + t(e[c], e))));
  if (typeof Ih == "function")
    for (var l = 0; l < a.length; l++)
      kI.call(e, a[l]) && r.push("[" + t(a[l]) + "]: " + t(e[a[l]], e));
  return r;
}
var lv = av,
  yc = MO,
  vP = JO,
  yP = lv("%TypeError%"),
  ju = lv("%WeakMap%", !0),
  Mu = lv("%Map%", !0),
  bP = yc("WeakMap.prototype.get", !0),
  _P = yc("WeakMap.prototype.set", !0),
  EP = yc("WeakMap.prototype.has", !0),
  wP = yc("Map.prototype.get", !0),
  xP = yc("Map.prototype.set", !0),
  AP = yc("Map.prototype.has", !0),
  uv = function (e, t) {
    for (var n = e, r; (r = n.next) !== null; n = r)
      if (r.key === t)
        return (n.next = r.next), (r.next = e.next), (e.next = r), r;
  },
  SP = function (e, t) {
    var n = uv(e, t);
    return n && n.value;
  },
  IP = function (e, t, n) {
    var r = uv(e, t);
    r ? (r.value = n) : (e.next = { key: t, next: e.next, value: n });
  },
  $P = function (e, t) {
    return !!uv(e, t);
  },
  DI = function () {
    var t,
      n,
      r,
      i = {
        assert: function (a) {
          if (!i.has(a)) throw new yP("Side channel does not contain " + vP(a));
        },
        get: function (a) {
          if (ju && a && (typeof a == "object" || typeof a == "function")) {
            if (t) return bP(t, a);
          } else if (Mu) {
            if (n) return wP(n, a);
          } else if (r) return SP(r, a);
        },
        has: function (a) {
          if (ju && a && (typeof a == "object" || typeof a == "function")) {
            if (t) return EP(t, a);
          } else if (Mu) {
            if (n) return AP(n, a);
          } else if (r) return $P(r, a);
          return !1;
        },
        set: function (a, s) {
          ju && a && (typeof a == "object" || typeof a == "function")
            ? (t || (t = new ju()), _P(t, a, s))
            : Mu
            ? (n || (n = new Mu()), xP(n, a, s))
            : (r || (r = { key: {}, next: null }), IP(r, a, s));
        },
      };
    return i;
  },
  CP = String.prototype.replace,
  RP = /%20/g,
  Ch = { RFC1738: "RFC1738", RFC3986: "RFC3986" },
  fv = {
    default: Ch.RFC3986,
    formatters: {
      RFC1738: function (e) {
        return CP.call(e, RP, "+");
      },
      RFC3986: function (e) {
        return String(e);
      },
    },
    RFC1738: Ch.RFC1738,
    RFC3986: Ch.RFC3986,
  },
  kP = fv,
  Rh = Object.prototype.hasOwnProperty,
  hs = Array.isArray,
  Ri = (function () {
    for (var e = [], t = 0; t < 256; ++t)
      e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
    return e;
  })(),
  TP = function (t) {
    for (; t.length > 1; ) {
      var n = t.pop(),
        r = n.obj[n.prop];
      if (hs(r)) {
        for (var i = [], a = 0; a < r.length; ++a)
          typeof r[a] < "u" && i.push(r[a]);
        n.obj[n.prop] = i;
      }
    }
  },
  LI = function (t, n) {
    for (
      var r = n && n.plainObjects ? Object.create(null) : {}, i = 0;
      i < t.length;
      ++i
    )
      typeof t[i] < "u" && (r[i] = t[i]);
    return r;
  },
  NP = function e(t, n, r) {
    if (!n) return t;
    if (typeof n != "object") {
      if (hs(t)) t.push(n);
      else if (t && typeof t == "object")
        ((r && (r.plainObjects || r.allowPrototypes)) ||
          !Rh.call(Object.prototype, n)) &&
          (t[n] = !0);
      else return [t, n];
      return t;
    }
    if (!t || typeof t != "object") return [t].concat(n);
    var i = t;
    return (
      hs(t) && !hs(n) && (i = LI(t, r)),
      hs(t) && hs(n)
        ? (n.forEach(function (a, s) {
            if (Rh.call(t, s)) {
              var o = t[s];
              o && typeof o == "object" && a && typeof a == "object"
                ? (t[s] = e(o, a, r))
                : t.push(a);
            } else t[s] = a;
          }),
          t)
        : Object.keys(n).reduce(function (a, s) {
            var o = n[s];
            return Rh.call(a, s) ? (a[s] = e(a[s], o, r)) : (a[s] = o), a;
          }, i)
    );
  },
  OP = function (t, n) {
    return Object.keys(n).reduce(function (r, i) {
      return (r[i] = n[i]), r;
    }, t);
  },
  PP = function (e, t, n) {
    var r = e.replace(/\+/g, " ");
    if (n === "iso-8859-1") return r.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(r);
    } catch {
      return r;
    }
  },
  DP = function (t, n, r, i, a) {
    if (t.length === 0) return t;
    var s = t;
    if (
      (typeof t == "symbol"
        ? (s = Symbol.prototype.toString.call(t))
        : typeof t != "string" && (s = String(t)),
      r === "iso-8859-1")
    )
      return escape(s).replace(/%u[0-9a-f]{4}/gi, function (f) {
        return "%26%23" + parseInt(f.slice(2), 16) + "%3B";
      });
    for (var o = "", c = 0; c < s.length; ++c) {
      var l = s.charCodeAt(c);
      if (
        l === 45 ||
        l === 46 ||
        l === 95 ||
        l === 126 ||
        (l >= 48 && l <= 57) ||
        (l >= 65 && l <= 90) ||
        (l >= 97 && l <= 122) ||
        (a === kP.RFC1738 && (l === 40 || l === 41))
      ) {
        o += s.charAt(c);
        continue;
      }
      if (l < 128) {
        o = o + Ri[l];
        continue;
      }
      if (l < 2048) {
        o = o + (Ri[192 | (l >> 6)] + Ri[128 | (l & 63)]);
        continue;
      }
      if (l < 55296 || l >= 57344) {
        o =
          o +
          (Ri[224 | (l >> 12)] +
            Ri[128 | ((l >> 6) & 63)] +
            Ri[128 | (l & 63)]);
        continue;
      }
      (c += 1),
        (l = 65536 + (((l & 1023) << 10) | (s.charCodeAt(c) & 1023))),
        (o +=
          Ri[240 | (l >> 18)] +
          Ri[128 | ((l >> 12) & 63)] +
          Ri[128 | ((l >> 6) & 63)] +
          Ri[128 | (l & 63)]);
    }
    return o;
  },
  LP = function (t) {
    for (
      var n = [{ obj: { o: t }, prop: "o" }], r = [], i = 0;
      i < n.length;
      ++i
    )
      for (
        var a = n[i], s = a.obj[a.prop], o = Object.keys(s), c = 0;
        c < o.length;
        ++c
      ) {
        var l = o[c],
          f = s[l];
        typeof f == "object" &&
          f !== null &&
          r.indexOf(f) === -1 &&
          (n.push({ obj: s, prop: l }), r.push(f));
      }
    return TP(n), t;
  },
  BP = function (t) {
    return Object.prototype.toString.call(t) === "[object RegExp]";
  },
  UP = function (t) {
    return !t || typeof t != "object"
      ? !1
      : !!(
          t.constructor &&
          t.constructor.isBuffer &&
          t.constructor.isBuffer(t)
        );
  },
  FP = function (t, n) {
    return [].concat(t, n);
  },
  jP = function (t, n) {
    if (hs(t)) {
      for (var r = [], i = 0; i < t.length; i += 1) r.push(n(t[i]));
      return r;
    }
    return n(t);
  },
  BI = {
    arrayToObject: LI,
    assign: OP,
    combine: FP,
    compact: LP,
    decode: PP,
    encode: DP,
    isBuffer: UP,
    isRegExp: BP,
    maybeMap: jP,
    merge: NP,
  },
  UI = DI,
  zg = BI,
  fl = fv,
  MP = Object.prototype.hasOwnProperty,
  b_ = {
    brackets: function (t) {
      return t + "[]";
    },
    comma: "comma",
    indices: function (t, n) {
      return t + "[" + n + "]";
    },
    repeat: function (t) {
      return t;
    },
  },
  na = Array.isArray,
  HP = String.prototype.split,
  qP = Array.prototype.push,
  FI = function (e, t) {
    qP.apply(e, na(t) ? t : [t]);
  },
  GP = Date.prototype.toISOString,
  __ = fl.default,
  Zn = {
    addQueryPrefix: !1,
    allowDots: !1,
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encoder: zg.encode,
    encodeValuesOnly: !1,
    format: __,
    formatter: fl.formatters[__],
    indices: !1,
    serializeDate: function (t) {
      return GP.call(t);
    },
    skipNulls: !1,
    strictNullHandling: !1,
  },
  QP = function (t) {
    return (
      typeof t == "string" ||
      typeof t == "number" ||
      typeof t == "boolean" ||
      typeof t == "symbol" ||
      typeof t == "bigint"
    );
  },
  kh = {},
  WP = function e(t, n, r, i, a, s, o, c, l, f, u, d, p, h, m, g) {
    for (var v = t, y = g, _ = 0, E = !1; (y = y.get(kh)) !== void 0 && !E; ) {
      var R = y.get(t);
      if (((_ += 1), typeof R < "u")) {
        if (R === _) throw new RangeError("Cyclic object value");
        E = !0;
      }
      typeof y.get(kh) > "u" && (_ = 0);
    }
    if (
      (typeof c == "function"
        ? (v = c(n, v))
        : v instanceof Date
        ? (v = u(v))
        : r === "comma" &&
          na(v) &&
          (v = zg.maybeMap(v, function (G) {
            return G instanceof Date ? u(G) : G;
          })),
      v === null)
    ) {
      if (a) return o && !h ? o(n, Zn.encoder, m, "key", d) : n;
      v = "";
    }
    if (QP(v) || zg.isBuffer(v)) {
      if (o) {
        var A = h ? n : o(n, Zn.encoder, m, "key", d);
        if (r === "comma" && h) {
          for (
            var I = HP.call(String(v), ","), S = "", w = 0;
            w < I.length;
            ++w
          )
            S += (w === 0 ? "" : ",") + p(o(I[w], Zn.encoder, m, "value", d));
          return [p(A) + (i && na(v) && I.length === 1 ? "[]" : "") + "=" + S];
        }
        return [p(A) + "=" + p(o(v, Zn.encoder, m, "value", d))];
      }
      return [p(n) + "=" + p(String(v))];
    }
    var O = [];
    if (typeof v > "u") return O;
    var Q;
    if (r === "comma" && na(v))
      Q = [{ value: v.length > 0 ? v.join(",") || null : void 0 }];
    else if (na(c)) Q = c;
    else {
      var j = Object.keys(v);
      Q = l ? j.sort(l) : j;
    }
    for (
      var H = i && na(v) && v.length === 1 ? n + "[]" : n, q = 0;
      q < Q.length;
      ++q
    ) {
      var J = Q[q],
        Z = typeof J == "object" && typeof J.value < "u" ? J.value : v[J];
      if (!(s && Z === null)) {
        var z = na(v)
          ? typeof r == "function"
            ? r(H, J)
            : H
          : H + (f ? "." + J : "[" + J + "]");
        g.set(t, _);
        var U = UI();
        U.set(kh, g), FI(O, e(Z, z, r, i, a, s, o, c, l, f, u, d, p, h, m, U));
      }
    }
    return O;
  },
  zP = function (t) {
    if (!t) return Zn;
    if (
      t.encoder !== null &&
      typeof t.encoder < "u" &&
      typeof t.encoder != "function"
    )
      throw new TypeError("Encoder has to be a function.");
    var n = t.charset || Zn.charset;
    if (
      typeof t.charset < "u" &&
      t.charset !== "utf-8" &&
      t.charset !== "iso-8859-1"
    )
      throw new TypeError(
        "The charset option must be either utf-8, iso-8859-1, or undefined",
      );
    var r = fl.default;
    if (typeof t.format < "u") {
      if (!MP.call(fl.formatters, t.format))
        throw new TypeError("Unknown format option provided.");
      r = t.format;
    }
    var i = fl.formatters[r],
      a = Zn.filter;
    return (
      (typeof t.filter == "function" || na(t.filter)) && (a = t.filter),
      {
        addQueryPrefix:
          typeof t.addQueryPrefix == "boolean"
            ? t.addQueryPrefix
            : Zn.addQueryPrefix,
        allowDots: typeof t.allowDots > "u" ? Zn.allowDots : !!t.allowDots,
        charset: n,
        charsetSentinel:
          typeof t.charsetSentinel == "boolean"
            ? t.charsetSentinel
            : Zn.charsetSentinel,
        delimiter: typeof t.delimiter > "u" ? Zn.delimiter : t.delimiter,
        encode: typeof t.encode == "boolean" ? t.encode : Zn.encode,
        encoder: typeof t.encoder == "function" ? t.encoder : Zn.encoder,
        encodeValuesOnly:
          typeof t.encodeValuesOnly == "boolean"
            ? t.encodeValuesOnly
            : Zn.encodeValuesOnly,
        filter: a,
        format: r,
        formatter: i,
        serializeDate:
          typeof t.serializeDate == "function"
            ? t.serializeDate
            : Zn.serializeDate,
        skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Zn.skipNulls,
        sort: typeof t.sort == "function" ? t.sort : null,
        strictNullHandling:
          typeof t.strictNullHandling == "boolean"
            ? t.strictNullHandling
            : Zn.strictNullHandling,
      }
    );
  },
  KP = function (e, t) {
    var n = e,
      r = zP(t),
      i,
      a;
    typeof r.filter == "function"
      ? ((a = r.filter), (n = a("", n)))
      : na(r.filter) && ((a = r.filter), (i = a));
    var s = [];
    if (typeof n != "object" || n === null) return "";
    var o;
    t && t.arrayFormat in b_
      ? (o = t.arrayFormat)
      : t && "indices" in t
      ? (o = t.indices ? "indices" : "repeat")
      : (o = "indices");
    var c = b_[o];
    if (t && "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean")
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var l = c === "comma" && t && t.commaRoundTrip;
    i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
    for (var f = UI(), u = 0; u < i.length; ++u) {
      var d = i[u];
      (r.skipNulls && n[d] === null) ||
        FI(
          s,
          WP(
            n[d],
            d,
            c,
            l,
            r.strictNullHandling,
            r.skipNulls,
            r.encode ? r.encoder : null,
            r.filter,
            r.sort,
            r.allowDots,
            r.serializeDate,
            r.format,
            r.formatter,
            r.encodeValuesOnly,
            r.charset,
            f,
          ),
        );
    }
    var p = s.join(r.delimiter),
      h = r.addQueryPrefix === !0 ? "?" : "";
    return (
      r.charsetSentinel &&
        (r.charset === "iso-8859-1"
          ? (h += "utf8=%26%2310003%3B&")
          : (h += "utf8=%E2%9C%93&")),
      p.length > 0 ? h + p : ""
    );
  },
  Go = BI,
  Kg = Object.prototype.hasOwnProperty,
  VP = Array.isArray,
  qn = {
    allowDots: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decoder: Go.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictNullHandling: !1,
  },
  YP = function (e) {
    return e.replace(/&#(\d+);/g, function (t, n) {
      return String.fromCharCode(parseInt(n, 10));
    });
  },
  jI = function (e, t) {
    return e && typeof e == "string" && t.comma && e.indexOf(",") > -1
      ? e.split(",")
      : e;
  },
  XP = "utf8=%26%2310003%3B",
  JP = "utf8=%E2%9C%93",
  ZP = function (t, n) {
    var r = {},
      i = n.ignoreQueryPrefix ? t.replace(/^\?/, "") : t,
      a = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit,
      s = i.split(n.delimiter, a),
      o = -1,
      c,
      l = n.charset;
    if (n.charsetSentinel)
      for (c = 0; c < s.length; ++c)
        s[c].indexOf("utf8=") === 0 &&
          (s[c] === JP ? (l = "utf-8") : s[c] === XP && (l = "iso-8859-1"),
          (o = c),
          (c = s.length));
    for (c = 0; c < s.length; ++c)
      if (c !== o) {
        var f = s[c],
          u = f.indexOf("]="),
          d = u === -1 ? f.indexOf("=") : u + 1,
          p,
          h;
        d === -1
          ? ((p = n.decoder(f, qn.decoder, l, "key")),
            (h = n.strictNullHandling ? null : ""))
          : ((p = n.decoder(f.slice(0, d), qn.decoder, l, "key")),
            (h = Go.maybeMap(jI(f.slice(d + 1), n), function (m) {
              return n.decoder(m, qn.decoder, l, "value");
            }))),
          h && n.interpretNumericEntities && l === "iso-8859-1" && (h = YP(h)),
          f.indexOf("[]=") > -1 && (h = VP(h) ? [h] : h),
          Kg.call(r, p) ? (r[p] = Go.combine(r[p], h)) : (r[p] = h);
      }
    return r;
  },
  e8 = function (e, t, n, r) {
    for (var i = r ? t : jI(t, n), a = e.length - 1; a >= 0; --a) {
      var s,
        o = e[a];
      if (o === "[]" && n.parseArrays) s = [].concat(i);
      else {
        s = n.plainObjects ? Object.create(null) : {};
        var c =
            o.charAt(0) === "[" && o.charAt(o.length - 1) === "]"
              ? o.slice(1, -1)
              : o,
          l = parseInt(c, 10);
        !n.parseArrays && c === ""
          ? (s = { 0: i })
          : !isNaN(l) &&
            o !== c &&
            String(l) === c &&
            l >= 0 &&
            n.parseArrays &&
            l <= n.arrayLimit
          ? ((s = []), (s[l] = i))
          : c !== "__proto__" && (s[c] = i);
      }
      i = s;
    }
    return i;
  },
  t8 = function (t, n, r, i) {
    if (t) {
      var a = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t,
        s = /(\[[^[\]]*])/,
        o = /(\[[^[\]]*])/g,
        c = r.depth > 0 && s.exec(a),
        l = c ? a.slice(0, c.index) : a,
        f = [];
      if (l) {
        if (
          !r.plainObjects &&
          Kg.call(Object.prototype, l) &&
          !r.allowPrototypes
        )
          return;
        f.push(l);
      }
      for (
        var u = 0;
        r.depth > 0 && (c = o.exec(a)) !== null && u < r.depth;

      ) {
        if (
          ((u += 1),
          !r.plainObjects &&
            Kg.call(Object.prototype, c[1].slice(1, -1)) &&
            !r.allowPrototypes)
        )
          return;
        f.push(c[1]);
      }
      return c && f.push("[" + a.slice(c.index) + "]"), e8(f, n, r, i);
    }
  },
  n8 = function (t) {
    if (!t) return qn;
    if (
      t.decoder !== null &&
      t.decoder !== void 0 &&
      typeof t.decoder != "function"
    )
      throw new TypeError("Decoder has to be a function.");
    if (
      typeof t.charset < "u" &&
      t.charset !== "utf-8" &&
      t.charset !== "iso-8859-1"
    )
      throw new TypeError(
        "The charset option must be either utf-8, iso-8859-1, or undefined",
      );
    var n = typeof t.charset > "u" ? qn.charset : t.charset;
    return {
      allowDots: typeof t.allowDots > "u" ? qn.allowDots : !!t.allowDots,
      allowPrototypes:
        typeof t.allowPrototypes == "boolean"
          ? t.allowPrototypes
          : qn.allowPrototypes,
      allowSparse:
        typeof t.allowSparse == "boolean" ? t.allowSparse : qn.allowSparse,
      arrayLimit:
        typeof t.arrayLimit == "number" ? t.arrayLimit : qn.arrayLimit,
      charset: n,
      charsetSentinel:
        typeof t.charsetSentinel == "boolean"
          ? t.charsetSentinel
          : qn.charsetSentinel,
      comma: typeof t.comma == "boolean" ? t.comma : qn.comma,
      decoder: typeof t.decoder == "function" ? t.decoder : qn.decoder,
      delimiter:
        typeof t.delimiter == "string" || Go.isRegExp(t.delimiter)
          ? t.delimiter
          : qn.delimiter,
      depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : qn.depth,
      ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
      interpretNumericEntities:
        typeof t.interpretNumericEntities == "boolean"
          ? t.interpretNumericEntities
          : qn.interpretNumericEntities,
      parameterLimit:
        typeof t.parameterLimit == "number"
          ? t.parameterLimit
          : qn.parameterLimit,
      parseArrays: t.parseArrays !== !1,
      plainObjects:
        typeof t.plainObjects == "boolean" ? t.plainObjects : qn.plainObjects,
      strictNullHandling:
        typeof t.strictNullHandling == "boolean"
          ? t.strictNullHandling
          : qn.strictNullHandling,
    };
  },
  r8 = function (e, t) {
    var n = n8(t);
    if (e === "" || e === null || typeof e > "u")
      return n.plainObjects ? Object.create(null) : {};
    for (
      var r = typeof e == "string" ? ZP(e, n) : e,
        i = n.plainObjects ? Object.create(null) : {},
        a = Object.keys(r),
        s = 0;
      s < a.length;
      ++s
    ) {
      var o = a[s],
        c = t8(o, r[o], n, typeof e == "string");
      i = Go.merge(i, c, n);
    }
    return n.allowSparse === !0 ? i : Go.compact(i);
  },
  i8 = KP,
  a8 = r8,
  s8 = fv,
  dv = { formats: s8, parse: a8, stringify: i8 };
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Th, E_;
function o8() {
  if (E_) return Th;
  E_ = 1;
  var e = qi(),
    t = zs(),
    n = Gi,
    r = ma("body-parser:urlencoded"),
    i = wi("body-parser"),
    a = Gd(),
    s = ga;
  Th = c;
  var o = Object.create(null);
  function c(m) {
    var g = m || {};
    g.extended === void 0 && i("undefined extended: provide extended option");
    var v = g.extended !== !1,
      y = g.inflate !== !1,
      _ = typeof g.limit != "number" ? e.parse(g.limit || "100kb") : g.limit,
      E = g.type || "application/x-www-form-urlencoded",
      R = g.verify || !1;
    if (R !== !1 && typeof R != "function")
      throw new TypeError("option verify must be function");
    var A = v ? l(g) : p(g),
      I = typeof E != "function" ? h(E) : E;
    function S(w) {
      return w.length ? A(w) : {};
    }
    return function (O, Q, j) {
      if (O._body) {
        r("body already parsed"), j();
        return;
      }
      if (((O.body = O.body || {}), !s.hasBody(O))) {
        r("skip empty body"), j();
        return;
      }
      if ((r("content-type %j", O.headers["content-type"]), !I(O))) {
        r("skip parsing"), j();
        return;
      }
      var H = f(O) || "utf-8";
      if (H !== "utf-8") {
        r("invalid charset"),
          j(
            n(415, 'unsupported charset "' + H.toUpperCase() + '"', {
              charset: H,
              type: "charset.unsupported",
            }),
          );
        return;
      }
      a(O, Q, j, S, r, {
        debug: r,
        encoding: H,
        inflate: y,
        limit: _,
        verify: R,
      });
    };
  }
  function l(m) {
    var g = m.parameterLimit !== void 0 ? m.parameterLimit : 1e3,
      v = d("qs");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return (
      isFinite(g) && (g = g | 0),
      function (_) {
        var E = u(_, g);
        if (E === void 0)
          throw (
            (r("too many parameters"),
            n(413, "too many parameters", { type: "parameters.too.many" }))
          );
        var R = Math.max(100, E);
        return (
          r("parse extended urlencoding"),
          v(_, {
            allowPrototypes: !0,
            arrayLimit: R,
            depth: 1 / 0,
            parameterLimit: g,
          })
        );
      }
    );
  }
  function f(m) {
    try {
      return (t.parse(m).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function u(m, g) {
    for (var v = 0, y = 0; (y = m.indexOf("&", y)) !== -1; )
      if ((v++, y++, v === g)) return;
    return v;
  }
  function d(m) {
    var g = o[m];
    if (g !== void 0) return g.parse;
    switch (m) {
      case "qs":
        g = dv;
        break;
      case "querystring":
        g = X0;
        break;
    }
    return (o[m] = g), g.parse;
  }
  function p(m) {
    var g = m.parameterLimit !== void 0 ? m.parameterLimit : 1e3,
      v = d("querystring");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return (
      isFinite(g) && (g = g | 0),
      function (_) {
        var E = u(_, g);
        if (E === void 0)
          throw (
            (r("too many parameters"),
            n(413, "too many parameters", { type: "parameters.too.many" }))
          );
        return r("parse urlencoding"), v(_, void 0, void 0, { maxKeys: g });
      }
    );
  }
  function h(m) {
    return function (v) {
      return !!s(v, m);
    };
  }
  return Th;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e, t) {
  var n = wi("body-parser"),
    r = Object.create(null);
  (t = e.exports =
    n.function(i, "bodyParser: use individual json/urlencoded middlewares")),
    Object.defineProperty(t, "json", {
      configurable: !0,
      enumerable: !0,
      get: a("json"),
    }),
    Object.defineProperty(t, "raw", {
      configurable: !0,
      enumerable: !0,
      get: a("raw"),
    }),
    Object.defineProperty(t, "text", {
      configurable: !0,
      enumerable: !0,
      get: a("text"),
    }),
    Object.defineProperty(t, "urlencoded", {
      configurable: !0,
      enumerable: !0,
      get: a("urlencoded"),
    });
  function i(o) {
    var c = Object.create(o || null, {
        type: { configurable: !0, enumerable: !0, value: void 0, writable: !0 },
      }),
      l = t.urlencoded(c),
      f = t.json(c);
    return function (d, p, h) {
      f(d, p, function (m) {
        if (m) return h(m);
        l(d, p, h);
      });
    };
  }
  function a(o) {
    return function () {
      return s(o);
    };
  }
  function s(o) {
    var c = r[o];
    if (c !== void 0) return c;
    switch (o) {
      case "json":
        c = dO();
        break;
      case "raw":
        c = pO();
        break;
      case "text":
        c = hO();
        break;
      case "urlencoded":
        c = o8();
        break;
    }
    return (r[o] = c);
  }
})(Fg, Fg.exports);
var c8 = Fg.exports;
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var l8 = f8,
  u8 = Object.prototype.hasOwnProperty;
function f8(e, t, n) {
  if (!e) throw new TypeError("argument dest is required");
  if (!t) throw new TypeError("argument src is required");
  return (
    n === void 0 && (n = !0),
    Object.getOwnPropertyNames(t).forEach(function (i) {
      if (!(!n && u8.call(e, i))) {
        var a = Object.getOwnPropertyDescriptor(t, i);
        Object.defineProperty(e, i, a);
      }
    }),
    e
  );
}
var MI = { exports: {} },
  Vg = { exports: {} },
  Hu = { exports: {} },
  qu = { exports: {} },
  Nh,
  w_;
function d8() {
  if (w_) return Nh;
  w_ = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    i = r * 365.25;
  Nh = function (l, f) {
    f = f || {};
    var u = typeof l;
    if (u === "string" && l.length > 0) return a(l);
    if (u === "number" && isNaN(l) === !1) return f.long ? o(l) : s(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(l),
    );
  };
  function a(l) {
    if (((l = String(l)), !(l.length > 100))) {
      var f =
        /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
          l,
        );
      if (f) {
        var u = parseFloat(f[1]),
          d = (f[2] || "ms").toLowerCase();
        switch (d) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * i;
          case "days":
          case "day":
          case "d":
            return u * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function s(l) {
    return l >= r
      ? Math.round(l / r) + "d"
      : l >= n
      ? Math.round(l / n) + "h"
      : l >= t
      ? Math.round(l / t) + "m"
      : l >= e
      ? Math.round(l / e) + "s"
      : l + "ms";
  }
  function o(l) {
    return (
      c(l, r, "day") ||
      c(l, n, "hour") ||
      c(l, t, "minute") ||
      c(l, e, "second") ||
      l + " ms"
    );
  }
  function c(l, f, u) {
    if (!(l < f))
      return l < f * 1.5
        ? Math.floor(l / f) + " " + u
        : Math.ceil(l / f) + " " + u + "s";
  }
  return Nh;
}
var x_;
function HI() {
  return (
    x_ ||
      ((x_ = 1),
      (function (e, t) {
        (t = e.exports = i.debug = i.default = i),
          (t.coerce = c),
          (t.disable = s),
          (t.enable = a),
          (t.enabled = o),
          (t.humanize = d8()),
          (t.names = []),
          (t.skips = []),
          (t.formatters = {});
        var n;
        function r(l) {
          var f = 0,
            u;
          for (u in l) (f = (f << 5) - f + l.charCodeAt(u)), (f |= 0);
          return t.colors[Math.abs(f) % t.colors.length];
        }
        function i(l) {
          function f() {
            if (f.enabled) {
              var u = f,
                d = +new Date(),
                p = d - (n || d);
              (u.diff = p), (u.prev = n), (u.curr = d), (n = d);
              for (
                var h = new Array(arguments.length), m = 0;
                m < h.length;
                m++
              )
                h[m] = arguments[m];
              (h[0] = t.coerce(h[0])),
                typeof h[0] != "string" && h.unshift("%O");
              var g = 0;
              (h[0] = h[0].replace(/%([a-zA-Z%])/g, function (y, _) {
                if (y === "%%") return y;
                g++;
                var E = t.formatters[_];
                if (typeof E == "function") {
                  var R = h[g];
                  (y = E.call(u, R)), h.splice(g, 1), g--;
                }
                return y;
              })),
                t.formatArgs.call(u, h);
              var v = f.log || t.log || console.log.bind(console);
              v.apply(u, h);
            }
          }
          return (
            (f.namespace = l),
            (f.enabled = t.enabled(l)),
            (f.useColors = t.useColors()),
            (f.color = r(l)),
            typeof t.init == "function" && t.init(f),
            f
          );
        }
        function a(l) {
          t.save(l), (t.names = []), (t.skips = []);
          for (
            var f = (typeof l == "string" ? l : "").split(/[\s,]+/),
              u = f.length,
              d = 0;
            d < u;
            d++
          )
            f[d] &&
              ((l = f[d].replace(/\*/g, ".*?")),
              l[0] === "-"
                ? t.skips.push(new RegExp("^" + l.substr(1) + "$"))
                : t.names.push(new RegExp("^" + l + "$")));
        }
        function s() {
          t.enable("");
        }
        function o(l) {
          var f, u;
          for (f = 0, u = t.skips.length; f < u; f++)
            if (t.skips[f].test(l)) return !1;
          for (f = 0, u = t.names.length; f < u; f++)
            if (t.names[f].test(l)) return !0;
          return !1;
        }
        function c(l) {
          return l instanceof Error ? l.stack || l.message : l;
        }
      })(qu, qu.exports)),
    qu.exports
  );
}
var A_;
function p8() {
  return (
    A_ ||
      ((A_ = 1),
      (function (e, t) {
        (t = e.exports = HI()),
          (t.log = i),
          (t.formatArgs = r),
          (t.save = a),
          (t.load = s),
          (t.useColors = n),
          (t.storage =
            typeof chrome < "u" && typeof chrome.storage < "u"
              ? chrome.storage.local
              : o()),
          (t.colors = [
            "lightseagreen",
            "forestgreen",
            "goldenrod",
            "dodgerblue",
            "darkorchid",
            "crimson",
          ]);
        function n() {
          return typeof window < "u" &&
            window.process &&
            window.process.type === "renderer"
            ? !0
            : (typeof document < "u" &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
                (typeof window < "u" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/applewebkit\/(\d+)/));
        }
        t.formatters.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
        function r(c) {
          var l = this.useColors;
          if (
            ((c[0] =
              (l ? "%c" : "") +
              this.namespace +
              (l ? " %c" : " ") +
              c[0] +
              (l ? "%c " : " ") +
              "+" +
              t.humanize(this.diff)),
            !!l)
          ) {
            var f = "color: " + this.color;
            c.splice(1, 0, f, "color: inherit");
            var u = 0,
              d = 0;
            c[0].replace(/%[a-zA-Z%]/g, function (p) {
              p !== "%%" && (u++, p === "%c" && (d = u));
            }),
              c.splice(d, 0, f);
          }
        }
        function i() {
          return (
            typeof console == "object" &&
            console.log &&
            Function.prototype.apply.call(console.log, console, arguments)
          );
        }
        function a(c) {
          try {
            c == null ? t.storage.removeItem("debug") : (t.storage.debug = c);
          } catch {}
        }
        function s() {
          var c;
          try {
            c = t.storage.debug;
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        t.enable(s());
        function o() {
          try {
            return window.localStorage;
          } catch {}
        }
      })(Hu, Hu.exports)),
    Hu.exports
  );
}
var Gu = { exports: {} },
  S_;
function h8() {
  return (
    S_ ||
      ((S_ = 1),
      (function (e, t) {
        var n = hc,
          r = wr;
        (t = e.exports = HI()),
          (t.init = d),
          (t.log = c),
          (t.formatArgs = o),
          (t.save = l),
          (t.load = f),
          (t.useColors = s),
          (t.colors = [6, 2, 3, 4, 5, 1]),
          (t.inspectOpts = Object.keys(process.env)
            .filter(function (p) {
              return /^debug_/i.test(p);
            })
            .reduce(function (p, h) {
              var m = h
                  .substring(6)
                  .toLowerCase()
                  .replace(/_([a-z])/g, function (v, y) {
                    return y.toUpperCase();
                  }),
                g = process.env[h];
              return (
                /^(yes|on|true|enabled)$/i.test(g)
                  ? (g = !0)
                  : /^(no|off|false|disabled)$/i.test(g)
                  ? (g = !1)
                  : g === "null"
                  ? (g = null)
                  : (g = Number(g)),
                (p[m] = g),
                p
              );
            }, {}));
        var i = parseInt(process.env.DEBUG_FD, 10) || 2;
        i !== 1 &&
          i !== 2 &&
          r.deprecate(
            function () {},
            "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)",
          )();
        var a = i === 1 ? process.stdout : i === 2 ? process.stderr : u(i);
        function s() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(i);
        }
        (t.formatters.o = function (p) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(p, this.inspectOpts)
              .split(
                `
`,
              )
              .map(function (h) {
                return h.trim();
              })
              .join(" ")
          );
        }),
          (t.formatters.O = function (p) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(p, this.inspectOpts)
            );
          });
        function o(p) {
          var h = this.namespace,
            m = this.useColors;
          if (m) {
            var g = this.color,
              v = "  \x1B[3" + g + ";1m" + h + " \x1B[0m";
            (p[0] =
              v +
              p[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + v,
                )),
              p.push("\x1B[3" + g + "m+" + t.humanize(this.diff) + "\x1B[0m");
          } else p[0] = new Date().toUTCString() + " " + h + " " + p[0];
        }
        function c() {
          return a.write(
            r.format.apply(r, arguments) +
              `
`,
          );
        }
        function l(p) {
          p == null ? delete process.env.DEBUG : (process.env.DEBUG = p);
        }
        function f() {
          return process.env.DEBUG;
        }
        function u(p) {
          var h,
            m = process.binding("tty_wrap");
          switch (m.guessHandleType(p)) {
            case "TTY":
              (h = new n.WriteStream(p)),
                (h._type = "tty"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            case "FILE":
              var g = Xt;
              (h = new g.SyncWriteStream(p, { autoClose: !1 })),
                (h._type = "fs");
              break;
            case "PIPE":
            case "TCP":
              var v = ha;
              (h = new v.Socket({ fd: p, readable: !1, writable: !0 })),
                (h.readable = !1),
                (h.read = null),
                (h._type = "pipe"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            default:
              throw new Error("Implement me. Unknown stream file type!");
          }
          return (h.fd = p), (h._isStdio = !0), h;
        }
        function d(p) {
          p.inspectOpts = {};
          for (var h = Object.keys(t.inspectOpts), m = 0; m < h.length; m++)
            p.inspectOpts[h[m]] = t.inspectOpts[h[m]];
        }
        t.enable(f());
      })(Gu, Gu.exports)),
    Gu.exports
  );
}
typeof process < "u" && process.type === "renderer"
  ? (Vg.exports = p8())
  : (Vg.exports = h8());
var m8 = Vg.exports;
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var Qd = b8,
  g8 =
    /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g,
  v8 =
    /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g,
  y8 = "$1ï¿½$2";
function b8(e) {
  return String(e).replace(v8, y8).replace(g8, encodeURI);
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */ var _8 = /["'&<>]/,
  Wd = E8;
function E8(e) {
  var t = "" + e,
    n = _8.exec(t);
  if (!n) return t;
  var r,
    i = "",
    a = 0,
    s = 0;
  for (a = n.index; a < t.length; a++) {
    switch (t.charCodeAt(a)) {
      case 34:
        r = "&quot;";
        break;
      case 38:
        r = "&amp;";
        break;
      case 39:
        r = "&#39;";
        break;
      case 60:
        r = "&lt;";
        break;
      case 62:
        r = "&gt;";
        break;
      default:
        continue;
    }
    s !== a && (i += t.substring(s, a)), (s = a + 1), (i += r);
  }
  return s !== a ? i + t.substring(s, a) : i;
}
var pv = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var qI = Ya,
  I_ = qI.parse,
  id = qI.Url;
pv.exports = GI;
pv.exports.original = w8;
function GI(e) {
  var t = e.url;
  if (t !== void 0) {
    var n = e._parsedUrl;
    return WI(t, n) ? n : ((n = QI(t)), (n._raw = t), (e._parsedUrl = n));
  }
}
function w8(e) {
  var t = e.originalUrl;
  if (typeof t != "string") return GI(e);
  var n = e._parsedOriginalUrl;
  return WI(t, n) ? n : ((n = QI(t)), (n._raw = t), (e._parsedOriginalUrl = n));
}
function QI(e) {
  if (typeof e != "string" || e.charCodeAt(0) !== 47) return I_(e);
  for (var t = e, n = null, r = null, i = 1; i < e.length; i++)
    switch (e.charCodeAt(i)) {
      case 63:
        r === null &&
          ((t = e.substring(0, i)),
          (n = e.substring(i + 1)),
          (r = e.substring(i)));
        break;
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
      case 35:
      case 160:
      case 65279:
        return I_(e);
    }
  var a = id !== void 0 ? new id() : {};
  return (
    (a.path = e),
    (a.href = e),
    (a.pathname = t),
    r !== null && ((a.query = n), (a.search = r)),
    a
  );
}
function WI(e, t) {
  return (
    typeof t == "object" &&
    t !== null &&
    (id === void 0 || t instanceof id) &&
    t._raw === e
  );
}
var Yl = pv.exports;
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var Oh = m8("finalhandler"),
  x8 = Qd,
  A8 = Wd,
  zI = Kl,
  S8 = Yl,
  KI = Hd,
  I8 = zl,
  $8 = /\x20{2}/g,
  C8 = /\n/g,
  R8 =
    typeof setImmediate == "function"
      ? setImmediate
      : function (e) {
          process.nextTick(e.bind.apply(e, arguments));
        },
  k8 = zI.isFinished;
function T8(e) {
  var t = A8(e).replace(C8, "<br>").replace($8, " &nbsp;");
  return (
    `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Error</title>
</head>
<body>
<pre>` +
    t +
    `</pre>
</body>
</html>
`
  );
}
var N8 = O8;
function O8(e, t, n) {
  var r = n || {},
    i = r.env || process.env.NODE_ENV || "development",
    a = r.onerror;
  return function (s) {
    var o, c, l;
    if (!s && $_(t)) {
      Oh("cannot 404 after headers sent");
      return;
    }
    if (
      (s
        ? ((l = L8(s)),
          l === void 0 ? (l = U8(t)) : (o = P8(s)),
          (c = D8(s, l, i)))
        : ((l = 404), (c = "Cannot " + e.method + " " + x8(B8(e)))),
      Oh("default %s", l),
      s && a && R8(a, s, e, t),
      $_(t))
    ) {
      Oh("cannot %d after headers sent", l), e.socket.destroy();
      return;
    }
    F8(e, t, l, o, c);
  };
}
function P8(e) {
  if (!(!e.headers || typeof e.headers != "object")) {
    for (
      var t = Object.create(null), n = Object.keys(e.headers), r = 0;
      r < n.length;
      r++
    ) {
      var i = n[r];
      t[i] = e.headers[i];
    }
    return t;
  }
}
function D8(e, t, n) {
  var r;
  return (
    n !== "production" &&
      ((r = e.stack),
      !r && typeof e.toString == "function" && (r = e.toString())),
    r || KI.message[t]
  );
}
function L8(e) {
  if (typeof e.status == "number" && e.status >= 400 && e.status < 600)
    return e.status;
  if (
    typeof e.statusCode == "number" &&
    e.statusCode >= 400 &&
    e.statusCode < 600
  )
    return e.statusCode;
}
function B8(e) {
  try {
    return S8.original(e).pathname;
  } catch {
    return "resource";
  }
}
function U8(e) {
  var t = e.statusCode;
  return (typeof t != "number" || t < 400 || t > 599) && (t = 500), t;
}
function $_(e) {
  return typeof e.headersSent != "boolean" ? !!e._header : e.headersSent;
}
function F8(e, t, n, r, i) {
  function a() {
    var s = T8(i);
    if (
      ((t.statusCode = n),
      (t.statusMessage = KI.message[n]),
      t.removeHeader("Content-Encoding"),
      t.removeHeader("Content-Language"),
      t.removeHeader("Content-Range"),
      j8(t, r),
      t.setHeader("Content-Security-Policy", "default-src 'none'"),
      t.setHeader("X-Content-Type-Options", "nosniff"),
      t.setHeader("Content-Type", "text/html; charset=utf-8"),
      t.setHeader("Content-Length", Buffer.byteLength(s, "utf8")),
      e.method === "HEAD")
    ) {
      t.end();
      return;
    }
    t.end(s, "utf8");
  }
  if (k8(e)) {
    a();
    return;
  }
  I8(e), zI(e, a), e.resume();
}
function j8(e, t) {
  if (t)
    for (var n = Object.keys(t), r = 0; r < n.length; r++) {
      var i = n[r];
      e.setHeader(i, t[i]);
    }
}
var VI = { exports: {} },
  zd = M8;
function YI(e, t, n) {
  for (var r = 0; r < e.length; r++) {
    var i = e[r];
    n > 0 && Array.isArray(i) ? YI(i, t, n - 1) : t.push(i);
  }
  return t;
}
function XI(e, t) {
  for (var n = 0; n < e.length; n++) {
    var r = e[n];
    Array.isArray(r) ? XI(r, t) : t.push(r);
  }
  return t;
}
function M8(e, t) {
  return t == null ? XI(e, []) : YI(e, [], t);
}
var H8 = JI,
  C_ = /\((?!\?)/g;
function JI(e, t, n) {
  (n = n || {}), (t = t || []);
  var r = n.strict,
    i = n.end !== !1,
    a = n.sensitive ? "" : "i",
    s = 0,
    o = t.length,
    c = 0,
    l = 0,
    f;
  if (e instanceof RegExp) {
    for (; (f = C_.exec(e.source)); )
      t.push({ name: l++, optional: !1, offset: f.index });
    return e;
  }
  if (Array.isArray(e))
    return (
      (e = e.map(function (p) {
        return JI(p, t, n).source;
      })),
      new RegExp("(?:" + e.join("|") + ")", a)
    );
  for (
    e = ("^" + e + (r ? "" : e[e.length - 1] === "/" ? "?" : "/?"))
      .replace(/\/\(/g, "/(?:")
      .replace(/([\/\.])/g, "\\$1")
      .replace(
        /(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g,
        function (p, h, m, g, v, y, _, E) {
          (h = h || ""),
            (m = m || ""),
            (v = v || "([^\\/" + m + "]+?)"),
            (_ = _ || ""),
            t.push({ name: g, optional: !!_, offset: E + s });
          var R =
            "" +
            (_ ? "" : h) +
            "(?:" +
            m +
            (_ ? h : "") +
            v +
            (y ? "((?:[\\/" + m + "].+?)?)" : "") +
            ")" +
            _;
          return (s += R.length - p.length), R;
        },
      )
      .replace(/\*/g, function (p, h) {
        for (var m = t.length; m-- > o && t[m].offset > h; ) t[m].offset += 3;
        return "(.*)";
      });
    (f = C_.exec(e));

  ) {
    for (var u = 0, d = f.index; e.charAt(--d) === "\\"; ) u++;
    u % 2 !== 1 &&
      ((o + c === t.length || t[o + c].offset > f.index) &&
        t.splice(o + c, 0, { name: l++, optional: !1, offset: f.index }),
      c++);
  }
  return (
    (e += i ? "$" : e[e.length - 1] === "/" ? "" : "(?=\\/|$)"),
    new RegExp(e, a)
  );
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var q8 = H8,
  G8 = ma("express:router:layer"),
  Q8 = Object.prototype.hasOwnProperty,
  ZI = Qo;
function Qo(e, t, n) {
  if (!(this instanceof Qo)) return new Qo(e, t, n);
  G8("new %o", e);
  var r = t || {};
  (this.handle = n),
    (this.name = n.name || "<anonymous>"),
    (this.params = void 0),
    (this.path = void 0),
    (this.regexp = q8(e, (this.keys = []), r)),
    (this.regexp.fast_star = e === "*"),
    (this.regexp.fast_slash = e === "/" && r.end === !1);
}
Qo.prototype.handle_error = function (t, n, r, i) {
  var a = this.handle;
  if (a.length !== 4) return i(t);
  try {
    a(t, n, r, i);
  } catch (s) {
    i(s);
  }
};
Qo.prototype.handle_request = function (t, n, r) {
  var i = this.handle;
  if (i.length > 3) return r();
  try {
    i(t, n, r);
  } catch (a) {
    r(a);
  }
};
Qo.prototype.match = function (t) {
  var n;
  if (t != null) {
    if (this.regexp.fast_slash) return (this.params = {}), (this.path = ""), !0;
    if (this.regexp.fast_star)
      return (this.params = { 0: R_(t) }), (this.path = t), !0;
    n = this.regexp.exec(t);
  }
  if (!n) return (this.params = void 0), (this.path = void 0), !1;
  (this.params = {}), (this.path = n[0]);
  for (var r = this.keys, i = this.params, a = 1; a < n.length; a++) {
    var s = r[a - 1],
      o = s.name,
      c = R_(n[a]);
    (c !== void 0 || !Q8.call(i, o)) && (i[o] = c);
  }
  return !0;
};
function R_(e) {
  if (typeof e != "string" || e.length === 0) return e;
  try {
    return decodeURIComponent(e);
  } catch (t) {
    throw (
      (t instanceof URIError &&
        ((t.message = "Failed to decode param '" + e + "'"),
        (t.status = t.statusCode = 400)),
      t)
    );
  }
}
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var k_ = Ws,
  hv = W8() || z8();
function W8() {
  return (
    k_.METHODS &&
    k_.METHODS.map(function (t) {
      return t.toLowerCase();
    })
  );
}
function z8() {
  return [
    "get",
    "post",
    "put",
    "head",
    "delete",
    "options",
    "trace",
    "copy",
    "lock",
    "mkcol",
    "move",
    "purge",
    "propfind",
    "proppatch",
    "unlock",
    "report",
    "mkactivity",
    "checkout",
    "merge",
    "m-search",
    "notify",
    "subscribe",
    "unsubscribe",
    "patch",
    "search",
    "connect",
  ];
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var e$ = ma("express:router:route"),
  t$ = zd,
  n$ = ZI,
  K8 = hv,
  r$ = Array.prototype.slice,
  i$ = Object.prototype.toString,
  a$ = bc;
function bc(e) {
  (this.path = e), (this.stack = []), e$("new %o", e), (this.methods = {});
}
bc.prototype._handles_method = function (t) {
  if (this.methods._all) return !0;
  var n = t.toLowerCase();
  return n === "head" && !this.methods.head && (n = "get"), !!this.methods[n];
};
bc.prototype._options = function () {
  var t = Object.keys(this.methods);
  this.methods.get && !this.methods.head && t.push("head");
  for (var n = 0; n < t.length; n++) t[n] = t[n].toUpperCase();
  return t;
};
bc.prototype.dispatch = function (t, n, r) {
  var i = 0,
    a = this.stack,
    s = 0;
  if (a.length === 0) return r();
  var o = t.method.toLowerCase();
  o === "head" && !this.methods.head && (o = "get"), (t.route = this), c();
  function c(l) {
    if (l && l === "route") return r();
    if (l && l === "router") return r(l);
    if (++s > 100) return setImmediate(c, l);
    var f = a[i++];
    if (!f) return r(l);
    f.method && f.method !== o
      ? c(l)
      : l
      ? f.handle_error(l, t, n, c)
      : f.handle_request(t, n, c),
      (s = 0);
  }
};
bc.prototype.all = function () {
  for (var t = t$(r$.call(arguments)), n = 0; n < t.length; n++) {
    var r = t[n];
    if (typeof r != "function") {
      var i = i$.call(r),
        a = "Route.all() requires a callback function but got a " + i;
      throw new TypeError(a);
    }
    var s = n$("/", {}, r);
    (s.method = void 0), (this.methods._all = !0), this.stack.push(s);
  }
  return this;
};
K8.forEach(function (e) {
  bc.prototype[e] = function () {
    for (var t = t$(r$.call(arguments)), n = 0; n < t.length; n++) {
      var r = t[n];
      if (typeof r != "function") {
        var i = i$.call(r),
          a = "Route." + e + "() requires a callback function but got a " + i;
        throw new Error(a);
      }
      e$("%s %o", e, this.path);
      var s = n$("/", {}, r);
      (s.method = e), (this.methods[e] = !0), this.stack.push(s);
    }
    return this;
  };
});
var s$ = { exports: {} };
(function (e, t) {
  e.exports = function (n, r) {
    if (n && r) for (var i in r) n[i] = r[i];
    return n;
  };
})(s$);
var Kd = s$.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var V8 = a$,
  o$ = ZI,
  Y8 = hv,
  Ph = Kd,
  Lf = ma("express:router"),
  T_ = wi("express"),
  X8 = zd,
  J8 = Yl,
  Z8 = Md,
  e6 = /^\[object (\S+)\]$/,
  c$ = Array.prototype.slice,
  t6 = Object.prototype.toString,
  Ks = (VI.exports = function (e) {
    var t = e || {};
    function n(r, i, a) {
      n.handle(r, i, a);
    }
    return (
      Z8(n, Ks),
      (n.params = {}),
      (n._params = []),
      (n.caseSensitive = t.caseSensitive),
      (n.mergeParams = t.mergeParams),
      (n.strict = t.strict),
      (n.stack = []),
      n
    );
  });
Ks.param = function (t, n) {
  if (typeof t == "function") {
    T_("router.param(fn): Refactor to use path params"), this._params.push(t);
    return;
  }
  var r = this._params,
    i = r.length,
    a;
  t[0] === ":" &&
    (T_(
      "router.param(" +
        JSON.stringify(t) +
        ", fn): Use router.param(" +
        JSON.stringify(t.slice(1)) +
        ", fn) instead",
    ),
    (t = t.slice(1)));
  for (var s = 0; s < i; ++s) (a = r[s](t, n)) && (n = a);
  if (typeof n != "function")
    throw new Error("invalid param() call for " + t + ", got " + n);
  return (this.params[t] = this.params[t] || []).push(n), this;
};
Ks.handle = function (t, n, r) {
  var i = this;
  Lf("dispatching %s %s", t.method, t.url);
  var a = 0,
    s = i6(t.url) || "",
    o = "",
    c = !1,
    l = 0,
    f = {},
    u = [],
    d = i.stack,
    p = t.params,
    h = t.baseUrl || "",
    m = c6(r, t, "baseUrl", "next", "params");
  (t.next = g),
    t.method === "OPTIONS" &&
      (m = u6(m, function (y, _) {
        if (_ || u.length === 0) return y(_);
        l6(n, u, y);
      })),
    (t.baseUrl = h),
    (t.originalUrl = t.originalUrl || t.url),
    g();
  function g(y) {
    var _ = y === "route" ? null : y;
    if (
      (c && ((t.url = t.url.slice(1)), (c = !1)),
      o.length !== 0 &&
        ((t.baseUrl = h), (t.url = s + o + t.url.slice(s.length)), (o = "")),
      _ === "router")
    ) {
      setImmediate(m, null);
      return;
    }
    if (a >= d.length) {
      setImmediate(m, _);
      return;
    }
    if (++l > 100) return setImmediate(g, y);
    var E = r6(t);
    if (E == null) return m(_);
    for (var R, A, I; A !== !0 && a < d.length; )
      if (
        ((R = d[a++]),
        (A = s6(R, E)),
        (I = R.route),
        typeof A != "boolean" && (_ = _ || A),
        A === !0 && I)
      ) {
        if (_) {
          A = !1;
          continue;
        }
        var S = t.method,
          w = I._handles_method(S);
        !w && S === "OPTIONS" && n6(u, I._options()),
          !w && S !== "HEAD" && (A = !1);
      }
    if (A !== !0) return m(_);
    I && (t.route = I), (t.params = i.mergeParams ? o6(R.params, p) : R.params);
    var O = R.path;
    i.process_params(R, f, t, n, function (Q) {
      Q ? g(_ || Q) : I ? R.handle_request(t, n, g) : v(R, _, O, E), (l = 0);
    });
  }
  function v(y, _, E, R) {
    if (E.length !== 0) {
      if (E !== R.slice(0, E.length)) {
        g(_);
        return;
      }
      var A = R[E.length];
      if (A && A !== "/" && A !== ".") return g(_);
      Lf("trim prefix (%s) from url %s", E, t.url),
        (o = E),
        (t.url = s + t.url.slice(s.length + o.length)),
        !s && t.url[0] !== "/" && ((t.url = "/" + t.url), (c = !0)),
        (t.baseUrl =
          h + (o[o.length - 1] === "/" ? o.substring(0, o.length - 1) : o));
    }
    Lf("%s %s : %s", y.name, E, t.originalUrl),
      _ ? y.handle_error(_, t, n, g) : y.handle_request(t, n, g);
  }
};
Ks.process_params = function (t, n, r, i, a) {
  var s = this.params,
    o = t.keys;
  if (!o || o.length === 0) return a();
  var c = 0,
    l,
    f = 0,
    u,
    d,
    p,
    h;
  function m(v) {
    if (v) return a(v);
    if (c >= o.length) return a();
    if (
      ((f = 0),
      (u = o[c++]),
      (l = u.name),
      (d = r.params[l]),
      (p = s[l]),
      (h = n[l]),
      d === void 0 || !p)
    )
      return m();
    if (h && (h.match === d || (h.error && h.error !== "route")))
      return (r.params[l] = h.value), m(h.error);
    (n[l] = h = { error: null, match: d, value: d }), g();
  }
  function g(v) {
    var y = p[f++];
    if (((h.value = r.params[u.name]), v)) {
      (h.error = v), m(v);
      return;
    }
    if (!y) return m();
    try {
      y(r, i, g, d, u.name);
    } catch (_) {
      g(_);
    }
  }
  m();
};
Ks.use = function (t) {
  var n = 0,
    r = "/";
  if (typeof t != "function") {
    for (var i = t; Array.isArray(i) && i.length !== 0; ) i = i[0];
    typeof i != "function" && ((n = 1), (r = t));
  }
  var a = X8(c$.call(arguments, n));
  if (a.length === 0)
    throw new TypeError("Router.use() requires a middleware function");
  for (var s = 0; s < a.length; s++) {
    var t = a[s];
    if (typeof t != "function")
      throw new TypeError(
        "Router.use() requires a middleware function but got a " + a6(t),
      );
    Lf("use %o %s", r, t.name || "<anonymous>");
    var o = new o$(
      r,
      { sensitive: this.caseSensitive, strict: !1, end: !1 },
      t,
    );
    (o.route = void 0), this.stack.push(o);
  }
  return this;
};
Ks.route = function (t) {
  var n = new V8(t),
    r = new o$(
      t,
      { sensitive: this.caseSensitive, strict: this.strict, end: !0 },
      n.dispatch.bind(n),
    );
  return (r.route = n), this.stack.push(r), n;
};
Y8.concat("all").forEach(function (e) {
  Ks[e] = function (t) {
    var n = this.route(t);
    return n[e].apply(n, c$.call(arguments, 1)), this;
  };
});
function n6(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    e.indexOf(r) === -1 && e.push(r);
  }
}
function r6(e) {
  try {
    return J8(e).pathname;
  } catch {
    return;
  }
}
function i6(e) {
  if (!(typeof e != "string" || e.length === 0 || e[0] === "/")) {
    var t = e.indexOf("?"),
      n = t !== -1 ? t : e.length,
      r = e.slice(0, n).indexOf("://");
    return r !== -1 ? e.substring(0, e.indexOf("/", 3 + r)) : void 0;
  }
}
function a6(e) {
  var t = typeof e;
  return t !== "object" ? t : t6.call(e).replace(e6, "$1");
}
function s6(e, t) {
  try {
    return e.match(t);
  } catch (n) {
    return n;
  }
}
function o6(e, t) {
  if (typeof t != "object" || !t) return e;
  var n = Ph({}, t);
  if (!(0 in e) || !(0 in t)) return Ph(n, e);
  for (var r = 0, i = 0; r in e; ) r++;
  for (; i in t; ) i++;
  for (r--; r >= 0; r--) (e[r + i] = e[r]), r < i && delete e[r];
  return Ph(n, e);
}
function c6(e, t) {
  for (
    var n = new Array(arguments.length - 2),
      r = new Array(arguments.length - 2),
      i = 0;
    i < n.length;
    i++
  )
    (n[i] = arguments[i + 2]), (r[i] = t[n[i]]);
  return function () {
    for (var a = 0; a < n.length; a++) t[n[a]] = r[a];
    return e.apply(this, arguments);
  };
}
function l6(e, t, n) {
  try {
    var r = t.join(",");
    e.set("Allow", r), e.send(r);
  } catch (i) {
    n(i);
  }
}
function u6(e, t) {
  return function () {
    var r = new Array(arguments.length + 1);
    r[0] = e;
    for (var i = 0, a = arguments.length; i < a; i++) r[i + 1] = arguments[i];
    t.apply(this, r);
  };
}
var l$ = VI.exports,
  u$ = {};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var N_ = Md;
u$.init = function (e) {
  return function (n, r, i) {
    e.enabled("x-powered-by") && r.setHeader("X-Powered-By", "Express"),
      (n.res = r),
      (r.req = n),
      (n.next = i),
      N_(n, e.request),
      N_(r, e.response),
      (r.locals = r.locals || Object.create(null)),
      i();
  };
};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var f6 = Kd,
  d6 = Yl,
  p6 = dv,
  f$ = function (t) {
    var n = f6({}, t),
      r = p6.parse;
    return (
      typeof t == "function" && ((r = t), (n = void 0)),
      n !== void 0 && n.allowPrototypes === void 0 && (n.allowPrototypes = !0),
      function (a, s, o) {
        if (!a.query) {
          var c = d6(a).query;
          a.query = r(c, n);
        }
        o();
      }
    );
  };
function d$(e) {
  throw new Error(
    'Could not dynamically require "' +
      e +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.',
  );
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Vd = ma("express:view"),
  Xl = pt,
  h6 = Xt,
  m6 = Xl.dirname,
  p$ = Xl.basename,
  g6 = Xl.extname,
  O_ = Xl.join,
  v6 = Xl.resolve,
  y6 = Yd;
function Yd(e, t) {
  var n = t || {};
  if (
    ((this.defaultEngine = n.defaultEngine),
    (this.ext = g6(e)),
    (this.name = e),
    (this.root = n.root),
    !this.ext && !this.defaultEngine)
  )
    throw new Error(
      "No default engine was specified and no extension was provided.",
    );
  var r = e;
  if (
    (this.ext ||
      ((this.ext =
        this.defaultEngine[0] !== "."
          ? "." + this.defaultEngine
          : this.defaultEngine),
      (r += this.ext)),
    !n.engines[this.ext])
  ) {
    var i = this.ext.slice(1);
    Vd('require "%s"', i);
    var a = d$(i).__express;
    if (typeof a != "function")
      throw new Error('Module "' + i + '" does not provide a view engine.');
    n.engines[this.ext] = a;
  }
  (this.engine = n.engines[this.ext]), (this.path = this.lookup(r));
}
Yd.prototype.lookup = function (t) {
  var n,
    r = [].concat(this.root);
  Vd('lookup "%s"', t);
  for (var i = 0; i < r.length && !n; i++) {
    var a = r[i],
      s = v6(a, t),
      o = m6(s),
      c = p$(s);
    n = this.resolve(o, c);
  }
  return n;
};
Yd.prototype.render = function (t, n) {
  Vd('render "%s"', this.path), this.engine(this.path, t, n);
};
Yd.prototype.resolve = function (t, n) {
  var r = this.ext,
    i = O_(t, n),
    a = P_(i);
  if (
    (a && a.isFile()) ||
    ((i = O_(t, p$(n, r), "index" + r)), (a = P_(i)), a && a.isFile())
  )
    return i;
};
function P_(e) {
  Vd('stat "%s"', e);
  try {
    return h6.statSync(e);
  } catch {
    return;
  }
}
var Ha = {},
  Yg = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ (function (
  e,
  t,
) {
  var n = ks,
    r = n.Buffer;
  function i(s, o) {
    for (var c in s) o[c] = s[c];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow
    ? (e.exports = n)
    : (i(n, t), (t.Buffer = a));
  function a(s, o, c) {
    return r(s, o, c);
  }
  (a.prototype = Object.create(r.prototype)),
    i(r, a),
    (a.from = function (s, o, c) {
      if (typeof s == "number")
        throw new TypeError("Argument must not be a number");
      return r(s, o, c);
    }),
    (a.alloc = function (s, o, c) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      var l = r(s);
      return (
        o !== void 0
          ? typeof c == "string"
            ? l.fill(o, c)
            : l.fill(o)
          : l.fill(0),
        l
      );
    }),
    (a.allocUnsafe = function (s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return r(s);
    }),
    (a.allocUnsafeSlow = function (s) {
      if (typeof s != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(s);
    });
})(Yg, Yg.exports);
var mv = Yg.exports,
  gv = { exports: {} };
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ gv.exports = R6;
gv.exports.parse = O6;
var D_ = pt.basename,
  b6 = mv.Buffer,
  _6 = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g,
  E6 = /%[0-9A-Fa-f]{2}/,
  w6 = /%([0-9A-Fa-f]{2})/g,
  h$ = /[^\x20-\x7e\xa0-\xff]/g,
  x6 = /\\([\u0000-\u007f])/g,
  A6 = /([\\"])/g,
  L_ =
    /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g,
  S6 = /^[\x20-\x7e\x80-\xff]+$/,
  I6 = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/,
  $6 =
    /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/,
  C6 = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
function R6(e, t) {
  var n = t || {},
    r = n.type || "attachment",
    i = k6(e, n.fallback);
  return T6(new g$(r, i));
}
function k6(e, t) {
  if (e !== void 0) {
    var n = {};
    if (typeof e != "string") throw new TypeError("filename must be a string");
    if (
      (t === void 0 && (t = !0), typeof t != "string" && typeof t != "boolean")
    )
      throw new TypeError("fallback must be a string or boolean");
    if (typeof t == "string" && h$.test(t))
      throw new TypeError("fallback must be ISO-8859-1 string");
    var r = D_(e),
      i = S6.test(r),
      a = typeof t != "string" ? t && m$(r) : D_(t),
      s = typeof a == "string" && a !== r;
    return (
      (s || !i || E6.test(r)) && (n["filename*"] = r),
      (i || s) && (n.filename = s ? a : r),
      n
    );
  }
}
function T6(e) {
  var t = e.parameters,
    n = e.type;
  if (!n || typeof n != "string" || !I6.test(n))
    throw new TypeError("invalid type");
  var r = String(n).toLowerCase();
  if (t && typeof t == "object")
    for (var i, a = Object.keys(t).sort(), s = 0; s < a.length; s++) {
      i = a[s];
      var o = i.substr(-1) === "*" ? B6(t[i]) : L6(t[i]);
      r += "; " + i + "=" + o;
    }
  return r;
}
function N6(e) {
  var t = $6.exec(e);
  if (!t) throw new TypeError("invalid extended field value");
  var n = t[1].toLowerCase(),
    r = t[2],
    i,
    a = r.replace(w6, P6);
  switch (n) {
    case "iso-8859-1":
      i = m$(a);
      break;
    case "utf-8":
      i = b6.from(a, "binary").toString("utf8");
      break;
    default:
      throw new TypeError("unsupported charset in extended field");
  }
  return i;
}
function m$(e) {
  return String(e).replace(h$, "?");
}
function O6(e) {
  if (!e || typeof e != "string")
    throw new TypeError("argument string is required");
  var t = C6.exec(e);
  if (!t) throw new TypeError("invalid type format");
  var n = t[0].length,
    r = t[1].toLowerCase(),
    i,
    a = [],
    s = {},
    o;
  for (
    n = L_.lastIndex = t[0].substr(-1) === ";" ? n - 1 : n;
    (t = L_.exec(e));

  ) {
    if (t.index !== n) throw new TypeError("invalid parameter format");
    if (
      ((n += t[0].length),
      (i = t[1].toLowerCase()),
      (o = t[2]),
      a.indexOf(i) !== -1)
    )
      throw new TypeError("invalid duplicate parameter");
    if ((a.push(i), i.indexOf("*") + 1 === i.length)) {
      (i = i.slice(0, -1)), (o = N6(o)), (s[i] = o);
      continue;
    }
    typeof s[i] != "string" &&
      (o[0] === '"' && (o = o.substr(1, o.length - 2).replace(x6, "$1")),
      (s[i] = o));
  }
  if (n !== -1 && n !== e.length)
    throw new TypeError("invalid parameter format");
  return new g$(r, s);
}
function P6(e, t) {
  return String.fromCharCode(parseInt(t, 16));
}
function D6(e) {
  return "%" + String(e).charCodeAt(0).toString(16).toUpperCase();
}
function L6(e) {
  var t = String(e);
  return '"' + t.replace(A6, "\\$1") + '"';
}
function B6(e) {
  var t = String(e),
    n = encodeURIComponent(t).replace(_6, D6);
  return "UTF-8''" + n;
}
function g$(e, t) {
  (this.type = e), (this.parameters = t);
}
var v$ = gv.exports,
  vv = { exports: {} },
  Xg = { exports: {} },
  Qu = { exports: {} },
  Wu = { exports: {} },
  Dh,
  B_;
function U6() {
  if (B_) return Dh;
  B_ = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    i = r * 365.25;
  Dh = function (l, f) {
    f = f || {};
    var u = typeof l;
    if (u === "string" && l.length > 0) return a(l);
    if (u === "number" && isNaN(l) === !1) return f.long ? o(l) : s(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(l),
    );
  };
  function a(l) {
    if (((l = String(l)), !(l.length > 100))) {
      var f =
        /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
          l,
        );
      if (f) {
        var u = parseFloat(f[1]),
          d = (f[2] || "ms").toLowerCase();
        switch (d) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * i;
          case "days":
          case "day":
          case "d":
            return u * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function s(l) {
    return l >= r
      ? Math.round(l / r) + "d"
      : l >= n
      ? Math.round(l / n) + "h"
      : l >= t
      ? Math.round(l / t) + "m"
      : l >= e
      ? Math.round(l / e) + "s"
      : l + "ms";
  }
  function o(l) {
    return (
      c(l, r, "day") ||
      c(l, n, "hour") ||
      c(l, t, "minute") ||
      c(l, e, "second") ||
      l + " ms"
    );
  }
  function c(l, f, u) {
    if (!(l < f))
      return l < f * 1.5
        ? Math.floor(l / f) + " " + u
        : Math.ceil(l / f) + " " + u + "s";
  }
  return Dh;
}
var U_;
function y$() {
  return (
    U_ ||
      ((U_ = 1),
      (function (e, t) {
        (t = e.exports = i.debug = i.default = i),
          (t.coerce = c),
          (t.disable = s),
          (t.enable = a),
          (t.enabled = o),
          (t.humanize = U6()),
          (t.names = []),
          (t.skips = []),
          (t.formatters = {});
        var n;
        function r(l) {
          var f = 0,
            u;
          for (u in l) (f = (f << 5) - f + l.charCodeAt(u)), (f |= 0);
          return t.colors[Math.abs(f) % t.colors.length];
        }
        function i(l) {
          function f() {
            if (f.enabled) {
              var u = f,
                d = +new Date(),
                p = d - (n || d);
              (u.diff = p), (u.prev = n), (u.curr = d), (n = d);
              for (
                var h = new Array(arguments.length), m = 0;
                m < h.length;
                m++
              )
                h[m] = arguments[m];
              (h[0] = t.coerce(h[0])),
                typeof h[0] != "string" && h.unshift("%O");
              var g = 0;
              (h[0] = h[0].replace(/%([a-zA-Z%])/g, function (y, _) {
                if (y === "%%") return y;
                g++;
                var E = t.formatters[_];
                if (typeof E == "function") {
                  var R = h[g];
                  (y = E.call(u, R)), h.splice(g, 1), g--;
                }
                return y;
              })),
                t.formatArgs.call(u, h);
              var v = f.log || t.log || console.log.bind(console);
              v.apply(u, h);
            }
          }
          return (
            (f.namespace = l),
            (f.enabled = t.enabled(l)),
            (f.useColors = t.useColors()),
            (f.color = r(l)),
            typeof t.init == "function" && t.init(f),
            f
          );
        }
        function a(l) {
          t.save(l), (t.names = []), (t.skips = []);
          for (
            var f = (typeof l == "string" ? l : "").split(/[\s,]+/),
              u = f.length,
              d = 0;
            d < u;
            d++
          )
            f[d] &&
              ((l = f[d].replace(/\*/g, ".*?")),
              l[0] === "-"
                ? t.skips.push(new RegExp("^" + l.substr(1) + "$"))
                : t.names.push(new RegExp("^" + l + "$")));
        }
        function s() {
          t.enable("");
        }
        function o(l) {
          var f, u;
          for (f = 0, u = t.skips.length; f < u; f++)
            if (t.skips[f].test(l)) return !1;
          for (f = 0, u = t.names.length; f < u; f++)
            if (t.names[f].test(l)) return !0;
          return !1;
        }
        function c(l) {
          return l instanceof Error ? l.stack || l.message : l;
        }
      })(Wu, Wu.exports)),
    Wu.exports
  );
}
var F_;
function F6() {
  return (
    F_ ||
      ((F_ = 1),
      (function (e, t) {
        (t = e.exports = y$()),
          (t.log = i),
          (t.formatArgs = r),
          (t.save = a),
          (t.load = s),
          (t.useColors = n),
          (t.storage =
            typeof chrome < "u" && typeof chrome.storage < "u"
              ? chrome.storage.local
              : o()),
          (t.colors = [
            "lightseagreen",
            "forestgreen",
            "goldenrod",
            "dodgerblue",
            "darkorchid",
            "crimson",
          ]);
        function n() {
          return typeof window < "u" &&
            window.process &&
            window.process.type === "renderer"
            ? !0
            : (typeof document < "u" &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
                (typeof window < "u" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/applewebkit\/(\d+)/));
        }
        t.formatters.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
        function r(c) {
          var l = this.useColors;
          if (
            ((c[0] =
              (l ? "%c" : "") +
              this.namespace +
              (l ? " %c" : " ") +
              c[0] +
              (l ? "%c " : " ") +
              "+" +
              t.humanize(this.diff)),
            !!l)
          ) {
            var f = "color: " + this.color;
            c.splice(1, 0, f, "color: inherit");
            var u = 0,
              d = 0;
            c[0].replace(/%[a-zA-Z%]/g, function (p) {
              p !== "%%" && (u++, p === "%c" && (d = u));
            }),
              c.splice(d, 0, f);
          }
        }
        function i() {
          return (
            typeof console == "object" &&
            console.log &&
            Function.prototype.apply.call(console.log, console, arguments)
          );
        }
        function a(c) {
          try {
            c == null ? t.storage.removeItem("debug") : (t.storage.debug = c);
          } catch {}
        }
        function s() {
          var c;
          try {
            c = t.storage.debug;
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        t.enable(s());
        function o() {
          try {
            return window.localStorage;
          } catch {}
        }
      })(Qu, Qu.exports)),
    Qu.exports
  );
}
var zu = { exports: {} },
  j_;
function j6() {
  return (
    j_ ||
      ((j_ = 1),
      (function (e, t) {
        var n = hc,
          r = wr;
        (t = e.exports = y$()),
          (t.init = d),
          (t.log = c),
          (t.formatArgs = o),
          (t.save = l),
          (t.load = f),
          (t.useColors = s),
          (t.colors = [6, 2, 3, 4, 5, 1]),
          (t.inspectOpts = Object.keys(process.env)
            .filter(function (p) {
              return /^debug_/i.test(p);
            })
            .reduce(function (p, h) {
              var m = h
                  .substring(6)
                  .toLowerCase()
                  .replace(/_([a-z])/g, function (v, y) {
                    return y.toUpperCase();
                  }),
                g = process.env[h];
              return (
                /^(yes|on|true|enabled)$/i.test(g)
                  ? (g = !0)
                  : /^(no|off|false|disabled)$/i.test(g)
                  ? (g = !1)
                  : g === "null"
                  ? (g = null)
                  : (g = Number(g)),
                (p[m] = g),
                p
              );
            }, {}));
        var i = parseInt(process.env.DEBUG_FD, 10) || 2;
        i !== 1 &&
          i !== 2 &&
          r.deprecate(
            function () {},
            "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)",
          )();
        var a = i === 1 ? process.stdout : i === 2 ? process.stderr : u(i);
        function s() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(i);
        }
        (t.formatters.o = function (p) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(p, this.inspectOpts)
              .split(
                `
`,
              )
              .map(function (h) {
                return h.trim();
              })
              .join(" ")
          );
        }),
          (t.formatters.O = function (p) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(p, this.inspectOpts)
            );
          });
        function o(p) {
          var h = this.namespace,
            m = this.useColors;
          if (m) {
            var g = this.color,
              v = "  \x1B[3" + g + ";1m" + h + " \x1B[0m";
            (p[0] =
              v +
              p[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + v,
                )),
              p.push("\x1B[3" + g + "m+" + t.humanize(this.diff) + "\x1B[0m");
          } else p[0] = new Date().toUTCString() + " " + h + " " + p[0];
        }
        function c() {
          return a.write(
            r.format.apply(r, arguments) +
              `
`,
          );
        }
        function l(p) {
          p == null ? delete process.env.DEBUG : (process.env.DEBUG = p);
        }
        function f() {
          return process.env.DEBUG;
        }
        function u(p) {
          var h,
            m = process.binding("tty_wrap");
          switch (m.guessHandleType(p)) {
            case "TTY":
              (h = new n.WriteStream(p)),
                (h._type = "tty"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            case "FILE":
              var g = Xt;
              (h = new g.SyncWriteStream(p, { autoClose: !1 })),
                (h._type = "fs");
              break;
            case "PIPE":
            case "TCP":
              var v = ha;
              (h = new v.Socket({ fd: p, readable: !1, writable: !0 })),
                (h.readable = !1),
                (h.read = null),
                (h._type = "pipe"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            default:
              throw new Error("Implement me. Unknown stream file type!");
          }
          return (h.fd = p), (h._isStdio = !0), h;
        }
        function d(p) {
          p.inspectOpts = {};
          for (var h = Object.keys(t.inspectOpts), m = 0; m < h.length; m++)
            p.inspectOpts[h[m]] = t.inspectOpts[h[m]];
        }
        t.enable(f());
      })(zu, zu.exports)),
    zu.exports
  );
}
typeof process < "u" && process.type === "renderer"
  ? (Xg.exports = F6())
  : (Xg.exports = j6());
var M6 = Xg.exports;
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var b$ = G6,
  H6 = pr,
  M_ = Xt.Stats,
  H_ = Object.prototype.toString;
function q6(e) {
  if (e.length === 0) return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
  var t = H6.createHash("sha1")
      .update(e, "utf8")
      .digest("base64")
      .substring(0, 27),
    n = typeof e == "string" ? Buffer.byteLength(e, "utf8") : e.length;
  return '"' + n.toString(16) + "-" + t + '"';
}
function G6(e, t) {
  if (e == null) throw new TypeError("argument entity is required");
  var n = Q6(e),
    r = t && typeof t.weak == "boolean" ? t.weak : n;
  if (!n && typeof e != "string" && !Buffer.isBuffer(e))
    throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
  var i = n ? W6(e) : q6(e);
  return r ? "W/" + i : i;
}
function Q6(e) {
  return typeof M_ == "function" && e instanceof M_
    ? !0
    : e &&
        typeof e == "object" &&
        "ctime" in e &&
        H_.call(e.ctime) === "[object Date]" &&
        "mtime" in e &&
        H_.call(e.mtime) === "[object Date]" &&
        "ino" in e &&
        typeof e.ino == "number" &&
        "size" in e &&
        typeof e.size == "number";
}
function W6(e) {
  var t = e.mtime.getTime().toString(16),
    n = e.size.toString(16);
  return '"' + n + "-" + t + '"';
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var z6 = /(?:^|,)\s*?no-cache\s*?(?:,|$)/,
  _$ = K6;
function K6(e, t) {
  var n = e["if-modified-since"],
    r = e["if-none-match"];
  if (!n && !r) return !1;
  var i = e["cache-control"];
  if (i && z6.test(i)) return !1;
  if (r && r !== "*") {
    var a = t.etag;
    if (!a) return !1;
    for (var s = !0, o = V6(r), c = 0; c < o.length; c++) {
      var l = o[c];
      if (l === a || l === "W/" + a || "W/" + l === a) {
        s = !1;
        break;
      }
    }
    if (s) return !1;
  }
  if (n) {
    var f = t["last-modified"],
      u = !f || !(q_(f) <= q_(n));
    if (u) return !1;
  }
  return !0;
}
function q_(e) {
  var t = e && Date.parse(e);
  return typeof t == "number" ? t : NaN;
}
function V6(e) {
  for (var t = 0, n = [], r = 0, i = 0, a = e.length; i < a; i++)
    switch (e.charCodeAt(i)) {
      case 32:
        r === t && (r = t = i + 1);
        break;
      case 44:
        n.push(e.substring(r, t)), (r = t = i + 1);
        break;
      default:
        t = i + 1;
        break;
    }
  return n.push(e.substring(r, t)), n;
}
const Y6 = {
  "application/andrew-inset": ["ez"],
  "application/applixware": ["aw"],
  "application/atom+xml": ["atom"],
  "application/atomcat+xml": ["atomcat"],
  "application/atomsvc+xml": ["atomsvc"],
  "application/bdoc": ["bdoc"],
  "application/ccxml+xml": ["ccxml"],
  "application/cdmi-capability": ["cdmia"],
  "application/cdmi-container": ["cdmic"],
  "application/cdmi-domain": ["cdmid"],
  "application/cdmi-object": ["cdmio"],
  "application/cdmi-queue": ["cdmiq"],
  "application/cu-seeme": ["cu"],
  "application/dash+xml": ["mpd"],
  "application/davmount+xml": ["davmount"],
  "application/docbook+xml": ["dbk"],
  "application/dssc+der": ["dssc"],
  "application/dssc+xml": ["xdssc"],
  "application/ecmascript": ["ecma"],
  "application/emma+xml": ["emma"],
  "application/epub+zip": ["epub"],
  "application/exi": ["exi"],
  "application/font-tdpfr": ["pfr"],
  "application/font-woff": [],
  "application/font-woff2": [],
  "application/geo+json": ["geojson"],
  "application/gml+xml": ["gml"],
  "application/gpx+xml": ["gpx"],
  "application/gxf": ["gxf"],
  "application/gzip": ["gz"],
  "application/hyperstudio": ["stk"],
  "application/inkml+xml": ["ink", "inkml"],
  "application/ipfix": ["ipfix"],
  "application/java-archive": ["jar", "war", "ear"],
  "application/java-serialized-object": ["ser"],
  "application/java-vm": ["class"],
  "application/javascript": ["js", "mjs"],
  "application/json": ["json", "map"],
  "application/json5": ["json5"],
  "application/jsonml+json": ["jsonml"],
  "application/ld+json": ["jsonld"],
  "application/lost+xml": ["lostxml"],
  "application/mac-binhex40": ["hqx"],
  "application/mac-compactpro": ["cpt"],
  "application/mads+xml": ["mads"],
  "application/manifest+json": ["webmanifest"],
  "application/marc": ["mrc"],
  "application/marcxml+xml": ["mrcx"],
  "application/mathematica": ["ma", "nb", "mb"],
  "application/mathml+xml": ["mathml"],
  "application/mbox": ["mbox"],
  "application/mediaservercontrol+xml": ["mscml"],
  "application/metalink+xml": ["metalink"],
  "application/metalink4+xml": ["meta4"],
  "application/mets+xml": ["mets"],
  "application/mods+xml": ["mods"],
  "application/mp21": ["m21", "mp21"],
  "application/mp4": ["mp4s", "m4p"],
  "application/msword": ["doc", "dot"],
  "application/mxf": ["mxf"],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer",
  ],
  "application/oda": ["oda"],
  "application/oebps-package+xml": ["opf"],
  "application/ogg": ["ogx"],
  "application/omdoc+xml": ["omdoc"],
  "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"],
  "application/oxps": ["oxps"],
  "application/patch-ops-error+xml": ["xer"],
  "application/pdf": ["pdf"],
  "application/pgp-encrypted": ["pgp"],
  "application/pgp-signature": ["asc", "sig"],
  "application/pics-rules": ["prf"],
  "application/pkcs10": ["p10"],
  "application/pkcs7-mime": ["p7m", "p7c"],
  "application/pkcs7-signature": ["p7s"],
  "application/pkcs8": ["p8"],
  "application/pkix-attr-cert": ["ac"],
  "application/pkix-cert": ["cer"],
  "application/pkix-crl": ["crl"],
  "application/pkix-pkipath": ["pkipath"],
  "application/pkixcmp": ["pki"],
  "application/pls+xml": ["pls"],
  "application/postscript": ["ai", "eps", "ps"],
  "application/prs.cww": ["cww"],
  "application/pskc+xml": ["pskcxml"],
  "application/raml+yaml": ["raml"],
  "application/rdf+xml": ["rdf"],
  "application/reginfo+xml": ["rif"],
  "application/relax-ng-compact-syntax": ["rnc"],
  "application/resource-lists+xml": ["rl"],
  "application/resource-lists-diff+xml": ["rld"],
  "application/rls-services+xml": ["rs"],
  "application/rpki-ghostbusters": ["gbr"],
  "application/rpki-manifest": ["mft"],
  "application/rpki-roa": ["roa"],
  "application/rsd+xml": ["rsd"],
  "application/rss+xml": ["rss"],
  "application/rtf": ["rtf"],
  "application/sbml+xml": ["sbml"],
  "application/scvp-cv-request": ["scq"],
  "application/scvp-cv-response": ["scs"],
  "application/scvp-vp-request": ["spq"],
  "application/scvp-vp-response": ["spp"],
  "application/sdp": ["sdp"],
  "application/set-payment-initiation": ["setpay"],
  "application/set-registration-initiation": ["setreg"],
  "application/shf+xml": ["shf"],
  "application/smil+xml": ["smi", "smil"],
  "application/sparql-query": ["rq"],
  "application/sparql-results+xml": ["srx"],
  "application/srgs": ["gram"],
  "application/srgs+xml": ["grxml"],
  "application/sru+xml": ["sru"],
  "application/ssdl+xml": ["ssdl"],
  "application/ssml+xml": ["ssml"],
  "application/tei+xml": ["tei", "teicorpus"],
  "application/thraud+xml": ["tfi"],
  "application/timestamped-data": ["tsd"],
  "application/vnd.3gpp.pic-bw-large": ["plb"],
  "application/vnd.3gpp.pic-bw-small": ["psb"],
  "application/vnd.3gpp.pic-bw-var": ["pvb"],
  "application/vnd.3gpp2.tcap": ["tcap"],
  "application/vnd.3m.post-it-notes": ["pwn"],
  "application/vnd.accpac.simply.aso": ["aso"],
  "application/vnd.accpac.simply.imp": ["imp"],
  "application/vnd.acucobol": ["acu"],
  "application/vnd.acucorp": ["atc", "acutc"],
  "application/vnd.adobe.air-application-installer-package+zip": ["air"],
  "application/vnd.adobe.formscentral.fcdt": ["fcdt"],
  "application/vnd.adobe.fxp": ["fxp", "fxpl"],
  "application/vnd.adobe.xdp+xml": ["xdp"],
  "application/vnd.adobe.xfdf": ["xfdf"],
  "application/vnd.ahead.space": ["ahead"],
  "application/vnd.airzip.filesecure.azf": ["azf"],
  "application/vnd.airzip.filesecure.azs": ["azs"],
  "application/vnd.amazon.ebook": ["azw"],
  "application/vnd.americandynamics.acc": ["acc"],
  "application/vnd.amiga.ami": ["ami"],
  "application/vnd.android.package-archive": ["apk"],
  "application/vnd.anser-web-certificate-issue-initiation": ["cii"],
  "application/vnd.anser-web-funds-transfer-initiation": ["fti"],
  "application/vnd.antix.game-component": ["atx"],
  "application/vnd.apple.installer+xml": ["mpkg"],
  "application/vnd.apple.mpegurl": ["m3u8"],
  "application/vnd.apple.pkpass": ["pkpass"],
  "application/vnd.aristanetworks.swi": ["swi"],
  "application/vnd.astraea-software.iota": ["iota"],
  "application/vnd.audiograph": ["aep"],
  "application/vnd.blueice.multipass": ["mpm"],
  "application/vnd.bmi": ["bmi"],
  "application/vnd.businessobjects": ["rep"],
  "application/vnd.chemdraw+xml": ["cdxml"],
  "application/vnd.chipnuts.karaoke-mmd": ["mmd"],
  "application/vnd.cinderella": ["cdy"],
  "application/vnd.claymore": ["cla"],
  "application/vnd.cloanto.rp9": ["rp9"],
  "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"],
  "application/vnd.cluetrust.cartomobile-config": ["c11amc"],
  "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"],
  "application/vnd.commonspace": ["csp"],
  "application/vnd.contact.cmsg": ["cdbcmsg"],
  "application/vnd.cosmocaller": ["cmc"],
  "application/vnd.crick.clicker": ["clkx"],
  "application/vnd.crick.clicker.keyboard": ["clkk"],
  "application/vnd.crick.clicker.palette": ["clkp"],
  "application/vnd.crick.clicker.template": ["clkt"],
  "application/vnd.crick.clicker.wordbank": ["clkw"],
  "application/vnd.criticaltools.wbs+xml": ["wbs"],
  "application/vnd.ctc-posml": ["pml"],
  "application/vnd.cups-ppd": ["ppd"],
  "application/vnd.curl.car": ["car"],
  "application/vnd.curl.pcurl": ["pcurl"],
  "application/vnd.dart": ["dart"],
  "application/vnd.data-vision.rdz": ["rdz"],
  "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"],
  "application/vnd.dece.ttml+xml": ["uvt", "uvvt"],
  "application/vnd.dece.unspecified": ["uvx", "uvvx"],
  "application/vnd.dece.zip": ["uvz", "uvvz"],
  "application/vnd.denovo.fcselayout-link": ["fe_launch"],
  "application/vnd.dna": ["dna"],
  "application/vnd.dolby.mlp": ["mlp"],
  "application/vnd.dpgraph": ["dpg"],
  "application/vnd.dreamfactory": ["dfac"],
  "application/vnd.ds-keypoint": ["kpxx"],
  "application/vnd.dvb.ait": ["ait"],
  "application/vnd.dvb.service": ["svc"],
  "application/vnd.dynageo": ["geo"],
  "application/vnd.ecowin.chart": ["mag"],
  "application/vnd.enliven": ["nml"],
  "application/vnd.epson.esf": ["esf"],
  "application/vnd.epson.msf": ["msf"],
  "application/vnd.epson.quickanime": ["qam"],
  "application/vnd.epson.salt": ["slt"],
  "application/vnd.epson.ssf": ["ssf"],
  "application/vnd.eszigno3+xml": ["es3", "et3"],
  "application/vnd.ezpix-album": ["ez2"],
  "application/vnd.ezpix-package": ["ez3"],
  "application/vnd.fdf": ["fdf"],
  "application/vnd.fdsn.mseed": ["mseed"],
  "application/vnd.fdsn.seed": ["seed", "dataless"],
  "application/vnd.flographit": ["gph"],
  "application/vnd.fluxtime.clip": ["ftc"],
  "application/vnd.framemaker": ["fm", "frame", "maker", "book"],
  "application/vnd.frogans.fnc": ["fnc"],
  "application/vnd.frogans.ltf": ["ltf"],
  "application/vnd.fsc.weblaunch": ["fsc"],
  "application/vnd.fujitsu.oasys": ["oas"],
  "application/vnd.fujitsu.oasys2": ["oa2"],
  "application/vnd.fujitsu.oasys3": ["oa3"],
  "application/vnd.fujitsu.oasysgp": ["fg5"],
  "application/vnd.fujitsu.oasysprs": ["bh2"],
  "application/vnd.fujixerox.ddd": ["ddd"],
  "application/vnd.fujixerox.docuworks": ["xdw"],
  "application/vnd.fujixerox.docuworks.binder": ["xbd"],
  "application/vnd.fuzzysheet": ["fzs"],
  "application/vnd.genomatix.tuxedo": ["txd"],
  "application/vnd.geogebra.file": ["ggb"],
  "application/vnd.geogebra.tool": ["ggt"],
  "application/vnd.geometry-explorer": ["gex", "gre"],
  "application/vnd.geonext": ["gxt"],
  "application/vnd.geoplan": ["g2w"],
  "application/vnd.geospace": ["g3w"],
  "application/vnd.gmx": ["gmx"],
  "application/vnd.google-apps.document": ["gdoc"],
  "application/vnd.google-apps.presentation": ["gslides"],
  "application/vnd.google-apps.spreadsheet": ["gsheet"],
  "application/vnd.google-earth.kml+xml": ["kml"],
  "application/vnd.google-earth.kmz": ["kmz"],
  "application/vnd.grafeq": ["gqf", "gqs"],
  "application/vnd.groove-account": ["gac"],
  "application/vnd.groove-help": ["ghf"],
  "application/vnd.groove-identity-message": ["gim"],
  "application/vnd.groove-injector": ["grv"],
  "application/vnd.groove-tool-message": ["gtm"],
  "application/vnd.groove-tool-template": ["tpl"],
  "application/vnd.groove-vcard": ["vcg"],
  "application/vnd.hal+xml": ["hal"],
  "application/vnd.handheld-entertainment+xml": ["zmm"],
  "application/vnd.hbci": ["hbci"],
  "application/vnd.hhe.lesson-player": ["les"],
  "application/vnd.hp-hpgl": ["hpgl"],
  "application/vnd.hp-hpid": ["hpid"],
  "application/vnd.hp-hps": ["hps"],
  "application/vnd.hp-jlyt": ["jlt"],
  "application/vnd.hp-pcl": ["pcl"],
  "application/vnd.hp-pclxl": ["pclxl"],
  "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"],
  "application/vnd.ibm.minipay": ["mpy"],
  "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"],
  "application/vnd.ibm.rights-management": ["irm"],
  "application/vnd.ibm.secure-container": ["sc"],
  "application/vnd.iccprofile": ["icc", "icm"],
  "application/vnd.igloader": ["igl"],
  "application/vnd.immervision-ivp": ["ivp"],
  "application/vnd.immervision-ivu": ["ivu"],
  "application/vnd.insors.igm": ["igm"],
  "application/vnd.intercon.formnet": ["xpw", "xpx"],
  "application/vnd.intergeo": ["i2g"],
  "application/vnd.intu.qbo": ["qbo"],
  "application/vnd.intu.qfx": ["qfx"],
  "application/vnd.ipunplugged.rcprofile": ["rcprofile"],
  "application/vnd.irepository.package+xml": ["irp"],
  "application/vnd.is-xpr": ["xpr"],
  "application/vnd.isac.fcs": ["fcs"],
  "application/vnd.jam": ["jam"],
  "application/vnd.jcp.javame.midlet-rms": ["rms"],
  "application/vnd.jisp": ["jisp"],
  "application/vnd.joost.joda-archive": ["joda"],
  "application/vnd.kahootz": ["ktz", "ktr"],
  "application/vnd.kde.karbon": ["karbon"],
  "application/vnd.kde.kchart": ["chrt"],
  "application/vnd.kde.kformula": ["kfo"],
  "application/vnd.kde.kivio": ["flw"],
  "application/vnd.kde.kontour": ["kon"],
  "application/vnd.kde.kpresenter": ["kpr", "kpt"],
  "application/vnd.kde.kspread": ["ksp"],
  "application/vnd.kde.kword": ["kwd", "kwt"],
  "application/vnd.kenameaapp": ["htke"],
  "application/vnd.kidspiration": ["kia"],
  "application/vnd.kinar": ["kne", "knp"],
  "application/vnd.koan": ["skp", "skd", "skt", "skm"],
  "application/vnd.kodak-descriptor": ["sse"],
  "application/vnd.las.las+xml": ["lasxml"],
  "application/vnd.llamagraphics.life-balance.desktop": ["lbd"],
  "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"],
  "application/vnd.lotus-1-2-3": ["123"],
  "application/vnd.lotus-approach": ["apr"],
  "application/vnd.lotus-freelance": ["pre"],
  "application/vnd.lotus-notes": ["nsf"],
  "application/vnd.lotus-organizer": ["org"],
  "application/vnd.lotus-screencam": ["scm"],
  "application/vnd.lotus-wordpro": ["lwp"],
  "application/vnd.macports.portpkg": ["portpkg"],
  "application/vnd.mcd": ["mcd"],
  "application/vnd.medcalcdata": ["mc1"],
  "application/vnd.mediastation.cdkey": ["cdkey"],
  "application/vnd.mfer": ["mwf"],
  "application/vnd.mfmp": ["mfm"],
  "application/vnd.micrografx.flo": ["flo"],
  "application/vnd.micrografx.igx": ["igx"],
  "application/vnd.mif": ["mif"],
  "application/vnd.mobius.daf": ["daf"],
  "application/vnd.mobius.dis": ["dis"],
  "application/vnd.mobius.mbk": ["mbk"],
  "application/vnd.mobius.mqy": ["mqy"],
  "application/vnd.mobius.msl": ["msl"],
  "application/vnd.mobius.plc": ["plc"],
  "application/vnd.mobius.txf": ["txf"],
  "application/vnd.mophun.application": ["mpn"],
  "application/vnd.mophun.certificate": ["mpc"],
  "application/vnd.mozilla.xul+xml": ["xul"],
  "application/vnd.ms-artgalry": ["cil"],
  "application/vnd.ms-cab-compressed": ["cab"],
  "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
  "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"],
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"],
  "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"],
  "application/vnd.ms-excel.template.macroenabled.12": ["xltm"],
  "application/vnd.ms-fontobject": ["eot"],
  "application/vnd.ms-htmlhelp": ["chm"],
  "application/vnd.ms-ims": ["ims"],
  "application/vnd.ms-lrm": ["lrm"],
  "application/vnd.ms-officetheme": ["thmx"],
  "application/vnd.ms-outlook": ["msg"],
  "application/vnd.ms-pki.seccat": ["cat"],
  "application/vnd.ms-pki.stl": ["stl"],
  "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"],
  "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"],
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"],
  "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"],
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"],
  "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"],
  "application/vnd.ms-project": ["mpp", "mpt"],
  "application/vnd.ms-word.document.macroenabled.12": ["docm"],
  "application/vnd.ms-word.template.macroenabled.12": ["dotm"],
  "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"],
  "application/vnd.ms-wpl": ["wpl"],
  "application/vnd.ms-xpsdocument": ["xps"],
  "application/vnd.mseq": ["mseq"],
  "application/vnd.musician": ["mus"],
  "application/vnd.muvee.style": ["msty"],
  "application/vnd.mynfc": ["taglet"],
  "application/vnd.neurolanguage.nlu": ["nlu"],
  "application/vnd.nitf": ["ntf", "nitf"],
  "application/vnd.noblenet-directory": ["nnd"],
  "application/vnd.noblenet-sealer": ["nns"],
  "application/vnd.noblenet-web": ["nnw"],
  "application/vnd.nokia.n-gage.data": ["ngdat"],
  "application/vnd.nokia.n-gage.symbian.install": ["n-gage"],
  "application/vnd.nokia.radio-preset": ["rpst"],
  "application/vnd.nokia.radio-presets": ["rpss"],
  "application/vnd.novadigm.edm": ["edm"],
  "application/vnd.novadigm.edx": ["edx"],
  "application/vnd.novadigm.ext": ["ext"],
  "application/vnd.oasis.opendocument.chart": ["odc"],
  "application/vnd.oasis.opendocument.chart-template": ["otc"],
  "application/vnd.oasis.opendocument.database": ["odb"],
  "application/vnd.oasis.opendocument.formula": ["odf"],
  "application/vnd.oasis.opendocument.formula-template": ["odft"],
  "application/vnd.oasis.opendocument.graphics": ["odg"],
  "application/vnd.oasis.opendocument.graphics-template": ["otg"],
  "application/vnd.oasis.opendocument.image": ["odi"],
  "application/vnd.oasis.opendocument.image-template": ["oti"],
  "application/vnd.oasis.opendocument.presentation": ["odp"],
  "application/vnd.oasis.opendocument.presentation-template": ["otp"],
  "application/vnd.oasis.opendocument.spreadsheet": ["ods"],
  "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"],
  "application/vnd.oasis.opendocument.text": ["odt"],
  "application/vnd.oasis.opendocument.text-master": ["odm"],
  "application/vnd.oasis.opendocument.text-template": ["ott"],
  "application/vnd.oasis.opendocument.text-web": ["oth"],
  "application/vnd.olpc-sugar": ["xo"],
  "application/vnd.oma.dd2+xml": ["dd2"],
  "application/vnd.openofficeorg.extension": ["oxt"],
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": [
    "pptx",
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slide": [
    "sldx",
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
    "ppsx",
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.template": [
    "potx",
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
    "xltx",
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
    "docx",
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
    "dotx",
  ],
  "application/vnd.osgeo.mapguide.package": ["mgp"],
  "application/vnd.osgi.dp": ["dp"],
  "application/vnd.osgi.subsystem": ["esa"],
  "application/vnd.palm": ["pdb", "pqa", "oprc"],
  "application/vnd.pawaafile": ["paw"],
  "application/vnd.pg.format": ["str"],
  "application/vnd.pg.osasli": ["ei6"],
  "application/vnd.picsel": ["efif"],
  "application/vnd.pmi.widget": ["wg"],
  "application/vnd.pocketlearn": ["plf"],
  "application/vnd.powerbuilder6": ["pbd"],
  "application/vnd.previewsystems.box": ["box"],
  "application/vnd.proteus.magazine": ["mgz"],
  "application/vnd.publishare-delta-tree": ["qps"],
  "application/vnd.pvi.ptid1": ["ptid"],
  "application/vnd.quark.quarkxpress": [
    "qxd",
    "qxt",
    "qwd",
    "qwt",
    "qxl",
    "qxb",
  ],
  "application/vnd.realvnc.bed": ["bed"],
  "application/vnd.recordare.musicxml": ["mxl"],
  "application/vnd.recordare.musicxml+xml": ["musicxml"],
  "application/vnd.rig.cryptonote": ["cryptonote"],
  "application/vnd.rim.cod": ["cod"],
  "application/vnd.rn-realmedia": ["rm"],
  "application/vnd.rn-realmedia-vbr": ["rmvb"],
  "application/vnd.route66.link66+xml": ["link66"],
  "application/vnd.sailingtracker.track": ["st"],
  "application/vnd.seemail": ["see"],
  "application/vnd.sema": ["sema"],
  "application/vnd.semd": ["semd"],
  "application/vnd.semf": ["semf"],
  "application/vnd.shana.informed.formdata": ["ifm"],
  "application/vnd.shana.informed.formtemplate": ["itp"],
  "application/vnd.shana.informed.interchange": ["iif"],
  "application/vnd.shana.informed.package": ["ipk"],
  "application/vnd.simtech-mindmapper": ["twd", "twds"],
  "application/vnd.smaf": ["mmf"],
  "application/vnd.smart.teacher": ["teacher"],
  "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"],
  "application/vnd.spotfire.dxp": ["dxp"],
  "application/vnd.spotfire.sfs": ["sfs"],
  "application/vnd.stardivision.calc": ["sdc"],
  "application/vnd.stardivision.draw": ["sda"],
  "application/vnd.stardivision.impress": ["sdd"],
  "application/vnd.stardivision.math": ["smf"],
  "application/vnd.stardivision.writer": ["sdw", "vor"],
  "application/vnd.stardivision.writer-global": ["sgl"],
  "application/vnd.stepmania.package": ["smzip"],
  "application/vnd.stepmania.stepchart": ["sm"],
  "application/vnd.sun.wadl+xml": ["wadl"],
  "application/vnd.sun.xml.calc": ["sxc"],
  "application/vnd.sun.xml.calc.template": ["stc"],
  "application/vnd.sun.xml.draw": ["sxd"],
  "application/vnd.sun.xml.draw.template": ["std"],
  "application/vnd.sun.xml.impress": ["sxi"],
  "application/vnd.sun.xml.impress.template": ["sti"],
  "application/vnd.sun.xml.math": ["sxm"],
  "application/vnd.sun.xml.writer": ["sxw"],
  "application/vnd.sun.xml.writer.global": ["sxg"],
  "application/vnd.sun.xml.writer.template": ["stw"],
  "application/vnd.sus-calendar": ["sus", "susp"],
  "application/vnd.svd": ["svd"],
  "application/vnd.symbian.install": ["sis", "sisx"],
  "application/vnd.syncml+xml": ["xsm"],
  "application/vnd.syncml.dm+wbxml": ["bdm"],
  "application/vnd.syncml.dm+xml": ["xdm"],
  "application/vnd.tao.intent-module-archive": ["tao"],
  "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"],
  "application/vnd.tmobile-livetv": ["tmo"],
  "application/vnd.trid.tpt": ["tpt"],
  "application/vnd.triscape.mxs": ["mxs"],
  "application/vnd.trueapp": ["tra"],
  "application/vnd.ufdl": ["ufd", "ufdl"],
  "application/vnd.uiq.theme": ["utz"],
  "application/vnd.umajin": ["umj"],
  "application/vnd.unity": ["unityweb"],
  "application/vnd.uoml+xml": ["uoml"],
  "application/vnd.vcx": ["vcx"],
  "application/vnd.visio": ["vsd", "vst", "vss", "vsw"],
  "application/vnd.visionary": ["vis"],
  "application/vnd.vsf": ["vsf"],
  "application/vnd.wap.wbxml": ["wbxml"],
  "application/vnd.wap.wmlc": ["wmlc"],
  "application/vnd.wap.wmlscriptc": ["wmlsc"],
  "application/vnd.webturbo": ["wtb"],
  "application/vnd.wolfram.player": ["nbp"],
  "application/vnd.wordperfect": ["wpd"],
  "application/vnd.wqd": ["wqd"],
  "application/vnd.wt.stf": ["stf"],
  "application/vnd.xara": ["xar"],
  "application/vnd.xfdl": ["xfdl"],
  "application/vnd.yamaha.hv-dic": ["hvd"],
  "application/vnd.yamaha.hv-script": ["hvs"],
  "application/vnd.yamaha.hv-voice": ["hvp"],
  "application/vnd.yamaha.openscoreformat": ["osf"],
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"],
  "application/vnd.yamaha.smaf-audio": ["saf"],
  "application/vnd.yamaha.smaf-phrase": ["spf"],
  "application/vnd.yellowriver-custom-menu": ["cmp"],
  "application/vnd.zul": ["zir", "zirz"],
  "application/vnd.zzazz.deck+xml": ["zaz"],
  "application/voicexml+xml": ["vxml"],
  "application/wasm": ["wasm"],
  "application/widget": ["wgt"],
  "application/winhlp": ["hlp"],
  "application/wsdl+xml": ["wsdl"],
  "application/wspolicy+xml": ["wspolicy"],
  "application/x-7z-compressed": ["7z"],
  "application/x-abiword": ["abw"],
  "application/x-ace-compressed": ["ace"],
  "application/x-apple-diskimage": [],
  "application/x-arj": ["arj"],
  "application/x-authorware-bin": ["aab", "x32", "u32", "vox"],
  "application/x-authorware-map": ["aam"],
  "application/x-authorware-seg": ["aas"],
  "application/x-bcpio": ["bcpio"],
  "application/x-bdoc": [],
  "application/x-bittorrent": ["torrent"],
  "application/x-blorb": ["blb", "blorb"],
  "application/x-bzip": ["bz"],
  "application/x-bzip2": ["bz2", "boz"],
  "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"],
  "application/x-cdlink": ["vcd"],
  "application/x-cfs-compressed": ["cfs"],
  "application/x-chat": ["chat"],
  "application/x-chess-pgn": ["pgn"],
  "application/x-chrome-extension": ["crx"],
  "application/x-cocoa": ["cco"],
  "application/x-conference": ["nsc"],
  "application/x-cpio": ["cpio"],
  "application/x-csh": ["csh"],
  "application/x-debian-package": ["udeb"],
  "application/x-dgc-compressed": ["dgc"],
  "application/x-director": [
    "dir",
    "dcr",
    "dxr",
    "cst",
    "cct",
    "cxt",
    "w3d",
    "fgd",
    "swa",
  ],
  "application/x-doom": ["wad"],
  "application/x-dtbncx+xml": ["ncx"],
  "application/x-dtbook+xml": ["dtb"],
  "application/x-dtbresource+xml": ["res"],
  "application/x-dvi": ["dvi"],
  "application/x-envoy": ["evy"],
  "application/x-eva": ["eva"],
  "application/x-font-bdf": ["bdf"],
  "application/x-font-ghostscript": ["gsf"],
  "application/x-font-linux-psf": ["psf"],
  "application/x-font-pcf": ["pcf"],
  "application/x-font-snf": ["snf"],
  "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"],
  "application/x-freearc": ["arc"],
  "application/x-futuresplash": ["spl"],
  "application/x-gca-compressed": ["gca"],
  "application/x-glulx": ["ulx"],
  "application/x-gnumeric": ["gnumeric"],
  "application/x-gramps-xml": ["gramps"],
  "application/x-gtar": ["gtar"],
  "application/x-hdf": ["hdf"],
  "application/x-httpd-php": ["php"],
  "application/x-install-instructions": ["install"],
  "application/x-iso9660-image": [],
  "application/x-java-archive-diff": ["jardiff"],
  "application/x-java-jnlp-file": ["jnlp"],
  "application/x-latex": ["latex"],
  "application/x-lua-bytecode": ["luac"],
  "application/x-lzh-compressed": ["lzh", "lha"],
  "application/x-makeself": ["run"],
  "application/x-mie": ["mie"],
  "application/x-mobipocket-ebook": ["prc", "mobi"],
  "application/x-ms-application": ["application"],
  "application/x-ms-shortcut": ["lnk"],
  "application/x-ms-wmd": ["wmd"],
  "application/x-ms-wmz": ["wmz"],
  "application/x-ms-xbap": ["xbap"],
  "application/x-msaccess": ["mdb"],
  "application/x-msbinder": ["obd"],
  "application/x-mscardfile": ["crd"],
  "application/x-msclip": ["clp"],
  "application/x-msdos-program": [],
  "application/x-msdownload": ["com", "bat"],
  "application/x-msmediaview": ["mvb", "m13", "m14"],
  "application/x-msmetafile": ["wmf", "emf", "emz"],
  "application/x-msmoney": ["mny"],
  "application/x-mspublisher": ["pub"],
  "application/x-msschedule": ["scd"],
  "application/x-msterminal": ["trm"],
  "application/x-mswrite": ["wri"],
  "application/x-netcdf": ["nc", "cdf"],
  "application/x-ns-proxy-autoconfig": ["pac"],
  "application/x-nzb": ["nzb"],
  "application/x-perl": ["pl", "pm"],
  "application/x-pilot": [],
  "application/x-pkcs12": ["p12", "pfx"],
  "application/x-pkcs7-certificates": ["p7b", "spc"],
  "application/x-pkcs7-certreqresp": ["p7r"],
  "application/x-rar-compressed": ["rar"],
  "application/x-redhat-package-manager": ["rpm"],
  "application/x-research-info-systems": ["ris"],
  "application/x-sea": ["sea"],
  "application/x-sh": ["sh"],
  "application/x-shar": ["shar"],
  "application/x-shockwave-flash": ["swf"],
  "application/x-silverlight-app": ["xap"],
  "application/x-sql": ["sql"],
  "application/x-stuffit": ["sit"],
  "application/x-stuffitx": ["sitx"],
  "application/x-subrip": ["srt"],
  "application/x-sv4cpio": ["sv4cpio"],
  "application/x-sv4crc": ["sv4crc"],
  "application/x-t3vm-image": ["t3"],
  "application/x-tads": ["gam"],
  "application/x-tar": ["tar"],
  "application/x-tcl": ["tcl", "tk"],
  "application/x-tex": ["tex"],
  "application/x-tex-tfm": ["tfm"],
  "application/x-texinfo": ["texinfo", "texi"],
  "application/x-tgif": ["obj"],
  "application/x-ustar": ["ustar"],
  "application/x-virtualbox-hdd": ["hdd"],
  "application/x-virtualbox-ova": ["ova"],
  "application/x-virtualbox-ovf": ["ovf"],
  "application/x-virtualbox-vbox": ["vbox"],
  "application/x-virtualbox-vbox-extpack": ["vbox-extpack"],
  "application/x-virtualbox-vdi": ["vdi"],
  "application/x-virtualbox-vhd": ["vhd"],
  "application/x-virtualbox-vmdk": ["vmdk"],
  "application/x-wais-source": ["src"],
  "application/x-web-app-manifest+json": ["webapp"],
  "application/x-x509-ca-cert": ["der", "crt", "pem"],
  "application/x-xfig": ["fig"],
  "application/x-xliff+xml": ["xlf"],
  "application/x-xpinstall": ["xpi"],
  "application/x-xz": ["xz"],
  "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
  "application/xaml+xml": ["xaml"],
  "application/xcap-diff+xml": ["xdf"],
  "application/xenc+xml": ["xenc"],
  "application/xhtml+xml": ["xhtml", "xht"],
  "application/xml": ["xml", "xsl", "xsd", "rng"],
  "application/xml-dtd": ["dtd"],
  "application/xop+xml": ["xop"],
  "application/xproc+xml": ["xpl"],
  "application/xslt+xml": ["xslt"],
  "application/xspf+xml": ["xspf"],
  "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"],
  "application/yang": ["yang"],
  "application/yin+xml": ["yin"],
  "application/zip": ["zip"],
  "audio/3gpp": [],
  "audio/adpcm": ["adp"],
  "audio/basic": ["au", "snd"],
  "audio/midi": ["mid", "midi", "kar", "rmi"],
  "audio/mp3": [],
  "audio/mp4": ["m4a", "mp4a"],
  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  "audio/ogg": ["oga", "ogg", "spx"],
  "audio/s3m": ["s3m"],
  "audio/silk": ["sil"],
  "audio/vnd.dece.audio": ["uva", "uvva"],
  "audio/vnd.digital-winds": ["eol"],
  "audio/vnd.dra": ["dra"],
  "audio/vnd.dts": ["dts"],
  "audio/vnd.dts.hd": ["dtshd"],
  "audio/vnd.lucent.voice": ["lvp"],
  "audio/vnd.ms-playready.media.pya": ["pya"],
  "audio/vnd.nuera.ecelp4800": ["ecelp4800"],
  "audio/vnd.nuera.ecelp7470": ["ecelp7470"],
  "audio/vnd.nuera.ecelp9600": ["ecelp9600"],
  "audio/vnd.rip": ["rip"],
  "audio/wav": ["wav"],
  "audio/wave": [],
  "audio/webm": ["weba"],
  "audio/x-aac": ["aac"],
  "audio/x-aiff": ["aif", "aiff", "aifc"],
  "audio/x-caf": ["caf"],
  "audio/x-flac": ["flac"],
  "audio/x-m4a": [],
  "audio/x-matroska": ["mka"],
  "audio/x-mpegurl": ["m3u"],
  "audio/x-ms-wax": ["wax"],
  "audio/x-ms-wma": ["wma"],
  "audio/x-pn-realaudio": ["ram", "ra"],
  "audio/x-pn-realaudio-plugin": ["rmp"],
  "audio/x-realaudio": [],
  "audio/x-wav": [],
  "audio/xm": ["xm"],
  "chemical/x-cdx": ["cdx"],
  "chemical/x-cif": ["cif"],
  "chemical/x-cmdf": ["cmdf"],
  "chemical/x-cml": ["cml"],
  "chemical/x-csml": ["csml"],
  "chemical/x-xyz": ["xyz"],
  "font/collection": ["ttc"],
  "font/otf": ["otf"],
  "font/ttf": ["ttf"],
  "font/woff": ["woff"],
  "font/woff2": ["woff2"],
  "image/apng": ["apng"],
  "image/bmp": ["bmp"],
  "image/cgm": ["cgm"],
  "image/g3fax": ["g3"],
  "image/gif": ["gif"],
  "image/ief": ["ief"],
  "image/jp2": ["jp2", "jpg2"],
  "image/jpeg": ["jpeg", "jpg", "jpe"],
  "image/jpm": ["jpm"],
  "image/jpx": ["jpx", "jpf"],
  "image/ktx": ["ktx"],
  "image/png": ["png"],
  "image/prs.btif": ["btif"],
  "image/sgi": ["sgi"],
  "image/svg+xml": ["svg", "svgz"],
  "image/tiff": ["tiff", "tif"],
  "image/vnd.adobe.photoshop": ["psd"],
  "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"],
  "image/vnd.djvu": ["djvu", "djv"],
  "image/vnd.dvb.subtitle": [],
  "image/vnd.dwg": ["dwg"],
  "image/vnd.dxf": ["dxf"],
  "image/vnd.fastbidsheet": ["fbs"],
  "image/vnd.fpx": ["fpx"],
  "image/vnd.fst": ["fst"],
  "image/vnd.fujixerox.edmics-mmr": ["mmr"],
  "image/vnd.fujixerox.edmics-rlc": ["rlc"],
  "image/vnd.ms-modi": ["mdi"],
  "image/vnd.ms-photo": ["wdp"],
  "image/vnd.net-fpx": ["npx"],
  "image/vnd.wap.wbmp": ["wbmp"],
  "image/vnd.xiff": ["xif"],
  "image/webp": ["webp"],
  "image/x-3ds": ["3ds"],
  "image/x-cmu-raster": ["ras"],
  "image/x-cmx": ["cmx"],
  "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"],
  "image/x-icon": ["ico"],
  "image/x-jng": ["jng"],
  "image/x-mrsid-image": ["sid"],
  "image/x-ms-bmp": [],
  "image/x-pcx": ["pcx"],
  "image/x-pict": ["pic", "pct"],
  "image/x-portable-anymap": ["pnm"],
  "image/x-portable-bitmap": ["pbm"],
  "image/x-portable-graymap": ["pgm"],
  "image/x-portable-pixmap": ["ppm"],
  "image/x-rgb": ["rgb"],
  "image/x-tga": ["tga"],
  "image/x-xbitmap": ["xbm"],
  "image/x-xpixmap": ["xpm"],
  "image/x-xwindowdump": ["xwd"],
  "message/rfc822": ["eml", "mime"],
  "model/gltf+json": ["gltf"],
  "model/gltf-binary": ["glb"],
  "model/iges": ["igs", "iges"],
  "model/mesh": ["msh", "mesh", "silo"],
  "model/vnd.collada+xml": ["dae"],
  "model/vnd.dwf": ["dwf"],
  "model/vnd.gdl": ["gdl"],
  "model/vnd.gtw": ["gtw"],
  "model/vnd.mts": ["mts"],
  "model/vnd.vtu": ["vtu"],
  "model/vrml": ["wrl", "vrml"],
  "model/x3d+binary": ["x3db", "x3dbz"],
  "model/x3d+vrml": ["x3dv", "x3dvz"],
  "model/x3d+xml": ["x3d", "x3dz"],
  "text/cache-manifest": ["appcache", "manifest"],
  "text/calendar": ["ics", "ifb"],
  "text/coffeescript": ["coffee", "litcoffee"],
  "text/css": ["css"],
  "text/csv": ["csv"],
  "text/hjson": ["hjson"],
  "text/html": ["html", "htm", "shtml"],
  "text/jade": ["jade"],
  "text/jsx": ["jsx"],
  "text/less": ["less"],
  "text/markdown": ["markdown", "md"],
  "text/mathml": ["mml"],
  "text/n3": ["n3"],
  "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
  "text/prs.lines.tag": ["dsc"],
  "text/richtext": ["rtx"],
  "text/rtf": [],
  "text/sgml": ["sgml", "sgm"],
  "text/slim": ["slim", "slm"],
  "text/stylus": ["stylus", "styl"],
  "text/tab-separated-values": ["tsv"],
  "text/troff": ["t", "tr", "roff", "man", "me", "ms"],
  "text/turtle": ["ttl"],
  "text/uri-list": ["uri", "uris", "urls"],
  "text/vcard": ["vcard"],
  "text/vnd.curl": ["curl"],
  "text/vnd.curl.dcurl": ["dcurl"],
  "text/vnd.curl.mcurl": ["mcurl"],
  "text/vnd.curl.scurl": ["scurl"],
  "text/vnd.dvb.subtitle": ["sub"],
  "text/vnd.fly": ["fly"],
  "text/vnd.fmi.flexstor": ["flx"],
  "text/vnd.graphviz": ["gv"],
  "text/vnd.in3d.3dml": ["3dml"],
  "text/vnd.in3d.spot": ["spot"],
  "text/vnd.sun.j2me.app-descriptor": ["jad"],
  "text/vnd.wap.wml": ["wml"],
  "text/vnd.wap.wmlscript": ["wmls"],
  "text/vtt": ["vtt"],
  "text/x-asm": ["s", "asm"],
  "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
  "text/x-component": ["htc"],
  "text/x-fortran": ["f", "for", "f77", "f90"],
  "text/x-handlebars-template": ["hbs"],
  "text/x-java-source": ["java"],
  "text/x-lua": ["lua"],
  "text/x-markdown": ["mkd"],
  "text/x-nfo": ["nfo"],
  "text/x-opml": ["opml"],
  "text/x-org": [],
  "text/x-pascal": ["p", "pas"],
  "text/x-processing": ["pde"],
  "text/x-sass": ["sass"],
  "text/x-scss": ["scss"],
  "text/x-setext": ["etx"],
  "text/x-sfv": ["sfv"],
  "text/x-suse-ymp": ["ymp"],
  "text/x-uuencode": ["uu"],
  "text/x-vcalendar": ["vcs"],
  "text/x-vcard": ["vcf"],
  "text/xml": [],
  "text/yaml": ["yaml", "yml"],
  "video/3gpp": ["3gp", "3gpp"],
  "video/3gpp2": ["3g2"],
  "video/h261": ["h261"],
  "video/h263": ["h263"],
  "video/h264": ["h264"],
  "video/jpeg": ["jpgv"],
  "video/jpm": ["jpgm"],
  "video/mj2": ["mj2", "mjp2"],
  "video/mp2t": ["ts"],
  "video/mp4": ["mp4", "mp4v", "mpg4"],
  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  "video/ogg": ["ogv"],
  "video/quicktime": ["qt", "mov"],
  "video/vnd.dece.hd": ["uvh", "uvvh"],
  "video/vnd.dece.mobile": ["uvm", "uvvm"],
  "video/vnd.dece.pd": ["uvp", "uvvp"],
  "video/vnd.dece.sd": ["uvs", "uvvs"],
  "video/vnd.dece.video": ["uvv", "uvvv"],
  "video/vnd.dvb.file": ["dvb"],
  "video/vnd.fvt": ["fvt"],
  "video/vnd.mpegurl": ["mxu", "m4u"],
  "video/vnd.ms-playready.media.pyv": ["pyv"],
  "video/vnd.uvvu.mp4": ["uvu", "uvvu"],
  "video/vnd.vivo": ["viv"],
  "video/webm": ["webm"],
  "video/x-f4v": ["f4v"],
  "video/x-fli": ["fli"],
  "video/x-flv": ["flv"],
  "video/x-m4v": ["m4v"],
  "video/x-matroska": ["mkv", "mk3d", "mks"],
  "video/x-mng": ["mng"],
  "video/x-ms-asf": ["asf", "asx"],
  "video/x-ms-vob": ["vob"],
  "video/x-ms-wm": ["wm"],
  "video/x-ms-wmv": ["wmv"],
  "video/x-ms-wmx": ["wmx"],
  "video/x-ms-wvx": ["wvx"],
  "video/x-msvideo": ["avi"],
  "video/x-sgi-movie": ["movie"],
  "video/x-smv": ["smv"],
  "x-conference/x-cooltalk": ["ice"],
};
var X6 = Xt;
function _c() {
  (this.types = Object.create(null)), (this.extensions = Object.create(null));
}
_c.prototype.define = function (e) {
  for (var t in e) {
    for (var n = e[t], r = 0; r < n.length; r++)
      process.env.DEBUG_MIME &&
        this.types[n[r]] &&
        console.warn(
          (this._loading || "define()").replace(/.*\//, ""),
          'changes "' +
            n[r] +
            '" extension type from ' +
            this.types[n[r]] +
            " to " +
            t,
        ),
        (this.types[n[r]] = t);
    this.extensions[t] || (this.extensions[t] = n[0]);
  }
};
_c.prototype.load = function (e) {
  this._loading = e;
  var t = {},
    n = X6.readFileSync(e, "ascii"),
    r = n.split(/[\r\n]+/);
  r.forEach(function (i) {
    var a = i.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
    t[a.shift()] = a;
  }),
    this.define(t),
    (this._loading = null);
};
_c.prototype.lookup = function (e, t) {
  var n = e.replace(/^.*[\.\/\\]/, "").toLowerCase();
  return this.types[n] || t || this.default_type;
};
_c.prototype.extension = function (e) {
  var t = e.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[t];
};
var Wo = new _c();
Wo.define(Y6);
Wo.default_type = Wo.lookup("bin");
Wo.Mime = _c;
Wo.charsets = {
  lookup: function (e, t) {
    return /^text\/|^application\/(javascript|json)/.test(e) ? "UTF-8" : t;
  },
};
var J6 = Wo,
  zo = 1e3,
  Ko = zo * 60,
  Vo = Ko * 60,
  Ds = Vo * 24,
  Z6 = Ds * 7,
  e3 = Ds * 365.25,
  t3 = function (e, t) {
    t = t || {};
    var n = typeof e;
    if (n === "string" && e.length > 0) return n3(e);
    if (n === "number" && isFinite(e)) return t.long ? i3(e) : r3(e);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(e),
    );
  };
function n3(e) {
  if (((e = String(e)), !(e.length > 100))) {
    var t =
      /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        e,
      );
    if (t) {
      var n = parseFloat(t[1]),
        r = (t[2] || "ms").toLowerCase();
      switch (r) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * e3;
        case "weeks":
        case "week":
        case "w":
          return n * Z6;
        case "days":
        case "day":
        case "d":
          return n * Ds;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * Vo;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * Ko;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * zo;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return;
      }
    }
  }
}
function r3(e) {
  var t = Math.abs(e);
  return t >= Ds
    ? Math.round(e / Ds) + "d"
    : t >= Vo
    ? Math.round(e / Vo) + "h"
    : t >= Ko
    ? Math.round(e / Ko) + "m"
    : t >= zo
    ? Math.round(e / zo) + "s"
    : e + "ms";
}
function i3(e) {
  var t = Math.abs(e);
  return t >= Ds
    ? Ku(e, t, Ds, "day")
    : t >= Vo
    ? Ku(e, t, Vo, "hour")
    : t >= Ko
    ? Ku(e, t, Ko, "minute")
    : t >= zo
    ? Ku(e, t, zo, "second")
    : e + " ms";
}
function Ku(e, t, n, r) {
  var i = t >= n * 1.5;
  return Math.round(e / n) + " " + r + (i ? "s" : "");
}
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var E$ = a3;
function a3(e, t, n) {
  if (typeof t != "string")
    throw new TypeError("argument str must be a string");
  var r = t.indexOf("=");
  if (r === -1) return -2;
  var i = t.slice(r + 1).split(","),
    a = [];
  a.type = t.slice(0, r);
  for (var s = 0; s < i.length; s++) {
    var o = i[s].split("-"),
      c = parseInt(o[0], 10),
      l = parseInt(o[1], 10);
    isNaN(c) ? ((c = e - l), (l = e - 1)) : isNaN(l) && (l = e - 1),
      l > e - 1 && (l = e - 1),
      !(isNaN(c) || isNaN(l) || c > l || c < 0) && a.push({ start: c, end: l });
  }
  return a.length < 1 ? -1 : n && n.combine ? s3(a) : a;
}
function s3(e) {
  for (var t = e.map(o3).sort(u3), n = 0, r = 1; r < t.length; r++) {
    var i = t[r],
      a = t[n];
    i.start > a.end + 1
      ? (t[++n] = i)
      : i.end > a.end &&
        ((a.end = i.end), (a.index = Math.min(a.index, i.index)));
  }
  t.length = n + 1;
  var s = t.sort(l3).map(c3);
  return (s.type = e.type), s;
}
function o3(e, t) {
  return { start: e.start, end: e.end, index: t };
}
function c3(e) {
  return { start: e.start, end: e.end };
}
function l3(e, t) {
  return e.index - t.index;
}
function u3(e, t) {
  return e.start - t.start;
}
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var Lh = Gi,
  xn = M6("send"),
  Vs = wi("send"),
  f3 = ev,
  d3 = Qd,
  Jg = Wd,
  p3 = b$,
  h3 = _$,
  ad = Xt,
  Zg = J6,
  w$ = t3,
  m3 = Kl,
  g3 = E$,
  Jl = pt,
  v3 = Hd,
  x$ = Kr,
  y3 = wr,
  b3 = Jl.extname,
  A$ = Jl.join,
  Bh = Jl.normalize,
  yv = Jl.resolve,
  Bf = Jl.sep,
  _3 = /^ *bytes=/,
  S$ = 60 * 60 * 24 * 365 * 1e3,
  G_ = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
vv.exports = E3;
vv.exports.mime = Zg;
function E3(e, t, n) {
  return new Qt(e, t, n);
}
function Qt(e, t, n) {
  x$.call(this);
  var r = n || {};
  if (
    ((this.options = r),
    (this.path = t),
    (this.req = e),
    (this._acceptRanges = r.acceptRanges !== void 0 ? !!r.acceptRanges : !0),
    (this._cacheControl = r.cacheControl !== void 0 ? !!r.cacheControl : !0),
    (this._etag = r.etag !== void 0 ? !!r.etag : !0),
    (this._dotfiles = r.dotfiles !== void 0 ? r.dotfiles : "ignore"),
    this._dotfiles !== "ignore" &&
      this._dotfiles !== "allow" &&
      this._dotfiles !== "deny")
  )
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
  (this._hidden = !!r.hidden),
    r.hidden !== void 0 &&
      Vs(
        "hidden: use dotfiles: '" +
          (this._hidden ? "allow" : "ignore") +
          "' instead",
      ),
    r.dotfiles === void 0 && (this._dotfiles = void 0),
    (this._extensions =
      r.extensions !== void 0 ? e0(r.extensions, "extensions option") : []),
    (this._immutable = r.immutable !== void 0 ? !!r.immutable : !1),
    (this._index =
      r.index !== void 0 ? e0(r.index, "index option") : ["index.html"]),
    (this._lastModified = r.lastModified !== void 0 ? !!r.lastModified : !0),
    (this._maxage = r.maxAge || r.maxage),
    (this._maxage =
      typeof this._maxage == "string"
        ? w$(this._maxage)
        : Number(this._maxage)),
    (this._maxage = isNaN(this._maxage)
      ? 0
      : Math.min(Math.max(0, this._maxage), S$)),
    (this._root = r.root ? yv(r.root) : null),
    !this._root && r.from && this.from(r.from);
}
y3.inherits(Qt, x$);
Qt.prototype.etag = Vs.function(function (t) {
  return (this._etag = !!t), xn("etag %s", this._etag), this;
}, "send.etag: pass etag as option");
Qt.prototype.hidden = Vs.function(function (t) {
  return (
    (this._hidden = !!t),
    (this._dotfiles = void 0),
    xn("hidden %s", this._hidden),
    this
  );
}, "send.hidden: use dotfiles option");
Qt.prototype.index = Vs.function(function (t) {
  var n = t ? e0(t, "paths argument") : [];
  return xn("index %o", t), (this._index = n), this;
}, "send.index: pass index as option");
Qt.prototype.root = function (t) {
  return (this._root = yv(String(t))), xn("root %s", this._root), this;
};
Qt.prototype.from = Vs.function(
  Qt.prototype.root,
  "send.from: pass root as option",
);
Qt.prototype.root = Vs.function(
  Qt.prototype.root,
  "send.root: pass root as option",
);
Qt.prototype.maxage = Vs.function(function (t) {
  return (
    (this._maxage = typeof t == "string" ? w$(t) : Number(t)),
    (this._maxage = isNaN(this._maxage)
      ? 0
      : Math.min(Math.max(0, this._maxage), S$)),
    xn("max-age %d", this._maxage),
    this
  );
}, "send.maxage: pass maxAge as option");
Qt.prototype.error = function (t, n) {
  if ($$(this, "error")) return this.emit("error", S3(t, n));
  var r = this.res,
    i = v3.message[t] || String(t),
    a = I$("Error", Jg(i));
  w3(r),
    n && n.headers && k3(r, n.headers),
    (r.statusCode = t),
    r.setHeader("Content-Type", "text/html; charset=UTF-8"),
    r.setHeader("Content-Length", Buffer.byteLength(a)),
    r.setHeader("Content-Security-Policy", "default-src 'none'"),
    r.setHeader("X-Content-Type-Options", "nosniff"),
    r.end(a);
};
Qt.prototype.hasTrailingSlash = function () {
  return this.path[this.path.length - 1] === "/";
};
Qt.prototype.isConditionalGET = function () {
  return (
    this.req.headers["if-match"] ||
    this.req.headers["if-unmodified-since"] ||
    this.req.headers["if-none-match"] ||
    this.req.headers["if-modified-since"]
  );
};
Qt.prototype.isPreconditionFailure = function () {
  var t = this.req,
    n = this.res,
    r = t.headers["if-match"];
  if (r) {
    var i = n.getHeader("ETag");
    return (
      !i ||
      (r !== "*" &&
        R3(r).every(function (o) {
          return o !== i && o !== "W/" + i && "W/" + o !== i;
        }))
    );
  }
  var a = sd(t.headers["if-unmodified-since"]);
  if (!isNaN(a)) {
    var s = sd(n.getHeader("Last-Modified"));
    return isNaN(s) || s > a;
  }
  return !1;
};
Qt.prototype.removeContentHeaderFields = function () {
  var t = this.res;
  t.removeHeader("Content-Encoding"),
    t.removeHeader("Content-Language"),
    t.removeHeader("Content-Length"),
    t.removeHeader("Content-Range"),
    t.removeHeader("Content-Type");
};
Qt.prototype.notModified = function () {
  var t = this.res;
  xn("not modified"),
    this.removeContentHeaderFields(),
    (t.statusCode = 304),
    t.end();
};
Qt.prototype.headersAlreadySent = function () {
  var t = new Error("Can't set headers after they are sent.");
  xn("headers already sent"), this.error(500, t);
};
Qt.prototype.isCachable = function () {
  var t = this.res.statusCode;
  return (t >= 200 && t < 300) || t === 304;
};
Qt.prototype.onStatError = function (t) {
  switch (t.code) {
    case "ENAMETOOLONG":
    case "ENOENT":
    case "ENOTDIR":
      this.error(404, t);
      break;
    default:
      this.error(500, t);
      break;
  }
};
Qt.prototype.isFresh = function () {
  return h3(this.req.headers, {
    etag: this.res.getHeader("ETag"),
    "last-modified": this.res.getHeader("Last-Modified"),
  });
};
Qt.prototype.isRangeFresh = function () {
  var t = this.req.headers["if-range"];
  if (!t) return !0;
  if (t.indexOf('"') !== -1) {
    var n = this.res.getHeader("ETag");
    return !!(n && t.indexOf(n) !== -1);
  }
  var r = this.res.getHeader("Last-Modified");
  return sd(r) <= sd(t);
};
Qt.prototype.redirect = function (t) {
  var n = this.res;
  if ($$(this, "directory")) {
    this.emit("directory", n, t);
    return;
  }
  if (this.hasTrailingSlash()) {
    this.error(403);
    return;
  }
  var r = d3(x3(this.path + "/")),
    i = I$(
      "Redirecting",
      'Redirecting to <a href="' + Jg(r) + '">' + Jg(r) + "</a>",
    );
  (n.statusCode = 301),
    n.setHeader("Content-Type", "text/html; charset=UTF-8"),
    n.setHeader("Content-Length", Buffer.byteLength(i)),
    n.setHeader("Content-Security-Policy", "default-src 'none'"),
    n.setHeader("X-Content-Type-Options", "nosniff"),
    n.setHeader("Location", r),
    n.end(i);
};
Qt.prototype.pipe = function (t) {
  var n = this._root;
  this.res = t;
  var r = I3(this.path);
  if (r === -1) return this.error(400), t;
  if (~r.indexOf("\0")) return this.error(400), t;
  var i;
  if (n !== null) {
    if ((r && (r = Bh("." + Bf + r)), G_.test(r)))
      return xn('malicious path "%s"', r), this.error(403), t;
    (i = r.split(Bf)), (r = Bh(A$(n, r)));
  } else {
    if (G_.test(r)) return xn('malicious path "%s"', r), this.error(403), t;
    (i = Bh(r).split(Bf)), (r = yv(r));
  }
  if (A3(i)) {
    var a = this._dotfiles;
    switch (
      (a === void 0 &&
        (a =
          i[i.length - 1][0] === "."
            ? this._hidden
              ? "allow"
              : "ignore"
            : "allow"),
      xn('%s dotfile "%s"', a, r),
      a)
    ) {
      case "allow":
        break;
      case "deny":
        return this.error(403), t;
      case "ignore":
      default:
        return this.error(404), t;
    }
  }
  return this._index.length && this.hasTrailingSlash()
    ? (this.sendIndex(r), t)
    : (this.sendFile(r), t);
};
Qt.prototype.send = function (t, n) {
  var r = n.size,
    i = this.options,
    a = {},
    s = this.res,
    o = this.req,
    c = o.headers.range,
    l = i.start || 0;
  if (C3(s)) {
    this.headersAlreadySent();
    return;
  }
  if (
    (xn('pipe "%s"', t),
    this.setHeader(t, n),
    this.type(t),
    this.isConditionalGET())
  ) {
    if (this.isPreconditionFailure()) {
      this.error(412);
      return;
    }
    if (this.isCachable() && this.isFresh()) {
      this.notModified();
      return;
    }
  }
  if (((r = Math.max(0, r - l)), i.end !== void 0)) {
    var f = i.end - l + 1;
    r > f && (r = f);
  }
  if (this._acceptRanges && _3.test(c)) {
    if (
      ((c = g3(r, c, { combine: !0 })),
      this.isRangeFresh() || (xn("range stale"), (c = -2)),
      c === -1)
    )
      return (
        xn("range unsatisfiable"),
        s.setHeader("Content-Range", Q_("bytes", r)),
        this.error(416, {
          headers: { "Content-Range": s.getHeader("Content-Range") },
        })
      );
    c !== -2 &&
      c.length === 1 &&
      (xn("range %j", c),
      (s.statusCode = 206),
      s.setHeader("Content-Range", Q_("bytes", r, c[0])),
      (l += c[0].start),
      (r = c[0].end - c[0].start + 1));
  }
  for (var u in i) a[u] = i[u];
  if (
    ((a.start = l),
    (a.end = Math.max(l, l + r - 1)),
    s.setHeader("Content-Length", r),
    o.method === "HEAD")
  ) {
    s.end();
    return;
  }
  this.stream(t, a);
};
Qt.prototype.sendFile = function (t) {
  var n = 0,
    r = this;
  xn('stat "%s"', t),
    ad.stat(t, function (s, o) {
      if (s && s.code === "ENOENT" && !b3(t) && t[t.length - 1] !== Bf)
        return i(s);
      if (s) return r.onStatError(s);
      if (o.isDirectory()) return r.redirect(t);
      r.emit("file", t, o), r.send(t, o);
    });
  function i(a) {
    if (r._extensions.length <= n) return a ? r.onStatError(a) : r.error(404);
    var s = t + "." + r._extensions[n++];
    xn('stat "%s"', s),
      ad.stat(s, function (o, c) {
        if (o) return i(o);
        if (c.isDirectory()) return i();
        r.emit("file", s, c), r.send(s, c);
      });
  }
};
Qt.prototype.sendIndex = function (t) {
  var n = -1,
    r = this;
  function i(a) {
    if (++n >= r._index.length) return a ? r.onStatError(a) : r.error(404);
    var s = A$(t, r._index[n]);
    xn('stat "%s"', s),
      ad.stat(s, function (o, c) {
        if (o) return i(o);
        if (c.isDirectory()) return i();
        r.emit("file", s, c), r.send(s, c);
      });
  }
  i();
};
Qt.prototype.stream = function (t, n) {
  var r = this,
    i = this.res,
    a = ad.createReadStream(t, n);
  this.emit("stream", a), a.pipe(i);
  function s() {
    f3(a, !0);
  }
  m3(i, s),
    a.on("error", function (c) {
      s(), r.onStatError(c);
    }),
    a.on("end", function () {
      r.emit("end");
    });
};
Qt.prototype.type = function (t) {
  var n = this.res;
  if (!n.getHeader("Content-Type")) {
    var r = Zg.lookup(t);
    if (!r) {
      xn("no content-type");
      return;
    }
    var i = Zg.charsets.lookup(r);
    xn("content-type %s", r),
      n.setHeader("Content-Type", r + (i ? "; charset=" + i : ""));
  }
};
Qt.prototype.setHeader = function (t, n) {
  var r = this.res;
  if (
    (this.emit("headers", r, t, n),
    this._acceptRanges &&
      !r.getHeader("Accept-Ranges") &&
      (xn("accept ranges"), r.setHeader("Accept-Ranges", "bytes")),
    this._cacheControl && !r.getHeader("Cache-Control"))
  ) {
    var i = "public, max-age=" + Math.floor(this._maxage / 1e3);
    this._immutable && (i += ", immutable"),
      xn("cache-control %s", i),
      r.setHeader("Cache-Control", i);
  }
  if (this._lastModified && !r.getHeader("Last-Modified")) {
    var a = n.mtime.toUTCString();
    xn("modified %s", a), r.setHeader("Last-Modified", a);
  }
  if (this._etag && !r.getHeader("ETag")) {
    var s = p3(n);
    xn("etag %s", s), r.setHeader("ETag", s);
  }
};
function w3(e) {
  for (var t = $3(e), n = 0; n < t.length; n++) e.removeHeader(t[n]);
}
function x3(e) {
  for (var t = 0; t < e.length && e[t] === "/"; t++);
  return t > 1 ? "/" + e.substr(t) : e;
}
function A3(e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    if (n.length > 1 && n[0] === ".") return !0;
  }
  return !1;
}
function Q_(e, t, n) {
  return e + " " + (n ? n.start + "-" + n.end : "*") + "/" + t;
}
function I$(e, t) {
  return (
    `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>` +
    e +
    `</title>
</head>
<body>
<pre>` +
    t +
    `</pre>
</body>
</html>
`
  );
}
function S3(e, t) {
  return t ? (t instanceof Error ? Lh(e, t, { expose: !1 }) : Lh(e, t)) : Lh(e);
}
function I3(e) {
  try {
    return decodeURIComponent(e);
  } catch {
    return -1;
  }
}
function $3(e) {
  return typeof e.getHeaderNames != "function"
    ? Object.keys(e._headers || {})
    : e.getHeaderNames();
}
function $$(e, t) {
  var n =
    typeof e.listenerCount != "function"
      ? e.listeners(t).length
      : e.listenerCount(t);
  return n > 0;
}
function C3(e) {
  return typeof e.headersSent != "boolean" ? !!e._header : e.headersSent;
}
function e0(e, t) {
  for (var n = [].concat(e || []), r = 0; r < n.length; r++)
    if (typeof n[r] != "string")
      throw new TypeError(t + " must be array of strings or false");
  return n;
}
function sd(e) {
  var t = e && Date.parse(e);
  return typeof t == "number" ? t : NaN;
}
function R3(e) {
  for (var t = 0, n = [], r = 0, i = 0, a = e.length; i < a; i++)
    switch (e.charCodeAt(i)) {
      case 32:
        r === t && (r = t = i + 1);
        break;
      case 44:
        r !== t && n.push(e.substring(r, t)), (r = t = i + 1);
        break;
      default:
        t = i + 1;
        break;
    }
  return r !== t && n.push(e.substring(r, t)), n;
}
function k3(e, t) {
  for (var n = Object.keys(t), r = 0; r < n.length; r++) {
    var i = n[r];
    e.setHeader(i, t[i]);
  }
}
var bv = vv.exports,
  Xd = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ var T3 = N3;
function N3(e) {
  if (!e) throw new TypeError("argument req is required");
  var t = P3(e.headers["x-forwarded-for"] || ""),
    n = O3(e),
    r = [n].concat(t);
  return r;
}
function O3(e) {
  return e.socket ? e.socket.remoteAddress : e.connection.remoteAddress;
}
function P3(e) {
  for (var t = e.length, n = [], r = e.length, i = e.length - 1; i >= 0; i--)
    switch (e.charCodeAt(i)) {
      case 32:
        r === t && (r = t = i);
        break;
      case 44:
        r !== t && n.push(e.substring(r, t)), (r = t = i);
        break;
      default:
        r = i;
        break;
    }
  return r !== t && n.push(e.substring(r, t)), n;
}
var _v = { exports: {} };
_v.exports;
(function (e) {
  (function () {
    var t, n, r, i, a, s, o, c, l;
    (n = {}),
      (c = this),
      e !== null && e.exports ? (e.exports = n) : (c.ipaddr = n),
      (o = function (f, u, d, p) {
        var h, m;
        if (f.length !== u.length)
          throw new Error(
            "ipaddr: cannot match CIDR for objects with different lengths",
          );
        for (h = 0; p > 0; ) {
          if (((m = d - p), m < 0 && (m = 0), f[h] >> m !== u[h] >> m))
            return !1;
          (p -= d), (h += 1);
        }
        return !0;
      }),
      (n.subnetMatch = function (f, u, d) {
        var p, h, m, g, v;
        d == null && (d = "unicast");
        for (m in u)
          for (
            g = u[m],
              g[0] && !(g[0] instanceof Array) && (g = [g]),
              p = 0,
              h = g.length;
            p < h;
            p++
          )
            if (((v = g[p]), f.kind() === v[0].kind() && f.match.apply(f, v)))
              return m;
        return d;
      }),
      (n.IPv4 = (function () {
        function f(u) {
          var d, p, h;
          if (u.length !== 4)
            throw new Error("ipaddr: ipv4 octet count should be 4");
          for (d = 0, p = u.length; d < p; d++)
            if (((h = u[d]), !(0 <= h && h <= 255)))
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          this.octets = u;
        }
        return (
          (f.prototype.kind = function () {
            return "ipv4";
          }),
          (f.prototype.toString = function () {
            return this.octets.join(".");
          }),
          (f.prototype.toNormalizedString = function () {
            return this.toString();
          }),
          (f.prototype.toByteArray = function () {
            return this.octets.slice(0);
          }),
          (f.prototype.match = function (u, d) {
            var p;
            if (
              (d === void 0 && ((p = u), (u = p[0]), (d = p[1])),
              u.kind() !== "ipv4")
            )
              throw new Error(
                "ipaddr: cannot match ipv4 address with non-ipv4 one",
              );
            return o(this.octets, u.octets, 8, d);
          }),
          (f.prototype.SpecialRanges = {
            unspecified: [[new f([0, 0, 0, 0]), 8]],
            broadcast: [[new f([255, 255, 255, 255]), 32]],
            multicast: [[new f([224, 0, 0, 0]), 4]],
            linkLocal: [[new f([169, 254, 0, 0]), 16]],
            loopback: [[new f([127, 0, 0, 0]), 8]],
            carrierGradeNat: [[new f([100, 64, 0, 0]), 10]],
            private: [
              [new f([10, 0, 0, 0]), 8],
              [new f([172, 16, 0, 0]), 12],
              [new f([192, 168, 0, 0]), 16],
            ],
            reserved: [
              [new f([192, 0, 0, 0]), 24],
              [new f([192, 0, 2, 0]), 24],
              [new f([192, 88, 99, 0]), 24],
              [new f([198, 51, 100, 0]), 24],
              [new f([203, 0, 113, 0]), 24],
              [new f([240, 0, 0, 0]), 4],
            ],
          }),
          (f.prototype.range = function () {
            return n.subnetMatch(this, this.SpecialRanges);
          }),
          (f.prototype.toIPv4MappedAddress = function () {
            return n.IPv6.parse("::ffff:" + this.toString());
          }),
          (f.prototype.prefixLengthFromSubnetMask = function () {
            var u, d, p, h, m, g, v;
            for (
              v = {
                0: 8,
                128: 7,
                192: 6,
                224: 5,
                240: 4,
                248: 3,
                252: 2,
                254: 1,
                255: 0,
              },
                u = 0,
                m = !1,
                d = p = 3;
              p >= 0;
              d = p += -1
            )
              if (((h = this.octets[d]), h in v)) {
                if (((g = v[h]), m && g !== 0)) return null;
                g !== 8 && (m = !0), (u += g);
              } else return null;
            return 32 - u;
          }),
          f
        );
      })()),
      (r = "(0?\\d+|0x[a-f0-9]+)"),
      (i = {
        fourOctet: new RegExp(
          "^" + r + "\\." + r + "\\." + r + "\\." + r + "$",
          "i",
        ),
        longValue: new RegExp("^" + r + "$", "i"),
      }),
      (n.IPv4.parser = function (f) {
        var u, d, p, h, m;
        if (
          ((d = function (g) {
            return g[0] === "0" && g[1] !== "x" ? parseInt(g, 8) : parseInt(g);
          }),
          (u = f.match(i.fourOctet)))
        )
          return (function () {
            var g, v, y, _;
            for (y = u.slice(1, 6), _ = [], g = 0, v = y.length; g < v; g++)
              (p = y[g]), _.push(d(p));
            return _;
          })();
        if ((u = f.match(i.longValue))) {
          if (((m = d(u[1])), m > 4294967295 || m < 0))
            throw new Error("ipaddr: address outside defined range");
          return (function () {
            var g, v;
            for (v = [], h = g = 0; g <= 24; h = g += 8) v.push((m >> h) & 255);
            return v;
          })().reverse();
        } else return null;
      }),
      (n.IPv6 = (function () {
        function f(u, d) {
          var p, h, m, g, v, y;
          if (u.length === 16)
            for (this.parts = [], p = h = 0; h <= 14; p = h += 2)
              this.parts.push((u[p] << 8) | u[p + 1]);
          else if (u.length === 8) this.parts = u;
          else throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          for (y = this.parts, m = 0, g = y.length; m < g; m++)
            if (((v = y[m]), !(0 <= v && v <= 65535)))
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          d && (this.zoneId = d);
        }
        return (
          (f.prototype.kind = function () {
            return "ipv6";
          }),
          (f.prototype.toString = function () {
            return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
          }),
          (f.prototype.toRFC5952String = function () {
            var u, d, p, h, m;
            for (
              h = /((^|:)(0(:|$)){2,})/g,
                m = this.toNormalizedString(),
                u = 0,
                d = -1;
              (p = h.exec(m));

            )
              p[0].length > d && ((u = p.index), (d = p[0].length));
            return d < 0 ? m : m.substring(0, u) + "::" + m.substring(u + d);
          }),
          (f.prototype.toByteArray = function () {
            var u, d, p, h, m;
            for (u = [], m = this.parts, d = 0, p = m.length; d < p; d++)
              (h = m[d]), u.push(h >> 8), u.push(h & 255);
            return u;
          }),
          (f.prototype.toNormalizedString = function () {
            var u, d, p;
            return (
              (u = function () {
                var h, m, g, v;
                for (g = this.parts, v = [], h = 0, m = g.length; h < m; h++)
                  (d = g[h]), v.push(d.toString(16));
                return v;
              }
                .call(this)
                .join(":")),
              (p = ""),
              this.zoneId && (p = "%" + this.zoneId),
              u + p
            );
          }),
          (f.prototype.toFixedLengthString = function () {
            var u, d, p;
            return (
              (u = function () {
                var h, m, g, v;
                for (g = this.parts, v = [], h = 0, m = g.length; h < m; h++)
                  (d = g[h]), v.push(d.toString(16).padStart(4, "0"));
                return v;
              }
                .call(this)
                .join(":")),
              (p = ""),
              this.zoneId && (p = "%" + this.zoneId),
              u + p
            );
          }),
          (f.prototype.match = function (u, d) {
            var p;
            if (
              (d === void 0 && ((p = u), (u = p[0]), (d = p[1])),
              u.kind() !== "ipv6")
            )
              throw new Error(
                "ipaddr: cannot match ipv6 address with non-ipv6 one",
              );
            return o(this.parts, u.parts, 16, d);
          }),
          (f.prototype.SpecialRanges = {
            unspecified: [new f([0, 0, 0, 0, 0, 0, 0, 0]), 128],
            linkLocal: [new f([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
            multicast: [new f([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
            loopback: [new f([0, 0, 0, 0, 0, 0, 0, 1]), 128],
            uniqueLocal: [new f([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
            ipv4Mapped: [new f([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
            rfc6145: [new f([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
            rfc6052: [new f([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
            "6to4": [new f([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
            teredo: [new f([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
            reserved: [[new f([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]],
          }),
          (f.prototype.range = function () {
            return n.subnetMatch(this, this.SpecialRanges);
          }),
          (f.prototype.isIPv4MappedAddress = function () {
            return this.range() === "ipv4Mapped";
          }),
          (f.prototype.toIPv4Address = function () {
            var u, d, p;
            if (!this.isIPv4MappedAddress())
              throw new Error(
                "ipaddr: trying to convert a generic ipv6 address to ipv4",
              );
            return (
              (p = this.parts.slice(-2)),
              (u = p[0]),
              (d = p[1]),
              new n.IPv4([u >> 8, u & 255, d >> 8, d & 255])
            );
          }),
          (f.prototype.prefixLengthFromSubnetMask = function () {
            var u, d, p, h, m, g, v;
            for (
              v = {
                0: 16,
                32768: 15,
                49152: 14,
                57344: 13,
                61440: 12,
                63488: 11,
                64512: 10,
                65024: 9,
                65280: 8,
                65408: 7,
                65472: 6,
                65504: 5,
                65520: 4,
                65528: 3,
                65532: 2,
                65534: 1,
                65535: 0,
              },
                u = 0,
                m = !1,
                d = p = 7;
              p >= 0;
              d = p += -1
            )
              if (((h = this.parts[d]), h in v)) {
                if (((g = v[h]), m && g !== 0)) return null;
                g !== 16 && (m = !0), (u += g);
              } else return null;
            return 128 - u;
          }),
          f
        );
      })()),
      (a = "(?:[0-9a-f]+::?)+"),
      (l = "%[0-9a-z]{1,}"),
      (s = {
        zoneIndex: new RegExp(l, "i"),
        native: new RegExp(
          "^(::)?(" + a + ")?([0-9a-f]+)?(::)?(" + l + ")?$",
          "i",
        ),
        transitional: new RegExp(
          "^((?:" +
            a +
            ")|(?:::)(?:" +
            a +
            ")?)" +
            (r + "\\." + r + "\\." + r + "\\." + r) +
            ("(" + l + ")?$"),
          "i",
        ),
      }),
      (t = function (f, u) {
        var d, p, h, m, g, v;
        if (f.indexOf("::") !== f.lastIndexOf("::")) return null;
        for (
          v = (f.match(s.zoneIndex) || [])[0],
            v && ((v = v.substring(1)), (f = f.replace(/%.+$/, ""))),
            d = 0,
            p = -1;
          (p = f.indexOf(":", p + 1)) >= 0;

        )
          d++;
        if (
          (f.substr(0, 2) === "::" && d--,
          f.substr(-2, 2) === "::" && d--,
          d > u)
        )
          return null;
        for (g = u - d, m = ":"; g--; ) m += "0:";
        return (
          (f = f.replace("::", m)),
          f[0] === ":" && (f = f.slice(1)),
          f[f.length - 1] === ":" && (f = f.slice(0, -1)),
          (u = (function () {
            var y, _, E, R;
            for (E = f.split(":"), R = [], y = 0, _ = E.length; y < _; y++)
              (h = E[y]), R.push(parseInt(h, 16));
            return R;
          })()),
          { parts: u, zoneId: v }
        );
      }),
      (n.IPv6.parser = function (f) {
        var u, d, p, h, m, g, v;
        if (s.native.test(f)) return t(f, 8);
        if (
          (h = f.match(s.transitional)) &&
          ((v = h[6] || ""), (u = t(h[1].slice(0, -1) + v, 6)), u.parts)
        ) {
          for (
            g = [
              parseInt(h[2]),
              parseInt(h[3]),
              parseInt(h[4]),
              parseInt(h[5]),
            ],
              d = 0,
              p = g.length;
            d < p;
            d++
          )
            if (((m = g[d]), !(0 <= m && m <= 255))) return null;
          return (
            u.parts.push((g[0] << 8) | g[1]),
            u.parts.push((g[2] << 8) | g[3]),
            { parts: u.parts, zoneId: u.zoneId }
          );
        }
        return null;
      }),
      (n.IPv4.isIPv4 = n.IPv6.isIPv6 =
        function (f) {
          return this.parser(f) !== null;
        }),
      (n.IPv4.isValid = function (f) {
        try {
          return new this(this.parser(f)), !0;
        } catch {
          return !1;
        }
      }),
      (n.IPv4.isValidFourPartDecimal = function (f) {
        return !!(
          n.IPv4.isValid(f) && f.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)
        );
      }),
      (n.IPv6.isValid = function (f) {
        var u;
        if (typeof f == "string" && f.indexOf(":") === -1) return !1;
        try {
          return (u = this.parser(f)), new this(u.parts, u.zoneId), !0;
        } catch {
          return !1;
        }
      }),
      (n.IPv4.parse = function (f) {
        var u;
        if (((u = this.parser(f)), u === null))
          throw new Error("ipaddr: string is not formatted like ip address");
        return new this(u);
      }),
      (n.IPv6.parse = function (f) {
        var u;
        if (((u = this.parser(f)), u.parts === null))
          throw new Error("ipaddr: string is not formatted like ip address");
        return new this(u.parts, u.zoneId);
      }),
      (n.IPv4.parseCIDR = function (f) {
        var u, d, p;
        if (
          (d = f.match(/^(.+)\/(\d+)$/)) &&
          ((u = parseInt(d[2])), u >= 0 && u <= 32)
        )
          return (
            (p = [this.parse(d[1]), u]),
            Object.defineProperty(p, "toString", {
              value: function () {
                return this.join("/");
              },
            }),
            p
          );
        throw new Error(
          "ipaddr: string is not formatted like an IPv4 CIDR range",
        );
      }),
      (n.IPv4.subnetMaskFromPrefixLength = function (f) {
        var u, d, p;
        if (((f = parseInt(f)), f < 0 || f > 32))
          throw new Error("ipaddr: invalid IPv4 prefix length");
        for (p = [0, 0, 0, 0], d = 0, u = Math.floor(f / 8); d < u; )
          (p[d] = 255), d++;
        return (
          u < 4 && (p[u] = (Math.pow(2, f % 8) - 1) << (8 - (f % 8))),
          new this(p)
        );
      }),
      (n.IPv4.broadcastAddressFromCIDR = function (f) {
        var u, d, p, h, m;
        try {
          for (
            u = this.parseCIDR(f),
              p = u[0].toByteArray(),
              m = this.subnetMaskFromPrefixLength(u[1]).toByteArray(),
              h = [],
              d = 0;
            d < 4;

          )
            h.push(parseInt(p[d], 10) | (parseInt(m[d], 10) ^ 255)), d++;
          return new this(h);
        } catch {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      }),
      (n.IPv4.networkAddressFromCIDR = function (f) {
        var u, d, p, h, m;
        try {
          for (
            u = this.parseCIDR(f),
              p = u[0].toByteArray(),
              m = this.subnetMaskFromPrefixLength(u[1]).toByteArray(),
              h = [],
              d = 0;
            d < 4;

          )
            h.push(parseInt(p[d], 10) & parseInt(m[d], 10)), d++;
          return new this(h);
        } catch {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      }),
      (n.IPv6.parseCIDR = function (f) {
        var u, d, p;
        if (
          (d = f.match(/^(.+)\/(\d+)$/)) &&
          ((u = parseInt(d[2])), u >= 0 && u <= 128)
        )
          return (
            (p = [this.parse(d[1]), u]),
            Object.defineProperty(p, "toString", {
              value: function () {
                return this.join("/");
              },
            }),
            p
          );
        throw new Error(
          "ipaddr: string is not formatted like an IPv6 CIDR range",
        );
      }),
      (n.isValid = function (f) {
        return n.IPv6.isValid(f) || n.IPv4.isValid(f);
      }),
      (n.parse = function (f) {
        if (n.IPv6.isValid(f)) return n.IPv6.parse(f);
        if (n.IPv4.isValid(f)) return n.IPv4.parse(f);
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }),
      (n.parseCIDR = function (f) {
        try {
          return n.IPv6.parseCIDR(f);
        } catch {
          try {
            return n.IPv4.parseCIDR(f);
          } catch {
            throw new Error(
              "ipaddr: the address has neither IPv6 nor IPv4 CIDR format",
            );
          }
        }
      }),
      (n.fromByteArray = function (f) {
        var u;
        if (((u = f.length), u === 4)) return new n.IPv4(f);
        if (u === 16) return new n.IPv6(f);
        throw new Error(
          "ipaddr: the binary input is neither an IPv6 nor IPv4 address",
        );
      }),
      (n.process = function (f) {
        var u;
        return (
          (u = this.parse(f)),
          u.kind() === "ipv6" && u.isIPv4MappedAddress() ? u.toIPv4Address() : u
        );
      });
  }).call(Tn);
})(_v);
var D3 = _v.exports;
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ Xd.exports = H3;
Xd.exports.all = R$;
Xd.exports.compile = k$;
var L3 = T3,
  C$ = D3,
  B3 = /^[0-9]+$/,
  od = C$.isValid,
  Jd = C$.parse,
  W_ = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"],
  };
function R$(e, t) {
  var n = L3(e);
  if (!t) return n;
  typeof t != "function" && (t = k$(t));
  for (var r = 0; r < n.length - 1; r++) t(n[r], r) || (n.length = r + 1);
  return n;
}
function k$(e) {
  if (!e) throw new TypeError("argument is required");
  var t;
  if (typeof e == "string") t = [e];
  else if (Array.isArray(e)) t = e.slice();
  else throw new TypeError("unsupported trust argument");
  for (var n = 0; n < t.length; n++)
    (e = t[n]),
      Object.prototype.hasOwnProperty.call(W_, e) &&
        ((e = W_[e]), t.splice.apply(t, [n, 1].concat(e)), (n += e.length - 1));
  return F3(U3(t));
}
function U3(e) {
  for (var t = new Array(e.length), n = 0; n < e.length; n++) t[n] = j3(e[n]);
  return t;
}
function F3(e) {
  var t = e.length;
  return t === 0 ? q3 : t === 1 ? Q3(e[0]) : G3(e);
}
function j3(e) {
  var t = e.lastIndexOf("/"),
    n = t !== -1 ? e.substring(0, t) : e;
  if (!od(n)) throw new TypeError("invalid IP address: " + n);
  var r = Jd(n);
  t === -1 &&
    r.kind() === "ipv6" &&
    r.isIPv4MappedAddress() &&
    (r = r.toIPv4Address());
  var i = r.kind() === "ipv6" ? 128 : 32,
    a = t !== -1 ? e.substring(t + 1, e.length) : null;
  if (
    (a === null
      ? (a = i)
      : B3.test(a)
      ? (a = parseInt(a, 10))
      : r.kind() === "ipv4" && od(a)
      ? (a = M3(a))
      : (a = null),
    a <= 0 || a > i)
  )
    throw new TypeError("invalid range on address: " + e);
  return [r, a];
}
function M3(e) {
  var t = Jd(e),
    n = t.kind();
  return n === "ipv4" ? t.prefixLengthFromSubnetMask() : null;
}
function H3(e, t) {
  if (!e) throw new TypeError("req argument is required");
  if (!t) throw new TypeError("trust argument is required");
  var n = R$(e, t),
    r = n[n.length - 1];
  return r;
}
function q3() {
  return !1;
}
function G3(e) {
  return function (n) {
    if (!od(n)) return !1;
    for (var r = Jd(n), i, a = r.kind(), s = 0; s < e.length; s++) {
      var o = e[s],
        c = o[0],
        l = c.kind(),
        f = o[1],
        u = r;
      if (a !== l) {
        if (l === "ipv4" && !r.isIPv4MappedAddress()) continue;
        i || (i = l === "ipv4" ? r.toIPv4Address() : r.toIPv4MappedAddress()),
          (u = i);
      }
      if (u.match(c, f)) return !0;
    }
    return !1;
  };
}
function Q3(e) {
  var t = e[0],
    n = t.kind(),
    r = n === "ipv4",
    i = e[1];
  return function (s) {
    if (!od(s)) return !1;
    var o = Jd(s),
      c = o.kind();
    if (c !== n) {
      if (r && !o.isIPv4MappedAddress()) return !1;
      o = r ? o.toIPv4Address() : o.toIPv4MappedAddress();
    }
    return o.match(t, i);
  };
}
var T$ = Xd.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e) {
  var t = mv.Buffer,
    n = v$,
    r = zs(),
    i = wi("express"),
    a = zd,
    s = bv.mime,
    o = b$,
    c = T$,
    l = dv,
    f = X0;
  (e.etag = d({ weak: !1 })),
    (e.wetag = d({ weak: !0 })),
    (e.isAbsolute = function (m) {
      if (
        m[0] === "/" ||
        (m[1] === ":" && (m[2] === "\\" || m[2] === "/")) ||
        m.substring(0, 2) === "\\\\"
      )
        return !0;
    }),
    (e.flatten = i.function(
      a,
      "utils.flatten: use array-flatten npm module instead",
    )),
    (e.normalizeType = function (m) {
      return ~m.indexOf("/") ? u(m) : { value: s.lookup(m), params: {} };
    }),
    (e.normalizeTypes = function (m) {
      for (var g = [], v = 0; v < m.length; ++v) g.push(e.normalizeType(m[v]));
      return g;
    }),
    (e.contentDisposition = i.function(
      n,
      "utils.contentDisposition: use content-disposition npm module instead",
    ));
  function u(m, g) {
    for (
      var v = m.split(/ *; */),
        y = { value: v[0], quality: 1, params: {}, originalIndex: g },
        _ = 1;
      _ < v.length;
      ++_
    ) {
      var E = v[_].split(/ *= */);
      E[0] === "q" ? (y.quality = parseFloat(E[1])) : (y.params[E[0]] = E[1]);
    }
    return y;
  }
  (e.compileETag = function (m) {
    var g;
    if (typeof m == "function") return m;
    switch (m) {
      case !0:
      case "weak":
        g = e.wetag;
        break;
      case !1:
        break;
      case "strong":
        g = e.etag;
        break;
      default:
        throw new TypeError("unknown value for etag function: " + m);
    }
    return g;
  }),
    (e.compileQueryParser = function (g) {
      var v;
      if (typeof g == "function") return g;
      switch (g) {
        case !0:
        case "simple":
          v = f.parse;
          break;
        case !1:
          v = h;
          break;
        case "extended":
          v = p;
          break;
        default:
          throw new TypeError("unknown value for query parser function: " + g);
      }
      return v;
    }),
    (e.compileTrust = function (m) {
      return typeof m == "function"
        ? m
        : m === !0
        ? function () {
            return !0;
          }
        : typeof m == "number"
        ? function (g, v) {
            return v < m;
          }
        : (typeof m == "string" &&
            (m = m.split(",").map(function (g) {
              return g.trim();
            })),
          c.compile(m || []));
    }),
    (e.setCharset = function (g, v) {
      if (!g || !v) return g;
      var y = r.parse(g);
      return (y.parameters.charset = v), r.format(y);
    });
  function d(m) {
    return function (v, y) {
      var _ = t.isBuffer(v) ? v : t.from(v, y);
      return o(_, m);
    };
  }
  function p(m) {
    return l.parse(m, { allowPrototypes: !0 });
  }
  function h() {
    return {};
  }
})(Ha);
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e, t) {
  var n = N8,
    r = l$,
    i = hv,
    a = u$,
    s = f$,
    o = ma("express:application"),
    c = y6,
    l = Ws,
    f = Ha.compileETag,
    u = Ha.compileQueryParser,
    d = Ha.compileTrust,
    p = wi("express"),
    h = zd,
    m = Kd,
    g = pt.resolve,
    v = Md,
    y = Object.prototype.hasOwnProperty,
    _ = Array.prototype.slice,
    E = (e.exports = {}),
    R = "@@symbol:trust_proxy_default";
  (E.init = function () {
    (this.cache = {}),
      (this.engines = {}),
      (this.settings = {}),
      this.defaultConfiguration();
  }),
    (E.defaultConfiguration = function () {
      var w = process.env.NODE_ENV || "development";
      this.enable("x-powered-by"),
        this.set("etag", "weak"),
        this.set("env", w),
        this.set("query parser", "extended"),
        this.set("subdomain offset", 2),
        this.set("trust proxy", !1),
        Object.defineProperty(this.settings, R, {
          configurable: !0,
          value: !0,
        }),
        o("booting in %s mode", w),
        this.on("mount", function (Q) {
          this.settings[R] === !0 &&
            typeof Q.settings["trust proxy fn"] == "function" &&
            (delete this.settings["trust proxy"],
            delete this.settings["trust proxy fn"]),
            v(this.request, Q.request),
            v(this.response, Q.response),
            v(this.engines, Q.engines),
            v(this.settings, Q.settings);
        }),
        (this.locals = Object.create(null)),
        (this.mountpath = "/"),
        (this.locals.settings = this.settings),
        this.set("view", c),
        this.set("views", g("views")),
        this.set("jsonp callback name", "callback"),
        w === "production" && this.enable("view cache"),
        Object.defineProperty(this, "router", {
          get: function () {
            throw new Error(`'app.router' is deprecated!
Please see the 3.x to 4.x migration guide for details on how to update your app.`);
          },
        });
    }),
    (E.lazyrouter = function () {
      this._router ||
        ((this._router = new r({
          caseSensitive: this.enabled("case sensitive routing"),
          strict: this.enabled("strict routing"),
        })),
        this._router.use(s(this.get("query parser fn"))),
        this._router.use(a.init(this)));
    }),
    (E.handle = function (w, O, Q) {
      var j = this._router,
        H = Q || n(w, O, { env: this.get("env"), onerror: A.bind(this) });
      if (!j) {
        o("no routes defined on app"), H();
        return;
      }
      j.handle(w, O, H);
    }),
    (E.use = function (w) {
      var O = 0,
        Q = "/";
      if (typeof w != "function") {
        for (var j = w; Array.isArray(j) && j.length !== 0; ) j = j[0];
        typeof j != "function" && ((O = 1), (Q = w));
      }
      var H = h(_.call(arguments, O));
      if (H.length === 0)
        throw new TypeError("app.use() requires a middleware function");
      this.lazyrouter();
      var q = this._router;
      return (
        H.forEach(function (J) {
          if (!J || !J.handle || !J.set) return q.use(Q, J);
          o(".use app under %s", Q),
            (J.mountpath = Q),
            (J.parent = this),
            q.use(Q, function (z, U, G) {
              var L = z.app;
              J.handle(z, U, function (k) {
                v(z, L.request), v(U, L.response), G(k);
              });
            }),
            J.emit("mount", this);
        }, this),
        this
      );
    }),
    (E.route = function (w) {
      return this.lazyrouter(), this._router.route(w);
    }),
    (E.engine = function (w, O) {
      if (typeof O != "function") throw new Error("callback function required");
      var Q = w[0] !== "." ? "." + w : w;
      return (this.engines[Q] = O), this;
    }),
    (E.param = function (w, O) {
      if ((this.lazyrouter(), Array.isArray(w))) {
        for (var Q = 0; Q < w.length; Q++) this.param(w[Q], O);
        return this;
      }
      return this._router.param(w, O), this;
    }),
    (E.set = function (w, O) {
      if (arguments.length === 1) {
        for (var Q = this.settings; Q && Q !== Object.prototype; ) {
          if (y.call(Q, w)) return Q[w];
          Q = Object.getPrototypeOf(Q);
        }
        return;
      }
      switch ((o('set "%s" to %o', w, O), (this.settings[w] = O), w)) {
        case "etag":
          this.set("etag fn", f(O));
          break;
        case "query parser":
          this.set("query parser fn", u(O));
          break;
        case "trust proxy":
          this.set("trust proxy fn", d(O)),
            Object.defineProperty(this.settings, R, {
              configurable: !0,
              value: !1,
            });
          break;
      }
      return this;
    }),
    (E.path = function () {
      return this.parent ? this.parent.path() + this.mountpath : "";
    }),
    (E.enabled = function (w) {
      return !!this.set(w);
    }),
    (E.disabled = function (w) {
      return !this.set(w);
    }),
    (E.enable = function (w) {
      return this.set(w, !0);
    }),
    (E.disable = function (w) {
      return this.set(w, !1);
    }),
    i.forEach(function (S) {
      E[S] = function (w) {
        if (S === "get" && arguments.length === 1) return this.set(w);
        this.lazyrouter();
        var O = this._router.route(w);
        return O[S].apply(O, _.call(arguments, 1)), this;
      };
    }),
    (E.all = function (w) {
      this.lazyrouter();
      for (
        var O = this._router.route(w), Q = _.call(arguments, 1), j = 0;
        j < i.length;
        j++
      )
        O[i[j]].apply(O, Q);
      return this;
    }),
    (E.del = p.function(E.delete, "app.del: Use app.delete instead")),
    (E.render = function (w, O, Q) {
      var j = this.cache,
        H = Q,
        q = this.engines,
        J = O,
        Z = {},
        z;
      if (
        (typeof O == "function" && ((H = O), (J = {})),
        m(Z, this.locals),
        J._locals && m(Z, J._locals),
        m(Z, J),
        Z.cache == null && (Z.cache = this.enabled("view cache")),
        Z.cache && (z = j[w]),
        !z)
      ) {
        var U = this.get("view");
        if (
          ((z = new U(w, {
            defaultEngine: this.get("view engine"),
            root: this.get("views"),
            engines: q,
          })),
          !z.path)
        ) {
          var G =
              Array.isArray(z.root) && z.root.length > 1
                ? 'directories "' +
                  z.root.slice(0, -1).join('", "') +
                  '" or "' +
                  z.root[z.root.length - 1] +
                  '"'
                : 'directory "' + z.root + '"',
            L = new Error('Failed to lookup view "' + w + '" in views ' + G);
          return (L.view = z), H(L);
        }
        Z.cache && (j[w] = z);
      }
      I(z, Z, H);
    }),
    (E.listen = function () {
      var w = l.createServer(this);
      return w.listen.apply(w, arguments);
    });
  function A(S) {
    this.get("env") !== "test" && console.error(S.stack || S.toString());
  }
  function I(S, w, O) {
    try {
      S.render(w, O);
    } catch (Q) {
      O(Q);
    }
  }
})(MI);
var W3 = MI.exports,
  Ev = { exports: {} },
  wv = { exports: {} };
wv.exports = N$;
wv.exports.preferredCharsets = N$;
var z3 = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function K3(e) {
  for (var t = e.split(","), n = 0, r = 0; n < t.length; n++) {
    var i = V3(t[n].trim(), n);
    i && (t[r++] = i);
  }
  return (t.length = r), t;
}
function V3(e, t) {
  var n = z3.exec(e);
  if (!n) return null;
  var r = n[1],
    i = 1;
  if (n[2])
    for (var a = n[2].split(";"), s = 0; s < a.length; s++) {
      var o = a[s].trim().split("=");
      if (o[0] === "q") {
        i = parseFloat(o[1]);
        break;
      }
    }
  return { charset: r, q: i, i: t };
}
function Y3(e, t, n) {
  for (var r = { o: -1, q: 0, s: 0 }, i = 0; i < t.length; i++) {
    var a = X3(e, t[i], n);
    a && (r.s - a.s || r.q - a.q || r.o - a.o) < 0 && (r = a);
  }
  return r;
}
function X3(e, t, n) {
  var r = 0;
  if (t.charset.toLowerCase() === e.toLowerCase()) r |= 1;
  else if (t.charset !== "*") return null;
  return { i: n, o: t.i, q: t.q, s: r };
}
function N$(e, t) {
  var n = K3(e === void 0 ? "*" : e || "");
  if (!t) return n.filter(K_).sort(z_).map(J3);
  var r = t.map(function (a, s) {
    return Y3(a, n, s);
  });
  return r
    .filter(K_)
    .sort(z_)
    .map(function (a) {
      return t[r.indexOf(a)];
    });
}
function z_(e, t) {
  return t.q - e.q || t.s - e.s || e.o - t.o || e.i - t.i || 0;
}
function J3(e) {
  return e.charset;
}
function K_(e) {
  return e.q > 0;
}
var Z3 = wv.exports,
  xv = { exports: {} };
xv.exports = P$;
xv.exports.preferredEncodings = P$;
var e5 = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function t5(e) {
  for (var t = e.split(","), n = !1, r = 1, i = 0, a = 0; i < t.length; i++) {
    var s = n5(t[i].trim(), i);
    s &&
      ((t[a++] = s), (n = n || O$("identity", s)), (r = Math.min(r, s.q || 1)));
  }
  return n || (t[a++] = { encoding: "identity", q: r, i }), (t.length = a), t;
}
function n5(e, t) {
  var n = e5.exec(e);
  if (!n) return null;
  var r = n[1],
    i = 1;
  if (n[2])
    for (var a = n[2].split(";"), s = 0; s < a.length; s++) {
      var o = a[s].trim().split("=");
      if (o[0] === "q") {
        i = parseFloat(o[1]);
        break;
      }
    }
  return { encoding: r, q: i, i: t };
}
function r5(e, t, n) {
  for (var r = { o: -1, q: 0, s: 0 }, i = 0; i < t.length; i++) {
    var a = O$(e, t[i], n);
    a && (r.s - a.s || r.q - a.q || r.o - a.o) < 0 && (r = a);
  }
  return r;
}
function O$(e, t, n) {
  var r = 0;
  if (t.encoding.toLowerCase() === e.toLowerCase()) r |= 1;
  else if (t.encoding !== "*") return null;
  return { i: n, o: t.i, q: t.q, s: r };
}
function P$(e, t) {
  var n = t5(e || "");
  if (!t) return n.filter(Y_).sort(V_).map(i5);
  var r = t.map(function (a, s) {
    return r5(a, n, s);
  });
  return r
    .filter(Y_)
    .sort(V_)
    .map(function (a) {
      return t[r.indexOf(a)];
    });
}
function V_(e, t) {
  return t.q - e.q || t.s - e.s || e.o - t.o || e.i - t.i || 0;
}
function i5(e) {
  return e.encoding;
}
function Y_(e) {
  return e.q > 0;
}
var a5 = xv.exports,
  Av = { exports: {} };
Av.exports = L$;
Av.exports.preferredLanguages = L$;
var s5 = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function o5(e) {
  for (var t = e.split(","), n = 0, r = 0; n < t.length; n++) {
    var i = D$(t[n].trim(), n);
    i && (t[r++] = i);
  }
  return (t.length = r), t;
}
function D$(e, t) {
  var n = s5.exec(e);
  if (!n) return null;
  var r = n[1],
    i = n[2],
    a = r;
  i && (a += "-" + i);
  var s = 1;
  if (n[3])
    for (var o = n[3].split(";"), c = 0; c < o.length; c++) {
      var l = o[c].split("=");
      l[0] === "q" && (s = parseFloat(l[1]));
    }
  return { prefix: r, suffix: i, q: s, i: t, full: a };
}
function c5(e, t, n) {
  for (var r = { o: -1, q: 0, s: 0 }, i = 0; i < t.length; i++) {
    var a = l5(e, t[i], n);
    a && (r.s - a.s || r.q - a.q || r.o - a.o) < 0 && (r = a);
  }
  return r;
}
function l5(e, t, n) {
  var r = D$(e);
  if (!r) return null;
  var i = 0;
  if (t.full.toLowerCase() === r.full.toLowerCase()) i |= 4;
  else if (t.prefix.toLowerCase() === r.full.toLowerCase()) i |= 2;
  else if (t.full.toLowerCase() === r.prefix.toLowerCase()) i |= 1;
  else if (t.full !== "*") return null;
  return { i: n, o: t.i, q: t.q, s: i };
}
function L$(e, t) {
  var n = o5(e === void 0 ? "*" : e || "");
  if (!t) return n.filter(J_).sort(X_).map(u5);
  var r = t.map(function (a, s) {
    return c5(a, n, s);
  });
  return r
    .filter(J_)
    .sort(X_)
    .map(function (a) {
      return t[r.indexOf(a)];
    });
}
function X_(e, t) {
  return t.q - e.q || t.s - e.s || e.o - t.o || e.i - t.i || 0;
}
function u5(e) {
  return e.full;
}
function J_(e) {
  return e.q > 0;
}
var f5 = Av.exports,
  Sv = { exports: {} };
Sv.exports = U$;
Sv.exports.preferredMediaTypes = U$;
var d5 = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function p5(e) {
  for (var t = y5(e), n = 0, r = 0; n < t.length; n++) {
    var i = B$(t[n].trim(), n);
    i && (t[r++] = i);
  }
  return (t.length = r), t;
}
function B$(e, t) {
  var n = d5.exec(e);
  if (!n) return null;
  var r = Object.create(null),
    i = 1,
    a = n[2],
    s = n[1];
  if (n[3])
    for (var o = b5(n[3]).map(v5), c = 0; c < o.length; c++) {
      var l = o[c],
        f = l[0].toLowerCase(),
        u = l[1],
        d =
          u && u[0] === '"' && u[u.length - 1] === '"'
            ? u.substr(1, u.length - 2)
            : u;
      if (f === "q") {
        i = parseFloat(d);
        break;
      }
      r[f] = d;
    }
  return { type: s, subtype: a, params: r, q: i, i: t };
}
function h5(e, t, n) {
  for (var r = { o: -1, q: 0, s: 0 }, i = 0; i < t.length; i++) {
    var a = m5(e, t[i], n);
    a && (r.s - a.s || r.q - a.q || r.o - a.o) < 0 && (r = a);
  }
  return r;
}
function m5(e, t, n) {
  var r = B$(e),
    i = 0;
  if (!r) return null;
  if (t.type.toLowerCase() == r.type.toLowerCase()) i |= 4;
  else if (t.type != "*") return null;
  if (t.subtype.toLowerCase() == r.subtype.toLowerCase()) i |= 2;
  else if (t.subtype != "*") return null;
  var a = Object.keys(t.params);
  if (a.length > 0)
    if (
      a.every(function (s) {
        return (
          t.params[s] == "*" ||
          (t.params[s] || "").toLowerCase() == (r.params[s] || "").toLowerCase()
        );
      })
    )
      i |= 1;
    else return null;
  return { i: n, o: t.i, q: t.q, s: i };
}
function U$(e, t) {
  var n = p5(e === void 0 ? "*/*" : e || "");
  if (!t) return n.filter(eE).sort(Z_).map(g5);
  var r = t.map(function (a, s) {
    return h5(a, n, s);
  });
  return r
    .filter(eE)
    .sort(Z_)
    .map(function (a) {
      return t[r.indexOf(a)];
    });
}
function Z_(e, t) {
  return t.q - e.q || t.s - e.s || e.o - t.o || e.i - t.i || 0;
}
function g5(e) {
  return e.type + "/" + e.subtype;
}
function eE(e) {
  return e.q > 0;
}
function F$(e) {
  for (var t = 0, n = 0; (n = e.indexOf('"', n)) !== -1; ) t++, n++;
  return t;
}
function v5(e) {
  var t = e.indexOf("="),
    n,
    r;
  return (
    t === -1 ? (n = e) : ((n = e.substr(0, t)), (r = e.substr(t + 1))), [n, r]
  );
}
function y5(e) {
  for (var t = e.split(","), n = 1, r = 0; n < t.length; n++)
    F$(t[r]) % 2 == 0 ? (t[++r] = t[n]) : (t[r] += "," + t[n]);
  return (t.length = r + 1), t;
}
function b5(e) {
  for (var t = e.split(";"), n = 1, r = 0; n < t.length; n++)
    F$(t[r]) % 2 == 0 ? (t[++r] = t[n]) : (t[r] += ";" + t[n]);
  t.length = r + 1;
  for (var n = 0; n < t.length; n++) t[n] = t[n].trim();
  return t;
}
var _5 = Sv.exports;
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var E5 = Z3,
  w5 = a5,
  x5 = f5,
  A5 = _5;
Ev.exports = tn;
Ev.exports.Negotiator = tn;
function tn(e) {
  if (!(this instanceof tn)) return new tn(e);
  this.request = e;
}
tn.prototype.charset = function (t) {
  var n = this.charsets(t);
  return n && n[0];
};
tn.prototype.charsets = function (t) {
  return E5(this.request.headers["accept-charset"], t);
};
tn.prototype.encoding = function (t) {
  var n = this.encodings(t);
  return n && n[0];
};
tn.prototype.encodings = function (t) {
  return w5(this.request.headers["accept-encoding"], t);
};
tn.prototype.language = function (t) {
  var n = this.languages(t);
  return n && n[0];
};
tn.prototype.languages = function (t) {
  return x5(this.request.headers["accept-language"], t);
};
tn.prototype.mediaType = function (t) {
  var n = this.mediaTypes(t);
  return n && n[0];
};
tn.prototype.mediaTypes = function (t) {
  return A5(this.request.headers.accept, t);
};
tn.prototype.preferredCharset = tn.prototype.charset;
tn.prototype.preferredCharsets = tn.prototype.charsets;
tn.prototype.preferredEncoding = tn.prototype.encoding;
tn.prototype.preferredEncodings = tn.prototype.encodings;
tn.prototype.preferredLanguage = tn.prototype.language;
tn.prototype.preferredLanguages = tn.prototype.languages;
tn.prototype.preferredMediaType = tn.prototype.mediaType;
tn.prototype.preferredMediaTypes = tn.prototype.mediaTypes;
var S5 = Ev.exports;
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var I5 = S5,
  $5 = rv,
  C5 = zr;
function zr(e) {
  if (!(this instanceof zr)) return new zr(e);
  (this.headers = e.headers), (this.negotiator = new I5(e));
}
zr.prototype.type = zr.prototype.types = function (e) {
  var t = e;
  if (t && !Array.isArray(t)) {
    t = new Array(arguments.length);
    for (var n = 0; n < t.length; n++) t[n] = arguments[n];
  }
  if (!t || t.length === 0) return this.negotiator.mediaTypes();
  if (!this.headers.accept) return t[0];
  var r = t.map(R5),
    i = this.negotiator.mediaTypes(r.filter(k5)),
    a = i[0];
  return a ? t[r.indexOf(a)] : !1;
};
zr.prototype.encoding = zr.prototype.encodings = function (e) {
  var t = e;
  if (t && !Array.isArray(t)) {
    t = new Array(arguments.length);
    for (var n = 0; n < t.length; n++) t[n] = arguments[n];
  }
  return !t || t.length === 0
    ? this.negotiator.encodings()
    : this.negotiator.encodings(t)[0] || !1;
};
zr.prototype.charset = zr.prototype.charsets = function (e) {
  var t = e;
  if (t && !Array.isArray(t)) {
    t = new Array(arguments.length);
    for (var n = 0; n < t.length; n++) t[n] = arguments[n];
  }
  return !t || t.length === 0
    ? this.negotiator.charsets()
    : this.negotiator.charsets(t)[0] || !1;
};
zr.prototype.lang =
  zr.prototype.langs =
  zr.prototype.language =
  zr.prototype.languages =
    function (e) {
      var t = e;
      if (t && !Array.isArray(t)) {
        t = new Array(arguments.length);
        for (var n = 0; n < t.length; n++) t[n] = arguments[n];
      }
      return !t || t.length === 0
        ? this.negotiator.languages()
        : this.negotiator.languages(t)[0] || !1;
    };
function R5(e) {
  return e.indexOf("/") === -1 ? $5.lookup(e) : e;
}
function k5(e) {
  return typeof e == "string";
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Zd = C5,
  Zl = wi("express"),
  T5 = ha.isIP,
  N5 = ga,
  O5 = Ws,
  P5 = _$,
  D5 = E$,
  L5 = Yl,
  j$ = T$,
  rn = Object.create(O5.IncomingMessage.prototype),
  B5 = rn;
rn.get = rn.header = function (t) {
  if (!t) throw new TypeError("name argument is required to req.get");
  if (typeof t != "string")
    throw new TypeError("name must be a string to req.get");
  var n = t.toLowerCase();
  switch (n) {
    case "referer":
    case "referrer":
      return this.headers.referrer || this.headers.referer;
    default:
      return this.headers[n];
  }
};
rn.accepts = function () {
  var e = Zd(this);
  return e.types.apply(e, arguments);
};
rn.acceptsEncodings = function () {
  var e = Zd(this);
  return e.encodings.apply(e, arguments);
};
rn.acceptsEncoding = Zl.function(
  rn.acceptsEncodings,
  "req.acceptsEncoding: Use acceptsEncodings instead",
);
rn.acceptsCharsets = function () {
  var e = Zd(this);
  return e.charsets.apply(e, arguments);
};
rn.acceptsCharset = Zl.function(
  rn.acceptsCharsets,
  "req.acceptsCharset: Use acceptsCharsets instead",
);
rn.acceptsLanguages = function () {
  var e = Zd(this);
  return e.languages.apply(e, arguments);
};
rn.acceptsLanguage = Zl.function(
  rn.acceptsLanguages,
  "req.acceptsLanguage: Use acceptsLanguages instead",
);
rn.range = function (t, n) {
  var r = this.get("Range");
  if (r) return D5(t, r, n);
};
rn.param = function (t, n) {
  var r = this.params || {},
    i = this.body || {},
    a = this.query || {},
    s = arguments.length === 1 ? "name" : "name, default";
  return (
    Zl("req.param(" + s + "): Use req.params, req.body, or req.query instead"),
    r[t] != null && r.hasOwnProperty(t)
      ? r[t]
      : i[t] != null
      ? i[t]
      : a[t] != null
      ? a[t]
      : n
  );
};
rn.is = function (t) {
  var n = t;
  if (!Array.isArray(t)) {
    n = new Array(arguments.length);
    for (var r = 0; r < n.length; r++) n[r] = arguments[r];
  }
  return N5(this, n);
};
xi(rn, "protocol", function () {
  var t = this.connection.encrypted ? "https" : "http",
    n = this.app.get("trust proxy fn");
  if (!n(this.connection.remoteAddress, 0)) return t;
  var r = this.get("X-Forwarded-Proto") || t,
    i = r.indexOf(",");
  return i !== -1 ? r.substring(0, i).trim() : r.trim();
});
xi(rn, "secure", function () {
  return this.protocol === "https";
});
xi(rn, "ip", function () {
  var t = this.app.get("trust proxy fn");
  return j$(this, t);
});
xi(rn, "ips", function () {
  var t = this.app.get("trust proxy fn"),
    n = j$.all(this, t);
  return n.reverse().pop(), n;
});
xi(rn, "subdomains", function () {
  var t = this.hostname;
  if (!t) return [];
  var n = this.app.get("subdomain offset"),
    r = T5(t) ? [t] : t.split(".").reverse();
  return r.slice(n);
});
xi(rn, "path", function () {
  return L5(this).pathname;
});
xi(rn, "hostname", function () {
  var t = this.app.get("trust proxy fn"),
    n = this.get("X-Forwarded-Host");
  if (
    (!n || !t(this.connection.remoteAddress, 0)
      ? (n = this.get("Host"))
      : n.indexOf(",") !== -1 &&
        (n = n.substring(0, n.indexOf(",")).trimRight()),
    !!n)
  ) {
    var r = n[0] === "[" ? n.indexOf("]") + 1 : 0,
      i = n.indexOf(":", r);
    return i !== -1 ? n.substring(0, i) : n;
  }
});
xi(
  rn,
  "host",
  Zl.function(function () {
    return this.hostname;
  }, "req.host: Use req.hostname instead"),
);
xi(rn, "fresh", function () {
  var e = this.method,
    t = this.res,
    n = t.statusCode;
  return e !== "GET" && e !== "HEAD"
    ? !1
    : (n >= 200 && n < 300) || n === 304
    ? P5(this.headers, {
        etag: t.get("ETag"),
        "last-modified": t.get("Last-Modified"),
      })
    : !1;
});
xi(rn, "stale", function () {
  return !this.fresh;
});
xi(rn, "xhr", function () {
  var t = this.get("X-Requested-With") || "";
  return t.toLowerCase() === "xmlhttprequest";
});
function xi(e, t, n) {
  Object.defineProperty(e, t, { configurable: !0, enumerable: !0, get: n });
}
var M$ = {};
(function (e) {
  var t = pr;
  (e.sign = function (r, i) {
    if (typeof r != "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (typeof i != "string")
      throw new TypeError("Secret string must be provided.");
    return (
      r +
      "." +
      t.createHmac("sha256", i).update(r).digest("base64").replace(/\=+$/, "")
    );
  }),
    (e.unsign = function (r, i) {
      if (typeof r != "string")
        throw new TypeError("Signed cookie string must be provided.");
      if (typeof i != "string")
        throw new TypeError("Secret string must be provided.");
      var a = r.slice(0, r.lastIndexOf(".")),
        s = e.sign(a, i);
      return n(s) == n(r) ? a : !1;
    });
  function n(r) {
    return t.createHash("sha1").update(r).digest("hex");
  }
})(M$);
var Iv = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ Iv.parse = F5;
Iv.serialize = j5;
var U5 = Object.prototype.toString,
  Vu = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function F5(e, t) {
  if (typeof e != "string")
    throw new TypeError("argument str must be a string");
  for (var n = {}, r = t || {}, i = r.decode || M5, a = 0; a < e.length; ) {
    var s = e.indexOf("=", a);
    if (s === -1) break;
    var o = e.indexOf(";", a);
    if (o === -1) o = e.length;
    else if (o < s) {
      a = e.lastIndexOf(";", s - 1) + 1;
      continue;
    }
    var c = e.slice(a, s).trim();
    if (n[c] === void 0) {
      var l = e.slice(s + 1, o).trim();
      l.charCodeAt(0) === 34 && (l = l.slice(1, -1)), (n[c] = G5(l, i));
    }
    a = o + 1;
  }
  return n;
}
function j5(e, t, n) {
  var r = n || {},
    i = r.encode || H5;
  if (typeof i != "function") throw new TypeError("option encode is invalid");
  if (!Vu.test(e)) throw new TypeError("argument name is invalid");
  var a = i(t);
  if (a && !Vu.test(a)) throw new TypeError("argument val is invalid");
  var s = e + "=" + a;
  if (r.maxAge != null) {
    var o = r.maxAge - 0;
    if (isNaN(o) || !isFinite(o))
      throw new TypeError("option maxAge is invalid");
    s += "; Max-Age=" + Math.floor(o);
  }
  if (r.domain) {
    if (!Vu.test(r.domain)) throw new TypeError("option domain is invalid");
    s += "; Domain=" + r.domain;
  }
  if (r.path) {
    if (!Vu.test(r.path)) throw new TypeError("option path is invalid");
    s += "; Path=" + r.path;
  }
  if (r.expires) {
    var c = r.expires;
    if (!q5(c) || isNaN(c.valueOf()))
      throw new TypeError("option expires is invalid");
    s += "; Expires=" + c.toUTCString();
  }
  if (
    (r.httpOnly && (s += "; HttpOnly"),
    r.secure && (s += "; Secure"),
    r.priority)
  ) {
    var l =
      typeof r.priority == "string" ? r.priority.toLowerCase() : r.priority;
    switch (l) {
      case "low":
        s += "; Priority=Low";
        break;
      case "medium":
        s += "; Priority=Medium";
        break;
      case "high":
        s += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (r.sameSite) {
    var f =
      typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite;
    switch (f) {
      case !0:
        s += "; SameSite=Strict";
        break;
      case "lax":
        s += "; SameSite=Lax";
        break;
      case "strict":
        s += "; SameSite=Strict";
        break;
      case "none":
        s += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return s;
}
function M5(e) {
  return e.indexOf("%") !== -1 ? decodeURIComponent(e) : e;
}
function H5(e) {
  return encodeURIComponent(e);
}
function q5(e) {
  return U5.call(e) === "[object Date]" || e instanceof Date;
}
function G5(e, t) {
  try {
    return t(e);
  } catch {
    return e;
  }
}
var $v = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */ $v.exports = W5;
$v.exports.append = H$;
var Q5 = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function H$(e, t) {
  if (typeof e != "string") throw new TypeError("header argument is required");
  if (!t) throw new TypeError("field argument is required");
  for (var n = Array.isArray(t) ? t : tE(String(t)), r = 0; r < n.length; r++)
    if (!Q5.test(n[r]))
      throw new TypeError("field argument contains an invalid header name");
  if (e === "*") return e;
  var i = e,
    a = tE(e.toLowerCase());
  if (n.indexOf("*") !== -1 || a.indexOf("*") !== -1) return "*";
  for (var s = 0; s < n.length; s++) {
    var o = n[s].toLowerCase();
    a.indexOf(o) === -1 && (a.push(o), (i = i ? i + ", " + n[s] : n[s]));
  }
  return i;
}
function tE(e) {
  for (var t = 0, n = [], r = 0, i = 0, a = e.length; i < a; i++)
    switch (e.charCodeAt(i)) {
      case 32:
        r === t && (r = t = i + 1);
        break;
      case 44:
        n.push(e.substring(r, t)), (r = t = i + 1);
        break;
      default:
        t = i + 1;
        break;
    }
  return n.push(e.substring(r, t)), n;
}
function W5(e, t) {
  if (!e || !e.getHeader || !e.setHeader)
    throw new TypeError("res argument is required");
  var n = e.getHeader("Vary") || "",
    r = Array.isArray(n) ? n.join(", ") : String(n);
  (n = H$(r, t)) && e.setHeader("Vary", n);
}
var q$ = $v.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var tl = mv.Buffer,
  G$ = v$,
  z5 = Gi,
  vi = wi("express"),
  K5 = Qd,
  V5 = Wd,
  Y5 = Ws,
  X5 = Ha.isAbsolute,
  J5 = Kl,
  Q$ = pt,
  cd = Hd,
  W$ = Kd,
  Z5 = M$.sign,
  eD = Ha.normalizeType,
  tD = Ha.normalizeTypes,
  nD = Ha.setCharset,
  rD = Iv,
  Cv = bv,
  iD = Q$.extname,
  z$ = Cv.mime,
  aD = Q$.resolve,
  sD = q$,
  cn = Object.create(Y5.ServerResponse.prototype),
  oD = cn,
  cD = /;\s*charset\s*=/;
cn.status = function (t) {
  return (
    (typeof t == "string" || Math.floor(t) !== t) &&
      t > 99 &&
      t < 1e3 &&
      vi(
        "res.status(" +
          JSON.stringify(t) +
          "): use res.status(" +
          Math.floor(t) +
          ") instead",
      ),
    (this.statusCode = t),
    this
  );
};
cn.links = function (e) {
  var t = this.get("Link") || "";
  return (
    t && (t += ", "),
    this.set(
      "Link",
      t +
        Object.keys(e)
          .map(function (n) {
            return "<" + e[n] + '>; rel="' + n + '"';
          })
          .join(", "),
    )
  );
};
cn.send = function (t) {
  var n = t,
    r,
    i = this.req,
    a,
    s = this.app;
  switch (
    (arguments.length === 2 &&
      (typeof arguments[0] != "number" && typeof arguments[1] == "number"
        ? (vi(
            "res.send(body, status): Use res.status(status).send(body) instead",
          ),
          (this.statusCode = arguments[1]))
        : (vi(
            "res.send(status, body): Use res.status(status).send(body) instead",
          ),
          (this.statusCode = arguments[0]),
          (n = arguments[1]))),
    typeof n == "number" &&
      arguments.length === 1 &&
      (this.get("Content-Type") || this.type("txt"),
      vi("res.send(status): Use res.sendStatus(status) instead"),
      (this.statusCode = n),
      (n = cd.message[n])),
    typeof n)
  ) {
    case "string":
      this.get("Content-Type") || this.type("html");
      break;
    case "boolean":
    case "number":
    case "object":
      if (n === null) n = "";
      else if (tl.isBuffer(n)) this.get("Content-Type") || this.type("bin");
      else return this.json(n);
      break;
  }
  typeof n == "string" &&
    ((r = "utf8"),
    (a = this.get("Content-Type")),
    typeof a == "string" && this.set("Content-Type", nD(a, "utf-8")));
  var o = s.get("etag fn"),
    c = !this.get("ETag") && typeof o == "function",
    l;
  n !== void 0 &&
    (tl.isBuffer(n)
      ? (l = n.length)
      : !c && n.length < 1e3
      ? (l = tl.byteLength(n, r))
      : ((n = tl.from(n, r)), (r = void 0), (l = n.length)),
    this.set("Content-Length", l));
  var f;
  return (
    c && l !== void 0 && (f = o(n, r)) && this.set("ETag", f),
    i.fresh && (this.statusCode = 304),
    (this.statusCode === 204 || this.statusCode === 304) &&
      (this.removeHeader("Content-Type"),
      this.removeHeader("Content-Length"),
      this.removeHeader("Transfer-Encoding"),
      (n = "")),
    this.statusCode === 205 &&
      (this.set("Content-Length", "0"),
      this.removeHeader("Transfer-Encoding"),
      (n = "")),
    i.method === "HEAD" ? this.end() : this.end(n, r),
    this
  );
};
cn.json = function (t) {
  var n = t;
  arguments.length === 2 &&
    (typeof arguments[1] == "number"
      ? (vi("res.json(obj, status): Use res.status(status).json(obj) instead"),
        (this.statusCode = arguments[1]))
      : (vi("res.json(status, obj): Use res.status(status).json(obj) instead"),
        (this.statusCode = arguments[0]),
        (n = arguments[1])));
  var r = this.app,
    i = r.get("json escape"),
    a = r.get("json replacer"),
    s = r.get("json spaces"),
    o = V$(n, a, s, i);
  return (
    this.get("Content-Type") || this.set("Content-Type", "application/json"),
    this.send(o)
  );
};
cn.jsonp = function (t) {
  var n = t;
  arguments.length === 2 &&
    (typeof arguments[1] == "number"
      ? (vi(
          "res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead",
        ),
        (this.statusCode = arguments[1]))
      : (vi(
          "res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead",
        ),
        (this.statusCode = arguments[0]),
        (n = arguments[1])));
  var r = this.app,
    i = r.get("json escape"),
    a = r.get("json replacer"),
    s = r.get("json spaces"),
    o = V$(n, a, s, i),
    c = this.req.query[r.get("jsonp callback name")];
  return (
    this.get("Content-Type") ||
      (this.set("X-Content-Type-Options", "nosniff"),
      this.set("Content-Type", "application/json")),
    Array.isArray(c) && (c = c[0]),
    typeof c == "string" &&
      c.length !== 0 &&
      (this.set("X-Content-Type-Options", "nosniff"),
      this.set("Content-Type", "text/javascript"),
      (c = c.replace(/[^\[\]\w$.]/g, "")),
      o === void 0
        ? (o = "")
        : typeof o == "string" &&
          (o = o.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029")),
      (o = "/**/ typeof " + c + " === 'function' && " + c + "(" + o + ");")),
    this.send(o)
  );
};
cn.sendStatus = function (t) {
  var n = cd.message[t] || String(t);
  return (this.statusCode = t), this.type("txt"), this.send(n);
};
cn.sendFile = function (t, n, r) {
  var i = r,
    a = this.req,
    s = this,
    o = a.next,
    c = n || {};
  if (!t) throw new TypeError("path argument is required to res.sendFile");
  if (typeof t != "string")
    throw new TypeError("path must be a string to res.sendFile");
  if ((typeof n == "function" && ((i = n), (c = {})), !c.root && !X5(t)))
    throw new TypeError(
      "path must be absolute or specify root to res.sendFile",
    );
  var l = encodeURI(t),
    f = Cv(a, l, c);
  K$(s, f, c, function (u) {
    if (i) return i(u);
    if (u && u.code === "EISDIR") return o();
    u && u.code !== "ECONNABORTED" && u.syscall !== "write" && o(u);
  });
};
cn.sendfile = function (e, t, n) {
  var r = n,
    i = this.req,
    a = this,
    s = i.next,
    o = t || {};
  typeof t == "function" && ((r = t), (o = {}));
  var c = Cv(i, e, o);
  K$(a, c, o, function (l) {
    if (r) return r(l);
    if (l && l.code === "EISDIR") return s();
    l && l.code !== "ECONNABORTED" && l.syscall !== "write" && s(l);
  });
};
cn.sendfile = vi.function(
  cn.sendfile,
  "res.sendfile: Use res.sendFile instead",
);
cn.download = function (t, n, r, i) {
  var a = i,
    s = n,
    o = r || null;
  typeof n == "function"
    ? ((a = n), (s = null), (o = null))
    : typeof r == "function" && ((a = r), (o = null)),
    typeof n == "object" &&
      (typeof r == "function" || r === void 0) &&
      ((s = null), (o = n));
  var c = { "Content-Disposition": G$(s || t) };
  if (o && o.headers)
    for (var l = Object.keys(o.headers), f = 0; f < l.length; f++) {
      var u = l[f];
      u.toLowerCase() !== "content-disposition" && (c[u] = o.headers[u]);
    }
  (o = Object.create(o)), (o.headers = c);
  var d = o.root ? t : aD(t);
  return this.sendFile(d, o, a);
};
cn.contentType = cn.type = function (t) {
  var n = t.indexOf("/") === -1 ? z$.lookup(t) : t;
  return this.set("Content-Type", n);
};
cn.format = function (e) {
  var t = this.req,
    n = t.next,
    r = Object.keys(e).filter(function (a) {
      return a !== "default";
    }),
    i = r.length > 0 ? t.accepts(r) : !1;
  return (
    this.vary("Accept"),
    i
      ? (this.set("Content-Type", eD(i).value), e[i](t, this, n))
      : e.default
      ? e.default(t, this, n)
      : n(
          z5(406, {
            types: tD(r).map(function (a) {
              return a.value;
            }),
          }),
        ),
    this
  );
};
cn.attachment = function (t) {
  return t && this.type(iD(t)), this.set("Content-Disposition", G$(t)), this;
};
cn.append = function (t, n) {
  var r = this.get(t),
    i = n;
  return (
    r &&
      (i = Array.isArray(r)
        ? r.concat(n)
        : Array.isArray(n)
        ? [r].concat(n)
        : [r, n]),
    this.set(t, i)
  );
};
cn.set = cn.header = function (t, n) {
  if (arguments.length === 2) {
    var r = Array.isArray(n) ? n.map(String) : String(n);
    if (t.toLowerCase() === "content-type") {
      if (Array.isArray(r))
        throw new TypeError("Content-Type cannot be set to an Array");
      if (!cD.test(r)) {
        var i = z$.charsets.lookup(r.split(";")[0]);
        i && (r += "; charset=" + i.toLowerCase());
      }
    }
    this.setHeader(t, r);
  } else for (var a in t) this.set(a, t[a]);
  return this;
};
cn.get = function (e) {
  return this.getHeader(e);
};
cn.clearCookie = function (t, n) {
  var r = W$({ expires: new Date(1), path: "/" }, n);
  return this.cookie(t, "", r);
};
cn.cookie = function (e, t, n) {
  var r = W$({}, n),
    i = this.req.secret,
    a = r.signed;
  if (a && !i)
    throw new Error('cookieParser("secret") required for signed cookies');
  var s = typeof t == "object" ? "j:" + JSON.stringify(t) : String(t);
  if ((a && (s = "s:" + Z5(s, i)), r.maxAge != null)) {
    var o = r.maxAge - 0;
    isNaN(o) ||
      ((r.expires = new Date(Date.now() + o)),
      (r.maxAge = Math.floor(o / 1e3)));
  }
  return (
    r.path == null && (r.path = "/"),
    this.append("Set-Cookie", rD.serialize(e, String(s), r)),
    this
  );
};
cn.location = function (t) {
  var n = t;
  return (
    t === "back" && (n = this.req.get("Referrer") || "/"),
    this.set("Location", K5(n))
  );
};
cn.redirect = function (t) {
  var n = t,
    r,
    i = 302;
  arguments.length === 2 &&
    (typeof arguments[0] == "number"
      ? ((i = arguments[0]), (n = arguments[1]))
      : (vi("res.redirect(url, status): Use res.redirect(status, url) instead"),
        (i = arguments[1]))),
    (n = this.location(n).get("Location")),
    this.format({
      text: function () {
        r = cd.message[i] + ". Redirecting to " + n;
      },
      html: function () {
        var a = V5(n);
        r =
          "<p>" +
          cd.message[i] +
          '. Redirecting to <a href="' +
          a +
          '">' +
          a +
          "</a></p>";
      },
      default: function () {
        r = "";
      },
    }),
    (this.statusCode = i),
    this.set("Content-Length", tl.byteLength(r)),
    this.req.method === "HEAD" ? this.end() : this.end(r);
};
cn.vary = function (e) {
  return !e || (Array.isArray(e) && !e.length)
    ? (vi("res.vary(): Provide a field name"), this)
    : (sD(this, e), this);
};
cn.render = function (t, n, r) {
  var i = this.req.app,
    a = r,
    s = n || {},
    o = this.req,
    c = this;
  typeof n == "function" && ((a = n), (s = {})),
    (s._locals = c.locals),
    (a =
      a ||
      function (l, f) {
        if (l) return o.next(l);
        c.send(f);
      }),
    i.render(t, s, a);
};
function K$(e, t, n, r) {
  var i = !1,
    a;
  function s() {
    if (!i) {
      i = !0;
      var p = new Error("Request aborted");
      (p.code = "ECONNABORTED"), r(p);
    }
  }
  function o() {
    if (!i) {
      i = !0;
      var p = new Error("EISDIR, read");
      (p.code = "EISDIR"), r(p);
    }
  }
  function c(p) {
    i || ((i = !0), r(p));
  }
  function l() {
    i || ((i = !0), r());
  }
  function f() {
    a = !1;
  }
  function u(p) {
    if (p && p.code === "ECONNRESET") return s();
    if (p) return c(p);
    i ||
      setImmediate(function () {
        if (a !== !1 && !i) {
          s();
          return;
        }
        i || ((i = !0), r());
      });
  }
  function d() {
    a = !0;
  }
  t.on("directory", o),
    t.on("end", l),
    t.on("error", c),
    t.on("file", f),
    t.on("stream", d),
    J5(e, u),
    n.headers &&
      t.on("headers", function (h) {
        for (var m = n.headers, g = Object.keys(m), v = 0; v < g.length; v++) {
          var y = g[v];
          h.setHeader(y, m[y]);
        }
      }),
    t.pipe(e);
}
function V$(e, t, n, r) {
  var i = t || n ? JSON.stringify(e, t, n) : JSON.stringify(e);
  return (
    r &&
      typeof i == "string" &&
      (i = i.replace(/[<>&]/g, function (a) {
        switch (a.charCodeAt(0)) {
          case 60:
            return "\\u003c";
          case 62:
            return "\\u003e";
          case 38:
            return "\\u0026";
          default:
            return a;
        }
      })),
    i
  );
}
var Yu = { exports: {} };
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */ var nE;
function lD() {
  if (nE) return Yu.exports;
  nE = 1;
  var e = Qd,
    t = Wd,
    n = Yl,
    r = pt.resolve,
    i = bv,
    a = Ya;
  (Yu.exports = s), (Yu.exports.mime = i.mime);
  function s(u, d) {
    if (!u) throw new TypeError("root path required");
    if (typeof u != "string") throw new TypeError("root path must be a string");
    var p = Object.create(d || null),
      h = p.fallthrough !== !1,
      m = p.redirect !== !1,
      g = p.setHeaders;
    if (g && typeof g != "function")
      throw new TypeError("option setHeaders must be function");
    (p.maxage = p.maxage || p.maxAge || 0), (p.root = r(u));
    var v = m ? f() : l();
    return function (_, E, R) {
      if (_.method !== "GET" && _.method !== "HEAD") {
        if (h) return R();
        (E.statusCode = 405),
          E.setHeader("Allow", "GET, HEAD"),
          E.setHeader("Content-Length", "0"),
          E.end();
        return;
      }
      var A = !h,
        I = n.original(_),
        S = n(_).pathname;
      S === "/" && I.pathname.substr(-1) !== "/" && (S = "");
      var w = i(_, S, p);
      w.on("directory", v),
        g && w.on("headers", g),
        h &&
          w.on("file", function () {
            A = !0;
          }),
        w.on("error", function (Q) {
          if (A || !(Q.statusCode < 500)) {
            R(Q);
            return;
          }
          R();
        }),
        w.pipe(E);
    };
  }
  function o(u) {
    for (var d = 0; d < u.length && u.charCodeAt(d) === 47; d++);
    return d > 1 ? "/" + u.substr(d) : u;
  }
  function c(u, d) {
    return (
      `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>` +
      u +
      `</title>
</head>
<body>
<pre>` +
      d +
      `</pre>
</body>
</html>
`
    );
  }
  function l() {
    return function () {
      this.error(404);
    };
  }
  function f() {
    return function (d) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var p = n.original(this.req);
      (p.path = null), (p.pathname = o(p.pathname + "/"));
      var h = e(a.format(p)),
        m = c(
          "Redirecting",
          'Redirecting to <a href="' + t(h) + '">' + t(h) + "</a>",
        );
      (d.statusCode = 301),
        d.setHeader("Content-Type", "text/html; charset=UTF-8"),
        d.setHeader("Content-Length", Buffer.byteLength(m)),
        d.setHeader("Content-Security-Policy", "default-src 'none'"),
        d.setHeader("X-Content-Type-Options", "nosniff"),
        d.setHeader("Location", h),
        d.end(m);
    };
  }
  return Yu.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e, t) {
  var n = c8,
    r = Hi.EventEmitter,
    i = l8,
    a = W3,
    s = a$,
    o = l$,
    c = B5,
    l = oD;
  t = e.exports = f;
  function f() {
    var d = function (p, h, m) {
      d.handle(p, h, m);
    };
    return (
      i(d, r.prototype, !1),
      i(d, a, !1),
      (d.request = Object.create(c, {
        app: { configurable: !0, enumerable: !0, writable: !0, value: d },
      })),
      (d.response = Object.create(l, {
        app: { configurable: !0, enumerable: !0, writable: !0, value: d },
      })),
      d.init(),
      d
    );
  }
  (t.application = a),
    (t.request = c),
    (t.response = l),
    (t.Route = s),
    (t.Router = o),
    (t.json = n.json),
    (t.query = f$),
    (t.raw = n.raw),
    (t.static = lD()),
    (t.text = n.text),
    (t.urlencoded = n.urlencoded);
  var u = [
    "bodyParser",
    "compress",
    "cookieSession",
    "session",
    "logger",
    "cookieParser",
    "favicon",
    "responseTime",
    "errorHandler",
    "timeout",
    "methodOverride",
    "vhost",
    "csrf",
    "directory",
    "limit",
    "multipart",
    "staticCache",
  ];
  u.forEach(function (d) {
    Object.defineProperty(t, d, {
      get: function () {
        throw new Error(
          "Most middleware (like " +
            d +
            ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.",
        );
      },
      configurable: !0,
    });
  });
})(Ug, Ug.exports);
var uD = Ug.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var fD = uD;
const dD = Wl(fD);
var t0 = { exports: {} },
  Xu = { exports: {} },
  Ju = { exports: {} },
  Zu = { exports: {} },
  Uh,
  rE;
function pD() {
  if (rE) return Uh;
  rE = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    i = r * 365.25;
  Uh = function (l, f) {
    f = f || {};
    var u = typeof l;
    if (u === "string" && l.length > 0) return a(l);
    if (u === "number" && isNaN(l) === !1) return f.long ? o(l) : s(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(l),
    );
  };
  function a(l) {
    if (((l = String(l)), !(l.length > 100))) {
      var f =
        /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
          l,
        );
      if (f) {
        var u = parseFloat(f[1]),
          d = (f[2] || "ms").toLowerCase();
        switch (d) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return u * i;
          case "days":
          case "day":
          case "d":
            return u * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return u * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return u * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return u * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return u;
          default:
            return;
        }
      }
    }
  }
  function s(l) {
    return l >= r
      ? Math.round(l / r) + "d"
      : l >= n
      ? Math.round(l / n) + "h"
      : l >= t
      ? Math.round(l / t) + "m"
      : l >= e
      ? Math.round(l / e) + "s"
      : l + "ms";
  }
  function o(l) {
    return (
      c(l, r, "day") ||
      c(l, n, "hour") ||
      c(l, t, "minute") ||
      c(l, e, "second") ||
      l + " ms"
    );
  }
  function c(l, f, u) {
    if (!(l < f))
      return l < f * 1.5
        ? Math.floor(l / f) + " " + u
        : Math.ceil(l / f) + " " + u + "s";
  }
  return Uh;
}
var iE;
function Y$() {
  return (
    iE ||
      ((iE = 1),
      (function (e, t) {
        (t = e.exports = i.debug = i.default = i),
          (t.coerce = c),
          (t.disable = s),
          (t.enable = a),
          (t.enabled = o),
          (t.humanize = pD()),
          (t.names = []),
          (t.skips = []),
          (t.formatters = {});
        var n;
        function r(l) {
          var f = 0,
            u;
          for (u in l) (f = (f << 5) - f + l.charCodeAt(u)), (f |= 0);
          return t.colors[Math.abs(f) % t.colors.length];
        }
        function i(l) {
          function f() {
            if (f.enabled) {
              var u = f,
                d = +new Date(),
                p = d - (n || d);
              (u.diff = p), (u.prev = n), (u.curr = d), (n = d);
              for (
                var h = new Array(arguments.length), m = 0;
                m < h.length;
                m++
              )
                h[m] = arguments[m];
              (h[0] = t.coerce(h[0])),
                typeof h[0] != "string" && h.unshift("%O");
              var g = 0;
              (h[0] = h[0].replace(/%([a-zA-Z%])/g, function (y, _) {
                if (y === "%%") return y;
                g++;
                var E = t.formatters[_];
                if (typeof E == "function") {
                  var R = h[g];
                  (y = E.call(u, R)), h.splice(g, 1), g--;
                }
                return y;
              })),
                t.formatArgs.call(u, h);
              var v = f.log || t.log || console.log.bind(console);
              v.apply(u, h);
            }
          }
          return (
            (f.namespace = l),
            (f.enabled = t.enabled(l)),
            (f.useColors = t.useColors()),
            (f.color = r(l)),
            typeof t.init == "function" && t.init(f),
            f
          );
        }
        function a(l) {
          t.save(l), (t.names = []), (t.skips = []);
          for (
            var f = (typeof l == "string" ? l : "").split(/[\s,]+/),
              u = f.length,
              d = 0;
            d < u;
            d++
          )
            f[d] &&
              ((l = f[d].replace(/\*/g, ".*?")),
              l[0] === "-"
                ? t.skips.push(new RegExp("^" + l.substr(1) + "$"))
                : t.names.push(new RegExp("^" + l + "$")));
        }
        function s() {
          t.enable("");
        }
        function o(l) {
          var f, u;
          for (f = 0, u = t.skips.length; f < u; f++)
            if (t.skips[f].test(l)) return !1;
          for (f = 0, u = t.names.length; f < u; f++)
            if (t.names[f].test(l)) return !0;
          return !1;
        }
        function c(l) {
          return l instanceof Error ? l.stack || l.message : l;
        }
      })(Zu, Zu.exports)),
    Zu.exports
  );
}
var aE;
function hD() {
  return (
    aE ||
      ((aE = 1),
      (function (e, t) {
        (t = e.exports = Y$()),
          (t.log = i),
          (t.formatArgs = r),
          (t.save = a),
          (t.load = s),
          (t.useColors = n),
          (t.storage =
            typeof chrome < "u" && typeof chrome.storage < "u"
              ? chrome.storage.local
              : o()),
          (t.colors = [
            "lightseagreen",
            "forestgreen",
            "goldenrod",
            "dodgerblue",
            "darkorchid",
            "crimson",
          ]);
        function n() {
          return typeof window < "u" &&
            window.process &&
            window.process.type === "renderer"
            ? !0
            : (typeof document < "u" &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
                (typeof window < "u" &&
                  window.console &&
                  (window.console.firebug ||
                    (window.console.exception && window.console.table))) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                  parseInt(RegExp.$1, 10) >= 31) ||
                (typeof navigator < "u" &&
                  navigator.userAgent &&
                  navigator.userAgent
                    .toLowerCase()
                    .match(/applewebkit\/(\d+)/));
        }
        t.formatters.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
        function r(c) {
          var l = this.useColors;
          if (
            ((c[0] =
              (l ? "%c" : "") +
              this.namespace +
              (l ? " %c" : " ") +
              c[0] +
              (l ? "%c " : " ") +
              "+" +
              t.humanize(this.diff)),
            !!l)
          ) {
            var f = "color: " + this.color;
            c.splice(1, 0, f, "color: inherit");
            var u = 0,
              d = 0;
            c[0].replace(/%[a-zA-Z%]/g, function (p) {
              p !== "%%" && (u++, p === "%c" && (d = u));
            }),
              c.splice(d, 0, f);
          }
        }
        function i() {
          return (
            typeof console == "object" &&
            console.log &&
            Function.prototype.apply.call(console.log, console, arguments)
          );
        }
        function a(c) {
          try {
            c == null ? t.storage.removeItem("debug") : (t.storage.debug = c);
          } catch {}
        }
        function s() {
          var c;
          try {
            c = t.storage.debug;
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        t.enable(s());
        function o() {
          try {
            return window.localStorage;
          } catch {}
        }
      })(Ju, Ju.exports)),
    Ju.exports
  );
}
var ef = { exports: {} },
  sE;
function mD() {
  return (
    sE ||
      ((sE = 1),
      (function (e, t) {
        var n = hc,
          r = wr;
        (t = e.exports = Y$()),
          (t.init = d),
          (t.log = c),
          (t.formatArgs = o),
          (t.save = l),
          (t.load = f),
          (t.useColors = s),
          (t.colors = [6, 2, 3, 4, 5, 1]),
          (t.inspectOpts = Object.keys(process.env)
            .filter(function (p) {
              return /^debug_/i.test(p);
            })
            .reduce(function (p, h) {
              var m = h
                  .substring(6)
                  .toLowerCase()
                  .replace(/_([a-z])/g, function (v, y) {
                    return y.toUpperCase();
                  }),
                g = process.env[h];
              return (
                /^(yes|on|true|enabled)$/i.test(g)
                  ? (g = !0)
                  : /^(no|off|false|disabled)$/i.test(g)
                  ? (g = !1)
                  : g === "null"
                  ? (g = null)
                  : (g = Number(g)),
                (p[m] = g),
                p
              );
            }, {}));
        var i = parseInt(process.env.DEBUG_FD, 10) || 2;
        i !== 1 &&
          i !== 2 &&
          r.deprecate(
            function () {},
            "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)",
          )();
        var a = i === 1 ? process.stdout : i === 2 ? process.stderr : u(i);
        function s() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(i);
        }
        (t.formatters.o = function (p) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(p, this.inspectOpts)
              .split(
                `
`,
              )
              .map(function (h) {
                return h.trim();
              })
              .join(" ")
          );
        }),
          (t.formatters.O = function (p) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(p, this.inspectOpts)
            );
          });
        function o(p) {
          var h = this.namespace,
            m = this.useColors;
          if (m) {
            var g = this.color,
              v = "  \x1B[3" + g + ";1m" + h + " \x1B[0m";
            (p[0] =
              v +
              p[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + v,
                )),
              p.push("\x1B[3" + g + "m+" + t.humanize(this.diff) + "\x1B[0m");
          } else p[0] = new Date().toUTCString() + " " + h + " " + p[0];
        }
        function c() {
          return a.write(
            r.format.apply(r, arguments) +
              `
`,
          );
        }
        function l(p) {
          p == null ? delete process.env.DEBUG : (process.env.DEBUG = p);
        }
        function f() {
          return process.env.DEBUG;
        }
        function u(p) {
          var h,
            m = process.binding("tty_wrap");
          switch (m.guessHandleType(p)) {
            case "TTY":
              (h = new n.WriteStream(p)),
                (h._type = "tty"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            case "FILE":
              var g = Xt;
              (h = new g.SyncWriteStream(p, { autoClose: !1 })),
                (h._type = "fs");
              break;
            case "PIPE":
            case "TCP":
              var v = ha;
              (h = new v.Socket({ fd: p, readable: !1, writable: !0 })),
                (h.readable = !1),
                (h.read = null),
                (h._type = "pipe"),
                h._handle && h._handle.unref && h._handle.unref();
              break;
            default:
              throw new Error("Implement me. Unknown stream file type!");
          }
          return (h.fd = p), (h._isStdio = !0), h;
        }
        function d(p) {
          p.inspectOpts = {};
          for (var h = Object.keys(t.inspectOpts), m = 0; m < h.length; m++)
            p.inspectOpts[h[m]] = t.inspectOpts[h[m]];
        }
        t.enable(f());
      })(ef, ef.exports)),
    ef.exports
  );
}
var oE;
function ep() {
  return (
    oE ||
      ((oE = 1),
      typeof process < "u" && process.type === "renderer"
        ? (Xu.exports = hD())
        : (Xu.exports = mD())),
    Xu.exports
  );
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */ var Fh, cE;
function gD() {
  if (cE) return Fh;
  cE = 1;
  var e = f(),
    t = qi(),
    n = Gi,
    r = qd(),
    i = zl;
  Fh = o;
  var a = /^Encoding not recognized: /;
  function s(d) {
    if (!d) return null;
    try {
      return r.getDecoder(d);
    } catch (p) {
      throw a.test(p.message)
        ? n(415, "specified encoding unsupported", {
            encoding: d,
            type: "encoding.unsupported",
          })
        : p;
    }
  }
  function o(d, p, h) {
    var m = h,
      g = p || {};
    if (d === void 0) throw new TypeError("argument stream is required");
    if (typeof d != "object" || d === null || typeof d.on != "function")
      throw new TypeError("argument stream must be a stream");
    if (
      ((p === !0 || typeof p == "string") && (g = { encoding: p }),
      typeof p == "function" && ((m = p), (g = {})),
      m !== void 0 && typeof m != "function")
    )
      throw new TypeError("argument callback must be a function");
    if (!m && !Tn.Promise) throw new TypeError("argument callback is required");
    var v = g.encoding !== !0 ? g.encoding : "utf-8",
      y = t.parse(g.limit),
      _ = g.length != null && !isNaN(g.length) ? parseInt(g.length, 10) : null;
    return m
      ? l(d, v, _, y, u(m))
      : new Promise(function (R, A) {
          l(d, v, _, y, function (S, w) {
            if (S) return A(S);
            R(w);
          });
        });
  }
  function c(d) {
    i(d), typeof d.pause == "function" && d.pause();
  }
  function l(d, p, h, m, g) {
    var v = !1,
      y = !0;
    if (m !== null && h !== null && h > m)
      return I(
        n(413, "request entity too large", {
          expected: h,
          length: h,
          limit: m,
          type: "entity.too.large",
        }),
      );
    var _ = d._readableState;
    if (d._decoder || (_ && (_.encoding || _.decoder)))
      return I(
        n(500, "stream encoding should not be set", {
          type: "stream.encoding.set",
        }),
      );
    if (typeof d.readable < "u" && !d.readable)
      return I(
        n(500, "stream is not readable", { type: "stream.not.readable" }),
      );
    var E = 0,
      R;
    try {
      R = s(p);
    } catch (j) {
      return I(j);
    }
    var A = R ? "" : [];
    d.on("aborted", S),
      d.on("close", Q),
      d.on("data", w),
      d.on("end", O),
      d.on("error", O),
      (y = !1);
    function I() {
      for (var j = new Array(arguments.length), H = 0; H < j.length; H++)
        j[H] = arguments[H];
      (v = !0), y ? process.nextTick(q) : q();
      function q() {
        Q(), j[0] && c(d), g.apply(null, j);
      }
    }
    function S() {
      v ||
        I(
          n(400, "request aborted", {
            code: "ECONNABORTED",
            expected: h,
            length: h,
            received: E,
            type: "request.aborted",
          }),
        );
    }
    function w(j) {
      v ||
        ((E += j.length),
        m !== null && E > m
          ? I(
              n(413, "request entity too large", {
                limit: m,
                received: E,
                type: "entity.too.large",
              }),
            )
          : R
          ? (A += R.write(j))
          : A.push(j));
    }
    function O(j) {
      if (!v) {
        if (j) return I(j);
        if (h !== null && E !== h)
          I(
            n(400, "request size did not match content length", {
              expected: h,
              length: h,
              received: E,
              type: "request.size.invalid",
            }),
          );
        else {
          var H = R ? A + (R.end() || "") : Buffer.concat(A);
          I(null, H);
        }
      }
    }
    function Q() {
      (A = null),
        d.removeListener("aborted", S),
        d.removeListener("data", w),
        d.removeListener("end", O),
        d.removeListener("error", O),
        d.removeListener("close", Q);
    }
  }
  function f() {
    try {
      return require("async_hooks");
    } catch {
      return {};
    }
  }
  function u(d) {
    var p;
    return (
      e.AsyncResource &&
        (p = new e.AsyncResource(d.name || "bound-anonymous-fn")),
      !p || !p.runInAsyncScope ? d : p.runInAsyncScope.bind(p, d, null)
    );
  }
  return Fh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var jh, lE;
function tp() {
  if (lE) return jh;
  lE = 1;
  var e = Gi,
    t = ev,
    n = gD(),
    r = qd(),
    i = Kl,
    a = zl,
    s = mc;
  jh = o;
  function o(f, u, d, p, h, m) {
    var g,
      v = m,
      y;
    f._body = !0;
    var _ = v.encoding !== null ? v.encoding : null,
      E = v.verify;
    try {
      (y = c(f, h, v.inflate)), (g = y.length), (y.length = void 0);
    } catch (R) {
      return d(R);
    }
    if (
      ((v.length = g),
      (v.encoding = E ? null : _),
      v.encoding === null && _ !== null && !r.encodingExists(_))
    )
      return d(
        e(415, 'unsupported charset "' + _.toUpperCase() + '"', {
          charset: _.toLowerCase(),
          type: "charset.unsupported",
        }),
      );
    h("read body"),
      n(y, v, function (R, A) {
        if (R) {
          var I;
          R.type === "encoding.unsupported"
            ? (I = e(415, 'unsupported charset "' + _.toUpperCase() + '"', {
                charset: _.toLowerCase(),
                type: "charset.unsupported",
              }))
            : (I = e(400, R)),
            y !== f && (a(f), t(y, !0)),
            l(f, function () {
              d(e(400, I));
            });
          return;
        }
        if (E)
          try {
            h("verify body"), E(f, u, A, _);
          } catch (w) {
            d(e(403, w, { body: A, type: w.type || "entity.verify.failed" }));
            return;
          }
        var S = A;
        try {
          h("parse body"),
            (S = typeof A != "string" && _ !== null ? r.decode(A, _) : A),
            (f.body = p(S));
        } catch (w) {
          d(e(400, w, { body: S, type: w.type || "entity.parse.failed" }));
          return;
        }
        d();
      });
  }
  function c(f, u, d) {
    var p = (f.headers["content-encoding"] || "identity").toLowerCase(),
      h = f.headers["content-length"],
      m;
    if ((u('content-encoding "%s"', p), d === !1 && p !== "identity"))
      throw e(415, "content encoding unsupported", {
        encoding: p,
        type: "encoding.unsupported",
      });
    switch (p) {
      case "deflate":
        (m = s.createInflate()), u("inflate body"), f.pipe(m);
        break;
      case "gzip":
        (m = s.createGunzip()), u("gunzip body"), f.pipe(m);
        break;
      case "identity":
        (m = f), (m.length = h);
        break;
      default:
        throw e(415, 'unsupported content encoding "' + p + '"', {
          encoding: p,
          type: "encoding.unsupported",
        });
    }
    return m;
  }
  function l(f, u) {
    i.isFinished(f) ? u(null) : (i(f, u), f.resume());
  }
  return jh;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Mh, uE;
function vD() {
  if (uE) return Mh;
  uE = 1;
  var e = qi(),
    t = zs(),
    n = Gi,
    r = ep()("body-parser:json"),
    i = tp(),
    a = ga;
  Mh = l;
  var s = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/,
    o = "#",
    c = /#+/g;
  function l(m) {
    var g = m || {},
      v = typeof g.limit != "number" ? e.parse(g.limit || "100kb") : g.limit,
      y = g.inflate !== !1,
      _ = g.reviver,
      E = g.strict !== !1,
      R = g.type || "application/json",
      A = g.verify || !1;
    if (A !== !1 && typeof A != "function")
      throw new TypeError("option verify must be function");
    var I = typeof R != "function" ? h(R) : R;
    function S(w) {
      if (w.length === 0) return {};
      if (E) {
        var O = u(w);
        if (O !== "{" && O !== "[") throw (r("strict violation"), f(w, O));
      }
      try {
        return r("parse json"), JSON.parse(w, _);
      } catch (Q) {
        throw p(Q, { message: Q.message, stack: Q.stack });
      }
    }
    return function (O, Q, j) {
      if (O._body) {
        r("body already parsed"), j();
        return;
      }
      if (((O.body = O.body || {}), !a.hasBody(O))) {
        r("skip empty body"), j();
        return;
      }
      if ((r("content-type %j", O.headers["content-type"]), !I(O))) {
        r("skip parsing"), j();
        return;
      }
      var H = d(O) || "utf-8";
      if (H.slice(0, 4) !== "utf-") {
        r("invalid charset"),
          j(
            n(415, 'unsupported charset "' + H.toUpperCase() + '"', {
              charset: H,
              type: "charset.unsupported",
            }),
          );
        return;
      }
      i(O, Q, j, S, r, { encoding: H, inflate: y, limit: v, verify: A });
    };
  }
  function f(m, g) {
    var v = m.indexOf(g),
      y = "";
    if (v !== -1) {
      y = m.substring(0, v) + o;
      for (var _ = v + 1; _ < m.length; _++) y += o;
    }
    try {
      throw (JSON.parse(y), new SyntaxError("strict violation"));
    } catch (E) {
      return p(E, {
        message: E.message.replace(c, function (R) {
          return m.substring(v, v + R.length);
        }),
        stack: E.stack,
      });
    }
  }
  function u(m) {
    var g = s.exec(m);
    return g ? g[1] : void 0;
  }
  function d(m) {
    try {
      return (t.parse(m).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function p(m, g) {
    for (var v = Object.getOwnPropertyNames(m), y = 0; y < v.length; y++) {
      var _ = v[y];
      _ !== "stack" && _ !== "message" && delete m[_];
    }
    return (
      (m.stack = g.stack.replace(m.message, g.message)),
      (m.message = g.message),
      m
    );
  }
  function h(m) {
    return function (v) {
      return !!a(v, m);
    };
  }
  return Mh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Hh, fE;
function yD() {
  if (fE) return Hh;
  fE = 1;
  var e = qi(),
    t = ep()("body-parser:raw"),
    n = tp(),
    r = ga;
  Hh = i;
  function i(s) {
    var o = s || {},
      c = o.inflate !== !1,
      l = typeof o.limit != "number" ? e.parse(o.limit || "100kb") : o.limit,
      f = o.type || "application/octet-stream",
      u = o.verify || !1;
    if (u !== !1 && typeof u != "function")
      throw new TypeError("option verify must be function");
    var d = typeof f != "function" ? a(f) : f;
    function p(h) {
      return h;
    }
    return function (m, g, v) {
      if (m._body) {
        t("body already parsed"), v();
        return;
      }
      if (((m.body = m.body || {}), !r.hasBody(m))) {
        t("skip empty body"), v();
        return;
      }
      if ((t("content-type %j", m.headers["content-type"]), !d(m))) {
        t("skip parsing"), v();
        return;
      }
      n(m, g, v, p, t, { encoding: null, inflate: c, limit: l, verify: u });
    };
  }
  function a(s) {
    return function (c) {
      return !!r(c, s);
    };
  }
  return Hh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var qh, dE;
function bD() {
  if (dE) return qh;
  dE = 1;
  var e = qi(),
    t = zs(),
    n = ep()("body-parser:text"),
    r = tp(),
    i = ga;
  qh = a;
  function a(c) {
    var l = c || {},
      f = l.defaultCharset || "utf-8",
      u = l.inflate !== !1,
      d = typeof l.limit != "number" ? e.parse(l.limit || "100kb") : l.limit,
      p = l.type || "text/plain",
      h = l.verify || !1;
    if (h !== !1 && typeof h != "function")
      throw new TypeError("option verify must be function");
    var m = typeof p != "function" ? o(p) : p;
    function g(v) {
      return v;
    }
    return function (y, _, E) {
      if (y._body) {
        n("body already parsed"), E();
        return;
      }
      if (((y.body = y.body || {}), !i.hasBody(y))) {
        n("skip empty body"), E();
        return;
      }
      if ((n("content-type %j", y.headers["content-type"]), !m(y))) {
        n("skip parsing"), E();
        return;
      }
      var R = s(y) || f;
      r(y, _, E, g, n, { encoding: R, inflate: u, limit: d, verify: h });
    };
  }
  function s(c) {
    try {
      return (t.parse(c).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function o(c) {
    return function (f) {
      return !!i(f, c);
    };
  }
  return qh;
}
var Gh, pE;
function Rv() {
  if (pE) return Gh;
  pE = 1;
  var e = String.prototype.replace,
    t = /%20/g,
    n = { RFC1738: "RFC1738", RFC3986: "RFC3986" };
  return (
    (Gh = {
      default: n.RFC3986,
      formatters: {
        RFC1738: function (r) {
          return e.call(r, t, "+");
        },
        RFC3986: function (r) {
          return String(r);
        },
      },
      RFC1738: n.RFC1738,
      RFC3986: n.RFC3986,
    }),
    Gh
  );
}
var Qh, hE;
function X$() {
  if (hE) return Qh;
  hE = 1;
  var e = Rv(),
    t = Object.prototype.hasOwnProperty,
    n = Array.isArray,
    r = (function () {
      for (var m = [], g = 0; g < 256; ++g)
        m.push("%" + ((g < 16 ? "0" : "") + g.toString(16)).toUpperCase());
      return m;
    })(),
    i = function (g) {
      for (; g.length > 1; ) {
        var v = g.pop(),
          y = v.obj[v.prop];
        if (n(y)) {
          for (var _ = [], E = 0; E < y.length; ++E)
            typeof y[E] < "u" && _.push(y[E]);
          v.obj[v.prop] = _;
        }
      }
    },
    a = function (g, v) {
      for (
        var y = v && v.plainObjects ? Object.create(null) : {}, _ = 0;
        _ < g.length;
        ++_
      )
        typeof g[_] < "u" && (y[_] = g[_]);
      return y;
    },
    s = function m(g, v, y) {
      if (!v) return g;
      if (typeof v != "object") {
        if (n(g)) g.push(v);
        else if (g && typeof g == "object")
          ((y && (y.plainObjects || y.allowPrototypes)) ||
            !t.call(Object.prototype, v)) &&
            (g[v] = !0);
        else return [g, v];
        return g;
      }
      if (!g || typeof g != "object") return [g].concat(v);
      var _ = g;
      return (
        n(g) && !n(v) && (_ = a(g, y)),
        n(g) && n(v)
          ? (v.forEach(function (E, R) {
              if (t.call(g, R)) {
                var A = g[R];
                A && typeof A == "object" && E && typeof E == "object"
                  ? (g[R] = m(A, E, y))
                  : g.push(E);
              } else g[R] = E;
            }),
            g)
          : Object.keys(v).reduce(function (E, R) {
              var A = v[R];
              return t.call(E, R) ? (E[R] = m(E[R], A, y)) : (E[R] = A), E;
            }, _)
      );
    },
    o = function (g, v) {
      return Object.keys(v).reduce(function (y, _) {
        return (y[_] = v[_]), y;
      }, g);
    },
    c = function (m, g, v) {
      var y = m.replace(/\+/g, " ");
      if (v === "iso-8859-1") return y.replace(/%[0-9a-f]{2}/gi, unescape);
      try {
        return decodeURIComponent(y);
      } catch {
        return y;
      }
    },
    l = function (g, v, y, _, E) {
      if (g.length === 0) return g;
      var R = g;
      if (
        (typeof g == "symbol"
          ? (R = Symbol.prototype.toString.call(g))
          : typeof g != "string" && (R = String(g)),
        y === "iso-8859-1")
      )
        return escape(R).replace(/%u[0-9a-f]{4}/gi, function (w) {
          return "%26%23" + parseInt(w.slice(2), 16) + "%3B";
        });
      for (var A = "", I = 0; I < R.length; ++I) {
        var S = R.charCodeAt(I);
        if (
          S === 45 ||
          S === 46 ||
          S === 95 ||
          S === 126 ||
          (S >= 48 && S <= 57) ||
          (S >= 65 && S <= 90) ||
          (S >= 97 && S <= 122) ||
          (E === e.RFC1738 && (S === 40 || S === 41))
        ) {
          A += R.charAt(I);
          continue;
        }
        if (S < 128) {
          A = A + r[S];
          continue;
        }
        if (S < 2048) {
          A = A + (r[192 | (S >> 6)] + r[128 | (S & 63)]);
          continue;
        }
        if (S < 55296 || S >= 57344) {
          A =
            A +
            (r[224 | (S >> 12)] + r[128 | ((S >> 6) & 63)] + r[128 | (S & 63)]);
          continue;
        }
        (I += 1),
          (S = 65536 + (((S & 1023) << 10) | (R.charCodeAt(I) & 1023))),
          (A +=
            r[240 | (S >> 18)] +
            r[128 | ((S >> 12) & 63)] +
            r[128 | ((S >> 6) & 63)] +
            r[128 | (S & 63)]);
      }
      return A;
    },
    f = function (g) {
      for (
        var v = [{ obj: { o: g }, prop: "o" }], y = [], _ = 0;
        _ < v.length;
        ++_
      )
        for (
          var E = v[_], R = E.obj[E.prop], A = Object.keys(R), I = 0;
          I < A.length;
          ++I
        ) {
          var S = A[I],
            w = R[S];
          typeof w == "object" &&
            w !== null &&
            y.indexOf(w) === -1 &&
            (v.push({ obj: R, prop: S }), y.push(w));
        }
      return i(v), g;
    },
    u = function (g) {
      return Object.prototype.toString.call(g) === "[object RegExp]";
    },
    d = function (g) {
      return !g || typeof g != "object"
        ? !1
        : !!(
            g.constructor &&
            g.constructor.isBuffer &&
            g.constructor.isBuffer(g)
          );
    },
    p = function (g, v) {
      return [].concat(g, v);
    },
    h = function (g, v) {
      if (n(g)) {
        for (var y = [], _ = 0; _ < g.length; _ += 1) y.push(v(g[_]));
        return y;
      }
      return v(g);
    };
  return (
    (Qh = {
      arrayToObject: a,
      assign: o,
      combine: p,
      compact: f,
      decode: c,
      encode: l,
      isBuffer: d,
      isRegExp: u,
      maybeMap: h,
      merge: s,
    }),
    Qh
  );
}
var Wh, mE;
function _D() {
  if (mE) return Wh;
  mE = 1;
  var e = DI,
    t = X$(),
    n = Rv(),
    r = Object.prototype.hasOwnProperty,
    i = {
      brackets: function (v) {
        return v + "[]";
      },
      comma: "comma",
      indices: function (v, y) {
        return v + "[" + y + "]";
      },
      repeat: function (v) {
        return v;
      },
    },
    a = Array.isArray,
    s = String.prototype.split,
    o = Array.prototype.push,
    c = function (g, v) {
      o.apply(g, a(v) ? v : [v]);
    },
    l = Date.prototype.toISOString,
    f = n.default,
    u = {
      addQueryPrefix: !1,
      allowDots: !1,
      charset: "utf-8",
      charsetSentinel: !1,
      delimiter: "&",
      encode: !0,
      encoder: t.encode,
      encodeValuesOnly: !1,
      format: f,
      formatter: n.formatters[f],
      indices: !1,
      serializeDate: function (v) {
        return l.call(v);
      },
      skipNulls: !1,
      strictNullHandling: !1,
    },
    d = function (v) {
      return (
        typeof v == "string" ||
        typeof v == "number" ||
        typeof v == "boolean" ||
        typeof v == "symbol" ||
        typeof v == "bigint"
      );
    },
    p = {},
    h = function g(v, y, _, E, R, A, I, S, w, O, Q, j, H, q, J, Z) {
      for (var z = v, U = Z, G = 0, L = !1; (U = U.get(p)) !== void 0 && !L; ) {
        var k = U.get(v);
        if (((G += 1), typeof k < "u")) {
          if (k === G) throw new RangeError("Cyclic object value");
          L = !0;
        }
        typeof U.get(p) > "u" && (G = 0);
      }
      if (
        (typeof S == "function"
          ? (z = S(y, z))
          : z instanceof Date
          ? (z = Q(z))
          : _ === "comma" &&
            a(z) &&
            (z = t.maybeMap(z, function (Ee) {
              return Ee instanceof Date ? Q(Ee) : Ee;
            })),
        z === null)
      ) {
        if (R) return I && !q ? I(y, u.encoder, J, "key", j) : y;
        z = "";
      }
      if (d(z) || t.isBuffer(z)) {
        if (I) {
          var W = q ? y : I(y, u.encoder, J, "key", j);
          if (_ === "comma" && q) {
            for (
              var F = s.call(String(z), ","), x = "", T = 0;
              T < F.length;
              ++T
            )
              x += (T === 0 ? "" : ",") + H(I(F[T], u.encoder, J, "value", j));
            return [H(W) + (E && a(z) && F.length === 1 ? "[]" : "") + "=" + x];
          }
          return [H(W) + "=" + H(I(z, u.encoder, J, "value", j))];
        }
        return [H(y) + "=" + H(String(z))];
      }
      var V = [];
      if (typeof z > "u") return V;
      var B;
      if (_ === "comma" && a(z))
        B = [{ value: z.length > 0 ? z.join(",") || null : void 0 }];
      else if (a(S)) B = S;
      else {
        var N = Object.keys(z);
        B = w ? N.sort(w) : N;
      }
      for (
        var ce = E && a(z) && z.length === 1 ? y + "[]" : y, re = 0;
        re < B.length;
        ++re
      ) {
        var ne = B[re],
          Y = typeof ne == "object" && typeof ne.value < "u" ? ne.value : z[ne];
        if (!(A && Y === null)) {
          var M = a(z)
            ? typeof _ == "function"
              ? _(ce, ne)
              : ce
            : ce + (O ? "." + ne : "[" + ne + "]");
          Z.set(v, G);
          var oe = e();
          oe.set(p, Z),
            c(V, g(Y, M, _, E, R, A, I, S, w, O, Q, j, H, q, J, oe));
        }
      }
      return V;
    },
    m = function (v) {
      if (!v) return u;
      if (
        v.encoder !== null &&
        typeof v.encoder < "u" &&
        typeof v.encoder != "function"
      )
        throw new TypeError("Encoder has to be a function.");
      var y = v.charset || u.charset;
      if (
        typeof v.charset < "u" &&
        v.charset !== "utf-8" &&
        v.charset !== "iso-8859-1"
      )
        throw new TypeError(
          "The charset option must be either utf-8, iso-8859-1, or undefined",
        );
      var _ = n.default;
      if (typeof v.format < "u") {
        if (!r.call(n.formatters, v.format))
          throw new TypeError("Unknown format option provided.");
        _ = v.format;
      }
      var E = n.formatters[_],
        R = u.filter;
      return (
        (typeof v.filter == "function" || a(v.filter)) && (R = v.filter),
        {
          addQueryPrefix:
            typeof v.addQueryPrefix == "boolean"
              ? v.addQueryPrefix
              : u.addQueryPrefix,
          allowDots: typeof v.allowDots > "u" ? u.allowDots : !!v.allowDots,
          charset: y,
          charsetSentinel:
            typeof v.charsetSentinel == "boolean"
              ? v.charsetSentinel
              : u.charsetSentinel,
          delimiter: typeof v.delimiter > "u" ? u.delimiter : v.delimiter,
          encode: typeof v.encode == "boolean" ? v.encode : u.encode,
          encoder: typeof v.encoder == "function" ? v.encoder : u.encoder,
          encodeValuesOnly:
            typeof v.encodeValuesOnly == "boolean"
              ? v.encodeValuesOnly
              : u.encodeValuesOnly,
          filter: R,
          format: _,
          formatter: E,
          serializeDate:
            typeof v.serializeDate == "function"
              ? v.serializeDate
              : u.serializeDate,
          skipNulls:
            typeof v.skipNulls == "boolean" ? v.skipNulls : u.skipNulls,
          sort: typeof v.sort == "function" ? v.sort : null,
          strictNullHandling:
            typeof v.strictNullHandling == "boolean"
              ? v.strictNullHandling
              : u.strictNullHandling,
        }
      );
    };
  return (
    (Wh = function (g, v) {
      var y = g,
        _ = m(v),
        E,
        R;
      typeof _.filter == "function"
        ? ((R = _.filter), (y = R("", y)))
        : a(_.filter) && ((R = _.filter), (E = R));
      var A = [];
      if (typeof y != "object" || y === null) return "";
      var I;
      v && v.arrayFormat in i
        ? (I = v.arrayFormat)
        : v && "indices" in v
        ? (I = v.indices ? "indices" : "repeat")
        : (I = "indices");
      var S = i[I];
      if (v && "commaRoundTrip" in v && typeof v.commaRoundTrip != "boolean")
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      var w = S === "comma" && v && v.commaRoundTrip;
      E || (E = Object.keys(y)), _.sort && E.sort(_.sort);
      for (var O = e(), Q = 0; Q < E.length; ++Q) {
        var j = E[Q];
        (_.skipNulls && y[j] === null) ||
          c(
            A,
            h(
              y[j],
              j,
              S,
              w,
              _.strictNullHandling,
              _.skipNulls,
              _.encode ? _.encoder : null,
              _.filter,
              _.sort,
              _.allowDots,
              _.serializeDate,
              _.format,
              _.formatter,
              _.encodeValuesOnly,
              _.charset,
              O,
            ),
          );
      }
      var H = A.join(_.delimiter),
        q = _.addQueryPrefix === !0 ? "?" : "";
      return (
        _.charsetSentinel &&
          (_.charset === "iso-8859-1"
            ? (q += "utf8=%26%2310003%3B&")
            : (q += "utf8=%E2%9C%93&")),
        H.length > 0 ? q + H : ""
      );
    }),
    Wh
  );
}
var zh, gE;
function ED() {
  if (gE) return zh;
  gE = 1;
  var e = X$(),
    t = Object.prototype.hasOwnProperty,
    n = Array.isArray,
    r = {
      allowDots: !1,
      allowPrototypes: !1,
      allowSparse: !1,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: !1,
      comma: !1,
      decoder: e.decode,
      delimiter: "&",
      depth: 5,
      ignoreQueryPrefix: !1,
      interpretNumericEntities: !1,
      parameterLimit: 1e3,
      parseArrays: !0,
      plainObjects: !1,
      strictNullHandling: !1,
    },
    i = function (d) {
      return d.replace(/&#(\d+);/g, function (p, h) {
        return String.fromCharCode(parseInt(h, 10));
      });
    },
    a = function (d, p) {
      return d && typeof d == "string" && p.comma && d.indexOf(",") > -1
        ? d.split(",")
        : d;
    },
    s = "utf8=%26%2310003%3B",
    o = "utf8=%E2%9C%93",
    c = function (p, h) {
      var m = {},
        g = h.ignoreQueryPrefix ? p.replace(/^\?/, "") : p,
        v = h.parameterLimit === 1 / 0 ? void 0 : h.parameterLimit,
        y = g.split(h.delimiter, v),
        _ = -1,
        E,
        R = h.charset;
      if (h.charsetSentinel)
        for (E = 0; E < y.length; ++E)
          y[E].indexOf("utf8=") === 0 &&
            (y[E] === o ? (R = "utf-8") : y[E] === s && (R = "iso-8859-1"),
            (_ = E),
            (E = y.length));
      for (E = 0; E < y.length; ++E)
        if (E !== _) {
          var A = y[E],
            I = A.indexOf("]="),
            S = I === -1 ? A.indexOf("=") : I + 1,
            w,
            O;
          S === -1
            ? ((w = h.decoder(A, r.decoder, R, "key")),
              (O = h.strictNullHandling ? null : ""))
            : ((w = h.decoder(A.slice(0, S), r.decoder, R, "key")),
              (O = e.maybeMap(a(A.slice(S + 1), h), function (Q) {
                return h.decoder(Q, r.decoder, R, "value");
              }))),
            O && h.interpretNumericEntities && R === "iso-8859-1" && (O = i(O)),
            A.indexOf("[]=") > -1 && (O = n(O) ? [O] : O),
            t.call(m, w) ? (m[w] = e.combine(m[w], O)) : (m[w] = O);
        }
      return m;
    },
    l = function (d, p, h, m) {
      for (var g = m ? p : a(p, h), v = d.length - 1; v >= 0; --v) {
        var y,
          _ = d[v];
        if (_ === "[]" && h.parseArrays) y = [].concat(g);
        else {
          y = h.plainObjects ? Object.create(null) : {};
          var E =
              _.charAt(0) === "[" && _.charAt(_.length - 1) === "]"
                ? _.slice(1, -1)
                : _,
            R = parseInt(E, 10);
          !h.parseArrays && E === ""
            ? (y = { 0: g })
            : !isNaN(R) &&
              _ !== E &&
              String(R) === E &&
              R >= 0 &&
              h.parseArrays &&
              R <= h.arrayLimit
            ? ((y = []), (y[R] = g))
            : E !== "__proto__" && (y[E] = g);
        }
        g = y;
      }
      return g;
    },
    f = function (p, h, m, g) {
      if (p) {
        var v = m.allowDots ? p.replace(/\.([^.[]+)/g, "[$1]") : p,
          y = /(\[[^[\]]*])/,
          _ = /(\[[^[\]]*])/g,
          E = m.depth > 0 && y.exec(v),
          R = E ? v.slice(0, E.index) : v,
          A = [];
        if (R) {
          if (
            !m.plainObjects &&
            t.call(Object.prototype, R) &&
            !m.allowPrototypes
          )
            return;
          A.push(R);
        }
        for (
          var I = 0;
          m.depth > 0 && (E = _.exec(v)) !== null && I < m.depth;

        ) {
          if (
            ((I += 1),
            !m.plainObjects &&
              t.call(Object.prototype, E[1].slice(1, -1)) &&
              !m.allowPrototypes)
          )
            return;
          A.push(E[1]);
        }
        return E && A.push("[" + v.slice(E.index) + "]"), l(A, h, m, g);
      }
    },
    u = function (p) {
      if (!p) return r;
      if (
        p.decoder !== null &&
        p.decoder !== void 0 &&
        typeof p.decoder != "function"
      )
        throw new TypeError("Decoder has to be a function.");
      if (
        typeof p.charset < "u" &&
        p.charset !== "utf-8" &&
        p.charset !== "iso-8859-1"
      )
        throw new TypeError(
          "The charset option must be either utf-8, iso-8859-1, or undefined",
        );
      var h = typeof p.charset > "u" ? r.charset : p.charset;
      return {
        allowDots: typeof p.allowDots > "u" ? r.allowDots : !!p.allowDots,
        allowPrototypes:
          typeof p.allowPrototypes == "boolean"
            ? p.allowPrototypes
            : r.allowPrototypes,
        allowSparse:
          typeof p.allowSparse == "boolean" ? p.allowSparse : r.allowSparse,
        arrayLimit:
          typeof p.arrayLimit == "number" ? p.arrayLimit : r.arrayLimit,
        charset: h,
        charsetSentinel:
          typeof p.charsetSentinel == "boolean"
            ? p.charsetSentinel
            : r.charsetSentinel,
        comma: typeof p.comma == "boolean" ? p.comma : r.comma,
        decoder: typeof p.decoder == "function" ? p.decoder : r.decoder,
        delimiter:
          typeof p.delimiter == "string" || e.isRegExp(p.delimiter)
            ? p.delimiter
            : r.delimiter,
        depth:
          typeof p.depth == "number" || p.depth === !1 ? +p.depth : r.depth,
        ignoreQueryPrefix: p.ignoreQueryPrefix === !0,
        interpretNumericEntities:
          typeof p.interpretNumericEntities == "boolean"
            ? p.interpretNumericEntities
            : r.interpretNumericEntities,
        parameterLimit:
          typeof p.parameterLimit == "number"
            ? p.parameterLimit
            : r.parameterLimit,
        parseArrays: p.parseArrays !== !1,
        plainObjects:
          typeof p.plainObjects == "boolean" ? p.plainObjects : r.plainObjects,
        strictNullHandling:
          typeof p.strictNullHandling == "boolean"
            ? p.strictNullHandling
            : r.strictNullHandling,
      };
    };
  return (
    (zh = function (d, p) {
      var h = u(p);
      if (d === "" || d === null || typeof d > "u")
        return h.plainObjects ? Object.create(null) : {};
      for (
        var m = typeof d == "string" ? c(d, h) : d,
          g = h.plainObjects ? Object.create(null) : {},
          v = Object.keys(m),
          y = 0;
        y < v.length;
        ++y
      ) {
        var _ = v[y],
          E = f(_, m[_], h, typeof d == "string");
        g = e.merge(g, E, h);
      }
      return h.allowSparse === !0 ? g : e.compact(g);
    }),
    zh
  );
}
var Kh, vE;
function wD() {
  if (vE) return Kh;
  vE = 1;
  var e = _D(),
    t = ED(),
    n = Rv();
  return (Kh = { formats: n, parse: t, stringify: e }), Kh;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var Vh, yE;
function xD() {
  if (yE) return Vh;
  yE = 1;
  var e = qi(),
    t = zs(),
    n = Gi,
    r = ep()("body-parser:urlencoded"),
    i = wi("body-parser"),
    a = tp(),
    s = ga;
  Vh = c;
  var o = Object.create(null);
  function c(m) {
    var g = m || {};
    g.extended === void 0 && i("undefined extended: provide extended option");
    var v = g.extended !== !1,
      y = g.inflate !== !1,
      _ = typeof g.limit != "number" ? e.parse(g.limit || "100kb") : g.limit,
      E = g.type || "application/x-www-form-urlencoded",
      R = g.verify || !1;
    if (R !== !1 && typeof R != "function")
      throw new TypeError("option verify must be function");
    var A = v ? l(g) : p(g),
      I = typeof E != "function" ? h(E) : E;
    function S(w) {
      return w.length ? A(w) : {};
    }
    return function (O, Q, j) {
      if (O._body) {
        r("body already parsed"), j();
        return;
      }
      if (((O.body = O.body || {}), !s.hasBody(O))) {
        r("skip empty body"), j();
        return;
      }
      if ((r("content-type %j", O.headers["content-type"]), !I(O))) {
        r("skip parsing"), j();
        return;
      }
      var H = f(O) || "utf-8";
      if (H !== "utf-8") {
        r("invalid charset"),
          j(
            n(415, 'unsupported charset "' + H.toUpperCase() + '"', {
              charset: H,
              type: "charset.unsupported",
            }),
          );
        return;
      }
      a(O, Q, j, S, r, {
        debug: r,
        encoding: H,
        inflate: y,
        limit: _,
        verify: R,
      });
    };
  }
  function l(m) {
    var g = m.parameterLimit !== void 0 ? m.parameterLimit : 1e3,
      v = d("qs");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return (
      isFinite(g) && (g = g | 0),
      function (_) {
        var E = u(_, g);
        if (E === void 0)
          throw (
            (r("too many parameters"),
            n(413, "too many parameters", { type: "parameters.too.many" }))
          );
        var R = Math.max(100, E);
        return (
          r("parse extended urlencoding"),
          v(_, {
            allowPrototypes: !0,
            arrayLimit: R,
            depth: 1 / 0,
            parameterLimit: g,
          })
        );
      }
    );
  }
  function f(m) {
    try {
      return (t.parse(m).parameters.charset || "").toLowerCase();
    } catch {
      return;
    }
  }
  function u(m, g) {
    for (var v = 0, y = 0; (y = m.indexOf("&", y)) !== -1; )
      if ((v++, y++, v === g)) return;
    return v;
  }
  function d(m) {
    var g = o[m];
    if (g !== void 0) return g.parse;
    switch (m) {
      case "qs":
        g = wD();
        break;
      case "querystring":
        g = X0;
        break;
    }
    return (o[m] = g), g.parse;
  }
  function p(m) {
    var g = m.parameterLimit !== void 0 ? m.parameterLimit : 1e3,
      v = d("querystring");
    if (isNaN(g) || g < 1)
      throw new TypeError("option parameterLimit must be a positive number");
    return (
      isFinite(g) && (g = g | 0),
      function (_) {
        var E = u(_, g);
        if (E === void 0)
          throw (
            (r("too many parameters"),
            n(413, "too many parameters", { type: "parameters.too.many" }))
          );
        return r("parse urlencoding"), v(_, void 0, void 0, { maxKeys: g });
      }
    );
  }
  function h(m) {
    return function (v) {
      return !!s(v, m);
    };
  }
  return Vh;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */ (function (e, t) {
  var n = wi("body-parser"),
    r = Object.create(null);
  (t = e.exports =
    n.function(i, "bodyParser: use individual json/urlencoded middlewares")),
    Object.defineProperty(t, "json", {
      configurable: !0,
      enumerable: !0,
      get: a("json"),
    }),
    Object.defineProperty(t, "raw", {
      configurable: !0,
      enumerable: !0,
      get: a("raw"),
    }),
    Object.defineProperty(t, "text", {
      configurable: !0,
      enumerable: !0,
      get: a("text"),
    }),
    Object.defineProperty(t, "urlencoded", {
      configurable: !0,
      enumerable: !0,
      get: a("urlencoded"),
    });
  function i(o) {
    var c = Object.create(o || null, {
        type: { configurable: !0, enumerable: !0, value: void 0, writable: !0 },
      }),
      l = t.urlencoded(c),
      f = t.json(c);
    return function (d, p, h) {
      f(d, p, function (m) {
        if (m) return h(m);
        l(d, p, h);
      });
    };
  }
  function a(o) {
    return function () {
      return s(o);
    };
  }
  function s(o) {
    var c = r[o];
    if (c !== void 0) return c;
    switch (o) {
      case "json":
        c = vD();
        break;
      case "raw":
        c = yD();
        break;
      case "text":
        c = bD();
        break;
      case "urlencoded":
        c = xD();
        break;
    }
    return (r[o] = c);
  }
})(t0, t0.exports);
var kv = t0.exports,
  J$ = { exports: {} };
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ var bE = Object.getOwnPropertySymbols,
  AD = Object.prototype.hasOwnProperty,
  SD = Object.prototype.propertyIsEnumerable;
function ID(e) {
  if (e == null)
    throw new TypeError(
      "Object.assign cannot be called with null or undefined",
    );
  return Object(e);
}
function $D() {
  try {
    if (!Object.assign) return !1;
    var e = new String("abc");
    if (((e[5] = "de"), Object.getOwnPropertyNames(e)[0] === "5")) return !1;
    for (var t = {}, n = 0; n < 10; n++) t["_" + String.fromCharCode(n)] = n;
    var r = Object.getOwnPropertyNames(t).map(function (a) {
      return t[a];
    });
    if (r.join("") !== "0123456789") return !1;
    var i = {};
    return (
      "abcdefghijklmnopqrst".split("").forEach(function (a) {
        i[a] = a;
      }),
      Object.keys(Object.assign({}, i)).join("") === "abcdefghijklmnopqrst"
    );
  } catch {
    return !1;
  }
}
var CD = $D()
  ? Object.assign
  : function (e, t) {
      for (var n, r = ID(e), i, a = 1; a < arguments.length; a++) {
        n = Object(arguments[a]);
        for (var s in n) AD.call(n, s) && (r[s] = n[s]);
        if (bE) {
          i = bE(n);
          for (var o = 0; o < i.length; o++)
            SD.call(n, i[o]) && (r[i[o]] = n[i[o]]);
        }
      }
      return r;
    };
(function () {
  var e = CD,
    t = q$,
    n = {
      origin: "*",
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
      preflightContinue: !1,
      optionsSuccessStatus: 204,
    };
  function r(h) {
    return typeof h == "string" || h instanceof String;
  }
  function i(h, m) {
    if (Array.isArray(m)) {
      for (var g = 0; g < m.length; ++g) if (i(h, m[g])) return !0;
      return !1;
    } else return r(m) ? h === m : m instanceof RegExp ? m.test(h) : !!m;
  }
  function a(h, m) {
    var g = m.headers.origin,
      v = [],
      y;
    return (
      !h.origin || h.origin === "*"
        ? v.push([{ key: "Access-Control-Allow-Origin", value: "*" }])
        : r(h.origin)
        ? (v.push([{ key: "Access-Control-Allow-Origin", value: h.origin }]),
          v.push([{ key: "Vary", value: "Origin" }]))
        : ((y = i(g, h.origin)),
          v.push([{ key: "Access-Control-Allow-Origin", value: y ? g : !1 }]),
          v.push([{ key: "Vary", value: "Origin" }])),
      v
    );
  }
  function s(h) {
    var m = h.methods;
    return (
      m.join && (m = h.methods.join(",")),
      { key: "Access-Control-Allow-Methods", value: m }
    );
  }
  function o(h) {
    return h.credentials === !0
      ? { key: "Access-Control-Allow-Credentials", value: "true" }
      : null;
  }
  function c(h, m) {
    var g = h.allowedHeaders || h.headers,
      v = [];
    return (
      g
        ? g.join && (g = g.join(","))
        : ((g = m.headers["access-control-request-headers"]),
          v.push([{ key: "Vary", value: "Access-Control-Request-Headers" }])),
      g &&
        g.length &&
        v.push([{ key: "Access-Control-Allow-Headers", value: g }]),
      v
    );
  }
  function l(h) {
    var m = h.exposedHeaders;
    if (m) m.join && (m = m.join(","));
    else return null;
    return m && m.length
      ? { key: "Access-Control-Expose-Headers", value: m }
      : null;
  }
  function f(h) {
    var m = (typeof h.maxAge == "number" || h.maxAge) && h.maxAge.toString();
    return m && m.length ? { key: "Access-Control-Max-Age", value: m } : null;
  }
  function u(h, m) {
    for (var g = 0, v = h.length; g < v; g++) {
      var y = h[g];
      y &&
        (Array.isArray(y)
          ? u(y, m)
          : y.key === "Vary" && y.value
          ? t(m, y.value)
          : y.value && m.setHeader(y.key, y.value));
    }
  }
  function d(h, m, g, v) {
    var y = [],
      _ = m.method && m.method.toUpperCase && m.method.toUpperCase();
    _ === "OPTIONS"
      ? (y.push(a(h, m)),
        y.push(o(h)),
        y.push(s(h)),
        y.push(c(h, m)),
        y.push(f(h)),
        y.push(l(h)),
        u(y, g),
        h.preflightContinue
          ? v()
          : ((g.statusCode = h.optionsSuccessStatus),
            g.setHeader("Content-Length", "0"),
            g.end()))
      : (y.push(a(h, m)), y.push(o(h)), y.push(l(h)), u(y, g), v());
  }
  function p(h) {
    var m = null;
    return (
      typeof h == "function"
        ? (m = h)
        : (m = function (g, v) {
            v(null, h);
          }),
      function (v, y, _) {
        m(v, function (E, R) {
          if (E) _(E);
          else {
            var A = e({}, n, R),
              I = null;
            A.origin && typeof A.origin == "function"
              ? (I = A.origin)
              : A.origin &&
                (I = function (S, w) {
                  w(null, A.origin);
                }),
              I
                ? I(v.headers.origin, function (S, w) {
                    S || !w ? _(S) : ((A.origin = w), d(A, v, y, _));
                  })
                : _();
          }
        });
      }
    );
  }
  J$.exports = p;
})();
var RD = J$.exports;
const kD = Wl(RD);
var Yh = {},
  Xh = {},
  Ls = {};
Object.defineProperty(Ls, "__esModule", { value: !0 });
Ls.CancellationError = Ls.CancellationToken = void 0;
const TD = Hi;
class ND extends TD.EventEmitter {
  constructor(t) {
    super(),
      (this.parentCancelHandler = null),
      (this._parent = null),
      (this._cancelled = !1),
      t != null && (this.parent = t);
  }
  get cancelled() {
    return this._cancelled || (this._parent != null && this._parent.cancelled);
  }
  set parent(t) {
    this.removeParentCancelHandler(),
      (this._parent = t),
      (this.parentCancelHandler = () => this.cancel()),
      this._parent.onCancel(this.parentCancelHandler);
  }
  cancel() {
    (this._cancelled = !0), this.emit("cancel");
  }
  onCancel(t) {
    this.cancelled ? t() : this.once("cancel", t);
  }
  createPromise(t) {
    if (this.cancelled) return Promise.reject(new n0());
    const n = () => {
      if (r != null)
        try {
          this.removeListener("cancel", r), (r = null);
        } catch {}
    };
    let r = null;
    return new Promise((i, a) => {
      let s = null;
      if (
        ((r = () => {
          try {
            s != null && (s(), (s = null));
          } finally {
            a(new n0());
          }
        }),
        this.cancelled)
      ) {
        r();
        return;
      }
      this.onCancel(r),
        t(i, a, (o) => {
          s = o;
        });
    })
      .then((i) => (n(), i))
      .catch((i) => {
        throw (n(), i);
      });
  }
  removeParentCancelHandler() {
    const t = this._parent;
    t != null &&
      this.parentCancelHandler != null &&
      (t.removeListener("cancel", this.parentCancelHandler),
      (this.parentCancelHandler = null));
  }
  dispose() {
    try {
      this.removeParentCancelHandler();
    } finally {
      this.removeAllListeners(), (this._parent = null);
    }
  }
}
Ls.CancellationToken = ND;
class n0 extends Error {
  constructor() {
    super("cancelled");
  }
}
Ls.CancellationError = n0;
var bn = {},
  r0 = { exports: {} },
  tf = { exports: {} },
  Jh,
  _E;
function OD() {
  if (_E) return Jh;
  _E = 1;
  var e = 1e3,
    t = e * 60,
    n = t * 60,
    r = n * 24,
    i = r * 7,
    a = r * 365.25;
  Jh = function (f, u) {
    u = u || {};
    var d = typeof f;
    if (d === "string" && f.length > 0) return s(f);
    if (d === "number" && isFinite(f)) return u.long ? c(f) : o(f);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(f),
    );
  };
  function s(f) {
    if (((f = String(f)), !(f.length > 100))) {
      var u =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          f,
        );
      if (u) {
        var d = parseFloat(u[1]),
          p = (u[2] || "ms").toLowerCase();
        switch (p) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return d * a;
          case "weeks":
          case "week":
          case "w":
            return d * i;
          case "days":
          case "day":
          case "d":
            return d * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return d * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return d * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return d * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return d;
          default:
            return;
        }
      }
    }
  }
  function o(f) {
    var u = Math.abs(f);
    return u >= r
      ? Math.round(f / r) + "d"
      : u >= n
      ? Math.round(f / n) + "h"
      : u >= t
      ? Math.round(f / t) + "m"
      : u >= e
      ? Math.round(f / e) + "s"
      : f + "ms";
  }
  function c(f) {
    var u = Math.abs(f);
    return u >= r
      ? l(f, u, r, "day")
      : u >= n
      ? l(f, u, n, "hour")
      : u >= t
      ? l(f, u, t, "minute")
      : u >= e
      ? l(f, u, e, "second")
      : f + " ms";
  }
  function l(f, u, d, p) {
    var h = u >= d * 1.5;
    return Math.round(f / d) + " " + p + (h ? "s" : "");
  }
  return Jh;
}
var Zh, EE;
function Z$() {
  if (EE) return Zh;
  EE = 1;
  function e(t) {
    (r.debug = r),
      (r.default = r),
      (r.coerce = l),
      (r.disable = s),
      (r.enable = a),
      (r.enabled = o),
      (r.humanize = OD()),
      (r.destroy = f),
      Object.keys(t).forEach((u) => {
        r[u] = t[u];
      }),
      (r.names = []),
      (r.skips = []),
      (r.formatters = {});
    function n(u) {
      let d = 0;
      for (let p = 0; p < u.length; p++)
        (d = (d << 5) - d + u.charCodeAt(p)), (d |= 0);
      return r.colors[Math.abs(d) % r.colors.length];
    }
    r.selectColor = n;
    function r(u) {
      let d,
        p = null,
        h,
        m;
      function g(...v) {
        if (!g.enabled) return;
        const y = g,
          _ = Number(new Date()),
          E = _ - (d || _);
        (y.diff = E),
          (y.prev = d),
          (y.curr = _),
          (d = _),
          (v[0] = r.coerce(v[0])),
          typeof v[0] != "string" && v.unshift("%O");
        let R = 0;
        (v[0] = v[0].replace(/%([a-zA-Z%])/g, (I, S) => {
          if (I === "%%") return "%";
          R++;
          const w = r.formatters[S];
          if (typeof w == "function") {
            const O = v[R];
            (I = w.call(y, O)), v.splice(R, 1), R--;
          }
          return I;
        })),
          r.formatArgs.call(y, v),
          (y.log || r.log).apply(y, v);
      }
      return (
        (g.namespace = u),
        (g.useColors = r.useColors()),
        (g.color = r.selectColor(u)),
        (g.extend = i),
        (g.destroy = r.destroy),
        Object.defineProperty(g, "enabled", {
          enumerable: !0,
          configurable: !1,
          get: () =>
            p !== null
              ? p
              : (h !== r.namespaces && ((h = r.namespaces), (m = r.enabled(u))),
                m),
          set: (v) => {
            p = v;
          },
        }),
        typeof r.init == "function" && r.init(g),
        g
      );
    }
    function i(u, d) {
      const p = r(this.namespace + (typeof d > "u" ? ":" : d) + u);
      return (p.log = this.log), p;
    }
    function a(u) {
      r.save(u), (r.namespaces = u), (r.names = []), (r.skips = []);
      let d;
      const p = (typeof u == "string" ? u : "").split(/[\s,]+/),
        h = p.length;
      for (d = 0; d < h; d++)
        p[d] &&
          ((u = p[d].replace(/\*/g, ".*?")),
          u[0] === "-"
            ? r.skips.push(new RegExp("^" + u.slice(1) + "$"))
            : r.names.push(new RegExp("^" + u + "$")));
    }
    function s() {
      const u = [...r.names.map(c), ...r.skips.map(c).map((d) => "-" + d)].join(
        ",",
      );
      return r.enable(""), u;
    }
    function o(u) {
      if (u[u.length - 1] === "*") return !0;
      let d, p;
      for (d = 0, p = r.skips.length; d < p; d++)
        if (r.skips[d].test(u)) return !1;
      for (d = 0, p = r.names.length; d < p; d++)
        if (r.names[d].test(u)) return !0;
      return !1;
    }
    function c(u) {
      return u
        .toString()
        .substring(2, u.toString().length - 2)
        .replace(/\.\*\?$/, "*");
    }
    function l(u) {
      return u instanceof Error ? u.stack || u.message : u;
    }
    function f() {
      console.warn(
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
      );
    }
    return r.enable(r.load()), r;
  }
  return (Zh = e), Zh;
}
var wE;
function PD() {
  return (
    wE ||
      ((wE = 1),
      (function (e, t) {
        (t.formatArgs = r),
          (t.save = i),
          (t.load = a),
          (t.useColors = n),
          (t.storage = s()),
          (t.destroy = (() => {
            let c = !1;
            return () => {
              c ||
                ((c = !0),
                console.warn(
                  "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
                ));
            };
          })()),
          (t.colors = [
            "#0000CC",
            "#0000FF",
            "#0033CC",
            "#0033FF",
            "#0066CC",
            "#0066FF",
            "#0099CC",
            "#0099FF",
            "#00CC00",
            "#00CC33",
            "#00CC66",
            "#00CC99",
            "#00CCCC",
            "#00CCFF",
            "#3300CC",
            "#3300FF",
            "#3333CC",
            "#3333FF",
            "#3366CC",
            "#3366FF",
            "#3399CC",
            "#3399FF",
            "#33CC00",
            "#33CC33",
            "#33CC66",
            "#33CC99",
            "#33CCCC",
            "#33CCFF",
            "#6600CC",
            "#6600FF",
            "#6633CC",
            "#6633FF",
            "#66CC00",
            "#66CC33",
            "#9900CC",
            "#9900FF",
            "#9933CC",
            "#9933FF",
            "#99CC00",
            "#99CC33",
            "#CC0000",
            "#CC0033",
            "#CC0066",
            "#CC0099",
            "#CC00CC",
            "#CC00FF",
            "#CC3300",
            "#CC3333",
            "#CC3366",
            "#CC3399",
            "#CC33CC",
            "#CC33FF",
            "#CC6600",
            "#CC6633",
            "#CC9900",
            "#CC9933",
            "#CCCC00",
            "#CCCC33",
            "#FF0000",
            "#FF0033",
            "#FF0066",
            "#FF0099",
            "#FF00CC",
            "#FF00FF",
            "#FF3300",
            "#FF3333",
            "#FF3366",
            "#FF3399",
            "#FF33CC",
            "#FF33FF",
            "#FF6600",
            "#FF6633",
            "#FF9900",
            "#FF9933",
            "#FFCC00",
            "#FFCC33",
          ]);
        function n() {
          return typeof window < "u" &&
            window.process &&
            (window.process.type === "renderer" || window.process.__nwjs)
            ? !0
            : typeof navigator < "u" &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
            ? !1
            : (typeof document < "u" &&
                document.documentElement &&
                document.documentElement.style &&
                document.documentElement.style.WebkitAppearance) ||
              (typeof window < "u" &&
                window.console &&
                (window.console.firebug ||
                  (window.console.exception && window.console.table))) ||
              (typeof navigator < "u" &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
                parseInt(RegExp.$1, 10) >= 31) ||
              (typeof navigator < "u" &&
                navigator.userAgent &&
                navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
        }
        function r(c) {
          if (
            ((c[0] =
              (this.useColors ? "%c" : "") +
              this.namespace +
              (this.useColors ? " %c" : " ") +
              c[0] +
              (this.useColors ? "%c " : " ") +
              "+" +
              e.exports.humanize(this.diff)),
            !this.useColors)
          )
            return;
          const l = "color: " + this.color;
          c.splice(1, 0, l, "color: inherit");
          let f = 0,
            u = 0;
          c[0].replace(/%[a-zA-Z%]/g, (d) => {
            d !== "%%" && (f++, d === "%c" && (u = f));
          }),
            c.splice(u, 0, l);
        }
        t.log = console.debug || console.log || (() => {});
        function i(c) {
          try {
            c ? t.storage.setItem("debug", c) : t.storage.removeItem("debug");
          } catch {}
        }
        function a() {
          let c;
          try {
            c = t.storage.getItem("debug");
          } catch {}
          return (
            !c &&
              typeof process < "u" &&
              "env" in process &&
              (c = process.env.DEBUG),
            c
          );
        }
        function s() {
          try {
            return localStorage;
          } catch {}
        }
        e.exports = Z$()(t);
        const { formatters: o } = e.exports;
        o.j = function (c) {
          try {
            return JSON.stringify(c);
          } catch (l) {
            return "[UnexpectedJSONParseError]: " + l.message;
          }
        };
      })(tf, tf.exports)),
    tf.exports
  );
}
var nf = { exports: {} },
  em,
  xE;
function DD() {
  return (
    xE ||
      ((xE = 1),
      (em = (e, t = process.argv) => {
        const n = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--",
          r = t.indexOf(n + e),
          i = t.indexOf("--");
        return r !== -1 && (i === -1 || r < i);
      })),
    em
  );
}
var tm, AE;
function LD() {
  if (AE) return tm;
  AE = 1;
  const e = Fr,
    t = hc,
    n = DD(),
    { env: r } = process;
  let i;
  n("no-color") || n("no-colors") || n("color=false") || n("color=never")
    ? (i = 0)
    : (n("color") || n("colors") || n("color=true") || n("color=always")) &&
      (i = 1),
    "FORCE_COLOR" in r &&
      (r.FORCE_COLOR === "true"
        ? (i = 1)
        : r.FORCE_COLOR === "false"
        ? (i = 0)
        : (i =
            r.FORCE_COLOR.length === 0
              ? 1
              : Math.min(parseInt(r.FORCE_COLOR, 10), 3)));
  function a(c) {
    return c === 0
      ? !1
      : { level: c, hasBasic: !0, has256: c >= 2, has16m: c >= 3 };
  }
  function s(c, l) {
    if (i === 0) return 0;
    if (n("color=16m") || n("color=full") || n("color=truecolor")) return 3;
    if (n("color=256")) return 2;
    if (c && !l && i === void 0) return 0;
    const f = i || 0;
    if (r.TERM === "dumb") return f;
    if (process.platform === "win32") {
      const u = e.release().split(".");
      return Number(u[0]) >= 10 && Number(u[2]) >= 10586
        ? Number(u[2]) >= 14931
          ? 3
          : 2
        : 1;
    }
    if ("CI" in r)
      return [
        "TRAVIS",
        "CIRCLECI",
        "APPVEYOR",
        "GITLAB_CI",
        "GITHUB_ACTIONS",
        "BUILDKITE",
      ].some((u) => u in r) || r.CI_NAME === "codeship"
        ? 1
        : f;
    if ("TEAMCITY_VERSION" in r)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(r.TEAMCITY_VERSION) ? 1 : 0;
    if (r.COLORTERM === "truecolor") return 3;
    if ("TERM_PROGRAM" in r) {
      const u = parseInt((r.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (r.TERM_PROGRAM) {
        case "iTerm.app":
          return u >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(r.TERM)
      ? 2
      : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
          r.TERM,
        ) || "COLORTERM" in r
      ? 1
      : f;
  }
  function o(c) {
    const l = s(c, c && c.isTTY);
    return a(l);
  }
  return (
    (tm = {
      supportsColor: o,
      stdout: a(s(!0, t.isatty(1))),
      stderr: a(s(!0, t.isatty(2))),
    }),
    tm
  );
}
var SE;
function BD() {
  return (
    SE ||
      ((SE = 1),
      (function (e, t) {
        const n = hc,
          r = wr;
        (t.init = f),
          (t.log = o),
          (t.formatArgs = a),
          (t.save = c),
          (t.load = l),
          (t.useColors = i),
          (t.destroy = r.deprecate(
            () => {},
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
          )),
          (t.colors = [6, 2, 3, 4, 5, 1]);
        try {
          const d = LD();
          d &&
            (d.stderr || d).level >= 2 &&
            (t.colors = [
              20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57,
              62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99,
              112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164,
              165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185,
              196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
              209, 214, 215, 220, 221,
            ]);
        } catch {}
        t.inspectOpts = Object.keys(process.env)
          .filter((d) => /^debug_/i.test(d))
          .reduce((d, p) => {
            const h = p
              .substring(6)
              .toLowerCase()
              .replace(/_([a-z])/g, (g, v) => v.toUpperCase());
            let m = process.env[p];
            return (
              /^(yes|on|true|enabled)$/i.test(m)
                ? (m = !0)
                : /^(no|off|false|disabled)$/i.test(m)
                ? (m = !1)
                : m === "null"
                ? (m = null)
                : (m = Number(m)),
              (d[h] = m),
              d
            );
          }, {});
        function i() {
          return "colors" in t.inspectOpts
            ? !!t.inspectOpts.colors
            : n.isatty(process.stderr.fd);
        }
        function a(d) {
          const { namespace: p, useColors: h } = this;
          if (h) {
            const m = this.color,
              g = "\x1B[3" + (m < 8 ? m : "8;5;" + m),
              v = `  ${g};1m${p} \x1B[0m`;
            (d[0] =
              v +
              d[0]
                .split(
                  `
`,
                )
                .join(
                  `
` + v,
                )),
              d.push(g + "m+" + e.exports.humanize(this.diff) + "\x1B[0m");
          } else d[0] = s() + p + " " + d[0];
        }
        function s() {
          return t.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
        }
        function o(...d) {
          return process.stderr.write(
            r.format(...d) +
              `
`,
          );
        }
        function c(d) {
          d ? (process.env.DEBUG = d) : delete process.env.DEBUG;
        }
        function l() {
          return process.env.DEBUG;
        }
        function f(d) {
          d.inspectOpts = {};
          const p = Object.keys(t.inspectOpts);
          for (let h = 0; h < p.length; h++)
            d.inspectOpts[p[h]] = t.inspectOpts[p[h]];
        }
        e.exports = Z$()(t);
        const { formatters: u } = e.exports;
        (u.o = function (d) {
          return (
            (this.inspectOpts.colors = this.useColors),
            r
              .inspect(d, this.inspectOpts)
              .split(
                `
`,
              )
              .map((p) => p.trim())
              .join(" ")
          );
        }),
          (u.O = function (d) {
            return (
              (this.inspectOpts.colors = this.useColors),
              r.inspect(d, this.inspectOpts)
            );
          });
      })(nf, nf.exports)),
    nf.exports
  );
}
typeof process > "u" ||
process.type === "renderer" ||
process.browser === !0 ||
process.__nwjs
  ? (r0.exports = PD())
  : (r0.exports = BD());
var UD = r0.exports,
  eu = {};
Object.defineProperty(eu, "__esModule", { value: !0 });
eu.ProgressCallbackTransform = void 0;
const FD = Kr;
class jD extends FD.Transform {
  constructor(t, n, r) {
    super(),
      (this.total = t),
      (this.cancellationToken = n),
      (this.onProgress = r),
      (this.start = Date.now()),
      (this.transferred = 0),
      (this.delta = 0),
      (this.nextUpdate = this.start + 1e3);
  }
  _transform(t, n, r) {
    if (this.cancellationToken.cancelled) {
      r(new Error("cancelled"), null);
      return;
    }
    (this.transferred += t.length), (this.delta += t.length);
    const i = Date.now();
    i >= this.nextUpdate &&
      this.transferred !== this.total &&
      ((this.nextUpdate = i + 1e3),
      this.onProgress({
        total: this.total,
        delta: this.delta,
        transferred: this.transferred,
        percent: (this.transferred / this.total) * 100,
        bytesPerSecond: Math.round(this.transferred / ((i - this.start) / 1e3)),
      }),
      (this.delta = 0)),
      r(null, t);
  }
  _flush(t) {
    if (this.cancellationToken.cancelled) {
      t(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.total,
      delta: this.delta,
      transferred: this.total,
      percent: 100,
      bytesPerSecond: Math.round(
        this.transferred / ((Date.now() - this.start) / 1e3),
      ),
    }),
      (this.delta = 0),
      t(null);
  }
}
eu.ProgressCallbackTransform = jD;
var IE;
function MD() {
  if (IE) return bn;
  (IE = 1),
    Object.defineProperty(bn, "__esModule", { value: !0 }),
    (bn.safeStringifyJson =
      bn.configureRequestOptions =
      bn.safeGetHeader =
      bn.DigestTransform =
      bn.configureRequestUrl =
      bn.configureRequestOptionsFromUrl =
      bn.HttpExecutor =
      bn.parseJson =
      bn.HttpError =
      bn.createHttpError =
        void 0);
  const e = pr,
    t = UD,
    n = Xt,
    r = Kr,
    i = Ya,
    a = Ls,
    s = Ln(),
    o = eu,
    c = (0, t.default)("electron-builder");
  function l(A, I = null) {
    return new u(
      A.statusCode || -1,
      `${A.statusCode} ${A.statusMessage}` +
        (I == null
          ? ""
          : `
` + JSON.stringify(I, null, "  ")) +
        `
Headers: ` +
        R(A.headers),
      I,
    );
  }
  bn.createHttpError = l;
  const f = new Map([
    [429, "Too many requests"],
    [400, "Bad request"],
    [403, "Forbidden"],
    [404, "Not found"],
    [405, "Method not allowed"],
    [406, "Not acceptable"],
    [408, "Request timeout"],
    [413, "Request entity too large"],
    [500, "Internal server error"],
    [502, "Bad gateway"],
    [503, "Service unavailable"],
    [504, "Gateway timeout"],
    [505, "HTTP version not supported"],
  ]);
  class u extends Error {
    constructor(I, S = `HTTP error: ${f.get(I) || I}`, w = null) {
      super(S),
        (this.statusCode = I),
        (this.description = w),
        (this.name = "HttpError"),
        (this.code = `HTTP_ERROR_${I}`);
    }
    isServerError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
  }
  bn.HttpError = u;
  function d(A) {
    return A.then((I) => (I == null || I.length === 0 ? null : JSON.parse(I)));
  }
  bn.parseJson = d;
  class p {
    constructor() {
      this.maxRedirects = 10;
    }
    request(I, S = new a.CancellationToken(), w) {
      E(I);
      const O = w == null ? void 0 : JSON.stringify(w),
        Q = O ? Buffer.from(O) : void 0;
      if (Q != null) {
        c(O);
        const { headers: j, ...H } = I;
        I = {
          method: "post",
          headers: {
            "Content-Type": "application/json",
            "Content-Length": Q.length,
            ...j,
          },
          ...H,
        };
      }
      return this.doApiRequest(I, S, (j) => j.end(Q));
    }
    doApiRequest(I, S, w, O = 0) {
      return (
        c.enabled && c(`Request: ${R(I)}`),
        S.createPromise((Q, j, H) => {
          const q = this.createRequest(I, (J) => {
            try {
              this.handleResponse(J, I, S, Q, j, O, w);
            } catch (Z) {
              j(Z);
            }
          });
          this.addErrorAndTimeoutHandlers(q, j, I.timeout),
            this.addRedirectHandlers(q, I, j, O, (J) => {
              this.doApiRequest(J, S, w, O).then(Q).catch(j);
            }),
            w(q, j),
            H(() => q.abort());
        })
      );
    }
    addRedirectHandlers(I, S, w, O, Q) {}
    addErrorAndTimeoutHandlers(I, S, w = 60 * 1e3) {
      this.addTimeOutHandler(I, S, w),
        I.on("error", S),
        I.on("aborted", () => {
          S(new Error("Request has been aborted by the server"));
        });
    }
    handleResponse(I, S, w, O, Q, j, H) {
      var q;
      if (
        (c.enabled &&
          c(
            `Response: ${I.statusCode} ${I.statusMessage}, request options: ${R(
              S,
            )}`,
          ),
        I.statusCode === 404)
      ) {
        Q(
          l(
            I,
            `method: ${S.method || "GET"} url: ${S.protocol || "https:"}//${
              S.hostname
            }${S.port ? `:${S.port}` : ""}${S.path}

Please double check that your authentication token is correct. Due to security reasons, actual status maybe not reported, but 404.
`,
          ),
        );
        return;
      } else if (I.statusCode === 204) {
        O();
        return;
      }
      const J = (q = I.statusCode) !== null && q !== void 0 ? q : 0,
        Z = J >= 300 && J < 400,
        z = y(I, "location");
      if (Z && z != null) {
        if (j > this.maxRedirects) {
          Q(this.createMaxRedirectError());
          return;
        }
        this.doApiRequest(p.prepareRedirectUrlOptions(z, S), w, H, j)
          .then(O)
          .catch(Q);
        return;
      }
      I.setEncoding("utf8");
      let U = "";
      I.on("error", Q),
        I.on("data", (G) => (U += G)),
        I.on("end", () => {
          try {
            if (I.statusCode != null && I.statusCode >= 400) {
              const G = y(I, "content-type"),
                L =
                  G != null &&
                  (Array.isArray(G)
                    ? G.find((k) => k.includes("json")) != null
                    : G.includes("json"));
              Q(
                l(
                  I,
                  `method: ${S.method || "GET"} url: ${
                    S.protocol || "https:"
                  }//${S.hostname}${S.port ? `:${S.port}` : ""}${S.path}

          Data:
          ${L ? JSON.stringify(JSON.parse(U)) : U}
          `,
                ),
              );
            } else O(U.length === 0 ? null : U);
          } catch (G) {
            Q(G);
          }
        });
    }
    async downloadToBuffer(I, S) {
      return await S.cancellationToken.createPromise((w, O, Q) => {
        const j = [],
          H = { headers: S.headers || void 0, redirect: "manual" };
        m(I, H),
          E(H),
          this.doDownload(
            H,
            {
              destination: null,
              options: S,
              onCancel: Q,
              callback: (q) => {
                q == null ? w(Buffer.concat(j)) : O(q);
              },
              responseHandler: (q, J) => {
                let Z = 0;
                q.on("data", (z) => {
                  if (((Z += z.length), Z > 524288e3)) {
                    J(new Error("Maximum allowed size is 500 MB"));
                    return;
                  }
                  j.push(z);
                }),
                  q.on("end", () => {
                    J(null);
                  });
              },
            },
            0,
          );
      });
    }
    doDownload(I, S, w) {
      const O = this.createRequest(I, (Q) => {
        if (Q.statusCode >= 400) {
          S.callback(
            new Error(
              `Cannot download "${I.protocol || "https:"}//${I.hostname}${
                I.path
              }", status ${Q.statusCode}: ${Q.statusMessage}`,
            ),
          );
          return;
        }
        Q.on("error", S.callback);
        const j = y(Q, "location");
        if (j != null) {
          w < this.maxRedirects
            ? this.doDownload(p.prepareRedirectUrlOptions(j, I), S, w++)
            : S.callback(this.createMaxRedirectError());
          return;
        }
        S.responseHandler == null ? _(S, Q) : S.responseHandler(Q, S.callback);
      });
      this.addErrorAndTimeoutHandlers(O, S.callback, I.timeout),
        this.addRedirectHandlers(O, I, S.callback, w, (Q) => {
          this.doDownload(Q, S, w++);
        }),
        O.end();
    }
    createMaxRedirectError() {
      return new Error(`Too many redirects (> ${this.maxRedirects})`);
    }
    addTimeOutHandler(I, S, w) {
      I.on("socket", (O) => {
        O.setTimeout(w, () => {
          I.abort(), S(new Error("Request timed out"));
        });
      });
    }
    static prepareRedirectUrlOptions(I, S) {
      const w = h(I, { ...S }),
        O = w.headers;
      if (O != null && O.authorization) {
        const Q = new i.URL(I);
        (Q.hostname.endsWith(".amazonaws.com") ||
          Q.searchParams.has("X-Amz-Credential")) &&
          delete O.authorization;
      }
      return w;
    }
    static retryOnServerError(I, S = 3) {
      for (let w = 0; ; w++)
        try {
          return I();
        } catch (O) {
          if (
            w < S &&
            ((O instanceof u && O.isServerError()) || O.code === "EPIPE")
          )
            continue;
          throw O;
        }
    }
  }
  bn.HttpExecutor = p;
  function h(A, I) {
    const S = E(I);
    return m(new i.URL(A), S), S;
  }
  bn.configureRequestOptionsFromUrl = h;
  function m(A, I) {
    (I.protocol = A.protocol),
      (I.hostname = A.hostname),
      A.port ? (I.port = A.port) : I.port && delete I.port,
      (I.path = A.pathname + A.search);
  }
  bn.configureRequestUrl = m;
  class g extends r.Transform {
    constructor(I, S = "sha512", w = "base64") {
      super(),
        (this.expected = I),
        (this.algorithm = S),
        (this.encoding = w),
        (this._actual = null),
        (this.isValidateOnEnd = !0),
        (this.digester = (0, e.createHash)(S));
    }
    get actual() {
      return this._actual;
    }
    _transform(I, S, w) {
      this.digester.update(I), w(null, I);
    }
    _flush(I) {
      if (
        ((this._actual = this.digester.digest(this.encoding)),
        this.isValidateOnEnd)
      )
        try {
          this.validate();
        } catch (S) {
          I(S);
          return;
        }
      I(null);
    }
    validate() {
      if (this._actual == null)
        throw (0, s.newError)("Not finished yet", "ERR_STREAM_NOT_FINISHED");
      if (this._actual !== this.expected)
        throw (0, s.newError)(
          `${this.algorithm} checksum mismatch, expected ${this.expected}, got ${this._actual}`,
          "ERR_CHECKSUM_MISMATCH",
        );
      return null;
    }
  }
  bn.DigestTransform = g;
  function v(A, I, S) {
    return A != null && I != null && A !== I
      ? (S(
          new Error(
            `checksum mismatch: expected ${I} but got ${A} (X-Checksum-Sha2 header)`,
          ),
        ),
        !1)
      : !0;
  }
  function y(A, I) {
    const S = A.headers[I];
    return S == null
      ? null
      : Array.isArray(S)
      ? S.length === 0
        ? null
        : S[S.length - 1]
      : S;
  }
  bn.safeGetHeader = y;
  function _(A, I) {
    if (!v(y(I, "X-Checksum-Sha2"), A.options.sha2, A.callback)) return;
    const S = [];
    if (A.options.onProgress != null) {
      const j = y(I, "content-length");
      j != null &&
        S.push(
          new o.ProgressCallbackTransform(
            parseInt(j, 10),
            A.options.cancellationToken,
            A.options.onProgress,
          ),
        );
    }
    const w = A.options.sha512;
    w != null
      ? S.push(
          new g(
            w,
            "sha512",
            w.length === 128 &&
            !w.includes("+") &&
            !w.includes("Z") &&
            !w.includes("=")
              ? "hex"
              : "base64",
          ),
        )
      : A.options.sha2 != null &&
        S.push(new g(A.options.sha2, "sha256", "hex"));
    const O = (0, n.createWriteStream)(A.destination);
    S.push(O);
    let Q = I;
    for (const j of S)
      j.on("error", (H) => {
        O.close(), A.options.cancellationToken.cancelled || A.callback(H);
      }),
        (Q = Q.pipe(j));
    O.on("finish", () => {
      O.close(A.callback);
    });
  }
  function E(A, I, S) {
    S != null && (A.method = S), (A.headers = { ...A.headers });
    const w = A.headers;
    return (
      I != null &&
        (w.authorization =
          I.startsWith("Basic") || I.startsWith("Bearer") ? I : `token ${I}`),
      w["User-Agent"] == null && (w["User-Agent"] = "electron-builder"),
      (S == null || S === "GET" || w["Cache-Control"] == null) &&
        (w["Cache-Control"] = "no-cache"),
      A.protocol == null &&
        process.versions.electron != null &&
        (A.protocol = "https:"),
      A
    );
  }
  bn.configureRequestOptions = E;
  function R(A, I) {
    return JSON.stringify(
      A,
      (S, w) =>
        S.endsWith("Authorization") ||
        S.endsWith("authorization") ||
        S.endsWith("Password") ||
        S.endsWith("PASSWORD") ||
        S.endsWith("Token") ||
        S.includes("password") ||
        S.includes("token") ||
        (I != null && I.has(S))
          ? "<stripped sensitive data>"
          : w,
      2,
    );
  }
  return (bn.safeStringifyJson = R), bn;
}
var Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.getS3LikeProviderBaseUrl = Yo.githubUrl = void 0;
function HD(e, t = "github.com") {
  return `${e.protocol || "https"}://${e.host || t}`;
}
Yo.githubUrl = HD;
function qD(e) {
  const t = e.provider;
  if (t === "s3") return GD(e);
  if (t === "spaces") return QD(e);
  throw new Error(`Not supported provider: ${t}`);
}
Yo.getS3LikeProviderBaseUrl = qD;
function GD(e) {
  let t;
  if (e.accelerate == !0) t = `https://${e.bucket}.s3-accelerate.amazonaws.com`;
  else if (e.endpoint != null) t = `${e.endpoint}/${e.bucket}`;
  else if (e.bucket.includes(".")) {
    if (e.region == null)
      throw new Error(
        `Bucket name "${e.bucket}" includes a dot, but S3 region is missing`,
      );
    e.region === "us-east-1"
      ? (t = `https://s3.amazonaws.com/${e.bucket}`)
      : (t = `https://s3-${e.region}.amazonaws.com/${e.bucket}`);
  } else
    e.region === "cn-north-1"
      ? (t = `https://${e.bucket}.s3.${e.region}.amazonaws.com.cn`)
      : (t = `https://${e.bucket}.s3.amazonaws.com`);
  return e2(t, e.path);
}
function e2(e, t) {
  return (
    t != null && t.length > 0 && (t.startsWith("/") || (e += "/"), (e += t)), e
  );
}
function QD(e) {
  if (e.name == null) throw new Error("name is missing");
  if (e.region == null) throw new Error("region is missing");
  return e2(`https://${e.name}.${e.region}.digitaloceanspaces.com`, e.path);
}
var np = {};
Object.defineProperty(np, "__esModule", { value: !0 });
np.parseDn = void 0;
function WD(e) {
  let t = !1,
    n = null,
    r = "",
    i = 0;
  e = e.trim();
  const a = new Map();
  for (let s = 0; s <= e.length; s++) {
    if (s === e.length) {
      n !== null && a.set(n, r);
      break;
    }
    const o = e[s];
    if (t) {
      if (o === '"') {
        t = !1;
        continue;
      }
    } else {
      if (o === '"') {
        t = !0;
        continue;
      }
      if (o === "\\") {
        s++;
        const c = parseInt(e.slice(s, s + 2), 16);
        Number.isNaN(c) ? (r += e[s]) : (s++, (r += String.fromCharCode(c)));
        continue;
      }
      if (n === null && o === "=") {
        (n = r), (r = "");
        continue;
      }
      if (o === "," || o === ";" || o === "+") {
        n !== null && a.set(n, r), (n = null), (r = "");
        continue;
      }
    }
    if (o === " " && !t) {
      if (r.length === 0) continue;
      if (s > i) {
        let c = s;
        for (; e[c] === " "; ) c++;
        i = c;
      }
      if (
        i >= e.length ||
        e[i] === "," ||
        e[i] === ";" ||
        (n === null && e[i] === "=") ||
        (n !== null && e[i] === "+")
      ) {
        s = i - 1;
        continue;
      }
    }
    r += o;
  }
  return a;
}
np.parseDn = WD;
var ss = {},
  $E;
function zD() {
  if ($E) return ss;
  ($E = 1),
    Object.defineProperty(ss, "__esModule", { value: !0 }),
    (ss.nil = ss.UUID = void 0);
  const e = pr,
    t = Ln(),
    n = "options.name must be either a string or a Buffer",
    r = (0, e.randomBytes)(16);
  r[0] = r[0] | 1;
  const i = {},
    a = [];
  for (let u = 0; u < 256; u++) {
    const d = (u + 256).toString(16).substr(1);
    (i[d] = u), (a[u] = d);
  }
  class s {
    constructor(d) {
      (this.ascii = null), (this.binary = null);
      const p = s.check(d);
      if (!p) throw new Error("not a UUID");
      (this.version = p.version),
        p.format === "ascii" ? (this.ascii = d) : (this.binary = d);
    }
    static v5(d, p) {
      return l(d, "sha1", 80, p);
    }
    toString() {
      return this.ascii == null && (this.ascii = f(this.binary)), this.ascii;
    }
    inspect() {
      return `UUID v${this.version} ${this.toString()}`;
    }
    static check(d, p = 0) {
      if (typeof d == "string")
        return (
          (d = d.toLowerCase()),
          /^[a-f0-9]{8}(-[a-f0-9]{4}){3}-([a-f0-9]{12})$/.test(d)
            ? d === "00000000-0000-0000-0000-000000000000"
              ? { version: void 0, variant: "nil", format: "ascii" }
              : {
                  version: (i[d[14] + d[15]] & 240) >> 4,
                  variant: o((i[d[19] + d[20]] & 224) >> 5),
                  format: "ascii",
                }
            : !1
        );
      if (Buffer.isBuffer(d)) {
        if (d.length < p + 16) return !1;
        let h = 0;
        for (; h < 16 && d[p + h] === 0; h++);
        return h === 16
          ? { version: void 0, variant: "nil", format: "binary" }
          : {
              version: (d[p + 6] & 240) >> 4,
              variant: o((d[p + 8] & 224) >> 5),
              format: "binary",
            };
      }
      throw (0, t.newError)("Unknown type of uuid", "ERR_UNKNOWN_UUID_TYPE");
    }
    static parse(d) {
      const p = Buffer.allocUnsafe(16);
      let h = 0;
      for (let m = 0; m < 16; m++)
        (p[m] = i[d[h++] + d[h++]]),
          (m === 3 || m === 5 || m === 7 || m === 9) && (h += 1);
      return p;
    }
  }
  (ss.UUID = s), (s.OID = s.parse("6ba7b812-9dad-11d1-80b4-00c04fd430c8"));
  function o(u) {
    switch (u) {
      case 0:
      case 1:
      case 3:
        return "ncs";
      case 4:
      case 5:
        return "rfc4122";
      case 6:
        return "microsoft";
      default:
        return "future";
    }
  }
  var c;
  (function (u) {
    (u[(u.ASCII = 0)] = "ASCII"),
      (u[(u.BINARY = 1)] = "BINARY"),
      (u[(u.OBJECT = 2)] = "OBJECT");
  })(c || (c = {}));
  function l(u, d, p, h, m = c.ASCII) {
    const g = (0, e.createHash)(d);
    if (typeof u != "string" && !Buffer.isBuffer(u))
      throw (0, t.newError)(n, "ERR_INVALID_UUID_NAME");
    g.update(h), g.update(u);
    const y = g.digest();
    let _;
    switch (m) {
      case c.BINARY:
        (y[6] = (y[6] & 15) | p), (y[8] = (y[8] & 63) | 128), (_ = y);
        break;
      case c.OBJECT:
        (y[6] = (y[6] & 15) | p), (y[8] = (y[8] & 63) | 128), (_ = new s(y));
        break;
      default:
        _ =
          a[y[0]] +
          a[y[1]] +
          a[y[2]] +
          a[y[3]] +
          "-" +
          a[y[4]] +
          a[y[5]] +
          "-" +
          a[(y[6] & 15) | p] +
          a[y[7]] +
          "-" +
          a[(y[8] & 63) | 128] +
          a[y[9]] +
          "-" +
          a[y[10]] +
          a[y[11]] +
          a[y[12]] +
          a[y[13]] +
          a[y[14]] +
          a[y[15]];
        break;
    }
    return _;
  }
  function f(u) {
    return (
      a[u[0]] +
      a[u[1]] +
      a[u[2]] +
      a[u[3]] +
      "-" +
      a[u[4]] +
      a[u[5]] +
      "-" +
      a[u[6]] +
      a[u[7]] +
      "-" +
      a[u[8]] +
      a[u[9]] +
      "-" +
      a[u[10]] +
      a[u[11]] +
      a[u[12]] +
      a[u[13]] +
      a[u[14]] +
      a[u[15]]
    );
  }
  return (ss.nil = new s("00000000-0000-0000-0000-000000000000")), ss;
}
var os = {},
  t2 = {};
(function (e) {
  (function (t) {
    (t.parser = function (B, N) {
      return new r(B, N);
    }),
      (t.SAXParser = r),
      (t.SAXStream = f),
      (t.createStream = l),
      (t.MAX_BUFFER_LENGTH = 64 * 1024);
    var n = [
      "comment",
      "sgmlDecl",
      "textNode",
      "tagName",
      "doctype",
      "procInstName",
      "procInstBody",
      "entity",
      "attribName",
      "attribValue",
      "cdata",
      "script",
    ];
    t.EVENTS = [
      "text",
      "processinginstruction",
      "sgmldeclaration",
      "doctype",
      "comment",
      "opentagstart",
      "attribute",
      "opentag",
      "closetag",
      "opencdata",
      "cdata",
      "closecdata",
      "error",
      "end",
      "ready",
      "script",
      "opennamespace",
      "closenamespace",
    ];
    function r(B, N) {
      if (!(this instanceof r)) return new r(B, N);
      var ce = this;
      a(ce),
        (ce.q = ce.c = ""),
        (ce.bufferCheckPosition = t.MAX_BUFFER_LENGTH),
        (ce.opt = N || {}),
        (ce.opt.lowercase = ce.opt.lowercase || ce.opt.lowercasetags),
        (ce.looseCase = ce.opt.lowercase ? "toLowerCase" : "toUpperCase"),
        (ce.tags = []),
        (ce.closed = ce.closedRoot = ce.sawRoot = !1),
        (ce.tag = ce.error = null),
        (ce.strict = !!B),
        (ce.noscript = !!(B || ce.opt.noscript)),
        (ce.state = w.BEGIN),
        (ce.strictEntities = ce.opt.strictEntities),
        (ce.ENTITIES = ce.strictEntities
          ? Object.create(t.XML_ENTITIES)
          : Object.create(t.ENTITIES)),
        (ce.attribList = []),
        ce.opt.xmlns && (ce.ns = Object.create(m)),
        (ce.trackPosition = ce.opt.position !== !1),
        ce.trackPosition && (ce.position = ce.line = ce.column = 0),
        Q(ce, "onready");
    }
    Object.create ||
      (Object.create = function (B) {
        function N() {}
        N.prototype = B;
        var ce = new N();
        return ce;
      }),
      Object.keys ||
        (Object.keys = function (B) {
          var N = [];
          for (var ce in B) B.hasOwnProperty(ce) && N.push(ce);
          return N;
        });
    function i(B) {
      for (
        var N = Math.max(t.MAX_BUFFER_LENGTH, 10),
          ce = 0,
          re = 0,
          ne = n.length;
        re < ne;
        re++
      ) {
        var Y = B[n[re]].length;
        if (Y > N)
          switch (n[re]) {
            case "textNode":
              H(B);
              break;
            case "cdata":
              j(B, "oncdata", B.cdata), (B.cdata = "");
              break;
            case "script":
              j(B, "onscript", B.script), (B.script = "");
              break;
            default:
              J(B, "Max buffer length exceeded: " + n[re]);
          }
        ce = Math.max(ce, Y);
      }
      var M = t.MAX_BUFFER_LENGTH - ce;
      B.bufferCheckPosition = M + B.position;
    }
    function a(B) {
      for (var N = 0, ce = n.length; N < ce; N++) B[n[N]] = "";
    }
    function s(B) {
      H(B),
        B.cdata !== "" && (j(B, "oncdata", B.cdata), (B.cdata = "")),
        B.script !== "" && (j(B, "onscript", B.script), (B.script = ""));
    }
    r.prototype = {
      end: function () {
        Z(this);
      },
      write: V,
      resume: function () {
        return (this.error = null), this;
      },
      close: function () {
        return this.write(null);
      },
      flush: function () {
        s(this);
      },
    };
    var o;
    try {
      o = require("stream").Stream;
    } catch {
      o = function () {};
    }
    var c = t.EVENTS.filter(function (B) {
      return B !== "error" && B !== "end";
    });
    function l(B, N) {
      return new f(B, N);
    }
    function f(B, N) {
      if (!(this instanceof f)) return new f(B, N);
      o.apply(this),
        (this._parser = new r(B, N)),
        (this.writable = !0),
        (this.readable = !0);
      var ce = this;
      (this._parser.onend = function () {
        ce.emit("end");
      }),
        (this._parser.onerror = function (re) {
          ce.emit("error", re), (ce._parser.error = null);
        }),
        (this._decoder = null),
        c.forEach(function (re) {
          Object.defineProperty(ce, "on" + re, {
            get: function () {
              return ce._parser["on" + re];
            },
            set: function (ne) {
              if (!ne)
                return (
                  ce.removeAllListeners(re), (ce._parser["on" + re] = ne), ne
                );
              ce.on(re, ne);
            },
            enumerable: !0,
            configurable: !1,
          });
        });
    }
    (f.prototype = Object.create(o.prototype, { constructor: { value: f } })),
      (f.prototype.write = function (B) {
        if (
          typeof Buffer == "function" &&
          typeof Buffer.isBuffer == "function" &&
          Buffer.isBuffer(B)
        ) {
          if (!this._decoder) {
            var N = dI.StringDecoder;
            this._decoder = new N("utf8");
          }
          B = this._decoder.write(B);
        }
        return this._parser.write(B.toString()), this.emit("data", B), !0;
      }),
      (f.prototype.end = function (B) {
        return B && B.length && this.write(B), this._parser.end(), !0;
      }),
      (f.prototype.on = function (B, N) {
        var ce = this;
        return (
          !ce._parser["on" + B] &&
            c.indexOf(B) !== -1 &&
            (ce._parser["on" + B] = function () {
              var re =
                arguments.length === 1
                  ? [arguments[0]]
                  : Array.apply(null, arguments);
              re.splice(0, 0, B), ce.emit.apply(ce, re);
            }),
          o.prototype.on.call(ce, B, N)
        );
      });
    var u = "[CDATA[",
      d = "DOCTYPE",
      p = "http://www.w3.org/XML/1998/namespace",
      h = "http://www.w3.org/2000/xmlns/",
      m = { xml: p, xmlns: h },
      g =
        /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
      v =
        /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/,
      y =
        /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
      _ =
        /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function E(B) {
      return (
        B === " " ||
        B ===
          `
` ||
        B === "\r" ||
        B === "	"
      );
    }
    function R(B) {
      return B === '"' || B === "'";
    }
    function A(B) {
      return B === ">" || E(B);
    }
    function I(B, N) {
      return B.test(N);
    }
    function S(B, N) {
      return !I(B, N);
    }
    var w = 0;
    (t.STATE = {
      BEGIN: w++,
      BEGIN_WHITESPACE: w++,
      TEXT: w++,
      TEXT_ENTITY: w++,
      OPEN_WAKA: w++,
      SGML_DECL: w++,
      SGML_DECL_QUOTED: w++,
      DOCTYPE: w++,
      DOCTYPE_QUOTED: w++,
      DOCTYPE_DTD: w++,
      DOCTYPE_DTD_QUOTED: w++,
      COMMENT_STARTING: w++,
      COMMENT: w++,
      COMMENT_ENDING: w++,
      COMMENT_ENDED: w++,
      CDATA: w++,
      CDATA_ENDING: w++,
      CDATA_ENDING_2: w++,
      PROC_INST: w++,
      PROC_INST_BODY: w++,
      PROC_INST_ENDING: w++,
      OPEN_TAG: w++,
      OPEN_TAG_SLASH: w++,
      ATTRIB: w++,
      ATTRIB_NAME: w++,
      ATTRIB_NAME_SAW_WHITE: w++,
      ATTRIB_VALUE: w++,
      ATTRIB_VALUE_QUOTED: w++,
      ATTRIB_VALUE_CLOSED: w++,
      ATTRIB_VALUE_UNQUOTED: w++,
      ATTRIB_VALUE_ENTITY_Q: w++,
      ATTRIB_VALUE_ENTITY_U: w++,
      CLOSE_TAG: w++,
      CLOSE_TAG_SAW_WHITE: w++,
      SCRIPT: w++,
      SCRIPT_ENDING: w++,
    }),
      (t.XML_ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" }),
      (t.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830,
      }),
      Object.keys(t.ENTITIES).forEach(function (B) {
        var N = t.ENTITIES[B],
          ce = typeof N == "number" ? String.fromCharCode(N) : N;
        t.ENTITIES[B] = ce;
      });
    for (var O in t.STATE) t.STATE[t.STATE[O]] = O;
    w = t.STATE;
    function Q(B, N, ce) {
      B[N] && B[N](ce);
    }
    function j(B, N, ce) {
      B.textNode && H(B), Q(B, N, ce);
    }
    function H(B) {
      (B.textNode = q(B.opt, B.textNode)),
        B.textNode && Q(B, "ontext", B.textNode),
        (B.textNode = "");
    }
    function q(B, N) {
      return (
        B.trim && (N = N.trim()), B.normalize && (N = N.replace(/\s+/g, " ")), N
      );
    }
    function J(B, N) {
      return (
        H(B),
        B.trackPosition &&
          (N +=
            `
Line: ` +
            B.line +
            `
Column: ` +
            B.column +
            `
Char: ` +
            B.c),
        (N = new Error(N)),
        (B.error = N),
        Q(B, "onerror", N),
        B
      );
    }
    function Z(B) {
      return (
        B.sawRoot && !B.closedRoot && z(B, "Unclosed root tag"),
        B.state !== w.BEGIN &&
          B.state !== w.BEGIN_WHITESPACE &&
          B.state !== w.TEXT &&
          J(B, "Unexpected end"),
        H(B),
        (B.c = ""),
        (B.closed = !0),
        Q(B, "onend"),
        r.call(B, B.strict, B.opt),
        B
      );
    }
    function z(B, N) {
      if (typeof B != "object" || !(B instanceof r))
        throw new Error("bad call to strictFail");
      B.strict && J(B, N);
    }
    function U(B) {
      B.strict || (B.tagName = B.tagName[B.looseCase]());
      var N = B.tags[B.tags.length - 1] || B,
        ce = (B.tag = { name: B.tagName, attributes: {} });
      B.opt.xmlns && (ce.ns = N.ns),
        (B.attribList.length = 0),
        j(B, "onopentagstart", ce);
    }
    function G(B, N) {
      var ce = B.indexOf(":"),
        re = ce < 0 ? ["", B] : B.split(":"),
        ne = re[0],
        Y = re[1];
      return (
        N && B === "xmlns" && ((ne = "xmlns"), (Y = "")),
        { prefix: ne, local: Y }
      );
    }
    function L(B) {
      if (
        (B.strict || (B.attribName = B.attribName[B.looseCase]()),
        B.attribList.indexOf(B.attribName) !== -1 ||
          B.tag.attributes.hasOwnProperty(B.attribName))
      ) {
        B.attribName = B.attribValue = "";
        return;
      }
      if (B.opt.xmlns) {
        var N = G(B.attribName, !0),
          ce = N.prefix,
          re = N.local;
        if (ce === "xmlns")
          if (re === "xml" && B.attribValue !== p)
            z(
              B,
              "xml: prefix must be bound to " +
                p +
                `
Actual: ` +
                B.attribValue,
            );
          else if (re === "xmlns" && B.attribValue !== h)
            z(
              B,
              "xmlns: prefix must be bound to " +
                h +
                `
Actual: ` +
                B.attribValue,
            );
          else {
            var ne = B.tag,
              Y = B.tags[B.tags.length - 1] || B;
            ne.ns === Y.ns && (ne.ns = Object.create(Y.ns)),
              (ne.ns[re] = B.attribValue);
          }
        B.attribList.push([B.attribName, B.attribValue]);
      } else
        (B.tag.attributes[B.attribName] = B.attribValue),
          j(B, "onattribute", { name: B.attribName, value: B.attribValue });
      B.attribName = B.attribValue = "";
    }
    function k(B, N) {
      if (B.opt.xmlns) {
        var ce = B.tag,
          re = G(B.tagName);
        (ce.prefix = re.prefix),
          (ce.local = re.local),
          (ce.uri = ce.ns[re.prefix] || ""),
          ce.prefix &&
            !ce.uri &&
            (z(B, "Unbound namespace prefix: " + JSON.stringify(B.tagName)),
            (ce.uri = re.prefix));
        var ne = B.tags[B.tags.length - 1] || B;
        ce.ns &&
          ne.ns !== ce.ns &&
          Object.keys(ce.ns).forEach(function (ye) {
            j(B, "onopennamespace", { prefix: ye, uri: ce.ns[ye] });
          });
        for (var Y = 0, M = B.attribList.length; Y < M; Y++) {
          var oe = B.attribList[Y],
            Ee = oe[0],
            le = oe[1],
            te = G(Ee, !0),
            ie = te.prefix,
            X = te.local,
            he = ie === "" ? "" : ce.ns[ie] || "",
            be = { name: Ee, value: le, prefix: ie, local: X, uri: he };
          ie &&
            ie !== "xmlns" &&
            !he &&
            (z(B, "Unbound namespace prefix: " + JSON.stringify(ie)),
            (be.uri = ie)),
            (B.tag.attributes[Ee] = be),
            j(B, "onattribute", be);
        }
        B.attribList.length = 0;
      }
      (B.tag.isSelfClosing = !!N),
        (B.sawRoot = !0),
        B.tags.push(B.tag),
        j(B, "onopentag", B.tag),
        N ||
          (!B.noscript && B.tagName.toLowerCase() === "script"
            ? (B.state = w.SCRIPT)
            : (B.state = w.TEXT),
          (B.tag = null),
          (B.tagName = "")),
        (B.attribName = B.attribValue = ""),
        (B.attribList.length = 0);
    }
    function W(B) {
      if (!B.tagName) {
        z(B, "Weird empty close tag."),
          (B.textNode += "</>"),
          (B.state = w.TEXT);
        return;
      }
      if (B.script) {
        if (B.tagName !== "script") {
          (B.script += "</" + B.tagName + ">"),
            (B.tagName = ""),
            (B.state = w.SCRIPT);
          return;
        }
        j(B, "onscript", B.script), (B.script = "");
      }
      var N = B.tags.length,
        ce = B.tagName;
      B.strict || (ce = ce[B.looseCase]());
      for (var re = ce; N--; ) {
        var ne = B.tags[N];
        if (ne.name !== re) z(B, "Unexpected close tag");
        else break;
      }
      if (N < 0) {
        z(B, "Unmatched closing tag: " + B.tagName),
          (B.textNode += "</" + B.tagName + ">"),
          (B.state = w.TEXT);
        return;
      }
      B.tagName = ce;
      for (var Y = B.tags.length; Y-- > N; ) {
        var M = (B.tag = B.tags.pop());
        (B.tagName = B.tag.name), j(B, "onclosetag", B.tagName);
        var oe = {};
        for (var Ee in M.ns) oe[Ee] = M.ns[Ee];
        var le = B.tags[B.tags.length - 1] || B;
        B.opt.xmlns &&
          M.ns !== le.ns &&
          Object.keys(M.ns).forEach(function (te) {
            var ie = M.ns[te];
            j(B, "onclosenamespace", { prefix: te, uri: ie });
          });
      }
      N === 0 && (B.closedRoot = !0),
        (B.tagName = B.attribValue = B.attribName = ""),
        (B.attribList.length = 0),
        (B.state = w.TEXT);
    }
    function F(B) {
      var N = B.entity,
        ce = N.toLowerCase(),
        re,
        ne = "";
      return B.ENTITIES[N]
        ? B.ENTITIES[N]
        : B.ENTITIES[ce]
        ? B.ENTITIES[ce]
        : ((N = ce),
          N.charAt(0) === "#" &&
            (N.charAt(1) === "x"
              ? ((N = N.slice(2)),
                (re = parseInt(N, 16)),
                (ne = re.toString(16)))
              : ((N = N.slice(1)),
                (re = parseInt(N, 10)),
                (ne = re.toString(10)))),
          (N = N.replace(/^0+/, "")),
          isNaN(re) || ne.toLowerCase() !== N
            ? (z(B, "Invalid character entity"), "&" + B.entity + ";")
            : String.fromCodePoint(re));
    }
    function x(B, N) {
      N === "<"
        ? ((B.state = w.OPEN_WAKA), (B.startTagPosition = B.position))
        : E(N) ||
          (z(B, "Non-whitespace before first tag."),
          (B.textNode = N),
          (B.state = w.TEXT));
    }
    function T(B, N) {
      var ce = "";
      return N < B.length && (ce = B.charAt(N)), ce;
    }
    function V(B) {
      var N = this;
      if (this.error) throw this.error;
      if (N.closed)
        return J(N, "Cannot write after close. Assign an onready handler.");
      if (B === null) return Z(N);
      typeof B == "object" && (B = B.toString());
      for (var ce = 0, re = ""; (re = T(B, ce++)), (N.c = re), !!re; )
        switch (
          (N.trackPosition &&
            (N.position++,
            re ===
            `
`
              ? (N.line++, (N.column = 0))
              : N.column++),
          N.state)
        ) {
          case w.BEGIN:
            if (((N.state = w.BEGIN_WHITESPACE), re === "\uFEFF")) continue;
            x(N, re);
            continue;
          case w.BEGIN_WHITESPACE:
            x(N, re);
            continue;
          case w.TEXT:
            if (N.sawRoot && !N.closedRoot) {
              for (var ne = ce - 1; re && re !== "<" && re !== "&"; )
                (re = T(B, ce++)),
                  re &&
                    N.trackPosition &&
                    (N.position++,
                    re ===
                    `
`
                      ? (N.line++, (N.column = 0))
                      : N.column++);
              N.textNode += B.substring(ne, ce - 1);
            }
            re === "<" && !(N.sawRoot && N.closedRoot && !N.strict)
              ? ((N.state = w.OPEN_WAKA), (N.startTagPosition = N.position))
              : (!E(re) &&
                  (!N.sawRoot || N.closedRoot) &&
                  z(N, "Text data outside of root node."),
                re === "&" ? (N.state = w.TEXT_ENTITY) : (N.textNode += re));
            continue;
          case w.SCRIPT:
            re === "<" ? (N.state = w.SCRIPT_ENDING) : (N.script += re);
            continue;
          case w.SCRIPT_ENDING:
            re === "/"
              ? (N.state = w.CLOSE_TAG)
              : ((N.script += "<" + re), (N.state = w.SCRIPT));
            continue;
          case w.OPEN_WAKA:
            if (re === "!") (N.state = w.SGML_DECL), (N.sgmlDecl = "");
            else if (!E(re))
              if (I(g, re)) (N.state = w.OPEN_TAG), (N.tagName = re);
              else if (re === "/") (N.state = w.CLOSE_TAG), (N.tagName = "");
              else if (re === "?")
                (N.state = w.PROC_INST), (N.procInstName = N.procInstBody = "");
              else {
                if (
                  (z(N, "Unencoded <"), N.startTagPosition + 1 < N.position)
                ) {
                  var Y = N.position - N.startTagPosition;
                  re = new Array(Y).join(" ") + re;
                }
                (N.textNode += "<" + re), (N.state = w.TEXT);
              }
            continue;
          case w.SGML_DECL:
            (N.sgmlDecl + re).toUpperCase() === u
              ? (j(N, "onopencdata"),
                (N.state = w.CDATA),
                (N.sgmlDecl = ""),
                (N.cdata = ""))
              : N.sgmlDecl + re === "--"
              ? ((N.state = w.COMMENT), (N.comment = ""), (N.sgmlDecl = ""))
              : (N.sgmlDecl + re).toUpperCase() === d
              ? ((N.state = w.DOCTYPE),
                (N.doctype || N.sawRoot) &&
                  z(N, "Inappropriately located doctype declaration"),
                (N.doctype = ""),
                (N.sgmlDecl = ""))
              : re === ">"
              ? (j(N, "onsgmldeclaration", N.sgmlDecl),
                (N.sgmlDecl = ""),
                (N.state = w.TEXT))
              : (R(re) && (N.state = w.SGML_DECL_QUOTED), (N.sgmlDecl += re));
            continue;
          case w.SGML_DECL_QUOTED:
            re === N.q && ((N.state = w.SGML_DECL), (N.q = "")),
              (N.sgmlDecl += re);
            continue;
          case w.DOCTYPE:
            re === ">"
              ? ((N.state = w.TEXT),
                j(N, "ondoctype", N.doctype),
                (N.doctype = !0))
              : ((N.doctype += re),
                re === "["
                  ? (N.state = w.DOCTYPE_DTD)
                  : R(re) && ((N.state = w.DOCTYPE_QUOTED), (N.q = re)));
            continue;
          case w.DOCTYPE_QUOTED:
            (N.doctype += re),
              re === N.q && ((N.q = ""), (N.state = w.DOCTYPE));
            continue;
          case w.DOCTYPE_DTD:
            (N.doctype += re),
              re === "]"
                ? (N.state = w.DOCTYPE)
                : R(re) && ((N.state = w.DOCTYPE_DTD_QUOTED), (N.q = re));
            continue;
          case w.DOCTYPE_DTD_QUOTED:
            (N.doctype += re),
              re === N.q && ((N.state = w.DOCTYPE_DTD), (N.q = ""));
            continue;
          case w.COMMENT:
            re === "-" ? (N.state = w.COMMENT_ENDING) : (N.comment += re);
            continue;
          case w.COMMENT_ENDING:
            re === "-"
              ? ((N.state = w.COMMENT_ENDED),
                (N.comment = q(N.opt, N.comment)),
                N.comment && j(N, "oncomment", N.comment),
                (N.comment = ""))
              : ((N.comment += "-" + re), (N.state = w.COMMENT));
            continue;
          case w.COMMENT_ENDED:
            re !== ">"
              ? (z(N, "Malformed comment"),
                (N.comment += "--" + re),
                (N.state = w.COMMENT))
              : (N.state = w.TEXT);
            continue;
          case w.CDATA:
            re === "]" ? (N.state = w.CDATA_ENDING) : (N.cdata += re);
            continue;
          case w.CDATA_ENDING:
            re === "]"
              ? (N.state = w.CDATA_ENDING_2)
              : ((N.cdata += "]" + re), (N.state = w.CDATA));
            continue;
          case w.CDATA_ENDING_2:
            re === ">"
              ? (N.cdata && j(N, "oncdata", N.cdata),
                j(N, "onclosecdata"),
                (N.cdata = ""),
                (N.state = w.TEXT))
              : re === "]"
              ? (N.cdata += "]")
              : ((N.cdata += "]]" + re), (N.state = w.CDATA));
            continue;
          case w.PROC_INST:
            re === "?"
              ? (N.state = w.PROC_INST_ENDING)
              : E(re)
              ? (N.state = w.PROC_INST_BODY)
              : (N.procInstName += re);
            continue;
          case w.PROC_INST_BODY:
            if (!N.procInstBody && E(re)) continue;
            re === "?"
              ? (N.state = w.PROC_INST_ENDING)
              : (N.procInstBody += re);
            continue;
          case w.PROC_INST_ENDING:
            re === ">"
              ? (j(N, "onprocessinginstruction", {
                  name: N.procInstName,
                  body: N.procInstBody,
                }),
                (N.procInstName = N.procInstBody = ""),
                (N.state = w.TEXT))
              : ((N.procInstBody += "?" + re), (N.state = w.PROC_INST_BODY));
            continue;
          case w.OPEN_TAG:
            I(v, re)
              ? (N.tagName += re)
              : (U(N),
                re === ">"
                  ? k(N)
                  : re === "/"
                  ? (N.state = w.OPEN_TAG_SLASH)
                  : (E(re) || z(N, "Invalid character in tag name"),
                    (N.state = w.ATTRIB)));
            continue;
          case w.OPEN_TAG_SLASH:
            re === ">"
              ? (k(N, !0), W(N))
              : (z(N, "Forward-slash in opening tag not followed by >"),
                (N.state = w.ATTRIB));
            continue;
          case w.ATTRIB:
            if (E(re)) continue;
            re === ">"
              ? k(N)
              : re === "/"
              ? (N.state = w.OPEN_TAG_SLASH)
              : I(g, re)
              ? ((N.attribName = re),
                (N.attribValue = ""),
                (N.state = w.ATTRIB_NAME))
              : z(N, "Invalid attribute name");
            continue;
          case w.ATTRIB_NAME:
            re === "="
              ? (N.state = w.ATTRIB_VALUE)
              : re === ">"
              ? (z(N, "Attribute without value"),
                (N.attribValue = N.attribName),
                L(N),
                k(N))
              : E(re)
              ? (N.state = w.ATTRIB_NAME_SAW_WHITE)
              : I(v, re)
              ? (N.attribName += re)
              : z(N, "Invalid attribute name");
            continue;
          case w.ATTRIB_NAME_SAW_WHITE:
            if (re === "=") N.state = w.ATTRIB_VALUE;
            else {
              if (E(re)) continue;
              z(N, "Attribute without value"),
                (N.tag.attributes[N.attribName] = ""),
                (N.attribValue = ""),
                j(N, "onattribute", { name: N.attribName, value: "" }),
                (N.attribName = ""),
                re === ">"
                  ? k(N)
                  : I(g, re)
                  ? ((N.attribName = re), (N.state = w.ATTRIB_NAME))
                  : (z(N, "Invalid attribute name"), (N.state = w.ATTRIB));
            }
            continue;
          case w.ATTRIB_VALUE:
            if (E(re)) continue;
            R(re)
              ? ((N.q = re), (N.state = w.ATTRIB_VALUE_QUOTED))
              : (z(N, "Unquoted attribute value"),
                (N.state = w.ATTRIB_VALUE_UNQUOTED),
                (N.attribValue = re));
            continue;
          case w.ATTRIB_VALUE_QUOTED:
            if (re !== N.q) {
              re === "&"
                ? (N.state = w.ATTRIB_VALUE_ENTITY_Q)
                : (N.attribValue += re);
              continue;
            }
            L(N), (N.q = ""), (N.state = w.ATTRIB_VALUE_CLOSED);
            continue;
          case w.ATTRIB_VALUE_CLOSED:
            E(re)
              ? (N.state = w.ATTRIB)
              : re === ">"
              ? k(N)
              : re === "/"
              ? (N.state = w.OPEN_TAG_SLASH)
              : I(g, re)
              ? (z(N, "No whitespace between attributes"),
                (N.attribName = re),
                (N.attribValue = ""),
                (N.state = w.ATTRIB_NAME))
              : z(N, "Invalid attribute name");
            continue;
          case w.ATTRIB_VALUE_UNQUOTED:
            if (!A(re)) {
              re === "&"
                ? (N.state = w.ATTRIB_VALUE_ENTITY_U)
                : (N.attribValue += re);
              continue;
            }
            L(N), re === ">" ? k(N) : (N.state = w.ATTRIB);
            continue;
          case w.CLOSE_TAG:
            if (N.tagName)
              re === ">"
                ? W(N)
                : I(v, re)
                ? (N.tagName += re)
                : N.script
                ? ((N.script += "</" + N.tagName),
                  (N.tagName = ""),
                  (N.state = w.SCRIPT))
                : (E(re) || z(N, "Invalid tagname in closing tag"),
                  (N.state = w.CLOSE_TAG_SAW_WHITE));
            else {
              if (E(re)) continue;
              S(g, re)
                ? N.script
                  ? ((N.script += "</" + re), (N.state = w.SCRIPT))
                  : z(N, "Invalid tagname in closing tag.")
                : (N.tagName = re);
            }
            continue;
          case w.CLOSE_TAG_SAW_WHITE:
            if (E(re)) continue;
            re === ">" ? W(N) : z(N, "Invalid characters in closing tag");
            continue;
          case w.TEXT_ENTITY:
          case w.ATTRIB_VALUE_ENTITY_Q:
          case w.ATTRIB_VALUE_ENTITY_U:
            var M, oe;
            switch (N.state) {
              case w.TEXT_ENTITY:
                (M = w.TEXT), (oe = "textNode");
                break;
              case w.ATTRIB_VALUE_ENTITY_Q:
                (M = w.ATTRIB_VALUE_QUOTED), (oe = "attribValue");
                break;
              case w.ATTRIB_VALUE_ENTITY_U:
                (M = w.ATTRIB_VALUE_UNQUOTED), (oe = "attribValue");
                break;
            }
            re === ";"
              ? ((N[oe] += F(N)), (N.entity = ""), (N.state = M))
              : I(N.entity.length ? _ : y, re)
              ? (N.entity += re)
              : (z(N, "Invalid character in entity name"),
                (N[oe] += "&" + N.entity + re),
                (N.entity = ""),
                (N.state = M));
            continue;
          default:
            throw new Error(N, "Unknown state: " + N.state);
        }
      return N.position >= N.bufferCheckPosition && i(N), N;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ String.fromCodePoint ||
      (function () {
        var B = String.fromCharCode,
          N = Math.floor,
          ce = function () {
            var re = 16384,
              ne = [],
              Y,
              M,
              oe = -1,
              Ee = arguments.length;
            if (!Ee) return "";
            for (var le = ""; ++oe < Ee; ) {
              var te = Number(arguments[oe]);
              if (!isFinite(te) || te < 0 || te > 1114111 || N(te) !== te)
                throw RangeError("Invalid code point: " + te);
              te <= 65535
                ? ne.push(te)
                : ((te -= 65536),
                  (Y = (te >> 10) + 55296),
                  (M = (te % 1024) + 56320),
                  ne.push(Y, M)),
                (oe + 1 === Ee || ne.length > re) &&
                  ((le += B.apply(null, ne)), (ne.length = 0));
            }
            return le;
          };
        Object.defineProperty
          ? Object.defineProperty(String, "fromCodePoint", {
              value: ce,
              configurable: !0,
              writable: !0,
            })
          : (String.fromCodePoint = ce);
      })();
  })(e);
})(t2);
var CE;
function KD() {
  if (CE) return os;
  (CE = 1),
    Object.defineProperty(os, "__esModule", { value: !0 }),
    (os.parseXml = os.XElement = void 0);
  const e = t2,
    t = Ln();
  class n {
    constructor(c) {
      if (
        ((this.name = c),
        (this.value = ""),
        (this.attributes = null),
        (this.isCData = !1),
        (this.elements = null),
        !c)
      )
        throw (0, t.newError)(
          "Element name cannot be empty",
          "ERR_XML_ELEMENT_NAME_EMPTY",
        );
      if (!i(c))
        throw (0, t.newError)(
          `Invalid element name: ${c}`,
          "ERR_XML_ELEMENT_INVALID_NAME",
        );
    }
    attribute(c) {
      const l = this.attributes === null ? null : this.attributes[c];
      if (l == null)
        throw (0, t.newError)(
          `No attribute "${c}"`,
          "ERR_XML_MISSED_ATTRIBUTE",
        );
      return l;
    }
    removeAttribute(c) {
      this.attributes !== null && delete this.attributes[c];
    }
    element(c, l = !1, f = null) {
      const u = this.elementOrNull(c, l);
      if (u === null)
        throw (0, t.newError)(
          f || `No element "${c}"`,
          "ERR_XML_MISSED_ELEMENT",
        );
      return u;
    }
    elementOrNull(c, l = !1) {
      if (this.elements === null) return null;
      for (const f of this.elements) if (a(f, c, l)) return f;
      return null;
    }
    getElements(c, l = !1) {
      return this.elements === null
        ? []
        : this.elements.filter((f) => a(f, c, l));
    }
    elementValueOrEmpty(c, l = !1) {
      const f = this.elementOrNull(c, l);
      return f === null ? "" : f.value;
    }
  }
  os.XElement = n;
  const r = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i);
  function i(o) {
    return r.test(o);
  }
  function a(o, c, l) {
    const f = o.name;
    return (
      f === c ||
      (l === !0 && f.length === c.length && f.toLowerCase() === c.toLowerCase())
    );
  }
  function s(o) {
    let c = null;
    const l = e.parser(!0, {}),
      f = [];
    return (
      (l.onopentag = (u) => {
        const d = new n(u.name);
        if (((d.attributes = u.attributes), c === null)) c = d;
        else {
          const p = f[f.length - 1];
          p.elements == null && (p.elements = []), p.elements.push(d);
        }
        f.push(d);
      }),
      (l.onclosetag = () => {
        f.pop();
      }),
      (l.ontext = (u) => {
        f.length > 0 && (f[f.length - 1].value = u);
      }),
      (l.oncdata = (u) => {
        const d = f[f.length - 1];
        (d.value = u), (d.isCData = !0);
      }),
      (l.onerror = (u) => {
        throw u;
      }),
      l.write(o),
      c
    );
  }
  return (os.parseXml = s), os;
}
var RE;
function Ln() {
  return (
    RE ||
      ((RE = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.newError =
            e.asArray =
            e.CURRENT_APP_PACKAGE_FILE_NAME =
            e.CURRENT_APP_INSTALLER_FILE_NAME =
            e.XElement =
            e.parseXml =
            e.ProgressCallbackTransform =
            e.UUID =
            e.parseDn =
            e.githubUrl =
            e.getS3LikeProviderBaseUrl =
            e.configureRequestUrl =
            e.parseJson =
            e.safeStringifyJson =
            e.configureRequestOptionsFromUrl =
            e.configureRequestOptions =
            e.safeGetHeader =
            e.DigestTransform =
            e.HttpExecutor =
            e.createHttpError =
            e.HttpError =
            e.CancellationError =
            e.CancellationToken =
              void 0);
        var t = Ls;
        Object.defineProperty(e, "CancellationToken", {
          enumerable: !0,
          get: function () {
            return t.CancellationToken;
          },
        }),
          Object.defineProperty(e, "CancellationError", {
            enumerable: !0,
            get: function () {
              return t.CancellationError;
            },
          });
        var n = MD();
        Object.defineProperty(e, "HttpError", {
          enumerable: !0,
          get: function () {
            return n.HttpError;
          },
        }),
          Object.defineProperty(e, "createHttpError", {
            enumerable: !0,
            get: function () {
              return n.createHttpError;
            },
          }),
          Object.defineProperty(e, "HttpExecutor", {
            enumerable: !0,
            get: function () {
              return n.HttpExecutor;
            },
          }),
          Object.defineProperty(e, "DigestTransform", {
            enumerable: !0,
            get: function () {
              return n.DigestTransform;
            },
          }),
          Object.defineProperty(e, "safeGetHeader", {
            enumerable: !0,
            get: function () {
              return n.safeGetHeader;
            },
          }),
          Object.defineProperty(e, "configureRequestOptions", {
            enumerable: !0,
            get: function () {
              return n.configureRequestOptions;
            },
          }),
          Object.defineProperty(e, "configureRequestOptionsFromUrl", {
            enumerable: !0,
            get: function () {
              return n.configureRequestOptionsFromUrl;
            },
          }),
          Object.defineProperty(e, "safeStringifyJson", {
            enumerable: !0,
            get: function () {
              return n.safeStringifyJson;
            },
          }),
          Object.defineProperty(e, "parseJson", {
            enumerable: !0,
            get: function () {
              return n.parseJson;
            },
          }),
          Object.defineProperty(e, "configureRequestUrl", {
            enumerable: !0,
            get: function () {
              return n.configureRequestUrl;
            },
          });
        var r = Yo;
        Object.defineProperty(e, "getS3LikeProviderBaseUrl", {
          enumerable: !0,
          get: function () {
            return r.getS3LikeProviderBaseUrl;
          },
        }),
          Object.defineProperty(e, "githubUrl", {
            enumerable: !0,
            get: function () {
              return r.githubUrl;
            },
          });
        var i = np;
        Object.defineProperty(e, "parseDn", {
          enumerable: !0,
          get: function () {
            return i.parseDn;
          },
        });
        var a = zD();
        Object.defineProperty(e, "UUID", {
          enumerable: !0,
          get: function () {
            return a.UUID;
          },
        });
        var s = eu;
        Object.defineProperty(e, "ProgressCallbackTransform", {
          enumerable: !0,
          get: function () {
            return s.ProgressCallbackTransform;
          },
        });
        var o = KD();
        Object.defineProperty(e, "parseXml", {
          enumerable: !0,
          get: function () {
            return o.parseXml;
          },
        }),
          Object.defineProperty(e, "XElement", {
            enumerable: !0,
            get: function () {
              return o.XElement;
            },
          }),
          (e.CURRENT_APP_INSTALLER_FILE_NAME = "installer.exe"),
          (e.CURRENT_APP_PACKAGE_FILE_NAME = "package.7z");
        function c(f) {
          return f == null ? [] : Array.isArray(f) ? f : [f];
        }
        e.asArray = c;
        function l(f, u) {
          const d = new Error(f);
          return (d.code = u), d;
        }
        e.newError = l;
      })(Xh)),
    Xh
  );
}
var Ys = {},
  xr = {};
xr.fromCallback = function (e) {
  return Object.defineProperty(
    function (...t) {
      if (typeof t[t.length - 1] == "function") e.apply(this, t);
      else
        return new Promise((n, r) => {
          e.call(this, ...t, (i, a) => (i != null ? r(i) : n(a)));
        });
    },
    "name",
    { value: e.name },
  );
};
xr.fromPromise = function (e) {
  return Object.defineProperty(
    function (...t) {
      const n = t[t.length - 1];
      if (typeof n != "function") return e.apply(this, t);
      e.apply(this, t.slice(0, -1)).then((r) => n(null, r), n);
    },
    "name",
    { value: e.name },
  );
};
var ba = $T,
  VD = process.cwd,
  Uf = null,
  YD = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function () {
  return Uf || (Uf = VD.call(process)), Uf;
};
try {
  process.cwd();
} catch {}
if (typeof process.chdir == "function") {
  var kE = process.chdir;
  (process.chdir = function (e) {
    (Uf = null), kE.call(process, e);
  }),
    Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, kE);
}
var XD = JD;
function JD(e) {
  ba.hasOwnProperty("O_SYMLINK") &&
    process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) &&
    t(e),
    e.lutimes || n(e),
    (e.chown = a(e.chown)),
    (e.fchown = a(e.fchown)),
    (e.lchown = a(e.lchown)),
    (e.chmod = r(e.chmod)),
    (e.fchmod = r(e.fchmod)),
    (e.lchmod = r(e.lchmod)),
    (e.chownSync = s(e.chownSync)),
    (e.fchownSync = s(e.fchownSync)),
    (e.lchownSync = s(e.lchownSync)),
    (e.chmodSync = i(e.chmodSync)),
    (e.fchmodSync = i(e.fchmodSync)),
    (e.lchmodSync = i(e.lchmodSync)),
    (e.stat = o(e.stat)),
    (e.fstat = o(e.fstat)),
    (e.lstat = o(e.lstat)),
    (e.statSync = c(e.statSync)),
    (e.fstatSync = c(e.fstatSync)),
    (e.lstatSync = c(e.lstatSync)),
    e.chmod &&
      !e.lchmod &&
      ((e.lchmod = function (f, u, d) {
        d && process.nextTick(d);
      }),
      (e.lchmodSync = function () {})),
    e.chown &&
      !e.lchown &&
      ((e.lchown = function (f, u, d, p) {
        p && process.nextTick(p);
      }),
      (e.lchownSync = function () {})),
    YD === "win32" &&
      (e.rename =
        typeof e.rename != "function"
          ? e.rename
          : (function (f) {
              function u(d, p, h) {
                var m = Date.now(),
                  g = 0;
                f(d, p, function v(y) {
                  if (
                    y &&
                    (y.code === "EACCES" ||
                      y.code === "EPERM" ||
                      y.code === "EBUSY") &&
                    Date.now() - m < 6e4
                  ) {
                    setTimeout(function () {
                      e.stat(p, function (_, E) {
                        _ && _.code === "ENOENT" ? f(d, p, v) : h(y);
                      });
                    }, g),
                      g < 100 && (g += 10);
                    return;
                  }
                  h && h(y);
                });
              }
              return Object.setPrototypeOf && Object.setPrototypeOf(u, f), u;
            })(e.rename)),
    (e.read =
      typeof e.read != "function"
        ? e.read
        : (function (f) {
            function u(d, p, h, m, g, v) {
              var y;
              if (v && typeof v == "function") {
                var _ = 0;
                y = function (E, R, A) {
                  if (E && E.code === "EAGAIN" && _ < 10)
                    return _++, f.call(e, d, p, h, m, g, y);
                  v.apply(this, arguments);
                };
              }
              return f.call(e, d, p, h, m, g, y);
            }
            return Object.setPrototypeOf && Object.setPrototypeOf(u, f), u;
          })(e.read)),
    (e.readSync =
      typeof e.readSync != "function"
        ? e.readSync
        : (function (f) {
            return function (u, d, p, h, m) {
              for (var g = 0; ; )
                try {
                  return f.call(e, u, d, p, h, m);
                } catch (v) {
                  if (v.code === "EAGAIN" && g < 10) {
                    g++;
                    continue;
                  }
                  throw v;
                }
            };
          })(e.readSync));
  function t(f) {
    (f.lchmod = function (u, d, p) {
      f.open(u, ba.O_WRONLY | ba.O_SYMLINK, d, function (h, m) {
        if (h) {
          p && p(h);
          return;
        }
        f.fchmod(m, d, function (g) {
          f.close(m, function (v) {
            p && p(g || v);
          });
        });
      });
    }),
      (f.lchmodSync = function (u, d) {
        var p = f.openSync(u, ba.O_WRONLY | ba.O_SYMLINK, d),
          h = !0,
          m;
        try {
          (m = f.fchmodSync(p, d)), (h = !1);
        } finally {
          if (h)
            try {
              f.closeSync(p);
            } catch {}
          else f.closeSync(p);
        }
        return m;
      });
  }
  function n(f) {
    ba.hasOwnProperty("O_SYMLINK") && f.futimes
      ? ((f.lutimes = function (u, d, p, h) {
          f.open(u, ba.O_SYMLINK, function (m, g) {
            if (m) {
              h && h(m);
              return;
            }
            f.futimes(g, d, p, function (v) {
              f.close(g, function (y) {
                h && h(v || y);
              });
            });
          });
        }),
        (f.lutimesSync = function (u, d, p) {
          var h = f.openSync(u, ba.O_SYMLINK),
            m,
            g = !0;
          try {
            (m = f.futimesSync(h, d, p)), (g = !1);
          } finally {
            if (g)
              try {
                f.closeSync(h);
              } catch {}
            else f.closeSync(h);
          }
          return m;
        }))
      : f.futimes &&
        ((f.lutimes = function (u, d, p, h) {
          h && process.nextTick(h);
        }),
        (f.lutimesSync = function () {}));
  }
  function r(f) {
    return (
      f &&
      function (u, d, p) {
        return f.call(e, u, d, function (h) {
          l(h) && (h = null), p && p.apply(this, arguments);
        });
      }
    );
  }
  function i(f) {
    return (
      f &&
      function (u, d) {
        try {
          return f.call(e, u, d);
        } catch (p) {
          if (!l(p)) throw p;
        }
      }
    );
  }
  function a(f) {
    return (
      f &&
      function (u, d, p, h) {
        return f.call(e, u, d, p, function (m) {
          l(m) && (m = null), h && h.apply(this, arguments);
        });
      }
    );
  }
  function s(f) {
    return (
      f &&
      function (u, d, p) {
        try {
          return f.call(e, u, d, p);
        } catch (h) {
          if (!l(h)) throw h;
        }
      }
    );
  }
  function o(f) {
    return (
      f &&
      function (u, d, p) {
        typeof d == "function" && ((p = d), (d = null));
        function h(m, g) {
          g &&
            (g.uid < 0 && (g.uid += 4294967296),
            g.gid < 0 && (g.gid += 4294967296)),
            p && p.apply(this, arguments);
        }
        return d ? f.call(e, u, d, h) : f.call(e, u, h);
      }
    );
  }
  function c(f) {
    return (
      f &&
      function (u, d) {
        var p = d ? f.call(e, u, d) : f.call(e, u);
        return (
          p &&
            (p.uid < 0 && (p.uid += 4294967296),
            p.gid < 0 && (p.gid += 4294967296)),
          p
        );
      }
    );
  }
  function l(f) {
    if (!f || f.code === "ENOSYS") return !0;
    var u = !process.getuid || process.getuid() !== 0;
    return !!(u && (f.code === "EINVAL" || f.code === "EPERM"));
  }
}
var TE = Kr.Stream,
  ZD = eL;
function eL(e) {
  return { ReadStream: t, WriteStream: n };
  function t(r, i) {
    if (!(this instanceof t)) return new t(r, i);
    TE.call(this);
    var a = this;
    (this.path = r),
      (this.fd = null),
      (this.readable = !0),
      (this.paused = !1),
      (this.flags = "r"),
      (this.mode = 438),
      (this.bufferSize = 64 * 1024),
      (i = i || {});
    for (var s = Object.keys(i), o = 0, c = s.length; o < c; o++) {
      var l = s[o];
      this[l] = i[l];
    }
    if (
      (this.encoding && this.setEncoding(this.encoding), this.start !== void 0)
    ) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.end === void 0) this.end = 1 / 0;
      else if (typeof this.end != "number")
        throw TypeError("end must be a Number");
      if (this.start > this.end) throw new Error("start must be <= end");
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function () {
        a._read();
      });
      return;
    }
    e.open(this.path, this.flags, this.mode, function (f, u) {
      if (f) {
        a.emit("error", f), (a.readable = !1);
        return;
      }
      (a.fd = u), a.emit("open", u), a._read();
    });
  }
  function n(r, i) {
    if (!(this instanceof n)) return new n(r, i);
    TE.call(this),
      (this.path = r),
      (this.fd = null),
      (this.writable = !0),
      (this.flags = "w"),
      (this.encoding = "binary"),
      (this.mode = 438),
      (this.bytesWritten = 0),
      (i = i || {});
    for (var a = Object.keys(i), s = 0, o = a.length; s < o; s++) {
      var c = a[s];
      this[c] = i[c];
    }
    if (this.start !== void 0) {
      if (typeof this.start != "number")
        throw TypeError("start must be a Number");
      if (this.start < 0) throw new Error("start must be >= zero");
      this.pos = this.start;
    }
    (this.busy = !1),
      (this._queue = []),
      this.fd === null &&
        ((this._open = e.open),
        this._queue.push([
          this._open,
          this.path,
          this.flags,
          this.mode,
          void 0,
        ]),
        this.flush());
  }
}
var tL = rL,
  nL =
    Object.getPrototypeOf ||
    function (e) {
      return e.__proto__;
    };
function rL(e) {
  if (e === null || typeof e != "object") return e;
  if (e instanceof Object) var t = { __proto__: nL(e) };
  else var t = Object.create(null);
  return (
    Object.getOwnPropertyNames(e).forEach(function (n) {
      Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n));
    }),
    t
  );
}
var En = Xt,
  iL = XD,
  aL = ZD,
  sL = tL,
  rf = wr,
  ir,
  ld;
typeof Symbol == "function" && typeof Symbol.for == "function"
  ? ((ir = Symbol.for("graceful-fs.queue")),
    (ld = Symbol.for("graceful-fs.previous")))
  : ((ir = "___graceful-fs.queue"), (ld = "___graceful-fs.previous"));
function oL() {}
function n2(e, t) {
  Object.defineProperty(e, ir, {
    get: function () {
      return t;
    },
  });
}
var Os = oL;
rf.debuglog
  ? (Os = rf.debuglog("gfs4"))
  : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") &&
    (Os = function () {
      var e = rf.format.apply(rf, arguments);
      (e =
        "GFS4: " +
        e.split(/\n/).join(`
GFS4: `)),
        console.error(e);
    });
if (!En[ir]) {
  var cL = Tn[ir] || [];
  n2(En, cL),
    (En.close = (function (e) {
      function t(n, r) {
        return e.call(En, n, function (i) {
          i || NE(), typeof r == "function" && r.apply(this, arguments);
        });
      }
      return Object.defineProperty(t, ld, { value: e }), t;
    })(En.close)),
    (En.closeSync = (function (e) {
      function t(n) {
        e.apply(En, arguments), NE();
      }
      return Object.defineProperty(t, ld, { value: e }), t;
    })(En.closeSync)),
    /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") &&
      process.on("exit", function () {
        Os(En[ir]), gc.equal(En[ir].length, 0);
      });
}
Tn[ir] || n2(Tn, En[ir]);
var Ar = Tv(sL(En));
process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH &&
  !En.__patched &&
  ((Ar = Tv(En)), (En.__patched = !0));
function Tv(e) {
  iL(e),
    (e.gracefulify = Tv),
    (e.createReadStream = R),
    (e.createWriteStream = A);
  var t = e.readFile;
  e.readFile = n;
  function n(w, O, Q) {
    return typeof O == "function" && ((Q = O), (O = null)), j(w, O, Q);
    function j(H, q, J, Z) {
      return t(H, q, function (z) {
        z && (z.code === "EMFILE" || z.code === "ENFILE")
          ? io([j, [H, q, J], z, Z || Date.now(), Date.now()])
          : typeof J == "function" && J.apply(this, arguments);
      });
    }
  }
  var r = e.writeFile;
  e.writeFile = i;
  function i(w, O, Q, j) {
    return typeof Q == "function" && ((j = Q), (Q = null)), H(w, O, Q, j);
    function H(q, J, Z, z, U) {
      return r(q, J, Z, function (G) {
        G && (G.code === "EMFILE" || G.code === "ENFILE")
          ? io([H, [q, J, Z, z], G, U || Date.now(), Date.now()])
          : typeof z == "function" && z.apply(this, arguments);
      });
    }
  }
  var a = e.appendFile;
  a && (e.appendFile = s);
  function s(w, O, Q, j) {
    return typeof Q == "function" && ((j = Q), (Q = null)), H(w, O, Q, j);
    function H(q, J, Z, z, U) {
      return a(q, J, Z, function (G) {
        G && (G.code === "EMFILE" || G.code === "ENFILE")
          ? io([H, [q, J, Z, z], G, U || Date.now(), Date.now()])
          : typeof z == "function" && z.apply(this, arguments);
      });
    }
  }
  var o = e.copyFile;
  o && (e.copyFile = c);
  function c(w, O, Q, j) {
    return typeof Q == "function" && ((j = Q), (Q = 0)), H(w, O, Q, j);
    function H(q, J, Z, z, U) {
      return o(q, J, Z, function (G) {
        G && (G.code === "EMFILE" || G.code === "ENFILE")
          ? io([H, [q, J, Z, z], G, U || Date.now(), Date.now()])
          : typeof z == "function" && z.apply(this, arguments);
      });
    }
  }
  var l = e.readdir;
  e.readdir = u;
  var f = /^v[0-5]\./;
  function u(w, O, Q) {
    typeof O == "function" && ((Q = O), (O = null));
    var j = f.test(process.version)
      ? function (J, Z, z, U) {
          return l(J, H(J, Z, z, U));
        }
      : function (J, Z, z, U) {
          return l(J, Z, H(J, Z, z, U));
        };
    return j(w, O, Q);
    function H(q, J, Z, z) {
      return function (U, G) {
        U && (U.code === "EMFILE" || U.code === "ENFILE")
          ? io([j, [q, J, Z], U, z || Date.now(), Date.now()])
          : (G && G.sort && G.sort(),
            typeof Z == "function" && Z.call(this, U, G));
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var d = aL(e);
    (v = d.ReadStream), (_ = d.WriteStream);
  }
  var p = e.ReadStream;
  p && ((v.prototype = Object.create(p.prototype)), (v.prototype.open = y));
  var h = e.WriteStream;
  h && ((_.prototype = Object.create(h.prototype)), (_.prototype.open = E)),
    Object.defineProperty(e, "ReadStream", {
      get: function () {
        return v;
      },
      set: function (w) {
        v = w;
      },
      enumerable: !0,
      configurable: !0,
    }),
    Object.defineProperty(e, "WriteStream", {
      get: function () {
        return _;
      },
      set: function (w) {
        _ = w;
      },
      enumerable: !0,
      configurable: !0,
    });
  var m = v;
  Object.defineProperty(e, "FileReadStream", {
    get: function () {
      return m;
    },
    set: function (w) {
      m = w;
    },
    enumerable: !0,
    configurable: !0,
  });
  var g = _;
  Object.defineProperty(e, "FileWriteStream", {
    get: function () {
      return g;
    },
    set: function (w) {
      g = w;
    },
    enumerable: !0,
    configurable: !0,
  });
  function v(w, O) {
    return this instanceof v
      ? (p.apply(this, arguments), this)
      : v.apply(Object.create(v.prototype), arguments);
  }
  function y() {
    var w = this;
    S(w.path, w.flags, w.mode, function (O, Q) {
      O
        ? (w.autoClose && w.destroy(), w.emit("error", O))
        : ((w.fd = Q), w.emit("open", Q), w.read());
    });
  }
  function _(w, O) {
    return this instanceof _
      ? (h.apply(this, arguments), this)
      : _.apply(Object.create(_.prototype), arguments);
  }
  function E() {
    var w = this;
    S(w.path, w.flags, w.mode, function (O, Q) {
      O ? (w.destroy(), w.emit("error", O)) : ((w.fd = Q), w.emit("open", Q));
    });
  }
  function R(w, O) {
    return new e.ReadStream(w, O);
  }
  function A(w, O) {
    return new e.WriteStream(w, O);
  }
  var I = e.open;
  e.open = S;
  function S(w, O, Q, j) {
    return typeof Q == "function" && ((j = Q), (Q = null)), H(w, O, Q, j);
    function H(q, J, Z, z, U) {
      return I(q, J, Z, function (G, L) {
        G && (G.code === "EMFILE" || G.code === "ENFILE")
          ? io([H, [q, J, Z, z], G, U || Date.now(), Date.now()])
          : typeof z == "function" && z.apply(this, arguments);
      });
    }
  }
  return e;
}
function io(e) {
  Os("ENQUEUE", e[0].name, e[1]), En[ir].push(e), Nv();
}
var af;
function NE() {
  for (var e = Date.now(), t = 0; t < En[ir].length; ++t)
    En[ir][t].length > 2 && ((En[ir][t][3] = e), (En[ir][t][4] = e));
  Nv();
}
function Nv() {
  if ((clearTimeout(af), (af = void 0), En[ir].length !== 0)) {
    var e = En[ir].shift(),
      t = e[0],
      n = e[1],
      r = e[2],
      i = e[3],
      a = e[4];
    if (i === void 0) Os("RETRY", t.name, n), t.apply(null, n);
    else if (Date.now() - i >= 6e4) {
      Os("TIMEOUT", t.name, n);
      var s = n.pop();
      typeof s == "function" && s.call(null, r);
    } else {
      var o = Date.now() - a,
        c = Math.max(a - i, 1),
        l = Math.min(c * 1.2, 100);
      o >= l
        ? (Os("RETRY", t.name, n), t.apply(null, n.concat([i])))
        : En[ir].push(e);
    }
    af === void 0 && (af = setTimeout(Nv, 0));
  }
}
(function (e) {
  const t = xr.fromCallback,
    n = Ar,
    r = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile",
    ].filter((i) => typeof n[i] == "function");
  Object.assign(e, n),
    r.forEach((i) => {
      e[i] = t(n[i]);
    }),
    (e.exists = function (i, a) {
      return typeof a == "function"
        ? n.exists(i, a)
        : new Promise((s) => n.exists(i, s));
    }),
    (e.read = function (i, a, s, o, c, l) {
      return typeof l == "function"
        ? n.read(i, a, s, o, c, l)
        : new Promise((f, u) => {
            n.read(i, a, s, o, c, (d, p, h) => {
              if (d) return u(d);
              f({ bytesRead: p, buffer: h });
            });
          });
    }),
    (e.write = function (i, a, ...s) {
      return typeof s[s.length - 1] == "function"
        ? n.write(i, a, ...s)
        : new Promise((o, c) => {
            n.write(i, a, ...s, (l, f, u) => {
              if (l) return c(l);
              o({ bytesWritten: f, buffer: u });
            });
          });
    }),
    typeof n.writev == "function" &&
      (e.writev = function (i, a, ...s) {
        return typeof s[s.length - 1] == "function"
          ? n.writev(i, a, ...s)
          : new Promise((o, c) => {
              n.writev(i, a, ...s, (l, f, u) => {
                if (l) return c(l);
                o({ bytesWritten: f, buffers: u });
              });
            });
      }),
    typeof n.realpath.native == "function"
      ? (e.realpath.native = t(n.realpath.native))
      : process.emitWarning(
          "fs.realpath.native is not a function. Is fs being monkey-patched?",
          "Warning",
          "fs-extra-WARN0003",
        );
})(Ys);
var Ov = {},
  r2 = {};
const lL = pt;
r2.checkPath = function (t) {
  if (
    process.platform === "win32" &&
    /[<>:"|?*]/.test(t.replace(lL.parse(t).root, ""))
  ) {
    const r = new Error(`Path contains invalid characters: ${t}`);
    throw ((r.code = "EINVAL"), r);
  }
};
const i2 = Ys,
  { checkPath: a2 } = r2,
  s2 = (e) => {
    const t = { mode: 511 };
    return typeof e == "number" ? e : { ...t, ...e }.mode;
  };
Ov.makeDir = async (e, t) => (
  a2(e), i2.mkdir(e, { mode: s2(t), recursive: !0 })
);
Ov.makeDirSync = (e, t) => (
  a2(e), i2.mkdirSync(e, { mode: s2(t), recursive: !0 })
);
const uL = xr.fromPromise,
  { makeDir: fL, makeDirSync: nm } = Ov,
  rm = uL(fL);
var Qi = {
  mkdirs: rm,
  mkdirsSync: nm,
  mkdirp: rm,
  mkdirpSync: nm,
  ensureDir: rm,
  ensureDirSync: nm,
};
const dL = xr.fromPromise,
  o2 = Ys;
function pL(e) {
  return o2
    .access(e)
    .then(() => !0)
    .catch(() => !1);
}
var Xs = { pathExists: dL(pL), pathExistsSync: o2.existsSync };
const Do = Ar;
function hL(e, t, n, r) {
  Do.open(e, "r+", (i, a) => {
    if (i) return r(i);
    Do.futimes(a, t, n, (s) => {
      Do.close(a, (o) => {
        r && r(s || o);
      });
    });
  });
}
function mL(e, t, n) {
  const r = Do.openSync(e, "r+");
  return Do.futimesSync(r, t, n), Do.closeSync(r);
}
var c2 = { utimesMillis: hL, utimesMillisSync: mL };
const Xo = Ys,
  zn = pt,
  gL = wr;
function vL(e, t, n) {
  const r = n.dereference
    ? (i) => Xo.stat(i, { bigint: !0 })
    : (i) => Xo.lstat(i, { bigint: !0 });
  return Promise.all([
    r(e),
    r(t).catch((i) => {
      if (i.code === "ENOENT") return null;
      throw i;
    }),
  ]).then(([i, a]) => ({ srcStat: i, destStat: a }));
}
function yL(e, t, n) {
  let r;
  const i = n.dereference
      ? (s) => Xo.statSync(s, { bigint: !0 })
      : (s) => Xo.lstatSync(s, { bigint: !0 }),
    a = i(e);
  try {
    r = i(t);
  } catch (s) {
    if (s.code === "ENOENT") return { srcStat: a, destStat: null };
    throw s;
  }
  return { srcStat: a, destStat: r };
}
function bL(e, t, n, r, i) {
  gL.callbackify(vL)(e, t, r, (a, s) => {
    if (a) return i(a);
    const { srcStat: o, destStat: c } = s;
    if (c) {
      if (tu(o, c)) {
        const l = zn.basename(e),
          f = zn.basename(t);
        return n === "move" && l !== f && l.toLowerCase() === f.toLowerCase()
          ? i(null, { srcStat: o, destStat: c, isChangingCase: !0 })
          : i(new Error("Source and destination must not be the same."));
      }
      if (o.isDirectory() && !c.isDirectory())
        return i(
          new Error(
            `Cannot overwrite non-directory '${t}' with directory '${e}'.`,
          ),
        );
      if (!o.isDirectory() && c.isDirectory())
        return i(
          new Error(
            `Cannot overwrite directory '${t}' with non-directory '${e}'.`,
          ),
        );
    }
    return o.isDirectory() && Pv(e, t)
      ? i(new Error(rp(e, t, n)))
      : i(null, { srcStat: o, destStat: c });
  });
}
function _L(e, t, n, r) {
  const { srcStat: i, destStat: a } = yL(e, t, r);
  if (a) {
    if (tu(i, a)) {
      const s = zn.basename(e),
        o = zn.basename(t);
      if (n === "move" && s !== o && s.toLowerCase() === o.toLowerCase())
        return { srcStat: i, destStat: a, isChangingCase: !0 };
      throw new Error("Source and destination must not be the same.");
    }
    if (i.isDirectory() && !a.isDirectory())
      throw new Error(
        `Cannot overwrite non-directory '${t}' with directory '${e}'.`,
      );
    if (!i.isDirectory() && a.isDirectory())
      throw new Error(
        `Cannot overwrite directory '${t}' with non-directory '${e}'.`,
      );
  }
  if (i.isDirectory() && Pv(e, t)) throw new Error(rp(e, t, n));
  return { srcStat: i, destStat: a };
}
function l2(e, t, n, r, i) {
  const a = zn.resolve(zn.dirname(e)),
    s = zn.resolve(zn.dirname(n));
  if (s === a || s === zn.parse(s).root) return i();
  Xo.stat(s, { bigint: !0 }, (o, c) =>
    o
      ? o.code === "ENOENT"
        ? i()
        : i(o)
      : tu(t, c)
      ? i(new Error(rp(e, n, r)))
      : l2(e, t, s, r, i),
  );
}
function u2(e, t, n, r) {
  const i = zn.resolve(zn.dirname(e)),
    a = zn.resolve(zn.dirname(n));
  if (a === i || a === zn.parse(a).root) return;
  let s;
  try {
    s = Xo.statSync(a, { bigint: !0 });
  } catch (o) {
    if (o.code === "ENOENT") return;
    throw o;
  }
  if (tu(t, s)) throw new Error(rp(e, n, r));
  return u2(e, t, a, r);
}
function tu(e, t) {
  return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev;
}
function Pv(e, t) {
  const n = zn
      .resolve(e)
      .split(zn.sep)
      .filter((i) => i),
    r = zn
      .resolve(t)
      .split(zn.sep)
      .filter((i) => i);
  return n.reduce((i, a, s) => i && r[s] === a, !0);
}
function rp(e, t, n) {
  return `Cannot ${n} '${e}' to a subdirectory of itself, '${t}'.`;
}
var Ec = {
  checkPaths: bL,
  checkPathsSync: _L,
  checkParentPaths: l2,
  checkParentPathsSync: u2,
  isSrcSubdir: Pv,
  areIdentical: tu,
};
const Br = Ar,
  Nl = pt,
  EL = Qi.mkdirs,
  wL = Xs.pathExists,
  xL = c2.utimesMillis,
  Ol = Ec;
function AL(e, t, n, r) {
  typeof n == "function" && !r
    ? ((r = n), (n = {}))
    : typeof n == "function" && (n = { filter: n }),
    (r = r || function () {}),
    (n = n || {}),
    (n.clobber = "clobber" in n ? !!n.clobber : !0),
    (n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber),
    n.preserveTimestamps &&
      process.arch === "ia32" &&
      process.emitWarning(
        `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
        "Warning",
        "fs-extra-WARN0001",
      ),
    Ol.checkPaths(e, t, "copy", n, (i, a) => {
      if (i) return r(i);
      const { srcStat: s, destStat: o } = a;
      Ol.checkParentPaths(e, s, t, "copy", (c) =>
        c ? r(c) : n.filter ? f2(OE, o, e, t, n, r) : OE(o, e, t, n, r),
      );
    });
}
function OE(e, t, n, r, i) {
  const a = Nl.dirname(n);
  wL(a, (s, o) => {
    if (s) return i(s);
    if (o) return ud(e, t, n, r, i);
    EL(a, (c) => (c ? i(c) : ud(e, t, n, r, i)));
  });
}
function f2(e, t, n, r, i, a) {
  Promise.resolve(i.filter(n, r)).then(
    (s) => (s ? e(t, n, r, i, a) : a()),
    (s) => a(s),
  );
}
function SL(e, t, n, r, i) {
  return r.filter ? f2(ud, e, t, n, r, i) : ud(e, t, n, r, i);
}
function ud(e, t, n, r, i) {
  (r.dereference ? Br.stat : Br.lstat)(t, (s, o) =>
    s
      ? i(s)
      : o.isDirectory()
      ? NL(o, e, t, n, r, i)
      : o.isFile() || o.isCharacterDevice() || o.isBlockDevice()
      ? IL(o, e, t, n, r, i)
      : o.isSymbolicLink()
      ? DL(e, t, n, r, i)
      : o.isSocket()
      ? i(new Error(`Cannot copy a socket file: ${t}`))
      : o.isFIFO()
      ? i(new Error(`Cannot copy a FIFO pipe: ${t}`))
      : i(new Error(`Unknown file: ${t}`)),
  );
}
function IL(e, t, n, r, i, a) {
  return t ? $L(e, n, r, i, a) : d2(e, n, r, i, a);
}
function $L(e, t, n, r, i) {
  if (r.overwrite) Br.unlink(n, (a) => (a ? i(a) : d2(e, t, n, r, i)));
  else return r.errorOnExist ? i(new Error(`'${n}' already exists`)) : i();
}
function d2(e, t, n, r, i) {
  Br.copyFile(t, n, (a) =>
    a ? i(a) : r.preserveTimestamps ? CL(e.mode, t, n, i) : ip(n, e.mode, i),
  );
}
function CL(e, t, n, r) {
  return RL(e) ? kL(n, e, (i) => (i ? r(i) : PE(e, t, n, r))) : PE(e, t, n, r);
}
function RL(e) {
  return (e & 128) === 0;
}
function kL(e, t, n) {
  return ip(e, t | 128, n);
}
function PE(e, t, n, r) {
  TL(t, n, (i) => (i ? r(i) : ip(n, e, r)));
}
function ip(e, t, n) {
  return Br.chmod(e, t, n);
}
function TL(e, t, n) {
  Br.stat(e, (r, i) => (r ? n(r) : xL(t, i.atime, i.mtime, n)));
}
function NL(e, t, n, r, i, a) {
  return t ? p2(n, r, i, a) : OL(e.mode, n, r, i, a);
}
function OL(e, t, n, r, i) {
  Br.mkdir(n, (a) => {
    if (a) return i(a);
    p2(t, n, r, (s) => (s ? i(s) : ip(n, e, i)));
  });
}
function p2(e, t, n, r) {
  Br.readdir(e, (i, a) => (i ? r(i) : h2(a, e, t, n, r)));
}
function h2(e, t, n, r, i) {
  const a = e.pop();
  return a ? PL(e, a, t, n, r, i) : i();
}
function PL(e, t, n, r, i, a) {
  const s = Nl.join(n, t),
    o = Nl.join(r, t);
  Ol.checkPaths(s, o, "copy", i, (c, l) => {
    if (c) return a(c);
    const { destStat: f } = l;
    SL(f, s, o, i, (u) => (u ? a(u) : h2(e, n, r, i, a)));
  });
}
function DL(e, t, n, r, i) {
  Br.readlink(t, (a, s) => {
    if (a) return i(a);
    if ((r.dereference && (s = Nl.resolve(process.cwd(), s)), e))
      Br.readlink(n, (o, c) =>
        o
          ? o.code === "EINVAL" || o.code === "UNKNOWN"
            ? Br.symlink(s, n, i)
            : i(o)
          : (r.dereference && (c = Nl.resolve(process.cwd(), c)),
            Ol.isSrcSubdir(s, c)
              ? i(
                  new Error(
                    `Cannot copy '${s}' to a subdirectory of itself, '${c}'.`,
                  ),
                )
              : e.isDirectory() && Ol.isSrcSubdir(c, s)
              ? i(new Error(`Cannot overwrite '${c}' with '${s}'.`))
              : LL(s, n, i)),
      );
    else return Br.symlink(s, n, i);
  });
}
function LL(e, t, n) {
  Br.unlink(t, (r) => (r ? n(r) : Br.symlink(e, t, n)));
}
var BL = AL;
const ur = Ar,
  Pl = pt,
  UL = Qi.mkdirsSync,
  FL = c2.utimesMillisSync,
  Dl = Ec;
function jL(e, t, n) {
  typeof n == "function" && (n = { filter: n }),
    (n = n || {}),
    (n.clobber = "clobber" in n ? !!n.clobber : !0),
    (n.overwrite = "overwrite" in n ? !!n.overwrite : n.clobber),
    n.preserveTimestamps &&
      process.arch === "ia32" &&
      process.emitWarning(
        `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
        "Warning",
        "fs-extra-WARN0002",
      );
  const { srcStat: r, destStat: i } = Dl.checkPathsSync(e, t, "copy", n);
  return Dl.checkParentPathsSync(e, r, t, "copy"), ML(i, e, t, n);
}
function ML(e, t, n, r) {
  if (r.filter && !r.filter(t, n)) return;
  const i = Pl.dirname(n);
  return ur.existsSync(i) || UL(i), m2(e, t, n, r);
}
function HL(e, t, n, r) {
  if (!(r.filter && !r.filter(t, n))) return m2(e, t, n, r);
}
function m2(e, t, n, r) {
  const a = (r.dereference ? ur.statSync : ur.lstatSync)(t);
  if (a.isDirectory()) return VL(a, e, t, n, r);
  if (a.isFile() || a.isCharacterDevice() || a.isBlockDevice())
    return qL(a, e, t, n, r);
  if (a.isSymbolicLink()) return JL(e, t, n, r);
  throw a.isSocket()
    ? new Error(`Cannot copy a socket file: ${t}`)
    : a.isFIFO()
    ? new Error(`Cannot copy a FIFO pipe: ${t}`)
    : new Error(`Unknown file: ${t}`);
}
function qL(e, t, n, r, i) {
  return t ? GL(e, n, r, i) : g2(e, n, r, i);
}
function GL(e, t, n, r) {
  if (r.overwrite) return ur.unlinkSync(n), g2(e, t, n, r);
  if (r.errorOnExist) throw new Error(`'${n}' already exists`);
}
function g2(e, t, n, r) {
  return (
    ur.copyFileSync(t, n),
    r.preserveTimestamps && QL(e.mode, t, n),
    Dv(n, e.mode)
  );
}
function QL(e, t, n) {
  return WL(e) && zL(n, e), KL(t, n);
}
function WL(e) {
  return (e & 128) === 0;
}
function zL(e, t) {
  return Dv(e, t | 128);
}
function Dv(e, t) {
  return ur.chmodSync(e, t);
}
function KL(e, t) {
  const n = ur.statSync(e);
  return FL(t, n.atime, n.mtime);
}
function VL(e, t, n, r, i) {
  return t ? v2(n, r, i) : YL(e.mode, n, r, i);
}
function YL(e, t, n, r) {
  return ur.mkdirSync(n), v2(t, n, r), Dv(n, e);
}
function v2(e, t, n) {
  ur.readdirSync(e).forEach((r) => XL(r, e, t, n));
}
function XL(e, t, n, r) {
  const i = Pl.join(t, e),
    a = Pl.join(n, e),
    { destStat: s } = Dl.checkPathsSync(i, a, "copy", r);
  return HL(s, i, a, r);
}
function JL(e, t, n, r) {
  let i = ur.readlinkSync(t);
  if ((r.dereference && (i = Pl.resolve(process.cwd(), i)), e)) {
    let a;
    try {
      a = ur.readlinkSync(n);
    } catch (s) {
      if (s.code === "EINVAL" || s.code === "UNKNOWN")
        return ur.symlinkSync(i, n);
      throw s;
    }
    if (
      (r.dereference && (a = Pl.resolve(process.cwd(), a)),
      Dl.isSrcSubdir(i, a))
    )
      throw new Error(
        `Cannot copy '${i}' to a subdirectory of itself, '${a}'.`,
      );
    if (ur.statSync(n).isDirectory() && Dl.isSrcSubdir(a, i))
      throw new Error(`Cannot overwrite '${a}' with '${i}'.`);
    return ZL(i, n);
  } else return ur.symlinkSync(i, n);
}
function ZL(e, t) {
  return ur.unlinkSync(t), ur.symlinkSync(e, t);
}
var eB = jL;
const tB = xr.fromCallback;
var Lv = { copy: tB(BL), copySync: eB };
const DE = Ar,
  y2 = pt,
  nn = gc,
  Ll = process.platform === "win32";
function b2(e) {
  ["unlink", "chmod", "stat", "lstat", "rmdir", "readdir"].forEach((n) => {
    (e[n] = e[n] || DE[n]), (n = n + "Sync"), (e[n] = e[n] || DE[n]);
  }),
    (e.maxBusyTries = e.maxBusyTries || 3);
}
function Bv(e, t, n) {
  let r = 0;
  typeof t == "function" && ((n = t), (t = {})),
    nn(e, "rimraf: missing path"),
    nn.strictEqual(typeof e, "string", "rimraf: path should be a string"),
    nn.strictEqual(typeof n, "function", "rimraf: callback function required"),
    nn(t, "rimraf: invalid options argument provided"),
    nn.strictEqual(typeof t, "object", "rimraf: options should be object"),
    b2(t),
    LE(e, t, function i(a) {
      if (a) {
        if (
          (a.code === "EBUSY" ||
            a.code === "ENOTEMPTY" ||
            a.code === "EPERM") &&
          r < t.maxBusyTries
        ) {
          r++;
          const s = r * 100;
          return setTimeout(() => LE(e, t, i), s);
        }
        a.code === "ENOENT" && (a = null);
      }
      n(a);
    });
}
function LE(e, t, n) {
  nn(e),
    nn(t),
    nn(typeof n == "function"),
    t.lstat(e, (r, i) => {
      if (r && r.code === "ENOENT") return n(null);
      if (r && r.code === "EPERM" && Ll) return BE(e, t, r, n);
      if (i && i.isDirectory()) return Ff(e, t, r, n);
      t.unlink(e, (a) => {
        if (a) {
          if (a.code === "ENOENT") return n(null);
          if (a.code === "EPERM") return Ll ? BE(e, t, a, n) : Ff(e, t, a, n);
          if (a.code === "EISDIR") return Ff(e, t, a, n);
        }
        return n(a);
      });
    });
}
function BE(e, t, n, r) {
  nn(e),
    nn(t),
    nn(typeof r == "function"),
    t.chmod(e, 438, (i) => {
      i
        ? r(i.code === "ENOENT" ? null : n)
        : t.stat(e, (a, s) => {
            a
              ? r(a.code === "ENOENT" ? null : n)
              : s.isDirectory()
              ? Ff(e, t, n, r)
              : t.unlink(e, r);
          });
    });
}
function UE(e, t, n) {
  let r;
  nn(e), nn(t);
  try {
    t.chmodSync(e, 438);
  } catch (i) {
    if (i.code === "ENOENT") return;
    throw n;
  }
  try {
    r = t.statSync(e);
  } catch (i) {
    if (i.code === "ENOENT") return;
    throw n;
  }
  r.isDirectory() ? jf(e, t, n) : t.unlinkSync(e);
}
function Ff(e, t, n, r) {
  nn(e),
    nn(t),
    nn(typeof r == "function"),
    t.rmdir(e, (i) => {
      i && (i.code === "ENOTEMPTY" || i.code === "EEXIST" || i.code === "EPERM")
        ? nB(e, t, r)
        : i && i.code === "ENOTDIR"
        ? r(n)
        : r(i);
    });
}
function nB(e, t, n) {
  nn(e),
    nn(t),
    nn(typeof n == "function"),
    t.readdir(e, (r, i) => {
      if (r) return n(r);
      let a = i.length,
        s;
      if (a === 0) return t.rmdir(e, n);
      i.forEach((o) => {
        Bv(y2.join(e, o), t, (c) => {
          if (!s) {
            if (c) return n((s = c));
            --a === 0 && t.rmdir(e, n);
          }
        });
      });
    });
}
function _2(e, t) {
  let n;
  (t = t || {}),
    b2(t),
    nn(e, "rimraf: missing path"),
    nn.strictEqual(typeof e, "string", "rimraf: path should be a string"),
    nn(t, "rimraf: missing options"),
    nn.strictEqual(typeof t, "object", "rimraf: options should be object");
  try {
    n = t.lstatSync(e);
  } catch (r) {
    if (r.code === "ENOENT") return;
    r.code === "EPERM" && Ll && UE(e, t, r);
  }
  try {
    n && n.isDirectory() ? jf(e, t, null) : t.unlinkSync(e);
  } catch (r) {
    if (r.code === "ENOENT") return;
    if (r.code === "EPERM") return Ll ? UE(e, t, r) : jf(e, t, r);
    if (r.code !== "EISDIR") throw r;
    jf(e, t, r);
  }
}
function jf(e, t, n) {
  nn(e), nn(t);
  try {
    t.rmdirSync(e);
  } catch (r) {
    if (r.code === "ENOTDIR") throw n;
    if (r.code === "ENOTEMPTY" || r.code === "EEXIST" || r.code === "EPERM")
      rB(e, t);
    else if (r.code !== "ENOENT") throw r;
  }
}
function rB(e, t) {
  if (
    (nn(e), nn(t), t.readdirSync(e).forEach((n) => _2(y2.join(e, n), t)), Ll)
  ) {
    const n = Date.now();
    do
      try {
        return t.rmdirSync(e, t);
      } catch {}
    while (Date.now() - n < 500);
  } else return t.rmdirSync(e, t);
}
var iB = Bv;
Bv.sync = _2;
const fd = Ar,
  aB = xr.fromCallback,
  E2 = iB;
function sB(e, t) {
  if (fd.rm) return fd.rm(e, { recursive: !0, force: !0 }, t);
  E2(e, t);
}
function oB(e) {
  if (fd.rmSync) return fd.rmSync(e, { recursive: !0, force: !0 });
  E2.sync(e);
}
var ap = { remove: aB(sB), removeSync: oB };
const cB = xr.fromPromise,
  w2 = Ys,
  x2 = pt,
  A2 = Qi,
  S2 = ap,
  FE = cB(async function (t) {
    let n;
    try {
      n = await w2.readdir(t);
    } catch {
      return A2.mkdirs(t);
    }
    return Promise.all(n.map((r) => S2.remove(x2.join(t, r))));
  });
function jE(e) {
  let t;
  try {
    t = w2.readdirSync(e);
  } catch {
    return A2.mkdirsSync(e);
  }
  t.forEach((n) => {
    (n = x2.join(e, n)), S2.removeSync(n);
  });
}
var lB = { emptyDirSync: jE, emptydirSync: jE, emptyDir: FE, emptydir: FE };
const uB = xr.fromCallback,
  I2 = pt,
  Da = Ar,
  $2 = Qi;
function fB(e, t) {
  function n() {
    Da.writeFile(e, "", (r) => {
      if (r) return t(r);
      t();
    });
  }
  Da.stat(e, (r, i) => {
    if (!r && i.isFile()) return t();
    const a = I2.dirname(e);
    Da.stat(a, (s, o) => {
      if (s)
        return s.code === "ENOENT"
          ? $2.mkdirs(a, (c) => {
              if (c) return t(c);
              n();
            })
          : t(s);
      o.isDirectory()
        ? n()
        : Da.readdir(a, (c) => {
            if (c) return t(c);
          });
    });
  });
}
function dB(e) {
  let t;
  try {
    t = Da.statSync(e);
  } catch {}
  if (t && t.isFile()) return;
  const n = I2.dirname(e);
  try {
    Da.statSync(n).isDirectory() || Da.readdirSync(n);
  } catch (r) {
    if (r && r.code === "ENOENT") $2.mkdirsSync(n);
    else throw r;
  }
  Da.writeFileSync(e, "");
}
var pB = { createFile: uB(fB), createFileSync: dB };
const hB = xr.fromCallback,
  C2 = pt,
  Ta = Ar,
  R2 = Qi,
  mB = Xs.pathExists,
  { areIdentical: k2 } = Ec;
function gB(e, t, n) {
  function r(i, a) {
    Ta.link(i, a, (s) => {
      if (s) return n(s);
      n(null);
    });
  }
  Ta.lstat(t, (i, a) => {
    Ta.lstat(e, (s, o) => {
      if (s)
        return (s.message = s.message.replace("lstat", "ensureLink")), n(s);
      if (a && k2(o, a)) return n(null);
      const c = C2.dirname(t);
      mB(c, (l, f) => {
        if (l) return n(l);
        if (f) return r(e, t);
        R2.mkdirs(c, (u) => {
          if (u) return n(u);
          r(e, t);
        });
      });
    });
  });
}
function vB(e, t) {
  let n;
  try {
    n = Ta.lstatSync(t);
  } catch {}
  try {
    const a = Ta.lstatSync(e);
    if (n && k2(a, n)) return;
  } catch (a) {
    throw ((a.message = a.message.replace("lstat", "ensureLink")), a);
  }
  const r = C2.dirname(t);
  return Ta.existsSync(r) || R2.mkdirsSync(r), Ta.linkSync(e, t);
}
var yB = { createLink: hB(gB), createLinkSync: vB };
const La = pt,
  dl = Ar,
  bB = Xs.pathExists;
function _B(e, t, n) {
  if (La.isAbsolute(e))
    return dl.lstat(e, (r) =>
      r
        ? ((r.message = r.message.replace("lstat", "ensureSymlink")), n(r))
        : n(null, { toCwd: e, toDst: e }),
    );
  {
    const r = La.dirname(t),
      i = La.join(r, e);
    return bB(i, (a, s) =>
      a
        ? n(a)
        : s
        ? n(null, { toCwd: i, toDst: e })
        : dl.lstat(e, (o) =>
            o
              ? ((o.message = o.message.replace("lstat", "ensureSymlink")),
                n(o))
              : n(null, { toCwd: e, toDst: La.relative(r, e) }),
          ),
    );
  }
}
function EB(e, t) {
  let n;
  if (La.isAbsolute(e)) {
    if (((n = dl.existsSync(e)), !n))
      throw new Error("absolute srcpath does not exist");
    return { toCwd: e, toDst: e };
  } else {
    const r = La.dirname(t),
      i = La.join(r, e);
    if (((n = dl.existsSync(i)), n)) return { toCwd: i, toDst: e };
    if (((n = dl.existsSync(e)), !n))
      throw new Error("relative srcpath does not exist");
    return { toCwd: e, toDst: La.relative(r, e) };
  }
}
var wB = { symlinkPaths: _B, symlinkPathsSync: EB };
const T2 = Ar;
function xB(e, t, n) {
  if (
    ((n = typeof t == "function" ? t : n),
    (t = typeof t == "function" ? !1 : t),
    t)
  )
    return n(null, t);
  T2.lstat(e, (r, i) => {
    if (r) return n(null, "file");
    (t = i && i.isDirectory() ? "dir" : "file"), n(null, t);
  });
}
function AB(e, t) {
  let n;
  if (t) return t;
  try {
    n = T2.lstatSync(e);
  } catch {
    return "file";
  }
  return n && n.isDirectory() ? "dir" : "file";
}
var SB = { symlinkType: xB, symlinkTypeSync: AB };
const IB = xr.fromCallback,
  N2 = pt,
  di = Ys,
  O2 = Qi,
  $B = O2.mkdirs,
  CB = O2.mkdirsSync,
  P2 = wB,
  RB = P2.symlinkPaths,
  kB = P2.symlinkPathsSync,
  D2 = SB,
  TB = D2.symlinkType,
  NB = D2.symlinkTypeSync,
  OB = Xs.pathExists,
  { areIdentical: L2 } = Ec;
function PB(e, t, n, r) {
  (r = typeof n == "function" ? n : r),
    (n = typeof n == "function" ? !1 : n),
    di.lstat(t, (i, a) => {
      !i && a.isSymbolicLink()
        ? Promise.all([di.stat(e), di.stat(t)]).then(([s, o]) => {
            if (L2(s, o)) return r(null);
            ME(e, t, n, r);
          })
        : ME(e, t, n, r);
    });
}
function ME(e, t, n, r) {
  RB(e, t, (i, a) => {
    if (i) return r(i);
    (e = a.toDst),
      TB(a.toCwd, n, (s, o) => {
        if (s) return r(s);
        const c = N2.dirname(t);
        OB(c, (l, f) => {
          if (l) return r(l);
          if (f) return di.symlink(e, t, o, r);
          $B(c, (u) => {
            if (u) return r(u);
            di.symlink(e, t, o, r);
          });
        });
      });
  });
}
function DB(e, t, n) {
  let r;
  try {
    r = di.lstatSync(t);
  } catch {}
  if (r && r.isSymbolicLink()) {
    const o = di.statSync(e),
      c = di.statSync(t);
    if (L2(o, c)) return;
  }
  const i = kB(e, t);
  (e = i.toDst), (n = NB(i.toCwd, n));
  const a = N2.dirname(t);
  return di.existsSync(a) || CB(a), di.symlinkSync(e, t, n);
}
var LB = { createSymlink: IB(PB), createSymlinkSync: DB };
const { createFile: HE, createFileSync: qE } = pB,
  { createLink: GE, createLinkSync: QE } = yB,
  { createSymlink: WE, createSymlinkSync: zE } = LB;
var BB = {
  createFile: HE,
  createFileSync: qE,
  ensureFile: HE,
  ensureFileSync: qE,
  createLink: GE,
  createLinkSync: QE,
  ensureLink: GE,
  ensureLinkSync: QE,
  createSymlink: WE,
  createSymlinkSync: zE,
  ensureSymlink: WE,
  ensureSymlinkSync: zE,
};
function UB(
  e,
  {
    EOL: t = `
`,
    finalEOL: n = !0,
    replacer: r = null,
    spaces: i,
  } = {},
) {
  const a = n ? t : "";
  return JSON.stringify(e, r, i).replace(/\n/g, t) + a;
}
function FB(e) {
  return (
    Buffer.isBuffer(e) && (e = e.toString("utf8")), e.replace(/^\uFEFF/, "")
  );
}
var Uv = { stringify: UB, stripBom: FB };
let Jo;
try {
  Jo = Ar;
} catch {
  Jo = Xt;
}
const sp = xr,
  { stringify: B2, stripBom: U2 } = Uv;
async function jB(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const n = t.fs || Jo,
    r = "throws" in t ? t.throws : !0;
  let i = await sp.fromCallback(n.readFile)(e, t);
  i = U2(i);
  let a;
  try {
    a = JSON.parse(i, t ? t.reviver : null);
  } catch (s) {
    if (r) throw ((s.message = `${e}: ${s.message}`), s);
    return null;
  }
  return a;
}
const MB = sp.fromPromise(jB);
function HB(e, t = {}) {
  typeof t == "string" && (t = { encoding: t });
  const n = t.fs || Jo,
    r = "throws" in t ? t.throws : !0;
  try {
    let i = n.readFileSync(e, t);
    return (i = U2(i)), JSON.parse(i, t.reviver);
  } catch (i) {
    if (r) throw ((i.message = `${e}: ${i.message}`), i);
    return null;
  }
}
async function qB(e, t, n = {}) {
  const r = n.fs || Jo,
    i = B2(t, n);
  await sp.fromCallback(r.writeFile)(e, i, n);
}
const GB = sp.fromPromise(qB);
function QB(e, t, n = {}) {
  const r = n.fs || Jo,
    i = B2(t, n);
  return r.writeFileSync(e, i, n);
}
const WB = { readFile: MB, readFileSync: HB, writeFile: GB, writeFileSync: QB };
var zB = WB;
const sf = zB;
var KB = {
  readJson: sf.readFile,
  readJsonSync: sf.readFileSync,
  writeJson: sf.writeFile,
  writeJsonSync: sf.writeFileSync,
};
const VB = xr.fromCallback,
  pl = Ar,
  F2 = pt,
  j2 = Qi,
  YB = Xs.pathExists;
function XB(e, t, n, r) {
  typeof n == "function" && ((r = n), (n = "utf8"));
  const i = F2.dirname(e);
  YB(i, (a, s) => {
    if (a) return r(a);
    if (s) return pl.writeFile(e, t, n, r);
    j2.mkdirs(i, (o) => {
      if (o) return r(o);
      pl.writeFile(e, t, n, r);
    });
  });
}
function JB(e, ...t) {
  const n = F2.dirname(e);
  if (pl.existsSync(n)) return pl.writeFileSync(e, ...t);
  j2.mkdirsSync(n), pl.writeFileSync(e, ...t);
}
var Fv = { outputFile: VB(XB), outputFileSync: JB };
const { stringify: ZB } = Uv,
  { outputFile: eU } = Fv;
async function tU(e, t, n = {}) {
  const r = ZB(t, n);
  await eU(e, r, n);
}
var nU = tU;
const { stringify: rU } = Uv,
  { outputFileSync: iU } = Fv;
function aU(e, t, n) {
  const r = rU(t, n);
  iU(e, r, n);
}
var sU = aU;
const oU = xr.fromPromise,
  Er = KB;
Er.outputJson = oU(nU);
Er.outputJsonSync = sU;
Er.outputJSON = Er.outputJson;
Er.outputJSONSync = Er.outputJsonSync;
Er.writeJSON = Er.writeJson;
Er.writeJSONSync = Er.writeJsonSync;
Er.readJSON = Er.readJson;
Er.readJSONSync = Er.readJsonSync;
var cU = Er;
const lU = Ar,
  i0 = pt,
  uU = Lv.copy,
  M2 = ap.remove,
  fU = Qi.mkdirp,
  dU = Xs.pathExists,
  KE = Ec;
function pU(e, t, n, r) {
  typeof n == "function" && ((r = n), (n = {})), (n = n || {});
  const i = n.overwrite || n.clobber || !1;
  KE.checkPaths(e, t, "move", n, (a, s) => {
    if (a) return r(a);
    const { srcStat: o, isChangingCase: c = !1 } = s;
    KE.checkParentPaths(e, o, t, "move", (l) => {
      if (l) return r(l);
      if (hU(t)) return VE(e, t, i, c, r);
      fU(i0.dirname(t), (f) => (f ? r(f) : VE(e, t, i, c, r)));
    });
  });
}
function hU(e) {
  const t = i0.dirname(e);
  return i0.parse(t).root === t;
}
function VE(e, t, n, r, i) {
  if (r) return im(e, t, n, i);
  if (n) return M2(t, (a) => (a ? i(a) : im(e, t, n, i)));
  dU(t, (a, s) =>
    a ? i(a) : s ? i(new Error("dest already exists.")) : im(e, t, n, i),
  );
}
function im(e, t, n, r) {
  lU.rename(e, t, (i) =>
    i ? (i.code !== "EXDEV" ? r(i) : mU(e, t, n, r)) : r(),
  );
}
function mU(e, t, n, r) {
  uU(e, t, { overwrite: n, errorOnExist: !0 }, (a) => (a ? r(a) : M2(e, r)));
}
var gU = pU;
const H2 = Ar,
  a0 = pt,
  vU = Lv.copySync,
  q2 = ap.removeSync,
  yU = Qi.mkdirpSync,
  YE = Ec;
function bU(e, t, n) {
  n = n || {};
  const r = n.overwrite || n.clobber || !1,
    { srcStat: i, isChangingCase: a = !1 } = YE.checkPathsSync(e, t, "move", n);
  return (
    YE.checkParentPathsSync(e, i, t, "move"),
    _U(t) || yU(a0.dirname(t)),
    EU(e, t, r, a)
  );
}
function _U(e) {
  const t = a0.dirname(e);
  return a0.parse(t).root === t;
}
function EU(e, t, n, r) {
  if (r) return am(e, t, n);
  if (n) return q2(t), am(e, t, n);
  if (H2.existsSync(t)) throw new Error("dest already exists.");
  return am(e, t, n);
}
function am(e, t, n) {
  try {
    H2.renameSync(e, t);
  } catch (r) {
    if (r.code !== "EXDEV") throw r;
    return wU(e, t, n);
  }
}
function wU(e, t, n) {
  return vU(e, t, { overwrite: n, errorOnExist: !0 }), q2(e);
}
var xU = bU;
const AU = xr.fromCallback;
var SU = { move: AU(gU), moveSync: xU },
  Za = { ...Ys, ...Lv, ...lB, ...BB, ...cU, ...Qi, ...SU, ...Fv, ...Xs, ...ap },
  cs = {},
  ar = {},
  jv = {},
  Ai = {};
function G2(e) {
  return typeof e > "u" || e === null;
}
function IU(e) {
  return typeof e == "object" && e !== null;
}
function $U(e) {
  return Array.isArray(e) ? e : G2(e) ? [] : [e];
}
function CU(e, t) {
  var n, r, i, a;
  if (t)
    for (a = Object.keys(t), n = 0, r = a.length; n < r; n += 1)
      (i = a[n]), (e[i] = t[i]);
  return e;
}
function RU(e, t) {
  var n = "",
    r;
  for (r = 0; r < t; r += 1) n += e;
  return n;
}
function kU(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
Ai.isNothing = G2;
Ai.isObject = IU;
Ai.toArray = $U;
Ai.repeat = RU;
Ai.isNegativeZero = kU;
Ai.extend = CU;
function Q2(e, t) {
  var n = "",
    r = e.reason || "(unknown reason)";
  return e.mark
    ? (e.mark.name && (n += 'in "' + e.mark.name + '" '),
      (n += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")"),
      !t &&
        e.mark.snippet &&
        (n +=
          `

` + e.mark.snippet),
      r + " " + n)
    : r;
}
function Bl(e, t) {
  Error.call(this),
    (this.name = "YAMLException"),
    (this.reason = e),
    (this.mark = t),
    (this.message = Q2(this, !1)),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack || "");
}
Bl.prototype = Object.create(Error.prototype);
Bl.prototype.constructor = Bl;
Bl.prototype.toString = function (t) {
  return this.name + ": " + Q2(this, t);
};
var nu = Bl,
  nl = Ai;
function sm(e, t, n, r, i) {
  var a = "",
    s = "",
    o = Math.floor(i / 2) - 1;
  return (
    r - t > o && ((a = " ... "), (t = r - o + a.length)),
    n - r > o && ((s = " ..."), (n = r + o - s.length)),
    { str: a + e.slice(t, n).replace(/\t/g, "â†’") + s, pos: r - t + a.length }
  );
}
function om(e, t) {
  return nl.repeat(" ", t - e.length) + e;
}
function TU(e, t) {
  if (((t = Object.create(t || null)), !e.buffer)) return null;
  t.maxLength || (t.maxLength = 79),
    typeof t.indent != "number" && (t.indent = 1),
    typeof t.linesBefore != "number" && (t.linesBefore = 3),
    typeof t.linesAfter != "number" && (t.linesAfter = 2);
  for (
    var n = /\r?\n|\r|\0/g, r = [0], i = [], a, s = -1;
    (a = n.exec(e.buffer));

  )
    i.push(a.index),
      r.push(a.index + a[0].length),
      e.position <= a.index && s < 0 && (s = r.length - 2);
  s < 0 && (s = r.length - 1);
  var o = "",
    c,
    l,
    f = Math.min(e.line + t.linesAfter, i.length).toString().length,
    u = t.maxLength - (t.indent + f + 3);
  for (c = 1; c <= t.linesBefore && !(s - c < 0); c++)
    (l = sm(e.buffer, r[s - c], i[s - c], e.position - (r[s] - r[s - c]), u)),
      (o =
        nl.repeat(" ", t.indent) +
        om((e.line - c + 1).toString(), f) +
        " | " +
        l.str +
        `
` +
        o);
  for (
    l = sm(e.buffer, r[s], i[s], e.position, u),
      o +=
        nl.repeat(" ", t.indent) +
        om((e.line + 1).toString(), f) +
        " | " +
        l.str +
        `
`,
      o +=
        nl.repeat("-", t.indent + f + 3 + l.pos) +
        `^
`,
      c = 1;
    c <= t.linesAfter && !(s + c >= i.length);
    c++
  )
    (l = sm(e.buffer, r[s + c], i[s + c], e.position - (r[s] - r[s + c]), u)),
      (o +=
        nl.repeat(" ", t.indent) +
        om((e.line + c + 1).toString(), f) +
        " | " +
        l.str +
        `
`);
  return o.replace(/\n$/, "");
}
var NU = TU,
  XE = nu,
  OU = [
    "kind",
    "multi",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "representName",
    "defaultStyle",
    "styleAliases",
  ],
  PU = ["scalar", "sequence", "mapping"];
function DU(e) {
  var t = {};
  return (
    e !== null &&
      Object.keys(e).forEach(function (n) {
        e[n].forEach(function (r) {
          t[String(r)] = n;
        });
      }),
    t
  );
}
function LU(e, t) {
  if (
    ((t = t || {}),
    Object.keys(t).forEach(function (n) {
      if (OU.indexOf(n) === -1)
        throw new XE(
          'Unknown option "' +
            n +
            '" is met in definition of "' +
            e +
            '" YAML type.',
        );
    }),
    (this.options = t),
    (this.tag = e),
    (this.kind = t.kind || null),
    (this.resolve =
      t.resolve ||
      function () {
        return !0;
      }),
    (this.construct =
      t.construct ||
      function (n) {
        return n;
      }),
    (this.instanceOf = t.instanceOf || null),
    (this.predicate = t.predicate || null),
    (this.represent = t.represent || null),
    (this.representName = t.representName || null),
    (this.defaultStyle = t.defaultStyle || null),
    (this.multi = t.multi || !1),
    (this.styleAliases = DU(t.styleAliases || null)),
    PU.indexOf(this.kind) === -1)
  )
    throw new XE(
      'Unknown kind "' +
        this.kind +
        '" is specified for "' +
        e +
        '" YAML type.',
    );
}
var Sr = LU,
  Dc = nu,
  cm = Sr;
function JE(e, t) {
  var n = [];
  return (
    e[t].forEach(function (r) {
      var i = n.length;
      n.forEach(function (a, s) {
        a.tag === r.tag && a.kind === r.kind && a.multi === r.multi && (i = s);
      }),
        (n[i] = r);
    }),
    n
  );
}
function BU() {
  var e = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
    },
    t,
    n;
  function r(i) {
    i.multi
      ? (e.multi[i.kind].push(i), e.multi.fallback.push(i))
      : (e[i.kind][i.tag] = e.fallback[i.tag] = i);
  }
  for (t = 0, n = arguments.length; t < n; t += 1) arguments[t].forEach(r);
  return e;
}
function s0(e) {
  return this.extend(e);
}
s0.prototype.extend = function (t) {
  var n = [],
    r = [];
  if (t instanceof cm) r.push(t);
  else if (Array.isArray(t)) r = r.concat(t);
  else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
    t.implicit && (n = n.concat(t.implicit)),
      t.explicit && (r = r.concat(t.explicit));
  else
    throw new Dc(
      "Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })",
    );
  n.forEach(function (a) {
    if (!(a instanceof cm))
      throw new Dc(
        "Specified list of YAML types (or a single Type object) contains a non-Type object.",
      );
    if (a.loadKind && a.loadKind !== "scalar")
      throw new Dc(
        "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.",
      );
    if (a.multi)
      throw new Dc(
        "There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.",
      );
  }),
    r.forEach(function (a) {
      if (!(a instanceof cm))
        throw new Dc(
          "Specified list of YAML types (or a single Type object) contains a non-Type object.",
        );
    });
  var i = Object.create(s0.prototype);
  return (
    (i.implicit = (this.implicit || []).concat(n)),
    (i.explicit = (this.explicit || []).concat(r)),
    (i.compiledImplicit = JE(i, "implicit")),
    (i.compiledExplicit = JE(i, "explicit")),
    (i.compiledTypeMap = BU(i.compiledImplicit, i.compiledExplicit)),
    i
  );
};
var W2 = s0,
  UU = Sr,
  z2 = new UU("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function (e) {
      return e !== null ? e : "";
    },
  }),
  FU = Sr,
  K2 = new FU("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function (e) {
      return e !== null ? e : [];
    },
  }),
  jU = Sr,
  V2 = new jU("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function (e) {
      return e !== null ? e : {};
    },
  }),
  MU = W2,
  Y2 = new MU({ explicit: [z2, K2, V2] }),
  HU = Sr;
function qU(e) {
  if (e === null) return !0;
  var t = e.length;
  return (
    (t === 1 && e === "~") ||
    (t === 4 && (e === "null" || e === "Null" || e === "NULL"))
  );
}
function GU() {
  return null;
}
function QU(e) {
  return e === null;
}
var X2 = new HU("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: qU,
    construct: GU,
    predicate: QU,
    represent: {
      canonical: function () {
        return "~";
      },
      lowercase: function () {
        return "null";
      },
      uppercase: function () {
        return "NULL";
      },
      camelcase: function () {
        return "Null";
      },
      empty: function () {
        return "";
      },
    },
    defaultStyle: "lowercase",
  }),
  WU = Sr;
function zU(e) {
  if (e === null) return !1;
  var t = e.length;
  return (
    (t === 4 && (e === "true" || e === "True" || e === "TRUE")) ||
    (t === 5 && (e === "false" || e === "False" || e === "FALSE"))
  );
}
function KU(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function VU(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var J2 = new WU("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: zU,
    construct: KU,
    predicate: VU,
    represent: {
      lowercase: function (e) {
        return e ? "true" : "false";
      },
      uppercase: function (e) {
        return e ? "TRUE" : "FALSE";
      },
      camelcase: function (e) {
        return e ? "True" : "False";
      },
    },
    defaultStyle: "lowercase",
  }),
  YU = Ai,
  XU = Sr;
function JU(e) {
  return (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102);
}
function ZU(e) {
  return 48 <= e && e <= 55;
}
function eF(e) {
  return 48 <= e && e <= 57;
}
function tF(e) {
  if (e === null) return !1;
  var t = e.length,
    n = 0,
    r = !1,
    i;
  if (!t) return !1;
  if (((i = e[n]), (i === "-" || i === "+") && (i = e[++n]), i === "0")) {
    if (n + 1 === t) return !0;
    if (((i = e[++n]), i === "b")) {
      for (n++; n < t; n++)
        if (((i = e[n]), i !== "_")) {
          if (i !== "0" && i !== "1") return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < t; n++)
        if (((i = e[n]), i !== "_")) {
          if (!JU(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < t; n++)
        if (((i = e[n]), i !== "_")) {
          if (!ZU(e.charCodeAt(n))) return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_") return !1;
  for (; n < t; n++)
    if (((i = e[n]), i !== "_")) {
      if (!eF(e.charCodeAt(n))) return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function nF(e) {
  var t = e,
    n = 1,
    r;
  if (
    (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")),
    (r = t[0]),
    (r === "-" || r === "+") &&
      (r === "-" && (n = -1), (t = t.slice(1)), (r = t[0])),
    t === "0")
  )
    return 0;
  if (r === "0") {
    if (t[1] === "b") return n * parseInt(t.slice(2), 2);
    if (t[1] === "x") return n * parseInt(t.slice(2), 16);
    if (t[1] === "o") return n * parseInt(t.slice(2), 8);
  }
  return n * parseInt(t, 10);
}
function rF(e) {
  return (
    Object.prototype.toString.call(e) === "[object Number]" &&
    e % 1 === 0 &&
    !YU.isNegativeZero(e)
  );
}
var Z2 = new XU("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: tF,
    construct: nF,
    predicate: rF,
    represent: {
      binary: function (e) {
        return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
      },
      octal: function (e) {
        return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
      },
      decimal: function (e) {
        return e.toString(10);
      },
      hexadecimal: function (e) {
        return e >= 0
          ? "0x" + e.toString(16).toUpperCase()
          : "-0x" + e.toString(16).toUpperCase().slice(1);
      },
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"],
    },
  }),
  eC = Ai,
  iF = Sr,
  aF = new RegExp(
    "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$",
  );
function sF(e) {
  return !(e === null || !aF.test(e) || e[e.length - 1] === "_");
}
function oF(e) {
  var t, n;
  return (
    (t = e.replace(/_/g, "").toLowerCase()),
    (n = t[0] === "-" ? -1 : 1),
    "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)),
    t === ".inf"
      ? n === 1
        ? Number.POSITIVE_INFINITY
        : Number.NEGATIVE_INFINITY
      : t === ".nan"
      ? NaN
      : n * parseFloat(t, 10)
  );
}
var cF = /^[-+]?[0-9]+e/;
function lF(e, t) {
  var n;
  if (isNaN(e))
    switch (t) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (eC.isNegativeZero(e)) return "-0.0";
  return (n = e.toString(10)), cF.test(n) ? n.replace("e", ".e") : n;
}
function uF(e) {
  return (
    Object.prototype.toString.call(e) === "[object Number]" &&
    (e % 1 !== 0 || eC.isNegativeZero(e))
  );
}
var tC = new iF("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: sF,
    construct: oF,
    predicate: uF,
    represent: lF,
    defaultStyle: "lowercase",
  }),
  nC = Y2.extend({ implicit: [X2, J2, Z2, tC] }),
  rC = nC,
  fF = Sr,
  iC = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
  aC = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$",
  );
function dF(e) {
  return e === null ? !1 : iC.exec(e) !== null || aC.exec(e) !== null;
}
function pF(e) {
  var t,
    n,
    r,
    i,
    a,
    s,
    o,
    c = 0,
    l = null,
    f,
    u,
    d;
  if (((t = iC.exec(e)), t === null && (t = aC.exec(e)), t === null))
    throw new Error("Date resolve error");
  if (((n = +t[1]), (r = +t[2] - 1), (i = +t[3]), !t[4]))
    return new Date(Date.UTC(n, r, i));
  if (((a = +t[4]), (s = +t[5]), (o = +t[6]), t[7])) {
    for (c = t[7].slice(0, 3); c.length < 3; ) c += "0";
    c = +c;
  }
  return (
    t[9] &&
      ((f = +t[10]),
      (u = +(t[11] || 0)),
      (l = (f * 60 + u) * 6e4),
      t[9] === "-" && (l = -l)),
    (d = new Date(Date.UTC(n, r, i, a, s, o, c))),
    l && d.setTime(d.getTime() - l),
    d
  );
}
function hF(e) {
  return e.toISOString();
}
var sC = new fF("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: dF,
    construct: pF,
    instanceOf: Date,
    represent: hF,
  }),
  mF = Sr;
function gF(e) {
  return e === "<<" || e === null;
}
var oC = new mF("tag:yaml.org,2002:merge", { kind: "scalar", resolve: gF }),
  vF = Sr,
  Mv = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function yF(e) {
  if (e === null) return !1;
  var t,
    n,
    r = 0,
    i = e.length,
    a = Mv;
  for (n = 0; n < i; n++)
    if (((t = a.indexOf(e.charAt(n))), !(t > 64))) {
      if (t < 0) return !1;
      r += 6;
    }
  return r % 8 === 0;
}
function bF(e) {
  var t,
    n,
    r = e.replace(/[\r\n=]/g, ""),
    i = r.length,
    a = Mv,
    s = 0,
    o = [];
  for (t = 0; t < i; t++)
    t % 4 === 0 &&
      t &&
      (o.push((s >> 16) & 255), o.push((s >> 8) & 255), o.push(s & 255)),
      (s = (s << 6) | a.indexOf(r.charAt(t)));
  return (
    (n = (i % 4) * 6),
    n === 0
      ? (o.push((s >> 16) & 255), o.push((s >> 8) & 255), o.push(s & 255))
      : n === 18
      ? (o.push((s >> 10) & 255), o.push((s >> 2) & 255))
      : n === 12 && o.push((s >> 4) & 255),
    new Uint8Array(o)
  );
}
function _F(e) {
  var t = "",
    n = 0,
    r,
    i,
    a = e.length,
    s = Mv;
  for (r = 0; r < a; r++)
    r % 3 === 0 &&
      r &&
      ((t += s[(n >> 18) & 63]),
      (t += s[(n >> 12) & 63]),
      (t += s[(n >> 6) & 63]),
      (t += s[n & 63])),
      (n = (n << 8) + e[r]);
  return (
    (i = a % 3),
    i === 0
      ? ((t += s[(n >> 18) & 63]),
        (t += s[(n >> 12) & 63]),
        (t += s[(n >> 6) & 63]),
        (t += s[n & 63]))
      : i === 2
      ? ((t += s[(n >> 10) & 63]),
        (t += s[(n >> 4) & 63]),
        (t += s[(n << 2) & 63]),
        (t += s[64]))
      : i === 1 &&
        ((t += s[(n >> 2) & 63]),
        (t += s[(n << 4) & 63]),
        (t += s[64]),
        (t += s[64])),
    t
  );
}
function EF(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var cC = new vF("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: yF,
    construct: bF,
    predicate: EF,
    represent: _F,
  }),
  wF = Sr,
  xF = Object.prototype.hasOwnProperty,
  AF = Object.prototype.toString;
function SF(e) {
  if (e === null) return !0;
  var t = [],
    n,
    r,
    i,
    a,
    s,
    o = e;
  for (n = 0, r = o.length; n < r; n += 1) {
    if (((i = o[n]), (s = !1), AF.call(i) !== "[object Object]")) return !1;
    for (a in i)
      if (xF.call(i, a))
        if (!s) s = !0;
        else return !1;
    if (!s) return !1;
    if (t.indexOf(a) === -1) t.push(a);
    else return !1;
  }
  return !0;
}
function IF(e) {
  return e !== null ? e : [];
}
var lC = new wF("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: SF,
    construct: IF,
  }),
  $F = Sr,
  CF = Object.prototype.toString;
function RF(e) {
  if (e === null) return !0;
  var t,
    n,
    r,
    i,
    a,
    s = e;
  for (a = new Array(s.length), t = 0, n = s.length; t < n; t += 1) {
    if (
      ((r = s[t]),
      CF.call(r) !== "[object Object]" ||
        ((i = Object.keys(r)), i.length !== 1))
    )
      return !1;
    a[t] = [i[0], r[i[0]]];
  }
  return !0;
}
function kF(e) {
  if (e === null) return [];
  var t,
    n,
    r,
    i,
    a,
    s = e;
  for (a = new Array(s.length), t = 0, n = s.length; t < n; t += 1)
    (r = s[t]), (i = Object.keys(r)), (a[t] = [i[0], r[i[0]]]);
  return a;
}
var uC = new $F("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: RF,
    construct: kF,
  }),
  TF = Sr,
  NF = Object.prototype.hasOwnProperty;
function OF(e) {
  if (e === null) return !0;
  var t,
    n = e;
  for (t in n) if (NF.call(n, t) && n[t] !== null) return !1;
  return !0;
}
function PF(e) {
  return e !== null ? e : {};
}
var fC = new TF("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: OF,
    construct: PF,
  }),
  Hv = rC.extend({ implicit: [sC, oC], explicit: [cC, lC, uC, fC] }),
  ms = Ai,
  dC = nu,
  DF = NU,
  LF = Hv,
  za = Object.prototype.hasOwnProperty,
  dd = 1,
  pC = 2,
  hC = 3,
  pd = 4,
  lm = 1,
  BF = 2,
  ZE = 3,
  UF =
    /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
  FF = /[\x85\u2028\u2029]/,
  jF = /[,\[\]\{\}]/,
  mC = /^(?:!|!!|![a-z\-]+!)$/i,
  gC =
    /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function ew(e) {
  return Object.prototype.toString.call(e);
}
function Mi(e) {
  return e === 10 || e === 13;
}
function Ps(e) {
  return e === 9 || e === 32;
}
function Ur(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function Io(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function MF(e) {
  var t;
  return 48 <= e && e <= 57
    ? e - 48
    : ((t = e | 32), 97 <= t && t <= 102 ? t - 97 + 10 : -1);
}
function HF(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function qF(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function tw(e) {
  return e === 48
    ? "\0"
    : e === 97
    ? "\x07"
    : e === 98
    ? "\b"
    : e === 116 || e === 9
    ? "	"
    : e === 110
    ? `
`
    : e === 118
    ? "\v"
    : e === 102
    ? "\f"
    : e === 114
    ? "\r"
    : e === 101
    ? "\x1B"
    : e === 32
    ? " "
    : e === 34
    ? '"'
    : e === 47
    ? "/"
    : e === 92
    ? "\\"
    : e === 78
    ? "Â…"
    : e === 95
    ? "Â "
    : e === 76
    ? "\u2028"
    : e === 80
    ? "\u2029"
    : "";
}
function GF(e) {
  return e <= 65535
    ? String.fromCharCode(e)
    : String.fromCharCode(
        ((e - 65536) >> 10) + 55296,
        ((e - 65536) & 1023) + 56320,
      );
}
var vC = new Array(256),
  yC = new Array(256);
for (var ao = 0; ao < 256; ao++) (vC[ao] = tw(ao) ? 1 : 0), (yC[ao] = tw(ao));
function QF(e, t) {
  (this.input = e),
    (this.filename = t.filename || null),
    (this.schema = t.schema || LF),
    (this.onWarning = t.onWarning || null),
    (this.legacy = t.legacy || !1),
    (this.json = t.json || !1),
    (this.listener = t.listener || null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.typeMap = this.schema.compiledTypeMap),
    (this.length = e.length),
    (this.position = 0),
    (this.line = 0),
    (this.lineStart = 0),
    (this.lineIndent = 0),
    (this.firstTabInLine = -1),
    (this.documents = []);
}
function bC(e, t) {
  var n = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart,
  };
  return (n.snippet = DF(n)), new dC(t, n);
}
function Ze(e, t) {
  throw bC(e, t);
}
function hd(e, t) {
  e.onWarning && e.onWarning.call(null, bC(e, t));
}
var nw = {
  YAML: function (t, n, r) {
    var i, a, s;
    t.version !== null && Ze(t, "duplication of %YAML directive"),
      r.length !== 1 && Ze(t, "YAML directive accepts exactly one argument"),
      (i = /^([0-9]+)\.([0-9]+)$/.exec(r[0])),
      i === null && Ze(t, "ill-formed argument of the YAML directive"),
      (a = parseInt(i[1], 10)),
      (s = parseInt(i[2], 10)),
      a !== 1 && Ze(t, "unacceptable YAML version of the document"),
      (t.version = r[0]),
      (t.checkLineBreaks = s < 2),
      s !== 1 && s !== 2 && hd(t, "unsupported YAML version of the document");
  },
  TAG: function (t, n, r) {
    var i, a;
    r.length !== 2 && Ze(t, "TAG directive accepts exactly two arguments"),
      (i = r[0]),
      (a = r[1]),
      mC.test(i) ||
        Ze(t, "ill-formed tag handle (first argument) of the TAG directive"),
      za.call(t.tagMap, i) &&
        Ze(
          t,
          'there is a previously declared suffix for "' + i + '" tag handle',
        ),
      gC.test(a) ||
        Ze(t, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      a = decodeURIComponent(a);
    } catch {
      Ze(t, "tag prefix is malformed: " + a);
    }
    t.tagMap[i] = a;
  },
};
function qa(e, t, n, r) {
  var i, a, s, o;
  if (t < n) {
    if (((o = e.input.slice(t, n)), r))
      for (i = 0, a = o.length; i < a; i += 1)
        (s = o.charCodeAt(i)),
          s === 9 ||
            (32 <= s && s <= 1114111) ||
            Ze(e, "expected valid JSON character");
    else UF.test(o) && Ze(e, "the stream contains non-printable characters");
    e.result += o;
  }
}
function rw(e, t, n, r) {
  var i, a, s, o;
  for (
    ms.isObject(n) ||
      Ze(
        e,
        "cannot merge mappings; the provided source object is unacceptable",
      ),
      i = Object.keys(n),
      s = 0,
      o = i.length;
    s < o;
    s += 1
  )
    (a = i[s]), za.call(t, a) || ((t[a] = n[a]), (r[a] = !0));
}
function $o(e, t, n, r, i, a, s, o, c) {
  var l, f;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), l = 0, f = i.length; l < f; l += 1)
      Array.isArray(i[l]) &&
        Ze(e, "nested arrays are not supported inside keys"),
        typeof i == "object" &&
          ew(i[l]) === "[object Object]" &&
          (i[l] = "[object Object]");
  if (
    (typeof i == "object" &&
      ew(i) === "[object Object]" &&
      (i = "[object Object]"),
    (i = String(i)),
    t === null && (t = {}),
    r === "tag:yaml.org,2002:merge")
  )
    if (Array.isArray(a))
      for (l = 0, f = a.length; l < f; l += 1) rw(e, t, a[l], n);
    else rw(e, t, a, n);
  else
    !e.json &&
      !za.call(n, i) &&
      za.call(t, i) &&
      ((e.line = s || e.line),
      (e.lineStart = o || e.lineStart),
      (e.position = c || e.position),
      Ze(e, "duplicated mapping key")),
      i === "__proto__"
        ? Object.defineProperty(t, i, {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: a,
          })
        : (t[i] = a),
      delete n[i];
  return t;
}
function qv(e) {
  var t;
  (t = e.input.charCodeAt(e.position)),
    t === 10
      ? e.position++
      : t === 13
      ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++)
      : Ze(e, "a line break is expected"),
    (e.line += 1),
    (e.lineStart = e.position),
    (e.firstTabInLine = -1);
}
function Dn(e, t, n) {
  for (var r = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; Ps(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position),
        (i = e.input.charCodeAt(++e.position));
    if (t && i === 35)
      do i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (Mi(i))
      for (
        qv(e), i = e.input.charCodeAt(e.position), r++, e.lineIndent = 0;
        i === 32;

      )
        e.lineIndent++, (i = e.input.charCodeAt(++e.position));
    else break;
  }
  return (
    n !== -1 && r !== 0 && e.lineIndent < n && hd(e, "deficient indentation"), r
  );
}
function op(e) {
  var t = e.position,
    n;
  return (
    (n = e.input.charCodeAt(t)),
    !!(
      (n === 45 || n === 46) &&
      n === e.input.charCodeAt(t + 1) &&
      n === e.input.charCodeAt(t + 2) &&
      ((t += 3), (n = e.input.charCodeAt(t)), n === 0 || Ur(n))
    )
  );
}
function Gv(e, t) {
  t === 1
    ? (e.result += " ")
    : t > 1 &&
      (e.result += ms.repeat(
        `
`,
        t - 1,
      ));
}
function WF(e, t, n) {
  var r,
    i,
    a,
    s,
    o,
    c,
    l,
    f,
    u = e.kind,
    d = e.result,
    p;
  if (
    ((p = e.input.charCodeAt(e.position)),
    Ur(p) ||
      Io(p) ||
      p === 35 ||
      p === 38 ||
      p === 42 ||
      p === 33 ||
      p === 124 ||
      p === 62 ||
      p === 39 ||
      p === 34 ||
      p === 37 ||
      p === 64 ||
      p === 96 ||
      ((p === 63 || p === 45) &&
        ((i = e.input.charCodeAt(e.position + 1)), Ur(i) || (n && Io(i)))))
  )
    return !1;
  for (
    e.kind = "scalar", e.result = "", a = s = e.position, o = !1;
    p !== 0;

  ) {
    if (p === 58) {
      if (((i = e.input.charCodeAt(e.position + 1)), Ur(i) || (n && Io(i))))
        break;
    } else if (p === 35) {
      if (((r = e.input.charCodeAt(e.position - 1)), Ur(r))) break;
    } else {
      if ((e.position === e.lineStart && op(e)) || (n && Io(p))) break;
      if (Mi(p))
        if (
          ((c = e.line),
          (l = e.lineStart),
          (f = e.lineIndent),
          Dn(e, !1, -1),
          e.lineIndent >= t)
        ) {
          (o = !0), (p = e.input.charCodeAt(e.position));
          continue;
        } else {
          (e.position = s), (e.line = c), (e.lineStart = l), (e.lineIndent = f);
          break;
        }
    }
    o && (qa(e, a, s, !1), Gv(e, e.line - c), (a = s = e.position), (o = !1)),
      Ps(p) || (s = e.position + 1),
      (p = e.input.charCodeAt(++e.position));
  }
  return qa(e, a, s, !1), e.result ? !0 : ((e.kind = u), (e.result = d), !1);
}
function zF(e, t) {
  var n, r, i;
  if (((n = e.input.charCodeAt(e.position)), n !== 39)) return !1;
  for (
    e.kind = "scalar", e.result = "", e.position++, r = i = e.position;
    (n = e.input.charCodeAt(e.position)) !== 0;

  )
    if (n === 39)
      if (
        (qa(e, r, e.position, !0),
        (n = e.input.charCodeAt(++e.position)),
        n === 39)
      )
        (r = e.position), e.position++, (i = e.position);
      else return !0;
    else
      Mi(n)
        ? (qa(e, r, i, !0), Gv(e, Dn(e, !1, t)), (r = i = e.position))
        : e.position === e.lineStart && op(e)
        ? Ze(e, "unexpected end of the document within a single quoted scalar")
        : (e.position++, (i = e.position));
  Ze(e, "unexpected end of the stream within a single quoted scalar");
}
function KF(e, t) {
  var n, r, i, a, s, o;
  if (((o = e.input.charCodeAt(e.position)), o !== 34)) return !1;
  for (
    e.kind = "scalar", e.result = "", e.position++, n = r = e.position;
    (o = e.input.charCodeAt(e.position)) !== 0;

  ) {
    if (o === 34) return qa(e, n, e.position, !0), e.position++, !0;
    if (o === 92) {
      if (
        (qa(e, n, e.position, !0),
        (o = e.input.charCodeAt(++e.position)),
        Mi(o))
      )
        Dn(e, !1, t);
      else if (o < 256 && vC[o]) (e.result += yC[o]), e.position++;
      else if ((s = HF(o)) > 0) {
        for (i = s, a = 0; i > 0; i--)
          (o = e.input.charCodeAt(++e.position)),
            (s = MF(o)) >= 0
              ? (a = (a << 4) + s)
              : Ze(e, "expected hexadecimal character");
        (e.result += GF(a)), e.position++;
      } else Ze(e, "unknown escape sequence");
      n = r = e.position;
    } else
      Mi(o)
        ? (qa(e, n, r, !0), Gv(e, Dn(e, !1, t)), (n = r = e.position))
        : e.position === e.lineStart && op(e)
        ? Ze(e, "unexpected end of the document within a double quoted scalar")
        : (e.position++, (r = e.position));
  }
  Ze(e, "unexpected end of the stream within a double quoted scalar");
}
function VF(e, t) {
  var n = !0,
    r,
    i,
    a,
    s = e.tag,
    o,
    c = e.anchor,
    l,
    f,
    u,
    d,
    p,
    h = Object.create(null),
    m,
    g,
    v,
    y;
  if (((y = e.input.charCodeAt(e.position)), y === 91))
    (f = 93), (p = !1), (o = []);
  else if (y === 123) (f = 125), (p = !0), (o = {});
  else return !1;
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = o),
      y = e.input.charCodeAt(++e.position);
    y !== 0;

  ) {
    if ((Dn(e, !0, t), (y = e.input.charCodeAt(e.position)), y === f))
      return (
        e.position++,
        (e.tag = s),
        (e.anchor = c),
        (e.kind = p ? "mapping" : "sequence"),
        (e.result = o),
        !0
      );
    n
      ? y === 44 && Ze(e, "expected the node content, but found ','")
      : Ze(e, "missed comma between flow collection entries"),
      (g = m = v = null),
      (u = d = !1),
      y === 63 &&
        ((l = e.input.charCodeAt(e.position + 1)),
        Ur(l) && ((u = d = !0), e.position++, Dn(e, !0, t))),
      (r = e.line),
      (i = e.lineStart),
      (a = e.position),
      Zo(e, t, dd, !1, !0),
      (g = e.tag),
      (m = e.result),
      Dn(e, !0, t),
      (y = e.input.charCodeAt(e.position)),
      (d || e.line === r) &&
        y === 58 &&
        ((u = !0),
        (y = e.input.charCodeAt(++e.position)),
        Dn(e, !0, t),
        Zo(e, t, dd, !1, !0),
        (v = e.result)),
      p
        ? $o(e, o, h, g, m, v, r, i, a)
        : u
        ? o.push($o(e, null, h, g, m, v, r, i, a))
        : o.push(m),
      Dn(e, !0, t),
      (y = e.input.charCodeAt(e.position)),
      y === 44 ? ((n = !0), (y = e.input.charCodeAt(++e.position))) : (n = !1);
  }
  Ze(e, "unexpected end of the stream within a flow collection");
}
function YF(e, t) {
  var n,
    r,
    i = lm,
    a = !1,
    s = !1,
    o = t,
    c = 0,
    l = !1,
    f,
    u;
  if (((u = e.input.charCodeAt(e.position)), u === 124)) r = !1;
  else if (u === 62) r = !0;
  else return !1;
  for (e.kind = "scalar", e.result = ""; u !== 0; )
    if (((u = e.input.charCodeAt(++e.position)), u === 43 || u === 45))
      lm === i
        ? (i = u === 43 ? ZE : BF)
        : Ze(e, "repeat of a chomping mode identifier");
    else if ((f = qF(u)) >= 0)
      f === 0
        ? Ze(
            e,
            "bad explicit indentation width of a block scalar; it cannot be less than one",
          )
        : s
        ? Ze(e, "repeat of an indentation width identifier")
        : ((o = t + f - 1), (s = !0));
    else break;
  if (Ps(u)) {
    do u = e.input.charCodeAt(++e.position);
    while (Ps(u));
    if (u === 35)
      do u = e.input.charCodeAt(++e.position);
      while (!Mi(u) && u !== 0);
  }
  for (; u !== 0; ) {
    for (
      qv(e), e.lineIndent = 0, u = e.input.charCodeAt(e.position);
      (!s || e.lineIndent < o) && u === 32;

    )
      e.lineIndent++, (u = e.input.charCodeAt(++e.position));
    if ((!s && e.lineIndent > o && (o = e.lineIndent), Mi(u))) {
      c++;
      continue;
    }
    if (e.lineIndent < o) {
      i === ZE
        ? (e.result += ms.repeat(
            `
`,
            a ? 1 + c : c,
          ))
        : i === lm &&
          a &&
          (e.result += `
`);
      break;
    }
    for (
      r
        ? Ps(u)
          ? ((l = !0),
            (e.result += ms.repeat(
              `
`,
              a ? 1 + c : c,
            )))
          : l
          ? ((l = !1),
            (e.result += ms.repeat(
              `
`,
              c + 1,
            )))
          : c === 0
          ? a && (e.result += " ")
          : (e.result += ms.repeat(
              `
`,
              c,
            ))
        : (e.result += ms.repeat(
            `
`,
            a ? 1 + c : c,
          )),
        a = !0,
        s = !0,
        c = 0,
        n = e.position;
      !Mi(u) && u !== 0;

    )
      u = e.input.charCodeAt(++e.position);
    qa(e, n, e.position, !1);
  }
  return !0;
}
function iw(e, t) {
  var n,
    r = e.tag,
    i = e.anchor,
    a = [],
    s,
    o = !1,
    c;
  if (e.firstTabInLine !== -1) return !1;
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = a),
      c = e.input.charCodeAt(e.position);
    c !== 0 &&
    (e.firstTabInLine !== -1 &&
      ((e.position = e.firstTabInLine),
      Ze(e, "tab characters must not be used in indentation")),
    !(c !== 45 || ((s = e.input.charCodeAt(e.position + 1)), !Ur(s))));

  ) {
    if (((o = !0), e.position++, Dn(e, !0, -1) && e.lineIndent <= t)) {
      a.push(null), (c = e.input.charCodeAt(e.position));
      continue;
    }
    if (
      ((n = e.line),
      Zo(e, t, hC, !1, !0),
      a.push(e.result),
      Dn(e, !0, -1),
      (c = e.input.charCodeAt(e.position)),
      (e.line === n || e.lineIndent > t) && c !== 0)
    )
      Ze(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < t) break;
  }
  return o
    ? ((e.tag = r), (e.anchor = i), (e.kind = "sequence"), (e.result = a), !0)
    : !1;
}
function XF(e, t, n) {
  var r,
    i,
    a,
    s,
    o,
    c,
    l = e.tag,
    f = e.anchor,
    u = {},
    d = Object.create(null),
    p = null,
    h = null,
    m = null,
    g = !1,
    v = !1,
    y;
  if (e.firstTabInLine !== -1) return !1;
  for (
    e.anchor !== null && (e.anchorMap[e.anchor] = u),
      y = e.input.charCodeAt(e.position);
    y !== 0;

  ) {
    if (
      (!g &&
        e.firstTabInLine !== -1 &&
        ((e.position = e.firstTabInLine),
        Ze(e, "tab characters must not be used in indentation")),
      (r = e.input.charCodeAt(e.position + 1)),
      (a = e.line),
      (y === 63 || y === 58) && Ur(r))
    )
      y === 63
        ? (g && ($o(e, u, d, p, h, null, s, o, c), (p = h = m = null)),
          (v = !0),
          (g = !0),
          (i = !0))
        : g
        ? ((g = !1), (i = !0))
        : Ze(
            e,
            "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line",
          ),
        (e.position += 1),
        (y = r);
    else {
      if (
        ((s = e.line),
        (o = e.lineStart),
        (c = e.position),
        !Zo(e, n, pC, !1, !0))
      )
        break;
      if (e.line === a) {
        for (y = e.input.charCodeAt(e.position); Ps(y); )
          y = e.input.charCodeAt(++e.position);
        if (y === 58)
          (y = e.input.charCodeAt(++e.position)),
            Ur(y) ||
              Ze(
                e,
                "a whitespace character is expected after the key-value separator within a block mapping",
              ),
            g && ($o(e, u, d, p, h, null, s, o, c), (p = h = m = null)),
            (v = !0),
            (g = !1),
            (i = !1),
            (p = e.tag),
            (h = e.result);
        else if (v)
          Ze(e, "can not read an implicit mapping pair; a colon is missed");
        else return (e.tag = l), (e.anchor = f), !0;
      } else if (v)
        Ze(
          e,
          "can not read a block mapping entry; a multiline key may not be an implicit key",
        );
      else return (e.tag = l), (e.anchor = f), !0;
    }
    if (
      ((e.line === a || e.lineIndent > t) &&
        (g && ((s = e.line), (o = e.lineStart), (c = e.position)),
        Zo(e, t, pd, !0, i) && (g ? (h = e.result) : (m = e.result)),
        g || ($o(e, u, d, p, h, m, s, o, c), (p = h = m = null)),
        Dn(e, !0, -1),
        (y = e.input.charCodeAt(e.position))),
      (e.line === a || e.lineIndent > t) && y !== 0)
    )
      Ze(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < t) break;
  }
  return (
    g && $o(e, u, d, p, h, null, s, o, c),
    v && ((e.tag = l), (e.anchor = f), (e.kind = "mapping"), (e.result = u)),
    v
  );
}
function JF(e) {
  var t,
    n = !1,
    r = !1,
    i,
    a,
    s;
  if (((s = e.input.charCodeAt(e.position)), s !== 33)) return !1;
  if (
    (e.tag !== null && Ze(e, "duplication of a tag property"),
    (s = e.input.charCodeAt(++e.position)),
    s === 60
      ? ((n = !0), (s = e.input.charCodeAt(++e.position)))
      : s === 33
      ? ((r = !0), (i = "!!"), (s = e.input.charCodeAt(++e.position)))
      : (i = "!"),
    (t = e.position),
    n)
  ) {
    do s = e.input.charCodeAt(++e.position);
    while (s !== 0 && s !== 62);
    e.position < e.length
      ? ((a = e.input.slice(t, e.position)),
        (s = e.input.charCodeAt(++e.position)))
      : Ze(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; s !== 0 && !Ur(s); )
      s === 33 &&
        (r
          ? Ze(e, "tag suffix cannot contain exclamation marks")
          : ((i = e.input.slice(t - 1, e.position + 1)),
            mC.test(i) ||
              Ze(e, "named tag handle cannot contain such characters"),
            (r = !0),
            (t = e.position + 1))),
        (s = e.input.charCodeAt(++e.position));
    (a = e.input.slice(t, e.position)),
      jF.test(a) &&
        Ze(e, "tag suffix cannot contain flow indicator characters");
  }
  a && !gC.test(a) && Ze(e, "tag name cannot contain such characters: " + a);
  try {
    a = decodeURIComponent(a);
  } catch {
    Ze(e, "tag name is malformed: " + a);
  }
  return (
    n
      ? (e.tag = a)
      : za.call(e.tagMap, i)
      ? (e.tag = e.tagMap[i] + a)
      : i === "!"
      ? (e.tag = "!" + a)
      : i === "!!"
      ? (e.tag = "tag:yaml.org,2002:" + a)
      : Ze(e, 'undeclared tag handle "' + i + '"'),
    !0
  );
}
function ZF(e) {
  var t, n;
  if (((n = e.input.charCodeAt(e.position)), n !== 38)) return !1;
  for (
    e.anchor !== null && Ze(e, "duplication of an anchor property"),
      n = e.input.charCodeAt(++e.position),
      t = e.position;
    n !== 0 && !Ur(n) && !Io(n);

  )
    n = e.input.charCodeAt(++e.position);
  return (
    e.position === t &&
      Ze(e, "name of an anchor node must contain at least one character"),
    (e.anchor = e.input.slice(t, e.position)),
    !0
  );
}
function e9(e) {
  var t, n, r;
  if (((r = e.input.charCodeAt(e.position)), r !== 42)) return !1;
  for (
    r = e.input.charCodeAt(++e.position), t = e.position;
    r !== 0 && !Ur(r) && !Io(r);

  )
    r = e.input.charCodeAt(++e.position);
  return (
    e.position === t &&
      Ze(e, "name of an alias node must contain at least one character"),
    (n = e.input.slice(t, e.position)),
    za.call(e.anchorMap, n) || Ze(e, 'unidentified alias "' + n + '"'),
    (e.result = e.anchorMap[n]),
    Dn(e, !0, -1),
    !0
  );
}
function Zo(e, t, n, r, i) {
  var a,
    s,
    o,
    c = 1,
    l = !1,
    f = !1,
    u,
    d,
    p,
    h,
    m,
    g;
  if (
    (e.listener !== null && e.listener("open", e),
    (e.tag = null),
    (e.anchor = null),
    (e.kind = null),
    (e.result = null),
    (a = s = o = pd === n || hC === n),
    r &&
      Dn(e, !0, -1) &&
      ((l = !0),
      e.lineIndent > t
        ? (c = 1)
        : e.lineIndent === t
        ? (c = 0)
        : e.lineIndent < t && (c = -1)),
    c === 1)
  )
    for (; JF(e) || ZF(e); )
      Dn(e, !0, -1)
        ? ((l = !0),
          (o = a),
          e.lineIndent > t
            ? (c = 1)
            : e.lineIndent === t
            ? (c = 0)
            : e.lineIndent < t && (c = -1))
        : (o = !1);
  if (
    (o && (o = l || i),
    (c === 1 || pd === n) &&
      (dd === n || pC === n ? (m = t) : (m = t + 1),
      (g = e.position - e.lineStart),
      c === 1
        ? (o && (iw(e, g) || XF(e, g, m))) || VF(e, m)
          ? (f = !0)
          : ((s && YF(e, m)) || zF(e, m) || KF(e, m)
              ? (f = !0)
              : e9(e)
              ? ((f = !0),
                (e.tag !== null || e.anchor !== null) &&
                  Ze(e, "alias node should not have any properties"))
              : WF(e, m, dd === n) &&
                ((f = !0), e.tag === null && (e.tag = "?")),
            e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
        : c === 0 && (f = o && iw(e, g))),
    e.tag === null)
  )
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (
      e.result !== null &&
        e.kind !== "scalar" &&
        Ze(
          e,
          'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
            e.kind +
            '"',
        ),
        u = 0,
        d = e.implicitTypes.length;
      u < d;
      u += 1
    )
      if (((h = e.implicitTypes[u]), h.resolve(e.result))) {
        (e.result = h.construct(e.result)),
          (e.tag = h.tag),
          e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (za.call(e.typeMap[e.kind || "fallback"], e.tag))
      h = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (
        h = null,
          p = e.typeMap.multi[e.kind || "fallback"],
          u = 0,
          d = p.length;
        u < d;
        u += 1
      )
        if (e.tag.slice(0, p[u].tag.length) === p[u].tag) {
          h = p[u];
          break;
        }
    h || Ze(e, "unknown tag !<" + e.tag + ">"),
      e.result !== null &&
        h.kind !== e.kind &&
        Ze(
          e,
          "unacceptable node kind for !<" +
            e.tag +
            '> tag; it should be "' +
            h.kind +
            '", not "' +
            e.kind +
            '"',
        ),
      h.resolve(e.result, e.tag)
        ? ((e.result = h.construct(e.result, e.tag)),
          e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
        : Ze(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return (
    e.listener !== null && e.listener("close", e),
    e.tag !== null || e.anchor !== null || f
  );
}
function t9(e) {
  var t = e.position,
    n,
    r,
    i,
    a = !1,
    s;
  for (
    e.version = null,
      e.checkLineBreaks = e.legacy,
      e.tagMap = Object.create(null),
      e.anchorMap = Object.create(null);
    (s = e.input.charCodeAt(e.position)) !== 0 &&
    (Dn(e, !0, -1),
    (s = e.input.charCodeAt(e.position)),
    !(e.lineIndent > 0 || s !== 37));

  ) {
    for (
      a = !0, s = e.input.charCodeAt(++e.position), n = e.position;
      s !== 0 && !Ur(s);

    )
      s = e.input.charCodeAt(++e.position);
    for (
      r = e.input.slice(n, e.position),
        i = [],
        r.length < 1 &&
          Ze(e, "directive name must not be less than one character in length");
      s !== 0;

    ) {
      for (; Ps(s); ) s = e.input.charCodeAt(++e.position);
      if (s === 35) {
        do s = e.input.charCodeAt(++e.position);
        while (s !== 0 && !Mi(s));
        break;
      }
      if (Mi(s)) break;
      for (n = e.position; s !== 0 && !Ur(s); )
        s = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(n, e.position));
    }
    s !== 0 && qv(e),
      za.call(nw, r)
        ? nw[r](e, r, i)
        : hd(e, 'unknown document directive "' + r + '"');
  }
  if (
    (Dn(e, !0, -1),
    e.lineIndent === 0 &&
    e.input.charCodeAt(e.position) === 45 &&
    e.input.charCodeAt(e.position + 1) === 45 &&
    e.input.charCodeAt(e.position + 2) === 45
      ? ((e.position += 3), Dn(e, !0, -1))
      : a && Ze(e, "directives end mark is expected"),
    Zo(e, e.lineIndent - 1, pd, !1, !0),
    Dn(e, !0, -1),
    e.checkLineBreaks &&
      FF.test(e.input.slice(t, e.position)) &&
      hd(e, "non-ASCII line breaks are interpreted as content"),
    e.documents.push(e.result),
    e.position === e.lineStart && op(e))
  ) {
    e.input.charCodeAt(e.position) === 46 && ((e.position += 3), Dn(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    Ze(e, "end of the stream or a document separator is expected");
  else return;
}
function _C(e, t) {
  (e = String(e)),
    (t = t || {}),
    e.length !== 0 &&
      (e.charCodeAt(e.length - 1) !== 10 &&
        e.charCodeAt(e.length - 1) !== 13 &&
        (e += `
`),
      e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var n = new QF(e, t),
    r = e.indexOf("\0");
  for (
    r !== -1 && ((n.position = r), Ze(n, "null byte is not allowed in input")),
      n.input += "\0";
    n.input.charCodeAt(n.position) === 32;

  )
    (n.lineIndent += 1), (n.position += 1);
  for (; n.position < n.length - 1; ) t9(n);
  return n.documents;
}
function n9(e, t, n) {
  t !== null && typeof t == "object" && typeof n > "u" && ((n = t), (t = null));
  var r = _C(e, n);
  if (typeof t != "function") return r;
  for (var i = 0, a = r.length; i < a; i += 1) t(r[i]);
}
function r9(e, t) {
  var n = _C(e, t);
  if (n.length !== 0) {
    if (n.length === 1) return n[0];
    throw new dC("expected a single document in the stream, but found more");
  }
}
jv.loadAll = n9;
jv.load = r9;
var EC = {},
  cp = Ai,
  ru = nu,
  i9 = Hv,
  wC = Object.prototype.toString,
  xC = Object.prototype.hasOwnProperty,
  Qv = 65279,
  a9 = 9,
  Ul = 10,
  s9 = 13,
  o9 = 32,
  c9 = 33,
  l9 = 34,
  o0 = 35,
  u9 = 37,
  f9 = 38,
  d9 = 39,
  p9 = 42,
  AC = 44,
  h9 = 45,
  md = 58,
  m9 = 61,
  g9 = 62,
  v9 = 63,
  y9 = 64,
  SC = 91,
  IC = 93,
  b9 = 96,
  $C = 123,
  _9 = 124,
  CC = 125,
  hr = {};
hr[0] = "\\0";
hr[7] = "\\a";
hr[8] = "\\b";
hr[9] = "\\t";
hr[10] = "\\n";
hr[11] = "\\v";
hr[12] = "\\f";
hr[13] = "\\r";
hr[27] = "\\e";
hr[34] = '\\"';
hr[92] = "\\\\";
hr[133] = "\\N";
hr[160] = "\\_";
hr[8232] = "\\L";
hr[8233] = "\\P";
var E9 = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF",
  ],
  w9 = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function x9(e, t) {
  var n, r, i, a, s, o, c;
  if (t === null) return {};
  for (n = {}, r = Object.keys(t), i = 0, a = r.length; i < a; i += 1)
    (s = r[i]),
      (o = String(t[s])),
      s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)),
      (c = e.compiledTypeMap.fallback[s]),
      c && xC.call(c.styleAliases, o) && (o = c.styleAliases[o]),
      (n[s] = o);
  return n;
}
function A9(e) {
  var t, n, r;
  if (((t = e.toString(16).toUpperCase()), e <= 255)) (n = "x"), (r = 2);
  else if (e <= 65535) (n = "u"), (r = 4);
  else if (e <= 4294967295) (n = "U"), (r = 8);
  else
    throw new ru(
      "code point within a string may not be greater than 0xFFFFFFFF",
    );
  return "\\" + n + cp.repeat("0", r - t.length) + t;
}
var S9 = 1,
  Fl = 2;
function I9(e) {
  (this.schema = e.schema || i9),
    (this.indent = Math.max(1, e.indent || 2)),
    (this.noArrayIndent = e.noArrayIndent || !1),
    (this.skipInvalid = e.skipInvalid || !1),
    (this.flowLevel = cp.isNothing(e.flowLevel) ? -1 : e.flowLevel),
    (this.styleMap = x9(this.schema, e.styles || null)),
    (this.sortKeys = e.sortKeys || !1),
    (this.lineWidth = e.lineWidth || 80),
    (this.noRefs = e.noRefs || !1),
    (this.noCompatMode = e.noCompatMode || !1),
    (this.condenseFlow = e.condenseFlow || !1),
    (this.quotingType = e.quotingType === '"' ? Fl : S9),
    (this.forceQuotes = e.forceQuotes || !1),
    (this.replacer = typeof e.replacer == "function" ? e.replacer : null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.explicitTypes = this.schema.compiledExplicit),
    (this.tag = null),
    (this.result = ""),
    (this.duplicates = []),
    (this.usedDuplicates = null);
}
function aw(e, t) {
  for (
    var n = cp.repeat(" ", t), r = 0, i = -1, a = "", s, o = e.length;
    r < o;

  )
    (i = e.indexOf(
      `
`,
      r,
    )),
      i === -1
        ? ((s = e.slice(r)), (r = o))
        : ((s = e.slice(r, i + 1)), (r = i + 1)),
      s.length &&
        s !==
          `
` &&
        (a += n),
      (a += s);
  return a;
}
function c0(e, t) {
  return (
    `
` + cp.repeat(" ", e.indent * t)
  );
}
function $9(e, t) {
  var n, r, i;
  for (n = 0, r = e.implicitTypes.length; n < r; n += 1)
    if (((i = e.implicitTypes[n]), i.resolve(t))) return !0;
  return !1;
}
function gd(e) {
  return e === o9 || e === a9;
}
function jl(e) {
  return (
    (32 <= e && e <= 126) ||
    (161 <= e && e <= 55295 && e !== 8232 && e !== 8233) ||
    (57344 <= e && e <= 65533 && e !== Qv) ||
    (65536 <= e && e <= 1114111)
  );
}
function sw(e) {
  return jl(e) && e !== Qv && e !== s9 && e !== Ul;
}
function ow(e, t, n) {
  var r = sw(e),
    i = r && !gd(e);
  return (
    ((n ? r : r && e !== AC && e !== SC && e !== IC && e !== $C && e !== CC) &&
      e !== o0 &&
      !(t === md && !i)) ||
    (sw(t) && !gd(t) && e === o0) ||
    (t === md && i)
  );
}
function C9(e) {
  return (
    jl(e) &&
    e !== Qv &&
    !gd(e) &&
    e !== h9 &&
    e !== v9 &&
    e !== md &&
    e !== AC &&
    e !== SC &&
    e !== IC &&
    e !== $C &&
    e !== CC &&
    e !== o0 &&
    e !== f9 &&
    e !== p9 &&
    e !== c9 &&
    e !== _9 &&
    e !== m9 &&
    e !== g9 &&
    e !== d9 &&
    e !== l9 &&
    e !== u9 &&
    e !== y9 &&
    e !== b9
  );
}
function R9(e) {
  return !gd(e) && e !== md;
}
function rl(e, t) {
  var n = e.charCodeAt(t),
    r;
  return n >= 55296 &&
    n <= 56319 &&
    t + 1 < e.length &&
    ((r = e.charCodeAt(t + 1)), r >= 56320 && r <= 57343)
    ? (n - 55296) * 1024 + r - 56320 + 65536
    : n;
}
function RC(e) {
  var t = /^\n* /;
  return t.test(e);
}
var kC = 1,
  l0 = 2,
  TC = 3,
  NC = 4,
  xo = 5;
function k9(e, t, n, r, i, a, s, o) {
  var c,
    l = 0,
    f = null,
    u = !1,
    d = !1,
    p = r !== -1,
    h = -1,
    m = C9(rl(e, 0)) && R9(rl(e, e.length - 1));
  if (t || s)
    for (c = 0; c < e.length; l >= 65536 ? (c += 2) : c++) {
      if (((l = rl(e, c)), !jl(l))) return xo;
      (m = m && ow(l, f, o)), (f = l);
    }
  else {
    for (c = 0; c < e.length; l >= 65536 ? (c += 2) : c++) {
      if (((l = rl(e, c)), l === Ul))
        (u = !0),
          p && ((d = d || (c - h - 1 > r && e[h + 1] !== " ")), (h = c));
      else if (!jl(l)) return xo;
      (m = m && ow(l, f, o)), (f = l);
    }
    d = d || (p && c - h - 1 > r && e[h + 1] !== " ");
  }
  return !u && !d
    ? m && !s && !i(e)
      ? kC
      : a === Fl
      ? xo
      : l0
    : n > 9 && RC(e)
    ? xo
    : s
    ? a === Fl
      ? xo
      : l0
    : d
    ? NC
    : TC;
}
function T9(e, t, n, r, i) {
  e.dump = (function () {
    if (t.length === 0) return e.quotingType === Fl ? '""' : "''";
    if (!e.noCompatMode && (E9.indexOf(t) !== -1 || w9.test(t)))
      return e.quotingType === Fl ? '"' + t + '"' : "'" + t + "'";
    var a = e.indent * Math.max(1, n),
      s =
        e.lineWidth === -1
          ? -1
          : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - a),
      o = r || (e.flowLevel > -1 && n >= e.flowLevel);
    function c(l) {
      return $9(e, l);
    }
    switch (k9(t, o, e.indent, s, c, e.quotingType, e.forceQuotes && !r, i)) {
      case kC:
        return t;
      case l0:
        return "'" + t.replace(/'/g, "''") + "'";
      case TC:
        return "|" + cw(t, e.indent) + lw(aw(t, a));
      case NC:
        return ">" + cw(t, e.indent) + lw(aw(N9(t, s), a));
      case xo:
        return '"' + O9(t) + '"';
      default:
        throw new ru("impossible error: invalid scalar style");
    }
  })();
}
function cw(e, t) {
  var n = RC(e) ? String(t) : "",
    r =
      e[e.length - 1] ===
      `
`,
    i =
      r &&
      (e[e.length - 2] ===
        `
` ||
        e ===
          `
`),
    a = i ? "+" : r ? "" : "-";
  return (
    n +
    a +
    `
`
  );
}
function lw(e) {
  return e[e.length - 1] ===
    `
`
    ? e.slice(0, -1)
    : e;
}
function N9(e, t) {
  for (
    var n = /(\n+)([^\n]*)/g,
      r = (function () {
        var l = e.indexOf(`
`);
        return (
          (l = l !== -1 ? l : e.length), (n.lastIndex = l), uw(e.slice(0, l), t)
        );
      })(),
      i =
        e[0] ===
          `
` || e[0] === " ",
      a,
      s;
    (s = n.exec(e));

  ) {
    var o = s[1],
      c = s[2];
    (a = c[0] === " "),
      (r +=
        o +
        (!i && !a && c !== ""
          ? `
`
          : "") +
        uw(c, t)),
      (i = a);
  }
  return r;
}
function uw(e, t) {
  if (e === "" || e[0] === " ") return e;
  for (var n = / [^ ]/g, r, i = 0, a, s = 0, o = 0, c = ""; (r = n.exec(e)); )
    (o = r.index),
      o - i > t &&
        ((a = s > i ? s : o),
        (c +=
          `
` + e.slice(i, a)),
        (i = a + 1)),
      (s = o);
  return (
    (c += `
`),
    e.length - i > t && s > i
      ? (c +=
          e.slice(i, s) +
          `
` +
          e.slice(s + 1))
      : (c += e.slice(i)),
    c.slice(1)
  );
}
function O9(e) {
  for (var t = "", n = 0, r, i = 0; i < e.length; n >= 65536 ? (i += 2) : i++)
    (n = rl(e, i)),
      (r = hr[n]),
      !r && jl(n)
        ? ((t += e[i]), n >= 65536 && (t += e[i + 1]))
        : (t += r || A9(n));
  return t;
}
function P9(e, t, n) {
  var r = "",
    i = e.tag,
    a,
    s,
    o;
  for (a = 0, s = n.length; a < s; a += 1)
    (o = n[a]),
      e.replacer && (o = e.replacer.call(n, String(a), o)),
      (pa(e, t, o, !1, !1) || (typeof o > "u" && pa(e, t, null, !1, !1))) &&
        (r !== "" && (r += "," + (e.condenseFlow ? "" : " ")), (r += e.dump));
  (e.tag = i), (e.dump = "[" + r + "]");
}
function fw(e, t, n, r) {
  var i = "",
    a = e.tag,
    s,
    o,
    c;
  for (s = 0, o = n.length; s < o; s += 1)
    (c = n[s]),
      e.replacer && (c = e.replacer.call(n, String(s), c)),
      (pa(e, t + 1, c, !0, !0, !1, !0) ||
        (typeof c > "u" && pa(e, t + 1, null, !0, !0, !1, !0))) &&
        ((!r || i !== "") && (i += c0(e, t)),
        e.dump && Ul === e.dump.charCodeAt(0) ? (i += "-") : (i += "- "),
        (i += e.dump));
  (e.tag = a), (e.dump = i || "[]");
}
function D9(e, t, n) {
  var r = "",
    i = e.tag,
    a = Object.keys(n),
    s,
    o,
    c,
    l,
    f;
  for (s = 0, o = a.length; s < o; s += 1)
    (f = ""),
      r !== "" && (f += ", "),
      e.condenseFlow && (f += '"'),
      (c = a[s]),
      (l = n[c]),
      e.replacer && (l = e.replacer.call(n, c, l)),
      pa(e, t, c, !1, !1) &&
        (e.dump.length > 1024 && (f += "? "),
        (f +=
          e.dump +
          (e.condenseFlow ? '"' : "") +
          ":" +
          (e.condenseFlow ? "" : " ")),
        pa(e, t, l, !1, !1) && ((f += e.dump), (r += f)));
  (e.tag = i), (e.dump = "{" + r + "}");
}
function L9(e, t, n, r) {
  var i = "",
    a = e.tag,
    s = Object.keys(n),
    o,
    c,
    l,
    f,
    u,
    d;
  if (e.sortKeys === !0) s.sort();
  else if (typeof e.sortKeys == "function") s.sort(e.sortKeys);
  else if (e.sortKeys) throw new ru("sortKeys must be a boolean or a function");
  for (o = 0, c = s.length; o < c; o += 1)
    (d = ""),
      (!r || i !== "") && (d += c0(e, t)),
      (l = s[o]),
      (f = n[l]),
      e.replacer && (f = e.replacer.call(n, l, f)),
      pa(e, t + 1, l, !0, !0, !0) &&
        ((u =
          (e.tag !== null && e.tag !== "?") ||
          (e.dump && e.dump.length > 1024)),
        u && (e.dump && Ul === e.dump.charCodeAt(0) ? (d += "?") : (d += "? ")),
        (d += e.dump),
        u && (d += c0(e, t)),
        pa(e, t + 1, f, !0, u) &&
          (e.dump && Ul === e.dump.charCodeAt(0) ? (d += ":") : (d += ": "),
          (d += e.dump),
          (i += d)));
  (e.tag = a), (e.dump = i || "{}");
}
function dw(e, t, n) {
  var r, i, a, s, o, c;
  for (
    i = n ? e.explicitTypes : e.implicitTypes, a = 0, s = i.length;
    a < s;
    a += 1
  )
    if (
      ((o = i[a]),
      (o.instanceOf || o.predicate) &&
        (!o.instanceOf ||
          (typeof t == "object" && t instanceof o.instanceOf)) &&
        (!o.predicate || o.predicate(t)))
    ) {
      if (
        (n
          ? o.multi && o.representName
            ? (e.tag = o.representName(t))
            : (e.tag = o.tag)
          : (e.tag = "?"),
        o.represent)
      ) {
        if (
          ((c = e.styleMap[o.tag] || o.defaultStyle),
          wC.call(o.represent) === "[object Function]")
        )
          r = o.represent(t, c);
        else if (xC.call(o.represent, c)) r = o.represent[c](t, c);
        else
          throw new ru(
            "!<" + o.tag + '> tag resolver accepts not "' + c + '" style',
          );
        e.dump = r;
      }
      return !0;
    }
  return !1;
}
function pa(e, t, n, r, i, a, s) {
  (e.tag = null), (e.dump = n), dw(e, n, !1) || dw(e, n, !0);
  var o = wC.call(e.dump),
    c = r,
    l;
  r && (r = e.flowLevel < 0 || e.flowLevel > t);
  var f = o === "[object Object]" || o === "[object Array]",
    u,
    d;
  if (
    (f && ((u = e.duplicates.indexOf(n)), (d = u !== -1)),
    ((e.tag !== null && e.tag !== "?") || d || (e.indent !== 2 && t > 0)) &&
      (i = !1),
    d && e.usedDuplicates[u])
  )
    e.dump = "*ref_" + u;
  else {
    if (
      (f && d && !e.usedDuplicates[u] && (e.usedDuplicates[u] = !0),
      o === "[object Object]")
    )
      r && Object.keys(e.dump).length !== 0
        ? (L9(e, t, e.dump, i), d && (e.dump = "&ref_" + u + e.dump))
        : (D9(e, t, e.dump), d && (e.dump = "&ref_" + u + " " + e.dump));
    else if (o === "[object Array]")
      r && e.dump.length !== 0
        ? (e.noArrayIndent && !s && t > 0
            ? fw(e, t - 1, e.dump, i)
            : fw(e, t, e.dump, i),
          d && (e.dump = "&ref_" + u + e.dump))
        : (P9(e, t, e.dump), d && (e.dump = "&ref_" + u + " " + e.dump));
    else if (o === "[object String]") e.tag !== "?" && T9(e, e.dump, t, a, c);
    else {
      if (o === "[object Undefined]") return !1;
      if (e.skipInvalid) return !1;
      throw new ru("unacceptable kind of an object to dump " + o);
    }
    e.tag !== null &&
      e.tag !== "?" &&
      ((l = encodeURI(e.tag[0] === "!" ? e.tag.slice(1) : e.tag).replace(
        /!/g,
        "%21",
      )),
      e.tag[0] === "!"
        ? (l = "!" + l)
        : l.slice(0, 18) === "tag:yaml.org,2002:"
        ? (l = "!!" + l.slice(18))
        : (l = "!<" + l + ">"),
      (e.dump = l + " " + e.dump));
  }
  return !0;
}
function B9(e, t) {
  var n = [],
    r = [],
    i,
    a;
  for (u0(e, n, r), i = 0, a = r.length; i < a; i += 1)
    t.duplicates.push(n[r[i]]);
  t.usedDuplicates = new Array(a);
}
function u0(e, t, n) {
  var r, i, a;
  if (e !== null && typeof e == "object")
    if (((i = t.indexOf(e)), i !== -1)) n.indexOf(i) === -1 && n.push(i);
    else if ((t.push(e), Array.isArray(e)))
      for (i = 0, a = e.length; i < a; i += 1) u0(e[i], t, n);
    else
      for (r = Object.keys(e), i = 0, a = r.length; i < a; i += 1)
        u0(e[r[i]], t, n);
}
function U9(e, t) {
  t = t || {};
  var n = new I9(t);
  n.noRefs || B9(e, n);
  var r = e;
  return (
    n.replacer && (r = n.replacer.call({ "": r }, "", r)),
    pa(n, 0, r, !0, !0)
      ? n.dump +
        `
`
      : ""
  );
}
EC.dump = U9;
var OC = jv,
  F9 = EC;
function Wv(e, t) {
  return function () {
    throw new Error(
      "Function yaml." +
        e +
        " is removed in js-yaml 4. Use yaml." +
        t +
        " instead, which is now safe by default.",
    );
  };
}
ar.Type = Sr;
ar.Schema = W2;
ar.FAILSAFE_SCHEMA = Y2;
ar.JSON_SCHEMA = nC;
ar.CORE_SCHEMA = rC;
ar.DEFAULT_SCHEMA = Hv;
ar.load = OC.load;
ar.loadAll = OC.loadAll;
ar.dump = F9.dump;
ar.YAMLException = nu;
ar.types = {
  binary: cC,
  float: tC,
  map: V2,
  null: X2,
  pairs: uC,
  set: fC,
  timestamp: sC,
  bool: J2,
  int: Z2,
  merge: oC,
  omap: lC,
  seq: K2,
  str: z2,
};
ar.safeLoad = Wv("safeLoad", "load");
ar.safeLoadAll = Wv("safeLoadAll", "loadAll");
ar.safeDump = Wv("safeDump", "dump");
var lp = {};
Object.defineProperty(lp, "__esModule", { value: !0 });
lp.Lazy = void 0;
class j9 {
  constructor(t) {
    (this._value = null), (this.creator = t);
  }
  get hasValue() {
    return this.creator == null;
  }
  get value() {
    if (this.creator == null) return this._value;
    const t = this.creator();
    return (this.value = t), t;
  }
  set value(t) {
    (this._value = t), (this.creator = null);
  }
}
lp.Lazy = j9;
var f0 = { exports: {} };
const M9 = "2.0.0",
  PC = 256,
  H9 = Number.MAX_SAFE_INTEGER || 9007199254740991,
  q9 = 16,
  G9 = PC - 6,
  Q9 = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease",
  ];
var up = {
  MAX_LENGTH: PC,
  MAX_SAFE_COMPONENT_LENGTH: q9,
  MAX_SAFE_BUILD_LENGTH: G9,
  MAX_SAFE_INTEGER: H9,
  RELEASE_TYPES: Q9,
  SEMVER_SPEC_VERSION: M9,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2,
};
const W9 =
  typeof process == "object" &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
    ? (...e) => console.error("SEMVER", ...e)
    : () => {};
var fp = W9;
(function (e, t) {
  const {
      MAX_SAFE_COMPONENT_LENGTH: n,
      MAX_SAFE_BUILD_LENGTH: r,
      MAX_LENGTH: i,
    } = up,
    a = fp;
  t = e.exports = {};
  const s = (t.re = []),
    o = (t.safeRe = []),
    c = (t.src = []),
    l = (t.t = {});
  let f = 0;
  const u = "[a-zA-Z0-9-]",
    d = [
      ["\\s", 1],
      ["\\d", i],
      [u, r],
    ],
    p = (m) => {
      for (const [g, v] of d)
        m = m
          .split(`${g}*`)
          .join(`${g}{0,${v}}`)
          .split(`${g}+`)
          .join(`${g}{1,${v}}`);
      return m;
    },
    h = (m, g, v) => {
      const y = p(g),
        _ = f++;
      a(m, _, g),
        (l[m] = _),
        (c[_] = g),
        (s[_] = new RegExp(g, v ? "g" : void 0)),
        (o[_] = new RegExp(y, v ? "g" : void 0));
    };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
    h("NUMERICIDENTIFIERLOOSE", "\\d+"),
    h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${u}*`),
    h(
      "MAINVERSION",
      `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${
        c[l.NUMERICIDENTIFIER]
      })`,
    ),
    h(
      "MAINVERSIONLOOSE",
      `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${
        c[l.NUMERICIDENTIFIERLOOSE]
      })`,
    ),
    h(
      "PRERELEASEIDENTIFIER",
      `(?:${c[l.NUMERICIDENTIFIER]}|${c[l.NONNUMERICIDENTIFIER]})`,
    ),
    h(
      "PRERELEASEIDENTIFIERLOOSE",
      `(?:${c[l.NUMERICIDENTIFIERLOOSE]}|${c[l.NONNUMERICIDENTIFIER]})`,
    ),
    h(
      "PRERELEASE",
      `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`,
    ),
    h(
      "PRERELEASELOOSE",
      `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${
        c[l.PRERELEASEIDENTIFIERLOOSE]
      })*))`,
    ),
    h("BUILDIDENTIFIER", `${u}+`),
    h(
      "BUILD",
      `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`,
    ),
    h("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`),
    h("FULL", `^${c[l.FULLPLAIN]}$`),
    h(
      "LOOSEPLAIN",
      `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`,
    ),
    h("LOOSE", `^${c[l.LOOSEPLAIN]}$`),
    h("GTLT", "((?:<|>)?=?)"),
    h("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
    h("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`),
    h(
      "XRANGEPLAIN",
      `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${
        c[l.XRANGEIDENTIFIER]
      })(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${
        c[l.BUILD]
      }?)?)?`,
    ),
    h(
      "XRANGEPLAINLOOSE",
      `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
        c[l.XRANGEIDENTIFIERLOOSE]
      })(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${
        c[l.BUILD]
      }?)?)?`,
    ),
    h("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`),
    h("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`),
    h(
      "COERCE",
      `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`,
    ),
    h("COERCERTL", c[l.COERCE], !0),
    h("LONETILDE", "(?:~>?)"),
    h("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0),
    (t.tildeTrimReplace = "$1~"),
    h("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`),
    h("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`),
    h("LONECARET", "(?:\\^)"),
    h("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0),
    (t.caretTrimReplace = "$1^"),
    h("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`),
    h("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`),
    h("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`),
    h("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`),
    h(
      "COMPARATORTRIM",
      `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`,
      !0,
    ),
    (t.comparatorTrimReplace = "$1$2$3"),
    h(
      "HYPHENRANGE",
      `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`,
    ),
    h(
      "HYPHENRANGELOOSE",
      `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`,
    ),
    h("STAR", "(<|>)?=?\\s*\\*"),
    h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
    h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(f0, f0.exports);
var iu = f0.exports;
const z9 = Object.freeze({ loose: !0 }),
  K9 = Object.freeze({}),
  V9 = (e) => (e ? (typeof e != "object" ? z9 : e) : K9);
var zv = V9;
const pw = /^[0-9]+$/,
  DC = (e, t) => {
    const n = pw.test(e),
      r = pw.test(t);
    return (
      n && r && ((e = +e), (t = +t)),
      e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1
    );
  },
  Y9 = (e, t) => DC(t, e);
var LC = { compareIdentifiers: DC, rcompareIdentifiers: Y9 };
const of = fp,
  { MAX_LENGTH: hw, MAX_SAFE_INTEGER: cf } = up,
  { safeRe: mw, t: gw } = iu,
  X9 = zv,
  { compareIdentifiers: so } = LC;
let J9 = class ki {
  constructor(t, n) {
    if (((n = X9(n)), t instanceof ki)) {
      if (
        t.loose === !!n.loose &&
        t.includePrerelease === !!n.includePrerelease
      )
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(
        `Invalid version. Must be a string. Got type "${typeof t}".`,
      );
    if (t.length > hw)
      throw new TypeError(`version is longer than ${hw} characters`);
    of("SemVer", t, n),
      (this.options = n),
      (this.loose = !!n.loose),
      (this.includePrerelease = !!n.includePrerelease);
    const r = t.trim().match(n.loose ? mw[gw.LOOSE] : mw[gw.FULL]);
    if (!r) throw new TypeError(`Invalid Version: ${t}`);
    if (
      ((this.raw = t),
      (this.major = +r[1]),
      (this.minor = +r[2]),
      (this.patch = +r[3]),
      this.major > cf || this.major < 0)
    )
      throw new TypeError("Invalid major version");
    if (this.minor > cf || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > cf || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4]
      ? (this.prerelease = r[4].split(".").map((i) => {
          if (/^[0-9]+$/.test(i)) {
            const a = +i;
            if (a >= 0 && a < cf) return a;
          }
          return i;
        }))
      : (this.prerelease = []),
      (this.build = r[5] ? r[5].split(".") : []),
      this.format();
  }
  format() {
    return (
      (this.version = `${this.major}.${this.minor}.${this.patch}`),
      this.prerelease.length &&
        (this.version += `-${this.prerelease.join(".")}`),
      this.version
    );
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (
      (of("SemVer.compare", this.version, this.options, t), !(t instanceof ki))
    ) {
      if (typeof t == "string" && t === this.version) return 0;
      t = new ki(t, this.options);
    }
    return t.version === this.version
      ? 0
      : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return (
      t instanceof ki || (t = new ki(t, this.options)),
      so(this.major, t.major) ||
        so(this.minor, t.minor) ||
        so(this.patch, t.patch)
    );
  }
  comparePre(t) {
    if (
      (t instanceof ki || (t = new ki(t, this.options)),
      this.prerelease.length && !t.prerelease.length)
    )
      return -1;
    if (!this.prerelease.length && t.prerelease.length) return 1;
    if (!this.prerelease.length && !t.prerelease.length) return 0;
    let n = 0;
    do {
      const r = this.prerelease[n],
        i = t.prerelease[n];
      if ((of("prerelease compare", n, r, i), r === void 0 && i === void 0))
        return 0;
      if (i === void 0) return 1;
      if (r === void 0) return -1;
      if (r === i) continue;
      return so(r, i);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof ki || (t = new ki(t, this.options));
    let n = 0;
    do {
      const r = this.build[n],
        i = t.build[n];
      if ((of("prerelease compare", n, r, i), r === void 0 && i === void 0))
        return 0;
      if (i === void 0) return 1;
      if (r === void 0) return -1;
      if (r === i) continue;
      return so(r, i);
    } while (++n);
  }
  inc(t, n, r) {
    switch (t) {
      case "premajor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          (this.minor = 0),
          this.major++,
          this.inc("pre", n, r);
        break;
      case "preminor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          this.minor++,
          this.inc("pre", n, r);
        break;
      case "prepatch":
        (this.prerelease.length = 0),
          this.inc("patch", n, r),
          this.inc("pre", n, r);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n, r),
          this.inc("pre", n, r);
        break;
      case "major":
        (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) &&
          this.major++,
          (this.minor = 0),
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, (this.prerelease = []);
        break;
      case "pre": {
        const i = Number(r) ? 1 : 0;
        if (!n && r === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0) this.prerelease = [i];
        else {
          let a = this.prerelease.length;
          for (; --a >= 0; )
            typeof this.prerelease[a] == "number" &&
              (this.prerelease[a]++, (a = -2));
          if (a === -1) {
            if (n === this.prerelease.join(".") && r === !1)
              throw new Error(
                "invalid increment argument: identifier already exists",
              );
            this.prerelease.push(i);
          }
        }
        if (n) {
          let a = [n, i];
          r === !1 && (a = [n]),
            so(this.prerelease[0], n) === 0
              ? isNaN(this.prerelease[1]) && (this.prerelease = a)
              : (this.prerelease = a);
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return (
      (this.raw = this.format()),
      this.build.length && (this.raw += `+${this.build.join(".")}`),
      this
    );
  }
};
var Ir = J9;
const vw = Ir,
  Z9 = (e, t, n = !1) => {
    if (e instanceof vw) return e;
    try {
      return new vw(e, t);
    } catch (r) {
      if (!n) return null;
      throw r;
    }
  };
var wc = Z9;
const ej = wc,
  tj = (e, t) => {
    const n = ej(e, t);
    return n ? n.version : null;
  };
var nj = tj;
const rj = wc,
  ij = (e, t) => {
    const n = rj(e.trim().replace(/^[=v]+/, ""), t);
    return n ? n.version : null;
  };
var aj = ij;
const yw = Ir,
  sj = (e, t, n, r, i) => {
    typeof n == "string" && ((i = r), (r = n), (n = void 0));
    try {
      return new yw(e instanceof yw ? e.version : e, n).inc(t, r, i).version;
    } catch {
      return null;
    }
  };
var oj = sj;
const bw = wc,
  cj = (e, t) => {
    const n = bw(e, null, !0),
      r = bw(t, null, !0),
      i = n.compare(r);
    if (i === 0) return null;
    const a = i > 0,
      s = a ? n : r,
      o = a ? r : n,
      c = !!s.prerelease.length;
    if (!!o.prerelease.length && !c)
      return !o.patch && !o.minor
        ? "major"
        : s.patch
        ? "patch"
        : s.minor
        ? "minor"
        : "major";
    const f = c ? "pre" : "";
    return n.major !== r.major
      ? f + "major"
      : n.minor !== r.minor
      ? f + "minor"
      : n.patch !== r.patch
      ? f + "patch"
      : "prerelease";
  };
var lj = cj;
const uj = Ir,
  fj = (e, t) => new uj(e, t).major;
var dj = fj;
const pj = Ir,
  hj = (e, t) => new pj(e, t).minor;
var mj = hj;
const gj = Ir,
  vj = (e, t) => new gj(e, t).patch;
var yj = vj;
const bj = wc,
  _j = (e, t) => {
    const n = bj(e, t);
    return n && n.prerelease.length ? n.prerelease : null;
  };
var Ej = _j;
const _w = Ir,
  wj = (e, t, n) => new _w(e, n).compare(new _w(t, n));
var Si = wj;
const xj = Si,
  Aj = (e, t, n) => xj(t, e, n);
var Sj = Aj;
const Ij = Si,
  $j = (e, t) => Ij(e, t, !0);
var Cj = $j;
const Ew = Ir,
  Rj = (e, t, n) => {
    const r = new Ew(e, n),
      i = new Ew(t, n);
    return r.compare(i) || r.compareBuild(i);
  };
var Kv = Rj;
const kj = Kv,
  Tj = (e, t) => e.sort((n, r) => kj(n, r, t));
var Nj = Tj;
const Oj = Kv,
  Pj = (e, t) => e.sort((n, r) => Oj(r, n, t));
var Dj = Pj;
const Lj = Si,
  Bj = (e, t, n) => Lj(e, t, n) > 0;
var dp = Bj;
const Uj = Si,
  Fj = (e, t, n) => Uj(e, t, n) < 0;
var Vv = Fj;
const jj = Si,
  Mj = (e, t, n) => jj(e, t, n) === 0;
var BC = Mj;
const Hj = Si,
  qj = (e, t, n) => Hj(e, t, n) !== 0;
var UC = qj;
const Gj = Si,
  Qj = (e, t, n) => Gj(e, t, n) >= 0;
var Yv = Qj;
const Wj = Si,
  zj = (e, t, n) => Wj(e, t, n) <= 0;
var Xv = zj;
const Kj = BC,
  Vj = UC,
  Yj = dp,
  Xj = Yv,
  Jj = Vv,
  Zj = Xv,
  eM = (e, t, n, r) => {
    switch (t) {
      case "===":
        return (
          typeof e == "object" && (e = e.version),
          typeof n == "object" && (n = n.version),
          e === n
        );
      case "!==":
        return (
          typeof e == "object" && (e = e.version),
          typeof n == "object" && (n = n.version),
          e !== n
        );
      case "":
      case "=":
      case "==":
        return Kj(e, n, r);
      case "!=":
        return Vj(e, n, r);
      case ">":
        return Yj(e, n, r);
      case ">=":
        return Xj(e, n, r);
      case "<":
        return Jj(e, n, r);
      case "<=":
        return Zj(e, n, r);
      default:
        throw new TypeError(`Invalid operator: ${t}`);
    }
  };
var FC = eM;
const tM = Ir,
  nM = wc,
  { safeRe: lf, t: uf } = iu,
  rM = (e, t) => {
    if (e instanceof tM) return e;
    if ((typeof e == "number" && (e = String(e)), typeof e != "string"))
      return null;
    t = t || {};
    let n = null;
    if (!t.rtl) n = e.match(lf[uf.COERCE]);
    else {
      let r;
      for (
        ;
        (r = lf[uf.COERCERTL].exec(e)) &&
        (!n || n.index + n[0].length !== e.length);

      )
        (!n || r.index + r[0].length !== n.index + n[0].length) && (n = r),
          (lf[uf.COERCERTL].lastIndex = r.index + r[1].length + r[2].length);
      lf[uf.COERCERTL].lastIndex = -1;
    }
    return n === null ? null : nM(`${n[2]}.${n[3] || "0"}.${n[4] || "0"}`, t);
  };
var iM = rM,
  um,
  ww;
function aM() {
  return (
    ww ||
      ((ww = 1),
      (um = function (e) {
        e.prototype[Symbol.iterator] = function* () {
          for (let t = this.head; t; t = t.next) yield t.value;
        };
      })),
    um
  );
}
var sM = Mt;
Mt.Node = Bs;
Mt.create = Mt;
function Mt(e) {
  var t = this;
  if (
    (t instanceof Mt || (t = new Mt()),
    (t.tail = null),
    (t.head = null),
    (t.length = 0),
    e && typeof e.forEach == "function")
  )
    e.forEach(function (i) {
      t.push(i);
    });
  else if (arguments.length > 0)
    for (var n = 0, r = arguments.length; n < r; n++) t.push(arguments[n]);
  return t;
}
Mt.prototype.removeNode = function (e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next,
    n = e.prev;
  return (
    t && (t.prev = n),
    n && (n.next = t),
    e === this.head && (this.head = t),
    e === this.tail && (this.tail = n),
    e.list.length--,
    (e.next = null),
    (e.prev = null),
    (e.list = null),
    t
  );
};
Mt.prototype.unshiftNode = function (e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    (e.list = this),
      (e.next = t),
      t && (t.prev = e),
      (this.head = e),
      this.tail || (this.tail = e),
      this.length++;
  }
};
Mt.prototype.pushNode = function (e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    (e.list = this),
      (e.prev = t),
      t && (t.next = e),
      (this.tail = e),
      this.head || (this.head = e),
      this.length++;
  }
};
Mt.prototype.push = function () {
  for (var e = 0, t = arguments.length; e < t; e++) cM(this, arguments[e]);
  return this.length;
};
Mt.prototype.unshift = function () {
  for (var e = 0, t = arguments.length; e < t; e++) lM(this, arguments[e]);
  return this.length;
};
Mt.prototype.pop = function () {
  if (this.tail) {
    var e = this.tail.value;
    return (
      (this.tail = this.tail.prev),
      this.tail ? (this.tail.next = null) : (this.head = null),
      this.length--,
      e
    );
  }
};
Mt.prototype.shift = function () {
  if (this.head) {
    var e = this.head.value;
    return (
      (this.head = this.head.next),
      this.head ? (this.head.prev = null) : (this.tail = null),
      this.length--,
      e
    );
  }
};
Mt.prototype.forEach = function (e, t) {
  t = t || this;
  for (var n = this.head, r = 0; n !== null; r++)
    e.call(t, n.value, r, this), (n = n.next);
};
Mt.prototype.forEachReverse = function (e, t) {
  t = t || this;
  for (var n = this.tail, r = this.length - 1; n !== null; r--)
    e.call(t, n.value, r, this), (n = n.prev);
};
Mt.prototype.get = function (e) {
  for (var t = 0, n = this.head; n !== null && t < e; t++) n = n.next;
  if (t === e && n !== null) return n.value;
};
Mt.prototype.getReverse = function (e) {
  for (var t = 0, n = this.tail; n !== null && t < e; t++) n = n.prev;
  if (t === e && n !== null) return n.value;
};
Mt.prototype.map = function (e, t) {
  t = t || this;
  for (var n = new Mt(), r = this.head; r !== null; )
    n.push(e.call(t, r.value, this)), (r = r.next);
  return n;
};
Mt.prototype.mapReverse = function (e, t) {
  t = t || this;
  for (var n = new Mt(), r = this.tail; r !== null; )
    n.push(e.call(t, r.value, this)), (r = r.prev);
  return n;
};
Mt.prototype.reduce = function (e, t) {
  var n,
    r = this.head;
  if (arguments.length > 1) n = t;
  else if (this.head) (r = this.head.next), (n = this.head.value);
  else throw new TypeError("Reduce of empty list with no initial value");
  for (var i = 0; r !== null; i++) (n = e(n, r.value, i)), (r = r.next);
  return n;
};
Mt.prototype.reduceReverse = function (e, t) {
  var n,
    r = this.tail;
  if (arguments.length > 1) n = t;
  else if (this.tail) (r = this.tail.prev), (n = this.tail.value);
  else throw new TypeError("Reduce of empty list with no initial value");
  for (var i = this.length - 1; r !== null; i--)
    (n = e(n, r.value, i)), (r = r.prev);
  return n;
};
Mt.prototype.toArray = function () {
  for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++)
    (e[t] = n.value), (n = n.next);
  return e;
};
Mt.prototype.toArrayReverse = function () {
  for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++)
    (e[t] = n.value), (n = n.prev);
  return e;
};
Mt.prototype.slice = function (e, t) {
  (t = t || this.length),
    t < 0 && (t += this.length),
    (e = e || 0),
    e < 0 && (e += this.length);
  var n = new Mt();
  if (t < e || t < 0) return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = 0, i = this.head; i !== null && r < e; r++) i = i.next;
  for (; i !== null && r < t; r++, i = i.next) n.push(i.value);
  return n;
};
Mt.prototype.sliceReverse = function (e, t) {
  (t = t || this.length),
    t < 0 && (t += this.length),
    (e = e || 0),
    e < 0 && (e += this.length);
  var n = new Mt();
  if (t < e || t < 0) return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = this.length, i = this.tail; i !== null && r > t; r--) i = i.prev;
  for (; i !== null && r > e; r--, i = i.prev) n.push(i.value);
  return n;
};
Mt.prototype.splice = function (e, t, ...n) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var r = 0, i = this.head; i !== null && r < e; r++) i = i.next;
  for (var a = [], r = 0; i && r < t; r++)
    a.push(i.value), (i = this.removeNode(i));
  i === null && (i = this.tail),
    i !== this.head && i !== this.tail && (i = i.prev);
  for (var r = 0; r < n.length; r++) i = oM(this, i, n[r]);
  return a;
};
Mt.prototype.reverse = function () {
  for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
    var r = n.prev;
    (n.prev = n.next), (n.next = r);
  }
  return (this.head = t), (this.tail = e), this;
};
function oM(e, t, n) {
  var r = t === e.head ? new Bs(n, null, t, e) : new Bs(n, t, t.next, e);
  return (
    r.next === null && (e.tail = r),
    r.prev === null && (e.head = r),
    e.length++,
    r
  );
}
function cM(e, t) {
  (e.tail = new Bs(t, e.tail, null, e)),
    e.head || (e.head = e.tail),
    e.length++;
}
function lM(e, t) {
  (e.head = new Bs(t, null, e.head, e)),
    e.tail || (e.tail = e.head),
    e.length++;
}
function Bs(e, t, n, r) {
  if (!(this instanceof Bs)) return new Bs(e, t, n, r);
  (this.list = r),
    (this.value = e),
    t ? ((t.next = this), (this.prev = t)) : (this.prev = null),
    n ? ((n.prev = this), (this.next = n)) : (this.next = null);
}
try {
  aM()(Mt);
} catch {}
const uM = sM,
  gs = Symbol("max"),
  ra = Symbol("length"),
  oo = Symbol("lengthCalculator"),
  hl = Symbol("allowStale"),
  Is = Symbol("maxAge"),
  Zi = Symbol("dispose"),
  xw = Symbol("noDisposeOnSet"),
  Gn = Symbol("lruList"),
  li = Symbol("cache"),
  jC = Symbol("updateAgeOnGet"),
  fm = () => 1;
let fM = class {
  constructor(t) {
    if (
      (typeof t == "number" && (t = { max: t }),
      t || (t = {}),
      t.max && (typeof t.max != "number" || t.max < 0))
    )
      throw new TypeError("max must be a non-negative number");
    this[gs] = t.max || 1 / 0;
    const n = t.length || fm;
    if (
      ((this[oo] = typeof n != "function" ? fm : n),
      (this[hl] = t.stale || !1),
      t.maxAge && typeof t.maxAge != "number")
    )
      throw new TypeError("maxAge must be a number");
    (this[Is] = t.maxAge || 0),
      (this[Zi] = t.dispose),
      (this[xw] = t.noDisposeOnSet || !1),
      (this[jC] = t.updateAgeOnGet || !1),
      this.reset();
  }
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    (this[gs] = t || 1 / 0), Lc(this);
  }
  get max() {
    return this[gs];
  }
  set allowStale(t) {
    this[hl] = !!t;
  }
  get allowStale() {
    return this[hl];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    (this[Is] = t), Lc(this);
  }
  get maxAge() {
    return this[Is];
  }
  set lengthCalculator(t) {
    typeof t != "function" && (t = fm),
      t !== this[oo] &&
        ((this[oo] = t),
        (this[ra] = 0),
        this[Gn].forEach((n) => {
          (n.length = this[oo](n.value, n.key)), (this[ra] += n.length);
        })),
      Lc(this);
  }
  get lengthCalculator() {
    return this[oo];
  }
  get length() {
    return this[ra];
  }
  get itemCount() {
    return this[Gn].length;
  }
  rforEach(t, n) {
    n = n || this;
    for (let r = this[Gn].tail; r !== null; ) {
      const i = r.prev;
      Aw(this, t, r, n), (r = i);
    }
  }
  forEach(t, n) {
    n = n || this;
    for (let r = this[Gn].head; r !== null; ) {
      const i = r.next;
      Aw(this, t, r, n), (r = i);
    }
  }
  keys() {
    return this[Gn].toArray().map((t) => t.key);
  }
  values() {
    return this[Gn].toArray().map((t) => t.value);
  }
  reset() {
    this[Zi] &&
      this[Gn] &&
      this[Gn].length &&
      this[Gn].forEach((t) => this[Zi](t.key, t.value)),
      (this[li] = new Map()),
      (this[Gn] = new uM()),
      (this[ra] = 0);
  }
  dump() {
    return this[Gn].map((t) =>
      vd(this, t) ? !1 : { k: t.key, v: t.value, e: t.now + (t.maxAge || 0) },
    )
      .toArray()
      .filter((t) => t);
  }
  dumpLru() {
    return this[Gn];
  }
  set(t, n, r) {
    if (((r = r || this[Is]), r && typeof r != "number"))
      throw new TypeError("maxAge must be a number");
    const i = r ? Date.now() : 0,
      a = this[oo](n, t);
    if (this[li].has(t)) {
      if (a > this[gs]) return Lo(this, this[li].get(t)), !1;
      const c = this[li].get(t).value;
      return (
        this[Zi] && (this[xw] || this[Zi](t, c.value)),
        (c.now = i),
        (c.maxAge = r),
        (c.value = n),
        (this[ra] += a - c.length),
        (c.length = a),
        this.get(t),
        Lc(this),
        !0
      );
    }
    const s = new dM(t, n, a, i, r);
    return s.length > this[gs]
      ? (this[Zi] && this[Zi](t, n), !1)
      : ((this[ra] += s.length),
        this[Gn].unshift(s),
        this[li].set(t, this[Gn].head),
        Lc(this),
        !0);
  }
  has(t) {
    if (!this[li].has(t)) return !1;
    const n = this[li].get(t).value;
    return !vd(this, n);
  }
  get(t) {
    return dm(this, t, !0);
  }
  peek(t) {
    return dm(this, t, !1);
  }
  pop() {
    const t = this[Gn].tail;
    return t ? (Lo(this, t), t.value) : null;
  }
  del(t) {
    Lo(this, this[li].get(t));
  }
  load(t) {
    this.reset();
    const n = Date.now();
    for (let r = t.length - 1; r >= 0; r--) {
      const i = t[r],
        a = i.e || 0;
      if (a === 0) this.set(i.k, i.v);
      else {
        const s = a - n;
        s > 0 && this.set(i.k, i.v, s);
      }
    }
  }
  prune() {
    this[li].forEach((t, n) => dm(this, n, !1));
  }
};
const dm = (e, t, n) => {
    const r = e[li].get(t);
    if (r) {
      const i = r.value;
      if (vd(e, i)) {
        if ((Lo(e, r), !e[hl])) return;
      } else n && (e[jC] && (r.value.now = Date.now()), e[Gn].unshiftNode(r));
      return i.value;
    }
  },
  vd = (e, t) => {
    if (!t || (!t.maxAge && !e[Is])) return !1;
    const n = Date.now() - t.now;
    return t.maxAge ? n > t.maxAge : e[Is] && n > e[Is];
  },
  Lc = (e) => {
    if (e[ra] > e[gs])
      for (let t = e[Gn].tail; e[ra] > e[gs] && t !== null; ) {
        const n = t.prev;
        Lo(e, t), (t = n);
      }
  },
  Lo = (e, t) => {
    if (t) {
      const n = t.value;
      e[Zi] && e[Zi](n.key, n.value),
        (e[ra] -= n.length),
        e[li].delete(n.key),
        e[Gn].removeNode(t);
    }
  };
let dM = class {
  constructor(t, n, r, i, a) {
    (this.key = t),
      (this.value = n),
      (this.length = r),
      (this.now = i),
      (this.maxAge = a || 0);
  }
};
const Aw = (e, t, n, r) => {
  let i = n.value;
  vd(e, i) && (Lo(e, n), e[hl] || (i = void 0)),
    i && t.call(r, i.value, i.key, e);
};
var pM = fM,
  pm,
  Sw;
function Ii() {
  if (Sw) return pm;
  Sw = 1;
  class e {
    constructor(q, J) {
      if (((J = r(J)), q instanceof e))
        return q.loose === !!J.loose &&
          q.includePrerelease === !!J.includePrerelease
          ? q
          : new e(q.raw, J);
      if (q instanceof i)
        return (this.raw = q.value), (this.set = [[q]]), this.format(), this;
      if (
        ((this.options = J),
        (this.loose = !!J.loose),
        (this.includePrerelease = !!J.includePrerelease),
        (this.raw = q.trim().split(/\s+/).join(" ")),
        (this.set = this.raw
          .split("||")
          .map((Z) => this.parseRange(Z.trim()))
          .filter((Z) => Z.length)),
        !this.set.length)
      )
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const Z = this.set[0];
        if (
          ((this.set = this.set.filter((z) => !h(z[0]))), this.set.length === 0)
        )
          this.set = [Z];
        else if (this.set.length > 1) {
          for (const z of this.set)
            if (z.length === 1 && m(z[0])) {
              this.set = [z];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return (
        (this.range = this.set
          .map((q) => q.join(" ").trim())
          .join("||")
          .trim()),
        this.range
      );
    }
    toString() {
      return this.range;
    }
    parseRange(q) {
      const Z =
          ((this.options.includePrerelease && d) | (this.options.loose && p)) +
          ":" +
          q,
        z = n.get(Z);
      if (z) return z;
      const U = this.options.loose,
        G = U ? o[c.HYPHENRANGELOOSE] : o[c.HYPHENRANGE];
      (q = q.replace(G, Q(this.options.includePrerelease))),
        a("hyphen replace", q),
        (q = q.replace(o[c.COMPARATORTRIM], l)),
        a("comparator trim", q),
        (q = q.replace(o[c.TILDETRIM], f)),
        a("tilde trim", q),
        (q = q.replace(o[c.CARETTRIM], u)),
        a("caret trim", q);
      let L = q
        .split(" ")
        .map((x) => v(x, this.options))
        .join(" ")
        .split(/\s+/)
        .map((x) => O(x, this.options));
      U &&
        (L = L.filter(
          (x) => (
            a("loose invalid filter", x, this.options),
            !!x.match(o[c.COMPARATORLOOSE])
          ),
        )),
        a("range list", L);
      const k = new Map(),
        W = L.map((x) => new i(x, this.options));
      for (const x of W) {
        if (h(x)) return [x];
        k.set(x.value, x);
      }
      k.size > 1 && k.has("") && k.delete("");
      const F = [...k.values()];
      return n.set(Z, F), F;
    }
    intersects(q, J) {
      if (!(q instanceof e)) throw new TypeError("a Range is required");
      return this.set.some(
        (Z) =>
          g(Z, J) &&
          q.set.some(
            (z) =>
              g(z, J) && Z.every((U) => z.every((G) => U.intersects(G, J))),
          ),
      );
    }
    test(q) {
      if (!q) return !1;
      if (typeof q == "string")
        try {
          q = new s(q, this.options);
        } catch {
          return !1;
        }
      for (let J = 0; J < this.set.length; J++)
        if (j(this.set[J], q, this.options)) return !0;
      return !1;
    }
  }
  pm = e;
  const t = pM,
    n = new t({ max: 1e3 }),
    r = zv,
    i = pp(),
    a = fp,
    s = Ir,
    {
      safeRe: o,
      t: c,
      comparatorTrimReplace: l,
      tildeTrimReplace: f,
      caretTrimReplace: u,
    } = iu,
    { FLAG_INCLUDE_PRERELEASE: d, FLAG_LOOSE: p } = up,
    h = (H) => H.value === "<0.0.0-0",
    m = (H) => H.value === "",
    g = (H, q) => {
      let J = !0;
      const Z = H.slice();
      let z = Z.pop();
      for (; J && Z.length; )
        (J = Z.every((U) => z.intersects(U, q))), (z = Z.pop());
      return J;
    },
    v = (H, q) => (
      a("comp", H, q),
      (H = R(H, q)),
      a("caret", H),
      (H = _(H, q)),
      a("tildes", H),
      (H = I(H, q)),
      a("xrange", H),
      (H = w(H, q)),
      a("stars", H),
      H
    ),
    y = (H) => !H || H.toLowerCase() === "x" || H === "*",
    _ = (H, q) =>
      H.trim()
        .split(/\s+/)
        .map((J) => E(J, q))
        .join(" "),
    E = (H, q) => {
      const J = q.loose ? o[c.TILDELOOSE] : o[c.TILDE];
      return H.replace(J, (Z, z, U, G, L) => {
        a("tilde", H, Z, z, U, G, L);
        let k;
        return (
          y(z)
            ? (k = "")
            : y(U)
            ? (k = `>=${z}.0.0 <${+z + 1}.0.0-0`)
            : y(G)
            ? (k = `>=${z}.${U}.0 <${z}.${+U + 1}.0-0`)
            : L
            ? (a("replaceTilde pr", L),
              (k = `>=${z}.${U}.${G}-${L} <${z}.${+U + 1}.0-0`))
            : (k = `>=${z}.${U}.${G} <${z}.${+U + 1}.0-0`),
          a("tilde return", k),
          k
        );
      });
    },
    R = (H, q) =>
      H.trim()
        .split(/\s+/)
        .map((J) => A(J, q))
        .join(" "),
    A = (H, q) => {
      a("caret", H, q);
      const J = q.loose ? o[c.CARETLOOSE] : o[c.CARET],
        Z = q.includePrerelease ? "-0" : "";
      return H.replace(J, (z, U, G, L, k) => {
        a("caret", H, z, U, G, L, k);
        let W;
        return (
          y(U)
            ? (W = "")
            : y(G)
            ? (W = `>=${U}.0.0${Z} <${+U + 1}.0.0-0`)
            : y(L)
            ? U === "0"
              ? (W = `>=${U}.${G}.0${Z} <${U}.${+G + 1}.0-0`)
              : (W = `>=${U}.${G}.0${Z} <${+U + 1}.0.0-0`)
            : k
            ? (a("replaceCaret pr", k),
              U === "0"
                ? G === "0"
                  ? (W = `>=${U}.${G}.${L}-${k} <${U}.${G}.${+L + 1}-0`)
                  : (W = `>=${U}.${G}.${L}-${k} <${U}.${+G + 1}.0-0`)
                : (W = `>=${U}.${G}.${L}-${k} <${+U + 1}.0.0-0`))
            : (a("no pr"),
              U === "0"
                ? G === "0"
                  ? (W = `>=${U}.${G}.${L}${Z} <${U}.${G}.${+L + 1}-0`)
                  : (W = `>=${U}.${G}.${L}${Z} <${U}.${+G + 1}.0-0`)
                : (W = `>=${U}.${G}.${L} <${+U + 1}.0.0-0`)),
          a("caret return", W),
          W
        );
      });
    },
    I = (H, q) => (
      a("replaceXRanges", H, q),
      H.split(/\s+/)
        .map((J) => S(J, q))
        .join(" ")
    ),
    S = (H, q) => {
      H = H.trim();
      const J = q.loose ? o[c.XRANGELOOSE] : o[c.XRANGE];
      return H.replace(J, (Z, z, U, G, L, k) => {
        a("xRange", H, Z, z, U, G, L, k);
        const W = y(U),
          F = W || y(G),
          x = F || y(L),
          T = x;
        return (
          z === "=" && T && (z = ""),
          (k = q.includePrerelease ? "-0" : ""),
          W
            ? z === ">" || z === "<"
              ? (Z = "<0.0.0-0")
              : (Z = "*")
            : z && T
            ? (F && (G = 0),
              (L = 0),
              z === ">"
                ? ((z = ">="),
                  F
                    ? ((U = +U + 1), (G = 0), (L = 0))
                    : ((G = +G + 1), (L = 0)))
                : z === "<=" && ((z = "<"), F ? (U = +U + 1) : (G = +G + 1)),
              z === "<" && (k = "-0"),
              (Z = `${z + U}.${G}.${L}${k}`))
            : F
            ? (Z = `>=${U}.0.0${k} <${+U + 1}.0.0-0`)
            : x && (Z = `>=${U}.${G}.0${k} <${U}.${+G + 1}.0-0`),
          a("xRange return", Z),
          Z
        );
      });
    },
    w = (H, q) => (a("replaceStars", H, q), H.trim().replace(o[c.STAR], "")),
    O = (H, q) => (
      a("replaceGTE0", H, q),
      H.trim().replace(o[q.includePrerelease ? c.GTE0PRE : c.GTE0], "")
    ),
    Q = (H) => (q, J, Z, z, U, G, L, k, W, F, x, T, V) => (
      y(Z)
        ? (J = "")
        : y(z)
        ? (J = `>=${Z}.0.0${H ? "-0" : ""}`)
        : y(U)
        ? (J = `>=${Z}.${z}.0${H ? "-0" : ""}`)
        : G
        ? (J = `>=${J}`)
        : (J = `>=${J}${H ? "-0" : ""}`),
      y(W)
        ? (k = "")
        : y(F)
        ? (k = `<${+W + 1}.0.0-0`)
        : y(x)
        ? (k = `<${W}.${+F + 1}.0-0`)
        : T
        ? (k = `<=${W}.${F}.${x}-${T}`)
        : H
        ? (k = `<${W}.${F}.${+x + 1}-0`)
        : (k = `<=${k}`),
      `${J} ${k}`.trim()
    ),
    j = (H, q, J) => {
      for (let Z = 0; Z < H.length; Z++) if (!H[Z].test(q)) return !1;
      if (q.prerelease.length && !J.includePrerelease) {
        for (let Z = 0; Z < H.length; Z++)
          if (
            (a(H[Z].semver),
            H[Z].semver !== i.ANY && H[Z].semver.prerelease.length > 0)
          ) {
            const z = H[Z].semver;
            if (
              z.major === q.major &&
              z.minor === q.minor &&
              z.patch === q.patch
            )
              return !0;
          }
        return !1;
      }
      return !0;
    };
  return pm;
}
var hm, Iw;
function pp() {
  if (Iw) return hm;
  Iw = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(f, u) {
      if (((u = n(u)), f instanceof t)) {
        if (f.loose === !!u.loose) return f;
        f = f.value;
      }
      (f = f.trim().split(/\s+/).join(" ")),
        s("comparator", f, u),
        (this.options = u),
        (this.loose = !!u.loose),
        this.parse(f),
        this.semver === e
          ? (this.value = "")
          : (this.value = this.operator + this.semver.version),
        s("comp", this);
    }
    parse(f) {
      const u = this.options.loose ? r[i.COMPARATORLOOSE] : r[i.COMPARATOR],
        d = f.match(u);
      if (!d) throw new TypeError(`Invalid comparator: ${f}`);
      (this.operator = d[1] !== void 0 ? d[1] : ""),
        this.operator === "=" && (this.operator = ""),
        d[2]
          ? (this.semver = new o(d[2], this.options.loose))
          : (this.semver = e);
    }
    toString() {
      return this.value;
    }
    test(f) {
      if (
        (s("Comparator.test", f, this.options.loose),
        this.semver === e || f === e)
      )
        return !0;
      if (typeof f == "string")
        try {
          f = new o(f, this.options);
        } catch {
          return !1;
        }
      return a(f, this.operator, this.semver, this.options);
    }
    intersects(f, u) {
      if (!(f instanceof t)) throw new TypeError("a Comparator is required");
      return this.operator === ""
        ? this.value === ""
          ? !0
          : new c(f.value, u).test(this.value)
        : f.operator === ""
        ? f.value === ""
          ? !0
          : new c(this.value, u).test(f.semver)
        : ((u = n(u)),
          (u.includePrerelease &&
            (this.value === "<0.0.0-0" || f.value === "<0.0.0-0")) ||
          (!u.includePrerelease &&
            (this.value.startsWith("<0.0.0") || f.value.startsWith("<0.0.0")))
            ? !1
            : !!(
                (this.operator.startsWith(">") && f.operator.startsWith(">")) ||
                (this.operator.startsWith("<") && f.operator.startsWith("<")) ||
                (this.semver.version === f.semver.version &&
                  this.operator.includes("=") &&
                  f.operator.includes("=")) ||
                (a(this.semver, "<", f.semver, u) &&
                  this.operator.startsWith(">") &&
                  f.operator.startsWith("<")) ||
                (a(this.semver, ">", f.semver, u) &&
                  this.operator.startsWith("<") &&
                  f.operator.startsWith(">"))
              ));
    }
  }
  hm = t;
  const n = zv,
    { safeRe: r, t: i } = iu,
    a = FC,
    s = fp,
    o = Ir,
    c = Ii();
  return hm;
}
const hM = Ii(),
  mM = (e, t, n) => {
    try {
      t = new hM(t, n);
    } catch {
      return !1;
    }
    return t.test(e);
  };
var hp = mM;
const gM = Ii(),
  vM = (e, t) =>
    new gM(e, t).set.map((n) =>
      n
        .map((r) => r.value)
        .join(" ")
        .trim()
        .split(" "),
    );
var yM = vM;
const bM = Ir,
  _M = Ii(),
  EM = (e, t, n) => {
    let r = null,
      i = null,
      a = null;
    try {
      a = new _M(t, n);
    } catch {
      return null;
    }
    return (
      e.forEach((s) => {
        a.test(s) &&
          (!r || i.compare(s) === -1) &&
          ((r = s), (i = new bM(r, n)));
      }),
      r
    );
  };
var wM = EM;
const xM = Ir,
  AM = Ii(),
  SM = (e, t, n) => {
    let r = null,
      i = null,
      a = null;
    try {
      a = new AM(t, n);
    } catch {
      return null;
    }
    return (
      e.forEach((s) => {
        a.test(s) &&
          (!r || i.compare(s) === 1) &&
          ((r = s), (i = new xM(r, n)));
      }),
      r
    );
  };
var IM = SM;
const mm = Ir,
  $M = Ii(),
  $w = dp,
  CM = (e, t) => {
    e = new $M(e, t);
    let n = new mm("0.0.0");
    if (e.test(n) || ((n = new mm("0.0.0-0")), e.test(n))) return n;
    n = null;
    for (let r = 0; r < e.set.length; ++r) {
      const i = e.set[r];
      let a = null;
      i.forEach((s) => {
        const o = new mm(s.semver.version);
        switch (s.operator) {
          case ">":
            o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0),
              (o.raw = o.format());
          case "":
          case ">=":
            (!a || $w(o, a)) && (a = o);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${s.operator}`);
        }
      }),
        a && (!n || $w(n, a)) && (n = a);
    }
    return n && e.test(n) ? n : null;
  };
var RM = CM;
const kM = Ii(),
  TM = (e, t) => {
    try {
      return new kM(e, t).range || "*";
    } catch {
      return null;
    }
  };
var NM = TM;
const OM = Ir,
  MC = pp(),
  { ANY: PM } = MC,
  DM = Ii(),
  LM = hp,
  Cw = dp,
  Rw = Vv,
  BM = Xv,
  UM = Yv,
  FM = (e, t, n, r) => {
    (e = new OM(e, r)), (t = new DM(t, r));
    let i, a, s, o, c;
    switch (n) {
      case ">":
        (i = Cw), (a = BM), (s = Rw), (o = ">"), (c = ">=");
        break;
      case "<":
        (i = Rw), (a = UM), (s = Cw), (o = "<"), (c = "<=");
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (LM(e, t, r)) return !1;
    for (let l = 0; l < t.set.length; ++l) {
      const f = t.set[l];
      let u = null,
        d = null;
      if (
        (f.forEach((p) => {
          p.semver === PM && (p = new MC(">=0.0.0")),
            (u = u || p),
            (d = d || p),
            i(p.semver, u.semver, r)
              ? (u = p)
              : s(p.semver, d.semver, r) && (d = p);
        }),
        u.operator === o ||
          u.operator === c ||
          ((!d.operator || d.operator === o) && a(e, d.semver)))
      )
        return !1;
      if (d.operator === c && s(e, d.semver)) return !1;
    }
    return !0;
  };
var Jv = FM;
const jM = Jv,
  MM = (e, t, n) => jM(e, t, ">", n);
var HM = MM;
const qM = Jv,
  GM = (e, t, n) => qM(e, t, "<", n);
var QM = GM;
const kw = Ii(),
  WM = (e, t, n) => (
    (e = new kw(e, n)), (t = new kw(t, n)), e.intersects(t, n)
  );
var zM = WM;
const KM = hp,
  VM = Si;
var YM = (e, t, n) => {
  const r = [];
  let i = null,
    a = null;
  const s = e.sort((f, u) => VM(f, u, n));
  for (const f of s)
    KM(f, t, n)
      ? ((a = f), i || (i = f))
      : (a && r.push([i, a]), (a = null), (i = null));
  i && r.push([i, null]);
  const o = [];
  for (const [f, u] of r)
    f === u
      ? o.push(f)
      : !u && f === s[0]
      ? o.push("*")
      : u
      ? f === s[0]
        ? o.push(`<=${u}`)
        : o.push(`${f} - ${u}`)
      : o.push(`>=${f}`);
  const c = o.join(" || "),
    l = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < l.length ? c : t;
};
const Tw = Ii(),
  Zv = pp(),
  { ANY: gm } = Zv,
  Bc = hp,
  ey = Si,
  XM = (e, t, n = {}) => {
    if (e === t) return !0;
    (e = new Tw(e, n)), (t = new Tw(t, n));
    let r = !1;
    e: for (const i of e.set) {
      for (const a of t.set) {
        const s = ZM(i, a, n);
        if (((r = r || s !== null), s)) continue e;
      }
      if (r) return !1;
    }
    return !0;
  },
  JM = [new Zv(">=0.0.0-0")],
  Nw = [new Zv(">=0.0.0")],
  ZM = (e, t, n) => {
    if (e === t) return !0;
    if (e.length === 1 && e[0].semver === gm) {
      if (t.length === 1 && t[0].semver === gm) return !0;
      n.includePrerelease ? (e = JM) : (e = Nw);
    }
    if (t.length === 1 && t[0].semver === gm) {
      if (n.includePrerelease) return !0;
      t = Nw;
    }
    const r = new Set();
    let i, a;
    for (const p of e)
      p.operator === ">" || p.operator === ">="
        ? (i = Ow(i, p, n))
        : p.operator === "<" || p.operator === "<="
        ? (a = Pw(a, p, n))
        : r.add(p.semver);
    if (r.size > 1) return null;
    let s;
    if (i && a) {
      if (((s = ey(i.semver, a.semver, n)), s > 0)) return null;
      if (s === 0 && (i.operator !== ">=" || a.operator !== "<=")) return null;
    }
    for (const p of r) {
      if ((i && !Bc(p, String(i), n)) || (a && !Bc(p, String(a), n)))
        return null;
      for (const h of t) if (!Bc(p, String(h), n)) return !1;
      return !0;
    }
    let o,
      c,
      l,
      f,
      u =
        a && !n.includePrerelease && a.semver.prerelease.length ? a.semver : !1,
      d =
        i && !n.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
    u &&
      u.prerelease.length === 1 &&
      a.operator === "<" &&
      u.prerelease[0] === 0 &&
      (u = !1);
    for (const p of t) {
      if (
        ((f = f || p.operator === ">" || p.operator === ">="),
        (l = l || p.operator === "<" || p.operator === "<="),
        i)
      ) {
        if (
          (d &&
            p.semver.prerelease &&
            p.semver.prerelease.length &&
            p.semver.major === d.major &&
            p.semver.minor === d.minor &&
            p.semver.patch === d.patch &&
            (d = !1),
          p.operator === ">" || p.operator === ">=")
        ) {
          if (((o = Ow(i, p, n)), o === p && o !== i)) return !1;
        } else if (i.operator === ">=" && !Bc(i.semver, String(p), n))
          return !1;
      }
      if (a) {
        if (
          (u &&
            p.semver.prerelease &&
            p.semver.prerelease.length &&
            p.semver.major === u.major &&
            p.semver.minor === u.minor &&
            p.semver.patch === u.patch &&
            (u = !1),
          p.operator === "<" || p.operator === "<=")
        ) {
          if (((c = Pw(a, p, n)), c === p && c !== a)) return !1;
        } else if (a.operator === "<=" && !Bc(a.semver, String(p), n))
          return !1;
      }
      if (!p.operator && (a || i) && s !== 0) return !1;
    }
    return !((i && l && !a && s !== 0) || (a && f && !i && s !== 0) || d || u);
  },
  Ow = (e, t, n) => {
    if (!e) return t;
    const r = ey(e.semver, t.semver, n);
    return r > 0
      ? e
      : r < 0 || (t.operator === ">" && e.operator === ">=")
      ? t
      : e;
  },
  Pw = (e, t, n) => {
    if (!e) return t;
    const r = ey(e.semver, t.semver, n);
    return r < 0
      ? e
      : r > 0 || (t.operator === "<" && e.operator === "<=")
      ? t
      : e;
  };
var e7 = XM;
const vm = iu,
  Dw = up,
  t7 = Ir,
  Lw = LC,
  n7 = wc,
  r7 = nj,
  i7 = aj,
  a7 = oj,
  s7 = lj,
  o7 = dj,
  c7 = mj,
  l7 = yj,
  u7 = Ej,
  f7 = Si,
  d7 = Sj,
  p7 = Cj,
  h7 = Kv,
  m7 = Nj,
  g7 = Dj,
  v7 = dp,
  y7 = Vv,
  b7 = BC,
  _7 = UC,
  E7 = Yv,
  w7 = Xv,
  x7 = FC,
  A7 = iM,
  S7 = pp(),
  I7 = Ii(),
  $7 = hp,
  C7 = yM,
  R7 = wM,
  k7 = IM,
  T7 = RM,
  N7 = NM,
  O7 = Jv,
  P7 = HM,
  D7 = QM,
  L7 = zM,
  B7 = YM,
  U7 = e7;
var HC = {
    parse: n7,
    valid: r7,
    clean: i7,
    inc: a7,
    diff: s7,
    major: o7,
    minor: c7,
    patch: l7,
    prerelease: u7,
    compare: f7,
    rcompare: d7,
    compareLoose: p7,
    compareBuild: h7,
    sort: m7,
    rsort: g7,
    gt: v7,
    lt: y7,
    eq: b7,
    neq: _7,
    gte: E7,
    lte: w7,
    cmp: x7,
    coerce: A7,
    Comparator: S7,
    Range: I7,
    satisfies: $7,
    toComparators: C7,
    maxSatisfying: R7,
    minSatisfying: k7,
    minVersion: T7,
    validRange: N7,
    outside: O7,
    gtr: P7,
    ltr: D7,
    intersects: L7,
    simplifyRange: B7,
    subset: U7,
    SemVer: t7,
    re: vm.re,
    src: vm.src,
    tokens: vm.t,
    SEMVER_SPEC_VERSION: Dw.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: Dw.RELEASE_TYPES,
    compareIdentifiers: Lw.compareIdentifiers,
    rcompareIdentifiers: Lw.rcompareIdentifiers,
  },
  ec = {},
  yd = { exports: {} };
yd.exports;
(function (e, t) {
  var n = 200,
    r = "__lodash_hash_undefined__",
    i = 1,
    a = 2,
    s = 9007199254740991,
    o = "[object Arguments]",
    c = "[object Array]",
    l = "[object AsyncFunction]",
    f = "[object Boolean]",
    u = "[object Date]",
    d = "[object Error]",
    p = "[object Function]",
    h = "[object GeneratorFunction]",
    m = "[object Map]",
    g = "[object Number]",
    v = "[object Null]",
    y = "[object Object]",
    _ = "[object Promise]",
    E = "[object Proxy]",
    R = "[object RegExp]",
    A = "[object Set]",
    I = "[object String]",
    S = "[object Symbol]",
    w = "[object Undefined]",
    O = "[object WeakMap]",
    Q = "[object ArrayBuffer]",
    j = "[object DataView]",
    H = "[object Float32Array]",
    q = "[object Float64Array]",
    J = "[object Int8Array]",
    Z = "[object Int16Array]",
    z = "[object Int32Array]",
    U = "[object Uint8Array]",
    G = "[object Uint8ClampedArray]",
    L = "[object Uint16Array]",
    k = "[object Uint32Array]",
    W = /[\\^$.*+?()[\]{}|]/g,
    F = /^\[object .+?Constructor\]$/,
    x = /^(?:0|[1-9]\d*)$/,
    T = {};
  (T[H] = T[q] = T[J] = T[Z] = T[z] = T[U] = T[G] = T[L] = T[k] = !0),
    (T[o] =
      T[c] =
      T[Q] =
      T[f] =
      T[j] =
      T[u] =
      T[d] =
      T[p] =
      T[m] =
      T[g] =
      T[y] =
      T[R] =
      T[A] =
      T[I] =
      T[O] =
        !1);
  var V = typeof Tn == "object" && Tn && Tn.Object === Object && Tn,
    B = typeof self == "object" && self && self.Object === Object && self,
    N = V || B || Function("return this")(),
    ce = t && !t.nodeType && t,
    re = ce && !0 && e && !e.nodeType && e,
    ne = re && re.exports === ce,
    Y = ne && V.process,
    M = (function () {
      try {
        return Y && Y.binding && Y.binding("util");
      } catch {}
    })(),
    oe = M && M.isTypedArray;
  function Ee(ee, ue) {
    for (
      var $e = -1, Ge = ee == null ? 0 : ee.length, ln = 0, Et = [];
      ++$e < Ge;

    ) {
      var Sn = ee[$e];
      ue(Sn, $e, ee) && (Et[ln++] = Sn);
    }
    return Et;
  }
  function le(ee, ue) {
    for (var $e = -1, Ge = ue.length, ln = ee.length; ++$e < Ge; )
      ee[ln + $e] = ue[$e];
    return ee;
  }
  function te(ee, ue) {
    for (var $e = -1, Ge = ee == null ? 0 : ee.length; ++$e < Ge; )
      if (ue(ee[$e], $e, ee)) return !0;
    return !1;
  }
  function ie(ee, ue) {
    for (var $e = -1, Ge = Array(ee); ++$e < ee; ) Ge[$e] = ue($e);
    return Ge;
  }
  function X(ee) {
    return function (ue) {
      return ee(ue);
    };
  }
  function he(ee, ue) {
    return ee.has(ue);
  }
  function be(ee, ue) {
    return ee == null ? void 0 : ee[ue];
  }
  function ye(ee) {
    var ue = -1,
      $e = Array(ee.size);
    return (
      ee.forEach(function (Ge, ln) {
        $e[++ue] = [ln, Ge];
      }),
      $e
    );
  }
  function Qe(ee, ue) {
    return function ($e) {
      return ee(ue($e));
    };
  }
  function lt(ee) {
    var ue = -1,
      $e = Array(ee.size);
    return (
      ee.forEach(function (Ge) {
        $e[++ue] = Ge;
      }),
      $e
    );
  }
  var Lt = Array.prototype,
    We = Function.prototype,
    bt = Object.prototype,
    wt = N["__core-js_shared__"],
    ct = We.toString,
    ze = bt.hasOwnProperty,
    dt = (function () {
      var ee = /[^.]+$/.exec((wt && wt.keys && wt.keys.IE_PROTO) || "");
      return ee ? "Symbol(src)_1." + ee : "";
    })(),
    ht = bt.toString,
    an = RegExp(
      "^" +
        ct
          .call(ze)
          .replace(W, "\\$&")
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            "$1.*?",
          ) +
        "$",
    ),
    $n = ne ? N.Buffer : void 0,
    Wt = N.Symbol,
    Jt = N.Uint8Array,
    Zt = bt.propertyIsEnumerable,
    jr = Lt.splice,
    Nn = Wt ? Wt.toStringTag : void 0,
    Vr = Object.getOwnPropertySymbols,
    Vi = $n ? $n.isBuffer : void 0,
    On = Qe(Object.keys, Object),
    ni = zt(N, "DataView"),
    An = zt(N, "Map"),
    Mr = zt(N, "Promise"),
    Hr = zt(N, "Set"),
    Yi = zt(N, "WeakMap"),
    qr = zt(Object, "create"),
    ns = rs(ni),
    kc = rs(An),
    Bn = rs(Mr),
    no = rs(Hr),
    P = rs(Yi),
    C = Wt ? Wt.prototype : void 0,
    $ = C ? C.valueOf : void 0;
  function b(ee) {
    var ue = -1,
      $e = ee == null ? 0 : ee.length;
    for (this.clear(); ++ue < $e; ) {
      var Ge = ee[ue];
      this.set(Ge[0], Ge[1]);
    }
  }
  function D() {
    (this.__data__ = qr ? qr(null) : {}), (this.size = 0);
  }
  function K(ee) {
    var ue = this.has(ee) && delete this.__data__[ee];
    return (this.size -= ue ? 1 : 0), ue;
  }
  function se(ee) {
    var ue = this.__data__;
    if (qr) {
      var $e = ue[ee];
      return $e === r ? void 0 : $e;
    }
    return ze.call(ue, ee) ? ue[ee] : void 0;
  }
  function pe(ee) {
    var ue = this.__data__;
    return qr ? ue[ee] !== void 0 : ze.call(ue, ee);
  }
  function we(ee, ue) {
    var $e = this.__data__;
    return (
      (this.size += this.has(ee) ? 0 : 1),
      ($e[ee] = qr && ue === void 0 ? r : ue),
      this
    );
  }
  (b.prototype.clear = D),
    (b.prototype.delete = K),
    (b.prototype.get = se),
    (b.prototype.has = pe),
    (b.prototype.set = we);
  function Re(ee) {
    var ue = -1,
      $e = ee == null ? 0 : ee.length;
    for (this.clear(); ++ue < $e; ) {
      var Ge = ee[ue];
      this.set(Ge[0], Ge[1]);
    }
  }
  function ke() {
    (this.__data__ = []), (this.size = 0);
  }
  function je(ee) {
    var ue = this.__data__,
      $e = Ce(ue, ee);
    if ($e < 0) return !1;
    var Ge = ue.length - 1;
    return $e == Ge ? ue.pop() : jr.call(ue, $e, 1), --this.size, !0;
  }
  function Te(ee) {
    var ue = this.__data__,
      $e = Ce(ue, ee);
    return $e < 0 ? void 0 : ue[$e][1];
  }
  function Me(ee) {
    return Ce(this.__data__, ee) > -1;
  }
  function Ne(ee, ue) {
    var $e = this.__data__,
      Ge = Ce($e, ee);
    return Ge < 0 ? (++this.size, $e.push([ee, ue])) : ($e[Ge][1] = ue), this;
  }
  (Re.prototype.clear = ke),
    (Re.prototype.delete = je),
    (Re.prototype.get = Te),
    (Re.prototype.has = Me),
    (Re.prototype.set = Ne);
  function Ue(ee) {
    var ue = -1,
      $e = ee == null ? 0 : ee.length;
    for (this.clear(); ++ue < $e; ) {
      var Ge = ee[ue];
      this.set(Ge[0], Ge[1]);
    }
  }
  function qe() {
    (this.size = 0),
      (this.__data__ = {
        hash: new b(),
        map: new (An || Re)(),
        string: new b(),
      });
  }
  function Fe(ee) {
    var ue = Pt(this, ee).delete(ee);
    return (this.size -= ue ? 1 : 0), ue;
  }
  function Je(ee) {
    return Pt(this, ee).get(ee);
  }
  function Ke(ee) {
    return Pt(this, ee).has(ee);
  }
  function Be(ee, ue) {
    var $e = Pt(this, ee),
      Ge = $e.size;
    return $e.set(ee, ue), (this.size += $e.size == Ge ? 0 : 1), this;
  }
  (Ue.prototype.clear = qe),
    (Ue.prototype.delete = Fe),
    (Ue.prototype.get = Je),
    (Ue.prototype.has = Ke),
    (Ue.prototype.set = Be);
  function He(ee) {
    var ue = -1,
      $e = ee == null ? 0 : ee.length;
    for (this.__data__ = new Ue(); ++ue < $e; ) this.add(ee[ue]);
  }
  function De(ee) {
    return this.__data__.set(ee, r), this;
  }
  function Le(ee) {
    return this.__data__.has(ee);
  }
  (He.prototype.add = He.prototype.push = De), (He.prototype.has = Le);
  function Pe(ee) {
    var ue = (this.__data__ = new Re(ee));
    this.size = ue.size;
  }
  function Oe() {
    (this.__data__ = new Re()), (this.size = 0);
  }
  function ge(ee) {
    var ue = this.__data__,
      $e = ue.delete(ee);
    return (this.size = ue.size), $e;
  }
  function ve(ee) {
    return this.__data__.get(ee);
  }
  function Ie(ee) {
    return this.__data__.has(ee);
  }
  function Se(ee, ue) {
    var $e = this.__data__;
    if ($e instanceof Re) {
      var Ge = $e.__data__;
      if (!An || Ge.length < n - 1)
        return Ge.push([ee, ue]), (this.size = ++$e.size), this;
      $e = this.__data__ = new Ue(Ge);
    }
    return $e.set(ee, ue), (this.size = $e.size), this;
  }
  (Pe.prototype.clear = Oe),
    (Pe.prototype.delete = ge),
    (Pe.prototype.get = ve),
    (Pe.prototype.has = Ie),
    (Pe.prototype.set = Se);
  function Ae(ee, ue) {
    var $e = Ru(ee),
      Ge = !$e && bT(ee),
      ln = !$e && !Ge && nh(ee),
      Et = !$e && !Ge && !ln && b1(ee),
      Sn = $e || Ge || ln || Et,
      Mn = Sn ? ie(ee.length, String) : [],
      Vn = Mn.length;
    for (var yn in ee)
      (ue || ze.call(ee, yn)) &&
        !(
          Sn &&
          (yn == "length" ||
            (ln && (yn == "offset" || yn == "parent")) ||
            (Et &&
              (yn == "buffer" || yn == "byteLength" || yn == "byteOffset")) ||
            Un(yn, Vn))
        ) &&
        Mn.push(yn);
    return Mn;
  }
  function Ce(ee, ue) {
    for (var $e = ee.length; $e--; ) if (m1(ee[$e][0], ue)) return $e;
    return -1;
  }
  function Ve(ee, ue, $e) {
    var Ge = ue(ee);
    return Ru(ee) ? Ge : le(Ge, $e(ee));
  }
  function it(ee) {
    return ee == null
      ? ee === void 0
        ? w
        : v
      : Nn && Nn in Object(ee)
      ? mn(ee)
      : yT(ee);
  }
  function mt(ee) {
    return Tc(ee) && it(ee) == o;
  }
  function at(ee, ue, $e, Ge, ln) {
    return ee === ue
      ? !0
      : ee == null || ue == null || (!Tc(ee) && !Tc(ue))
      ? ee !== ee && ue !== ue
      : ae(ee, ue, $e, Ge, at, ln);
  }
  function ae(ee, ue, $e, Ge, ln, Et) {
    var Sn = Ru(ee),
      Mn = Ru(ue),
      Vn = Sn ? c : en(ee),
      yn = Mn ? c : en(ue);
    (Vn = Vn == o ? y : Vn), (yn = yn == o ? y : yn);
    var Gr = Vn == y,
      ri = yn == y,
      sr = Vn == yn;
    if (sr && nh(ee)) {
      if (!nh(ue)) return !1;
      (Sn = !0), (Gr = !1);
    }
    if (sr && !Gr)
      return (
        Et || (Et = new Pe()),
        Sn || b1(ee)
          ? yt(ee, ue, $e, Ge, ln, Et)
          : Ct(ee, ue, Vn, $e, Ge, ln, Et)
      );
    if (!($e & i)) {
      var Yr = Gr && ze.call(ee, "__wrapped__"),
        Xr = ri && ze.call(ue, "__wrapped__");
      if (Yr || Xr) {
        var ya = Yr ? ee.value() : ee,
          Xi = Xr ? ue.value() : ue;
        return Et || (Et = new Pe()), ln(ya, Xi, $e, Ge, Et);
      }
    }
    return sr ? (Et || (Et = new Pe()), Rt(ee, ue, $e, Ge, ln, Et)) : !1;
  }
  function _t(ee) {
    if (!y1(ee) || jn(ee)) return !1;
    var ue = g1(ee) ? an : F;
    return ue.test(rs(ee));
  }
  function Nt(ee) {
    return Tc(ee) && v1(ee.length) && !!T[it(ee)];
  }
  function Ot(ee) {
    if (!vT(ee)) return On(ee);
    var ue = [];
    for (var $e in Object(ee))
      ze.call(ee, $e) && $e != "constructor" && ue.push($e);
    return ue;
  }
  function yt(ee, ue, $e, Ge, ln, Et) {
    var Sn = $e & i,
      Mn = ee.length,
      Vn = ue.length;
    if (Mn != Vn && !(Sn && Vn > Mn)) return !1;
    var yn = Et.get(ee);
    if (yn && Et.get(ue)) return yn == ue;
    var Gr = -1,
      ri = !0,
      sr = $e & a ? new He() : void 0;
    for (Et.set(ee, ue), Et.set(ue, ee); ++Gr < Mn; ) {
      var Yr = ee[Gr],
        Xr = ue[Gr];
      if (Ge)
        var ya = Sn ? Ge(Xr, Yr, Gr, ue, ee, Et) : Ge(Yr, Xr, Gr, ee, ue, Et);
      if (ya !== void 0) {
        if (ya) continue;
        ri = !1;
        break;
      }
      if (sr) {
        if (
          !te(ue, function (Xi, is) {
            if (!he(sr, is) && (Yr === Xi || ln(Yr, Xi, $e, Ge, Et)))
              return sr.push(is);
          })
        ) {
          ri = !1;
          break;
        }
      } else if (!(Yr === Xr || ln(Yr, Xr, $e, Ge, Et))) {
        ri = !1;
        break;
      }
    }
    return Et.delete(ee), Et.delete(ue), ri;
  }
  function Ct(ee, ue, $e, Ge, ln, Et, Sn) {
    switch ($e) {
      case j:
        if (ee.byteLength != ue.byteLength || ee.byteOffset != ue.byteOffset)
          return !1;
        (ee = ee.buffer), (ue = ue.buffer);
      case Q:
        return !(ee.byteLength != ue.byteLength || !Et(new Jt(ee), new Jt(ue)));
      case f:
      case u:
      case g:
        return m1(+ee, +ue);
      case d:
        return ee.name == ue.name && ee.message == ue.message;
      case R:
      case I:
        return ee == ue + "";
      case m:
        var Mn = ye;
      case A:
        var Vn = Ge & i;
        if ((Mn || (Mn = lt), ee.size != ue.size && !Vn)) return !1;
        var yn = Sn.get(ee);
        if (yn) return yn == ue;
        (Ge |= a), Sn.set(ee, ue);
        var Gr = yt(Mn(ee), Mn(ue), Ge, ln, Et, Sn);
        return Sn.delete(ee), Gr;
      case S:
        if ($) return $.call(ee) == $.call(ue);
    }
    return !1;
  }
  function Rt(ee, ue, $e, Ge, ln, Et) {
    var Sn = $e & i,
      Mn = hn(ee),
      Vn = Mn.length,
      yn = hn(ue),
      Gr = yn.length;
    if (Vn != Gr && !Sn) return !1;
    for (var ri = Vn; ri--; ) {
      var sr = Mn[ri];
      if (!(Sn ? sr in ue : ze.call(ue, sr))) return !1;
    }
    var Yr = Et.get(ee);
    if (Yr && Et.get(ue)) return Yr == ue;
    var Xr = !0;
    Et.set(ee, ue), Et.set(ue, ee);
    for (var ya = Sn; ++ri < Vn; ) {
      sr = Mn[ri];
      var Xi = ee[sr],
        is = ue[sr];
      if (Ge)
        var _1 = Sn ? Ge(is, Xi, sr, ue, ee, Et) : Ge(Xi, is, sr, ee, ue, Et);
      if (!(_1 === void 0 ? Xi === is || ln(Xi, is, $e, Ge, Et) : _1)) {
        Xr = !1;
        break;
      }
      ya || (ya = sr == "constructor");
    }
    if (Xr && !ya) {
      var ku = ee.constructor,
        Tu = ue.constructor;
      ku != Tu &&
        "constructor" in ee &&
        "constructor" in ue &&
        !(
          typeof ku == "function" &&
          ku instanceof ku &&
          typeof Tu == "function" &&
          Tu instanceof Tu
        ) &&
        (Xr = !1);
    }
    return Et.delete(ee), Et.delete(ue), Xr;
  }
  function hn(ee) {
    return Ve(ee, wT, gn);
  }
  function Pt(ee, ue) {
    var $e = ee.__data__;
    return Fn(ue) ? $e[typeof ue == "string" ? "string" : "hash"] : $e.map;
  }
  function zt(ee, ue) {
    var $e = be(ee, ue);
    return _t($e) ? $e : void 0;
  }
  function mn(ee) {
    var ue = ze.call(ee, Nn),
      $e = ee[Nn];
    try {
      ee[Nn] = void 0;
      var Ge = !0;
    } catch {}
    var ln = ht.call(ee);
    return Ge && (ue ? (ee[Nn] = $e) : delete ee[Nn]), ln;
  }
  var gn = Vr
      ? function (ee) {
          return ee == null
            ? []
            : ((ee = Object(ee)),
              Ee(Vr(ee), function (ue) {
                return Zt.call(ee, ue);
              }));
        }
      : xT,
    en = it;
  ((ni && en(new ni(new ArrayBuffer(1))) != j) ||
    (An && en(new An()) != m) ||
    (Mr && en(Mr.resolve()) != _) ||
    (Hr && en(new Hr()) != A) ||
    (Yi && en(new Yi()) != O)) &&
    (en = function (ee) {
      var ue = it(ee),
        $e = ue == y ? ee.constructor : void 0,
        Ge = $e ? rs($e) : "";
      if (Ge)
        switch (Ge) {
          case ns:
            return j;
          case kc:
            return m;
          case Bn:
            return _;
          case no:
            return A;
          case P:
            return O;
        }
      return ue;
    });
  function Un(ee, ue) {
    return (
      (ue = ue ?? s),
      !!ue &&
        (typeof ee == "number" || x.test(ee)) &&
        ee > -1 &&
        ee % 1 == 0 &&
        ee < ue
    );
  }
  function Fn(ee) {
    var ue = typeof ee;
    return ue == "string" || ue == "number" || ue == "symbol" || ue == "boolean"
      ? ee !== "__proto__"
      : ee === null;
  }
  function jn(ee) {
    return !!dt && dt in ee;
  }
  function vT(ee) {
    var ue = ee && ee.constructor,
      $e = (typeof ue == "function" && ue.prototype) || bt;
    return ee === $e;
  }
  function yT(ee) {
    return ht.call(ee);
  }
  function rs(ee) {
    if (ee != null) {
      try {
        return ct.call(ee);
      } catch {}
      try {
        return ee + "";
      } catch {}
    }
    return "";
  }
  function m1(ee, ue) {
    return ee === ue || (ee !== ee && ue !== ue);
  }
  var bT = mt(
      (function () {
        return arguments;
      })(),
    )
      ? mt
      : function (ee) {
          return Tc(ee) && ze.call(ee, "callee") && !Zt.call(ee, "callee");
        },
    Ru = Array.isArray;
  function _T(ee) {
    return ee != null && v1(ee.length) && !g1(ee);
  }
  var nh = Vi || AT;
  function ET(ee, ue) {
    return at(ee, ue);
  }
  function g1(ee) {
    if (!y1(ee)) return !1;
    var ue = it(ee);
    return ue == p || ue == h || ue == l || ue == E;
  }
  function v1(ee) {
    return typeof ee == "number" && ee > -1 && ee % 1 == 0 && ee <= s;
  }
  function y1(ee) {
    var ue = typeof ee;
    return ee != null && (ue == "object" || ue == "function");
  }
  function Tc(ee) {
    return ee != null && typeof ee == "object";
  }
  var b1 = oe ? X(oe) : Nt;
  function wT(ee) {
    return _T(ee) ? Ae(ee) : Ot(ee);
  }
  function xT() {
    return [];
  }
  function AT() {
    return !1;
  }
  e.exports = ET;
})(yd, yd.exports);
var F7 = yd.exports;
Object.defineProperty(ec, "__esModule", { value: !0 });
ec.createTempUpdateFile = ec.DownloadedUpdateHelper = void 0;
const j7 = pr,
  M7 = Xt,
  Bw = F7,
  ps = Za,
  ml = pt;
class H7 {
  constructor(t) {
    (this.cacheDir = t),
      (this._file = null),
      (this._packageFile = null),
      (this.versionInfo = null),
      (this.fileInfo = null),
      (this._downloadedFileInfo = null);
  }
  get downloadedFileInfo() {
    return this._downloadedFileInfo;
  }
  get file() {
    return this._file;
  }
  get packageFile() {
    return this._packageFile;
  }
  get cacheDirForPendingUpdate() {
    return ml.join(this.cacheDir, "pending");
  }
  async validateDownloadedPath(t, n, r, i) {
    if (this.versionInfo != null && this.file === t && this.fileInfo != null)
      return Bw(this.versionInfo, n) &&
        Bw(this.fileInfo.info, r.info) &&
        (await (0, ps.pathExists)(t))
        ? t
        : null;
    const a = await this.getValidCachedUpdateFile(r, i);
    return a === null
      ? null
      : (i.info(`Update has already been downloaded to ${t}).`),
        (this._file = a),
        a);
  }
  async setDownloadedFile(t, n, r, i, a, s) {
    (this._file = t),
      (this._packageFile = n),
      (this.versionInfo = r),
      (this.fileInfo = i),
      (this._downloadedFileInfo = {
        fileName: a,
        sha512: i.info.sha512,
        isAdminRightsRequired: i.info.isAdminRightsRequired === !0,
      }),
      s &&
        (await (0, ps.outputJson)(
          this.getUpdateInfoFile(),
          this._downloadedFileInfo,
        ));
  }
  async clear() {
    (this._file = null),
      (this._packageFile = null),
      (this.versionInfo = null),
      (this.fileInfo = null),
      await this.cleanCacheDirForPendingUpdate();
  }
  async cleanCacheDirForPendingUpdate() {
    try {
      await (0, ps.emptyDir)(this.cacheDirForPendingUpdate);
    } catch {}
  }
  async getValidCachedUpdateFile(t, n) {
    var r;
    const i = this.getUpdateInfoFile();
    if (!(await (0, ps.pathExists)(i))) return null;
    let s;
    try {
      s = await (0, ps.readJson)(i);
    } catch (f) {
      let u = "No cached update info available";
      return (
        f.code !== "ENOENT" &&
          (await this.cleanCacheDirForPendingUpdate(),
          (u += ` (error on read: ${f.message})`)),
        n.info(u),
        null
      );
    }
    if (
      !((r = (s == null ? void 0 : s.fileName) !== null) !== null &&
      r !== void 0
        ? r
        : !1)
    )
      return (
        n.warn(
          "Cached update info is corrupted: no fileName, directory for cached update will be cleaned",
        ),
        await this.cleanCacheDirForPendingUpdate(),
        null
      );
    if (t.info.sha512 !== s.sha512)
      return (
        n.info(
          `Cached update sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${s.sha512}, expected: ${t.info.sha512}. Directory for cached update will be cleaned`,
        ),
        await this.cleanCacheDirForPendingUpdate(),
        null
      );
    const c = ml.join(this.cacheDirForPendingUpdate, s.fileName);
    if (!(await (0, ps.pathExists)(c)))
      return n.info("Cached update file doesn't exist"), null;
    const l = await q7(c);
    return t.info.sha512 !== l
      ? (n.warn(
          `Sha512 checksum doesn't match the latest available update. New update must be downloaded. Cached: ${l}, expected: ${t.info.sha512}`,
        ),
        await this.cleanCacheDirForPendingUpdate(),
        null)
      : ((this._downloadedFileInfo = s), c);
  }
  getUpdateInfoFile() {
    return ml.join(this.cacheDirForPendingUpdate, "update-info.json");
  }
}
ec.DownloadedUpdateHelper = H7;
function q7(e, t = "sha512", n = "base64", r) {
  return new Promise((i, a) => {
    const s = (0, j7.createHash)(t);
    s.on("error", a).setEncoding(n),
      (0, M7.createReadStream)(e, { ...r, highWaterMark: 1024 * 1024 })
        .on("error", a)
        .on("end", () => {
          s.end(), i(s.read());
        })
        .pipe(s, { end: !1 });
  });
}
async function G7(e, t, n) {
  let r = 0,
    i = ml.join(t, e);
  for (let a = 0; a < 3; a++)
    try {
      return await (0, ps.unlink)(i), i;
    } catch (s) {
      if (s.code === "ENOENT") return i;
      n.warn(`Error on remove temp update file: ${s}`),
        (i = ml.join(t, `${r++}-${e}`));
    }
  return i;
}
ec.createTempUpdateFile = G7;
var mp = {},
  gp = {};
Object.defineProperty(gp, "__esModule", { value: !0 });
gp.getAppCacheDir = void 0;
const ym = pt,
  Q7 = Fr;
function W7() {
  const e = (0, Q7.homedir)();
  let t;
  return (
    process.platform === "win32"
      ? (t = process.env.LOCALAPPDATA || ym.join(e, "AppData", "Local"))
      : process.platform === "darwin"
      ? (t = ym.join(e, "Library", "Caches"))
      : (t = process.env.XDG_CACHE_HOME || ym.join(e, ".cache")),
    t
  );
}
gp.getAppCacheDir = W7;
Object.defineProperty(mp, "__esModule", { value: !0 });
mp.ElectronAppAdapter = void 0;
const Uw = pt,
  z7 = gp;
class K7 {
  constructor(t = xe.app) {
    this.app = t;
  }
  whenReady() {
    return this.app.whenReady();
  }
  get version() {
    return this.app.getVersion();
  }
  get name() {
    return this.app.getName();
  }
  get isPackaged() {
    return this.app.isPackaged === !0;
  }
  get appUpdateConfigPath() {
    return this.isPackaged
      ? Uw.join(process.resourcesPath, "app-update.yml")
      : Uw.join(this.app.getAppPath(), "dev-app-update.yml");
  }
  get userDataPath() {
    return this.app.getPath("userData");
  }
  get baseCachePath() {
    return (0, z7.getAppCacheDir)();
  }
  quit() {
    this.app.quit();
  }
  relaunch() {
    this.app.relaunch();
  }
  onQuit(t) {
    this.app.once("quit", (n, r) => t(r));
  }
}
mp.ElectronAppAdapter = K7;
var qC = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.ElectronHttpExecutor = e.getNetSession = e.NET_SESSION_NAME = void 0);
  const t = Ln();
  e.NET_SESSION_NAME = "electron-updater";
  function n() {
    return xe.session.fromPartition(e.NET_SESSION_NAME, { cache: !1 });
  }
  e.getNetSession = n;
  class r extends t.HttpExecutor {
    constructor(a) {
      super(), (this.proxyLoginCallback = a), (this.cachedSession = null);
    }
    async download(a, s, o) {
      return await o.cancellationToken.createPromise((c, l, f) => {
        const u = { headers: o.headers || void 0, redirect: "manual" };
        (0, t.configureRequestUrl)(a, u),
          (0, t.configureRequestOptions)(u),
          this.doDownload(
            u,
            {
              destination: s,
              options: o,
              onCancel: f,
              callback: (d) => {
                d == null ? c(s) : l(d);
              },
              responseHandler: null,
            },
            0,
          );
      });
    }
    createRequest(a, s) {
      a.headers &&
        a.headers.Host &&
        ((a.host = a.headers.Host), delete a.headers.Host),
        this.cachedSession == null && (this.cachedSession = n());
      const o = xe.net.request({ ...a, session: this.cachedSession });
      return (
        o.on("response", s),
        this.proxyLoginCallback != null &&
          o.on("login", this.proxyLoginCallback),
        o
      );
    }
    addRedirectHandlers(a, s, o, c, l) {
      a.on("redirect", (f, u, d) => {
        a.abort(),
          c > this.maxRedirects
            ? o(this.createMaxRedirectError())
            : l(t.HttpExecutor.prepareRedirectUrlOptions(d, s));
      });
    }
  }
  e.ElectronHttpExecutor = r;
})(qC);
var au = {},
  fr = {},
  V7 = 1 / 0,
  Y7 = "[object Symbol]",
  GC = /[\\^$.*+?()[\]{}|]/g,
  X7 = RegExp(GC.source),
  J7 = typeof Tn == "object" && Tn && Tn.Object === Object && Tn,
  Z7 = typeof self == "object" && self && self.Object === Object && self,
  eH = J7 || Z7 || Function("return this")(),
  tH = Object.prototype,
  nH = tH.toString,
  Fw = eH.Symbol,
  jw = Fw ? Fw.prototype : void 0,
  Mw = jw ? jw.toString : void 0;
function rH(e) {
  if (typeof e == "string") return e;
  if (aH(e)) return Mw ? Mw.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -V7 ? "-0" : t;
}
function iH(e) {
  return !!e && typeof e == "object";
}
function aH(e) {
  return typeof e == "symbol" || (iH(e) && nH.call(e) == Y7);
}
function sH(e) {
  return e == null ? "" : rH(e);
}
function oH(e) {
  return (e = sH(e)), e && X7.test(e) ? e.replace(GC, "\\$&") : e;
}
var cH = oH;
Object.defineProperty(fr, "__esModule", { value: !0 });
fr.blockmapFiles =
  fr.getChannelFilename =
  fr.newUrlFromBase =
  fr.newBaseUrl =
    void 0;
const QC = Ya,
  lH = cH;
function uH(e) {
  const t = new QC.URL(e);
  return t.pathname.endsWith("/") || (t.pathname += "/"), t;
}
fr.newBaseUrl = uH;
function d0(e, t, n = !1) {
  const r = new QC.URL(e, t),
    i = t.search;
  return (
    i != null && i.length !== 0
      ? (r.search = i)
      : n && (r.search = `noCache=${Date.now().toString(32)}`),
    r
  );
}
fr.newUrlFromBase = d0;
function fH(e) {
  return `${e}.yml`;
}
fr.getChannelFilename = fH;
function dH(e, t, n) {
  const r = d0(`${e.pathname}.blockmap`, e);
  return [
    d0(`${e.pathname.replace(new RegExp(lH(n), "g"), t)}.blockmap`, e),
    r,
  ];
}
fr.blockmapFiles = dH;
var In = {};
Object.defineProperty(In, "__esModule", { value: !0 });
In.resolveFiles =
  In.getFileList =
  In.parseUpdateInfo =
  In.findFile =
  In.Provider =
    void 0;
const Ka = Ln(),
  pH = ar,
  Hw = fr;
class hH {
  constructor(t) {
    (this.runtimeOptions = t),
      (this.requestHeaders = null),
      (this.executor = t.executor);
  }
  get isUseMultipleRangeRequest() {
    return this.runtimeOptions.isUseMultipleRangeRequest !== !1;
  }
  getChannelFilePrefix() {
    if (this.runtimeOptions.platform === "linux") {
      const t = process.env.TEST_UPDATER_ARCH || process.arch;
      return "-linux" + (t === "x64" ? "" : `-${t}`);
    } else return this.runtimeOptions.platform === "darwin" ? "-mac" : "";
  }
  getDefaultChannelName() {
    return this.getCustomChannelName("latest");
  }
  getCustomChannelName(t) {
    return `${t}${this.getChannelFilePrefix()}`;
  }
  get fileExtraDownloadHeaders() {
    return null;
  }
  setRequestHeaders(t) {
    this.requestHeaders = t;
  }
  httpRequest(t, n, r) {
    return this.executor.request(this.createRequestOptions(t, n), r);
  }
  createRequestOptions(t, n) {
    const r = {};
    return (
      this.requestHeaders == null
        ? n != null && (r.headers = n)
        : (r.headers =
            n == null ? this.requestHeaders : { ...this.requestHeaders, ...n }),
      (0, Ka.configureRequestUrl)(t, r),
      r
    );
  }
}
In.Provider = hH;
function mH(e, t, n) {
  if (e.length === 0)
    throw (0, Ka.newError)(
      "No files provided",
      "ERR_UPDATER_NO_FILES_PROVIDED",
    );
  const r = e.find((i) => i.url.pathname.toLowerCase().endsWith(`.${t}`));
  return (
    r ??
    (n == null
      ? e[0]
      : e.find(
          (i) => !n.some((a) => i.url.pathname.toLowerCase().endsWith(`.${a}`)),
        ))
  );
}
In.findFile = mH;
function gH(e, t, n) {
  if (e == null)
    throw (0, Ka.newError)(
      `Cannot parse update info from ${t} in the latest release artifacts (${n}): rawData: null`,
      "ERR_UPDATER_INVALID_UPDATE_INFO",
    );
  let r;
  try {
    r = (0, pH.load)(e);
  } catch (i) {
    throw (0, Ka.newError)(
      `Cannot parse update info from ${t} in the latest release artifacts (${n}): ${
        i.stack || i.message
      }, rawData: ${e}`,
      "ERR_UPDATER_INVALID_UPDATE_INFO",
    );
  }
  return r;
}
In.parseUpdateInfo = gH;
function WC(e) {
  const t = e.files;
  if (t != null && t.length > 0) return t;
  if (e.path != null) return [{ url: e.path, sha2: e.sha2, sha512: e.sha512 }];
  throw (0, Ka.newError)(
    `No files provided: ${(0, Ka.safeStringifyJson)(e)}`,
    "ERR_UPDATER_NO_FILES_PROVIDED",
  );
}
In.getFileList = WC;
function vH(e, t, n = (r) => r) {
  const i = WC(e).map((o) => {
      if (o.sha2 == null && o.sha512 == null)
        throw (0, Ka.newError)(
          `Update info doesn't contain nor sha256 neither sha512 checksum: ${(0,
          Ka.safeStringifyJson)(o)}`,
          "ERR_UPDATER_NO_CHECKSUM",
        );
      return { url: (0, Hw.newUrlFromBase)(n(o.url), t), info: o };
    }),
    a = e.packages,
    s = a == null ? null : a[process.arch] || a.ia32;
  return (
    s != null &&
      (i[0].packageInfo = {
        ...s,
        path: (0, Hw.newUrlFromBase)(n(s.path), t).href,
      }),
    i
  );
}
In.resolveFiles = vH;
Object.defineProperty(au, "__esModule", { value: !0 });
au.GenericProvider = void 0;
const qw = Ln(),
  bm = fr,
  _m = In;
class yH extends _m.Provider {
  constructor(t, n, r) {
    super(r),
      (this.configuration = t),
      (this.updater = n),
      (this.baseUrl = (0, bm.newBaseUrl)(this.configuration.url));
  }
  get channel() {
    const t = this.updater.channel || this.configuration.channel;
    return t == null
      ? this.getDefaultChannelName()
      : this.getCustomChannelName(t);
  }
  async getLatestVersion() {
    const t = (0, bm.getChannelFilename)(this.channel),
      n = (0, bm.newUrlFromBase)(
        t,
        this.baseUrl,
        this.updater.isAddNoCacheQuery,
      );
    for (let r = 0; ; r++)
      try {
        return (0, _m.parseUpdateInfo)(await this.httpRequest(n), t, n);
      } catch (i) {
        if (i instanceof qw.HttpError && i.statusCode === 404)
          throw (0, qw.newError)(
            `Cannot find channel "${t}" update info: ${i.stack || i.message}`,
            "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND",
          );
        if (i.code === "ECONNREFUSED" && r < 3) {
          await new Promise((a, s) => {
            try {
              setTimeout(a, 1e3 * r);
            } catch (o) {
              s(o);
            }
          });
          continue;
        }
        throw i;
      }
  }
  resolveFiles(t) {
    return (0, _m.resolveFiles)(t, this.baseUrl);
  }
}
au.GenericProvider = yH;
var tc = {},
  vp = {};
Object.defineProperty(vp, "__esModule", { value: !0 });
vp.BitbucketProvider = void 0;
const Gw = Ln(),
  Em = fr,
  wm = In;
class bH extends wm.Provider {
  constructor(t, n, r) {
    super({ ...r, isUseMultipleRangeRequest: !1 }),
      (this.configuration = t),
      (this.updater = n);
    const { owner: i, slug: a } = t;
    this.baseUrl = (0, Em.newBaseUrl)(
      `https://api.bitbucket.org/2.0/repositories/${i}/${a}/downloads`,
    );
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "latest";
  }
  async getLatestVersion() {
    const t = new Gw.CancellationToken(),
      n = (0, Em.getChannelFilename)(this.getCustomChannelName(this.channel)),
      r = (0, Em.newUrlFromBase)(
        n,
        this.baseUrl,
        this.updater.isAddNoCacheQuery,
      );
    try {
      const i = await this.httpRequest(r, void 0, t);
      return (0, wm.parseUpdateInfo)(i, n, r);
    } catch (i) {
      throw (0, Gw.newError)(
        `Unable to find latest version on ${this.toString()}, please ensure release exists: ${
          i.stack || i.message
        }`,
        "ERR_UPDATER_LATEST_VERSION_NOT_FOUND",
      );
    }
  }
  resolveFiles(t) {
    return (0, wm.resolveFiles)(t, this.baseUrl);
  }
  toString() {
    const { owner: t, slug: n } = this.configuration;
    return `Bitbucket (owner: ${t}, slug: ${n}, channel: ${this.channel})`;
  }
}
vp.BitbucketProvider = bH;
var ca = {};
Object.defineProperty(ca, "__esModule", { value: !0 });
ca.computeReleaseNotes = ca.GitHubProvider = ca.BaseGitHubProvider = void 0;
const ea = Ln(),
  gl = HC,
  _H = Ya,
  Co = fr,
  p0 = In,
  xm = /\/tag\/([^/]+)$/;
class zC extends p0.Provider {
  constructor(t, n, r) {
    super({ ...r, isUseMultipleRangeRequest: !1 }),
      (this.options = t),
      (this.baseUrl = (0, Co.newBaseUrl)((0, ea.githubUrl)(t, n)));
    const i = n === "github.com" ? "api.github.com" : n;
    this.baseApiUrl = (0, Co.newBaseUrl)((0, ea.githubUrl)(t, i));
  }
  computeGithubBasePath(t) {
    const n = this.options.host;
    return n && !["github.com", "api.github.com"].includes(n)
      ? `/api/v3${t}`
      : t;
  }
}
ca.BaseGitHubProvider = zC;
class EH extends zC {
  constructor(t, n, r) {
    super(t, "github.com", r), (this.options = t), (this.updater = n);
  }
  async getLatestVersion() {
    var t, n, r, i;
    const a = new ea.CancellationToken(),
      s = await this.httpRequest(
        (0, Co.newUrlFromBase)(`${this.basePath}.atom`, this.baseUrl),
        { accept: "application/xml, application/atom+xml, text/xml, */*" },
        a,
      ),
      o = (0, ea.parseXml)(s);
    let c = o.element("entry", !1, "No published versions on GitHub"),
      l = null;
    try {
      if (this.updater.allowPrerelease) {
        const m =
          ((t = this.updater) === null || t === void 0 ? void 0 : t.channel) ||
          ((n = gl.prerelease(this.updater.currentVersion)) === null ||
          n === void 0
            ? void 0
            : n[0]) ||
          null;
        if (m === null) l = xm.exec(c.element("link").attribute("href"))[1];
        else
          for (const g of o.getElements("entry")) {
            const v = xm.exec(g.element("link").attribute("href"));
            if (v === null) continue;
            const y = v[1],
              _ =
                ((r = gl.prerelease(y)) === null || r === void 0
                  ? void 0
                  : r[0]) || null,
              E = !m || ["alpha", "beta"].includes(m),
              R = _ !== null && !["alpha", "beta"].includes(String(_));
            if (E && !R && !(m === "beta" && _ === "alpha")) {
              l = y;
              break;
            }
            if (_ && _ === m) {
              l = y;
              break;
            }
          }
      } else {
        l = await this.getLatestTagName(a);
        for (const m of o.getElements("entry"))
          if (xm.exec(m.element("link").attribute("href"))[1] === l) {
            c = m;
            break;
          }
      }
    } catch (m) {
      throw (0, ea.newError)(
        `Cannot parse releases feed: ${m.stack || m.message},
XML:
${s}`,
        "ERR_UPDATER_INVALID_RELEASE_FEED",
      );
    }
    if (l == null)
      throw (0, ea.newError)(
        "No published versions on GitHub",
        "ERR_UPDATER_NO_PUBLISHED_VERSIONS",
      );
    let f,
      u = "",
      d = "";
    const p = async (m) => {
      (u = (0, Co.getChannelFilename)(m)),
        (d = (0, Co.newUrlFromBase)(
          this.getBaseDownloadPath(String(l), u),
          this.baseUrl,
        ));
      const g = this.createRequestOptions(d);
      try {
        return await this.executor.request(g, a);
      } catch (v) {
        throw v instanceof ea.HttpError && v.statusCode === 404
          ? (0, ea.newError)(
              `Cannot find ${u} in the latest release artifacts (${d}): ${
                v.stack || v.message
              }`,
              "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND",
            )
          : v;
      }
    };
    try {
      const m = this.updater.allowPrerelease
        ? this.getCustomChannelName(
            String(
              ((i = gl.prerelease(l)) === null || i === void 0
                ? void 0
                : i[0]) || "latest",
            ),
          )
        : this.getDefaultChannelName();
      f = await p(m);
    } catch (m) {
      if (this.updater.allowPrerelease)
        f = await p(this.getDefaultChannelName());
      else throw m;
    }
    const h = (0, p0.parseUpdateInfo)(f, u, d);
    return (
      h.releaseName == null && (h.releaseName = c.elementValueOrEmpty("title")),
      h.releaseNotes == null &&
        (h.releaseNotes = KC(
          this.updater.currentVersion,
          this.updater.fullChangelog,
          o,
          c,
        )),
      { tag: l, ...h }
    );
  }
  async getLatestTagName(t) {
    const n = this.options,
      r =
        n.host == null || n.host === "github.com"
          ? (0, Co.newUrlFromBase)(`${this.basePath}/latest`, this.baseUrl)
          : new _H.URL(
              `${this.computeGithubBasePath(
                `/repos/${n.owner}/${n.repo}/releases`,
              )}/latest`,
              this.baseApiUrl,
            );
    try {
      const i = await this.httpRequest(r, { Accept: "application/json" }, t);
      return i == null ? null : JSON.parse(i).tag_name;
    } catch (i) {
      throw (0, ea.newError)(
        `Unable to find latest version on GitHub (${r}), please ensure a production release exists: ${
          i.stack || i.message
        }`,
        "ERR_UPDATER_LATEST_VERSION_NOT_FOUND",
      );
    }
  }
  get basePath() {
    return `/${this.options.owner}/${this.options.repo}/releases`;
  }
  resolveFiles(t) {
    return (0, p0.resolveFiles)(t, this.baseUrl, (n) =>
      this.getBaseDownloadPath(t.tag, n.replace(/ /g, "-")),
    );
  }
  getBaseDownloadPath(t, n) {
    return `${this.basePath}/download/${t}/${n}`;
  }
}
ca.GitHubProvider = EH;
function Qw(e) {
  const t = e.elementValueOrEmpty("content");
  return t === "No content." ? "" : t;
}
function KC(e, t, n, r) {
  if (!t) return Qw(r);
  const i = [];
  for (const a of n.getElements("entry")) {
    const s = /\/tag\/v?([^/]+)$/.exec(a.element("link").attribute("href"))[1];
    gl.lt(e, s) && i.push({ version: s, note: Qw(a) });
  }
  return i.sort((a, s) => gl.rcompare(a.version, s.version));
}
ca.computeReleaseNotes = KC;
var yp = {};
Object.defineProperty(yp, "__esModule", { value: !0 });
yp.KeygenProvider = void 0;
const Ww = Ln(),
  Am = fr,
  Sm = In;
class wH extends Sm.Provider {
  constructor(t, n, r) {
    super({ ...r, isUseMultipleRangeRequest: !1 }),
      (this.configuration = t),
      (this.updater = n),
      (this.baseUrl = (0, Am.newBaseUrl)(
        `https://api.keygen.sh/v1/accounts/${this.configuration.account}/artifacts?product=${this.configuration.product}`,
      ));
  }
  get channel() {
    return this.updater.channel || this.configuration.channel || "stable";
  }
  async getLatestVersion() {
    const t = new Ww.CancellationToken(),
      n = (0, Am.getChannelFilename)(this.getCustomChannelName(this.channel)),
      r = (0, Am.newUrlFromBase)(
        n,
        this.baseUrl,
        this.updater.isAddNoCacheQuery,
      );
    try {
      const i = await this.httpRequest(
        r,
        { Accept: "application/vnd.api+json", "Keygen-Version": "1.1" },
        t,
      );
      return (0, Sm.parseUpdateInfo)(i, n, r);
    } catch (i) {
      throw (0, Ww.newError)(
        `Unable to find latest version on ${this.toString()}, please ensure release exists: ${
          i.stack || i.message
        }`,
        "ERR_UPDATER_LATEST_VERSION_NOT_FOUND",
      );
    }
  }
  resolveFiles(t) {
    return (0, Sm.resolveFiles)(t, this.baseUrl);
  }
  toString() {
    const { account: t, product: n, platform: r } = this.configuration;
    return `Keygen (account: ${t}, product: ${n}, platform: ${r}, channel: ${this.channel})`;
  }
}
yp.KeygenProvider = wH;
var bp = {};
Object.defineProperty(bp, "__esModule", { value: !0 });
bp.PrivateGitHubProvider = void 0;
const co = Ln(),
  xH = ar,
  AH = pt,
  zw = Ya,
  Kw = fr,
  SH = ca,
  IH = In;
class $H extends SH.BaseGitHubProvider {
  constructor(t, n, r, i) {
    super(t, "api.github.com", i), (this.updater = n), (this.token = r);
  }
  createRequestOptions(t, n) {
    const r = super.createRequestOptions(t, n);
    return (r.redirect = "manual"), r;
  }
  async getLatestVersion() {
    const t = new co.CancellationToken(),
      n = (0, Kw.getChannelFilename)(this.getDefaultChannelName()),
      r = await this.getLatestVersionInfo(t),
      i = r.assets.find((o) => o.name === n);
    if (i == null)
      throw (0, co.newError)(
        `Cannot find ${n} in the release ${r.html_url || r.name}`,
        "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND",
      );
    const a = new zw.URL(i.url);
    let s;
    try {
      s = (0, xH.load)(
        await this.httpRequest(
          a,
          this.configureHeaders("application/octet-stream"),
          t,
        ),
      );
    } catch (o) {
      throw o instanceof co.HttpError && o.statusCode === 404
        ? (0, co.newError)(
            `Cannot find ${n} in the latest release artifacts (${a}): ${
              o.stack || o.message
            }`,
            "ERR_UPDATER_CHANNEL_FILE_NOT_FOUND",
          )
        : o;
    }
    return (s.assets = r.assets), s;
  }
  get fileExtraDownloadHeaders() {
    return this.configureHeaders("application/octet-stream");
  }
  configureHeaders(t) {
    return { accept: t, authorization: `token ${this.token}` };
  }
  async getLatestVersionInfo(t) {
    const n = this.updater.allowPrerelease;
    let r = this.basePath;
    n || (r = `${r}/latest`);
    const i = (0, Kw.newUrlFromBase)(r, this.baseUrl);
    try {
      const a = JSON.parse(
        await this.httpRequest(
          i,
          this.configureHeaders("application/vnd.github.v3+json"),
          t,
        ),
      );
      return n ? a.find((s) => s.prerelease) || a[0] : a;
    } catch (a) {
      throw (0, co.newError)(
        `Unable to find latest version on GitHub (${i}), please ensure a production release exists: ${
          a.stack || a.message
        }`,
        "ERR_UPDATER_LATEST_VERSION_NOT_FOUND",
      );
    }
  }
  get basePath() {
    return this.computeGithubBasePath(
      `/repos/${this.options.owner}/${this.options.repo}/releases`,
    );
  }
  resolveFiles(t) {
    return (0, IH.getFileList)(t).map((n) => {
      const r = AH.posix.basename(n.url).replace(/ /g, "-"),
        i = t.assets.find((a) => a != null && a.name === r);
      if (i == null)
        throw (0, co.newError)(
          `Cannot find asset "${r}" in: ${JSON.stringify(t.assets, null, 2)}`,
          "ERR_UPDATER_ASSET_NOT_FOUND",
        );
      return { url: new zw.URL(i.url), info: n };
    });
  }
}
bp.PrivateGitHubProvider = $H;
Object.defineProperty(tc, "__esModule", { value: !0 });
tc.createClient = tc.isUrlProbablySupportMultiRangeRequests = void 0;
const ff = Ln(),
  CH = vp,
  Vw = au,
  RH = ca,
  kH = yp,
  TH = bp;
function VC(e) {
  return !e.includes("s3.amazonaws.com");
}
tc.isUrlProbablySupportMultiRangeRequests = VC;
function NH(e, t, n) {
  if (typeof e == "string")
    throw (0, ff.newError)(
      "Please pass PublishConfiguration object",
      "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION",
    );
  const r = e.provider;
  switch (r) {
    case "github": {
      const i = e,
        a =
          (i.private
            ? process.env.GH_TOKEN || process.env.GITHUB_TOKEN
            : null) || i.token;
      return a == null
        ? new RH.GitHubProvider(i, t, n)
        : new TH.PrivateGitHubProvider(i, t, a, n);
    }
    case "bitbucket":
      return new CH.BitbucketProvider(e, t, n);
    case "keygen":
      return new kH.KeygenProvider(e, t, n);
    case "s3":
    case "spaces":
      return new Vw.GenericProvider(
        {
          provider: "generic",
          url: (0, ff.getS3LikeProviderBaseUrl)(e),
          channel: e.channel || null,
        },
        t,
        { ...n, isUseMultipleRangeRequest: !1 },
      );
    case "generic": {
      const i = e;
      return new Vw.GenericProvider(i, t, {
        ...n,
        isUseMultipleRangeRequest:
          i.useMultipleRangeRequest !== !1 && VC(i.url),
      });
    }
    case "custom": {
      const i = e,
        a = i.updateProvider;
      if (!a)
        throw (0, ff.newError)(
          "Custom provider not specified",
          "ERR_UPDATER_INVALID_PROVIDER_CONFIGURATION",
        );
      return new a(i, t, n);
    }
    default:
      throw (0, ff.newError)(
        `Unsupported provider: ${r}`,
        "ERR_UPDATER_UNSUPPORTED_PROVIDER",
      );
  }
}
tc.createClient = NH;
var Yw;
function ty() {
  if (Yw) return cs;
  (Yw = 1),
    Object.defineProperty(cs, "__esModule", { value: !0 }),
    (cs.NoOpLogger = cs.AppUpdater = void 0);
  const e = Ln(),
    t = pr,
    n = Hi,
    r = Za,
    i = ar,
    a = lp,
    s = pt,
    o = HC,
    c = ec,
    l = mp,
    f = qC,
    u = au,
    d = xc(),
    p = tc;
  let h = class YC extends n.EventEmitter {
    constructor(y, _) {
      super(),
        (this.autoDownload = !0),
        (this.autoInstallOnAppQuit = !0),
        (this.autoRunAppAfterInstall = !0),
        (this.allowPrerelease = !1),
        (this.fullChangelog = !1),
        (this.allowDowngrade = !1),
        (this.disableWebInstaller = !1),
        (this.forceDevUpdateConfig = !1),
        (this._channel = null),
        (this.downloadedUpdateHelper = null),
        (this.requestHeaders = null),
        (this._logger = console),
        (this.signals = new d.UpdaterSignal(this)),
        (this._appUpdateConfigPath = null),
        (this.clientPromise = null),
        (this.stagingUserIdPromise = new a.Lazy(() =>
          this.getOrCreateStagingUserId(),
        )),
        (this.configOnDisk = new a.Lazy(() => this.loadUpdateConfig())),
        (this.checkForUpdatesPromise = null),
        (this.updateInfoAndProvider = null),
        (this._testOnlyOptions = null),
        this.on("error", (A) => {
          this._logger.error(`Error: ${A.stack || A.message}`);
        }),
        _ == null
          ? ((this.app = new l.ElectronAppAdapter()),
            (this.httpExecutor = new f.ElectronHttpExecutor((A, I) =>
              this.emit("login", A, I),
            )))
          : ((this.app = _), (this.httpExecutor = null));
      const E = this.app.version,
        R = (0, o.parse)(E);
      if (R == null)
        throw (0, e.newError)(
          `App version is not a valid semver version: "${E}"`,
          "ERR_UPDATER_INVALID_VERSION",
        );
      (this.currentVersion = R),
        (this.allowPrerelease = m(R)),
        y != null &&
          (this.setFeedURL(y),
          typeof y != "string" &&
            y.requestHeaders &&
            (this.requestHeaders = y.requestHeaders));
    }
    get channel() {
      return this._channel;
    }
    set channel(y) {
      if (this._channel != null) {
        if (typeof y != "string")
          throw (0, e.newError)(
            `Channel must be a string, but got: ${y}`,
            "ERR_UPDATER_INVALID_CHANNEL",
          );
        if (y.length === 0)
          throw (0, e.newError)(
            "Channel must be not an empty string",
            "ERR_UPDATER_INVALID_CHANNEL",
          );
      }
      (this._channel = y), (this.allowDowngrade = !0);
    }
    addAuthHeader(y) {
      this.requestHeaders = Object.assign({}, this.requestHeaders, {
        authorization: y,
      });
    }
    get netSession() {
      return (0, f.getNetSession)();
    }
    get logger() {
      return this._logger;
    }
    set logger(y) {
      this._logger = y ?? new g();
    }
    set updateConfigPath(y) {
      (this.clientPromise = null),
        (this._appUpdateConfigPath = y),
        (this.configOnDisk = new a.Lazy(() => this.loadUpdateConfig()));
    }
    getFeedURL() {
      return "Deprecated. Do not use it.";
    }
    setFeedURL(y) {
      const _ = this.createProviderRuntimeOptions();
      let E;
      typeof y == "string"
        ? (E = new u.GenericProvider({ provider: "generic", url: y }, this, {
            ..._,
            isUseMultipleRangeRequest: (0,
            p.isUrlProbablySupportMultiRangeRequests)(y),
          }))
        : (E = (0, p.createClient)(y, this, _)),
        (this.clientPromise = Promise.resolve(E));
    }
    checkForUpdates() {
      if (!this.isUpdaterActive()) return Promise.resolve(null);
      let y = this.checkForUpdatesPromise;
      if (y != null)
        return (
          this._logger.info("Checking for update (already in progress)"), y
        );
      const _ = () => (this.checkForUpdatesPromise = null);
      return (
        this._logger.info("Checking for update"),
        (y = this.doCheckForUpdates()
          .then((E) => (_(), E))
          .catch((E) => {
            throw (
              (_(),
              this.emit(
                "error",
                E,
                `Cannot check for updates: ${(E.stack || E).toString()}`,
              ),
              E)
            );
          })),
        (this.checkForUpdatesPromise = y),
        y
      );
    }
    isUpdaterActive() {
      return this.app.isPackaged || this.forceDevUpdateConfig
        ? !0
        : (this._logger.info(
            "Skip checkForUpdates because application is not packed and dev update config is not forced",
          ),
          !1);
    }
    checkForUpdatesAndNotify(y) {
      return this.checkForUpdates().then((_) =>
        _ != null && _.downloadPromise
          ? (_.downloadPromise.then(() => {
              const E = YC.formatDownloadNotification(
                _.updateInfo.version,
                this.app.name,
                y,
              );
              new xe.Notification(E).show();
            }),
            _)
          : (this._logger.debug != null &&
              this._logger.debug(
                "checkForUpdatesAndNotify called, downloadPromise is null",
              ),
            _),
      );
    }
    static formatDownloadNotification(y, _, E) {
      return (
        E == null &&
          (E = {
            title: "A new update is ready to install",
            body: "{appName} version {version} has been downloaded and will be automatically installed on exit",
          }),
        (E = {
          title: E.title.replace("{appName}", _).replace("{version}", y),
          body: E.body.replace("{appName}", _).replace("{version}", y),
        }),
        E
      );
    }
    async isStagingMatch(y) {
      const _ = y.stagingPercentage;
      let E = _;
      if (E == null) return !0;
      if (((E = parseInt(E, 10)), isNaN(E)))
        return this._logger.warn(`Staging percentage is NaN: ${_}`), !0;
      E = E / 100;
      const R = await this.stagingUserIdPromise.value,
        I = e.UUID.parse(R).readUInt32BE(12) / 4294967295;
      return (
        this._logger.info(
          `Staging percentage: ${E}, percentage: ${I}, user id: ${R}`,
        ),
        I < E
      );
    }
    computeFinalHeaders(y) {
      return (
        this.requestHeaders != null && Object.assign(y, this.requestHeaders), y
      );
    }
    async isUpdateAvailable(y) {
      const _ = (0, o.parse)(y.version);
      if (_ == null)
        throw (0, e.newError)(
          `This file could not be downloaded, or the latest version (from update server) does not have a valid semver version: "${y.version}"`,
          "ERR_UPDATER_INVALID_VERSION",
        );
      const E = this.currentVersion;
      if ((0, o.eq)(_, E) || !(await this.isStagingMatch(y))) return !1;
      const A = (0, o.gt)(_, E),
        I = (0, o.lt)(_, E);
      return A ? !0 : this.allowDowngrade && I;
    }
    async getUpdateInfoAndProvider() {
      await this.app.whenReady(),
        this.clientPromise == null &&
          (this.clientPromise = this.configOnDisk.value.then((E) =>
            (0, p.createClient)(E, this, this.createProviderRuntimeOptions()),
          ));
      const y = await this.clientPromise,
        _ = await this.stagingUserIdPromise.value;
      return (
        y.setRequestHeaders(
          this.computeFinalHeaders({ "x-user-staging-id": _ }),
        ),
        { info: await y.getLatestVersion(), provider: y }
      );
    }
    createProviderRuntimeOptions() {
      return {
        isUseMultipleRangeRequest: !0,
        platform:
          this._testOnlyOptions == null
            ? process.platform
            : this._testOnlyOptions.platform,
        executor: this.httpExecutor,
      };
    }
    async doCheckForUpdates() {
      this.emit("checking-for-update");
      const y = await this.getUpdateInfoAndProvider(),
        _ = y.info;
      if (!(await this.isUpdateAvailable(_)))
        return (
          this._logger.info(
            `Update for version ${
              this.currentVersion
            } is not available (latest version: ${_.version}, downgrade is ${
              this.allowDowngrade ? "allowed" : "disallowed"
            }).`,
          ),
          this.emit("update-not-available", _),
          { versionInfo: _, updateInfo: _ }
        );
      (this.updateInfoAndProvider = y), this.onUpdateAvailable(_);
      const E = new e.CancellationToken();
      return {
        versionInfo: _,
        updateInfo: _,
        cancellationToken: E,
        downloadPromise: this.autoDownload ? this.downloadUpdate(E) : null,
      };
    }
    onUpdateAvailable(y) {
      this._logger.info(
        `Found version ${y.version} (url: ${(0, e.asArray)(y.files)
          .map((_) => _.url)
          .join(", ")})`,
      ),
        this.emit("update-available", y);
    }
    downloadUpdate(y = new e.CancellationToken()) {
      const _ = this.updateInfoAndProvider;
      if (_ == null) {
        const R = new Error("Please check update first");
        return this.dispatchError(R), Promise.reject(R);
      }
      this._logger.info(
        `Downloading update from ${(0, e.asArray)(_.info.files)
          .map((R) => R.url)
          .join(", ")}`,
      );
      const E = (R) => {
        if (!(R instanceof e.CancellationError))
          try {
            this.dispatchError(R);
          } catch (A) {
            this._logger.warn(`Cannot dispatch error event: ${A.stack || A}`);
          }
        return R;
      };
      try {
        return this.doDownloadUpdate({
          updateInfoAndProvider: _,
          requestHeaders: this.computeRequestHeaders(_.provider),
          cancellationToken: y,
          disableWebInstaller: this.disableWebInstaller,
        }).catch((R) => {
          throw E(R);
        });
      } catch (R) {
        return Promise.reject(E(R));
      }
    }
    dispatchError(y) {
      this.emit("error", y, (y.stack || y).toString());
    }
    dispatchUpdateDownloaded(y) {
      this.emit(d.UPDATE_DOWNLOADED, y);
    }
    async loadUpdateConfig() {
      return (
        this._appUpdateConfigPath == null &&
          (this._appUpdateConfigPath = this.app.appUpdateConfigPath),
        (0, i.load)(await (0, r.readFile)(this._appUpdateConfigPath, "utf-8"))
      );
    }
    computeRequestHeaders(y) {
      const _ = y.fileExtraDownloadHeaders;
      if (_ != null) {
        const E = this.requestHeaders;
        return E == null ? _ : { ..._, ...E };
      }
      return this.computeFinalHeaders({ accept: "*/*" });
    }
    async getOrCreateStagingUserId() {
      const y = s.join(this.app.userDataPath, ".updaterId");
      try {
        const E = await (0, r.readFile)(y, "utf-8");
        if (e.UUID.check(E)) return E;
        this._logger.warn(
          `Staging user id file exists, but content was invalid: ${E}`,
        );
      } catch (E) {
        E.code !== "ENOENT" &&
          this._logger.warn(
            `Couldn't read staging user ID, creating a blank one: ${E}`,
          );
      }
      const _ = e.UUID.v5((0, t.randomBytes)(4096), e.UUID.OID);
      this._logger.info(`Generated new staging user ID: ${_}`);
      try {
        await (0, r.outputFile)(y, _);
      } catch (E) {
        this._logger.warn(`Couldn't write out staging user ID: ${E}`);
      }
      return _;
    }
    get isAddNoCacheQuery() {
      const y = this.requestHeaders;
      if (y == null) return !0;
      for (const _ of Object.keys(y)) {
        const E = _.toLowerCase();
        if (E === "authorization" || E === "private-token") return !1;
      }
      return !0;
    }
    async getOrCreateDownloadHelper() {
      let y = this.downloadedUpdateHelper;
      if (y == null) {
        const _ = (await this.configOnDisk.value).updaterCacheDirName,
          E = this._logger;
        _ == null &&
          E.error(
            "updaterCacheDirName is not specified in app-update.yml Was app build using at least electron-builder 20.34.0?",
          );
        const R = s.join(this.app.baseCachePath, _ || this.app.name);
        E.debug != null && E.debug(`updater cache dir: ${R}`),
          (y = new c.DownloadedUpdateHelper(R)),
          (this.downloadedUpdateHelper = y);
      }
      return y;
    }
    async executeDownload(y) {
      const _ = y.fileInfo,
        E = {
          headers: y.downloadUpdateOptions.requestHeaders,
          cancellationToken: y.downloadUpdateOptions.cancellationToken,
          sha2: _.info.sha2,
          sha512: _.info.sha512,
        };
      this.listenerCount(d.DOWNLOAD_PROGRESS) > 0 &&
        (E.onProgress = (G) => this.emit(d.DOWNLOAD_PROGRESS, G));
      const R = y.downloadUpdateOptions.updateInfoAndProvider.info,
        A = R.version,
        I = _.packageInfo;
      function S() {
        const G = decodeURIComponent(y.fileInfo.url.pathname);
        return G.endsWith(`.${y.fileExtension}`)
          ? s.basename(G)
          : y.fileInfo.info.url;
      }
      const w = await this.getOrCreateDownloadHelper(),
        O = w.cacheDirForPendingUpdate;
      await (0, r.mkdir)(O, { recursive: !0 });
      const Q = S();
      let j = s.join(O, Q);
      const H =
          I == null
            ? null
            : s.join(O, `package-${A}${s.extname(I.path) || ".7z"}`),
        q = async (G) => (
          await w.setDownloadedFile(j, H, R, _, Q, G),
          await y.done({ ...R, downloadedFile: j }),
          H == null ? [j] : [j, H]
        ),
        J = this._logger,
        Z = await w.validateDownloadedPath(j, R, _, J);
      if (Z != null) return (j = Z), await q(!1);
      const z = async () => (
          await w.clear().catch(() => {}),
          await (0, r.unlink)(j).catch(() => {})
        ),
        U = await (0, c.createTempUpdateFile)(`temp-${Q}`, O, J);
      try {
        await y.task(U, E, H, z), await (0, r.rename)(U, j);
      } catch (G) {
        throw (
          (await z(),
          G instanceof e.CancellationError &&
            (J.info("cancelled"), this.emit("update-cancelled", R)),
          G)
        );
      }
      return (
        J.info(`New version ${A} has been downloaded to ${j}`), await q(!0)
      );
    }
  };
  cs.AppUpdater = h;
  function m(v) {
    const y = (0, o.prerelease)(v);
    return y != null && y.length > 0;
  }
  class g {
    info(y) {}
    warn(y) {}
    error(y) {}
  }
  return (cs.NoOpLogger = g), cs;
}
var Uc = {},
  Fc = {},
  Xw;
function _p() {
  if (Xw) return Fc;
  (Xw = 1),
    Object.defineProperty(Fc, "__esModule", { value: !0 }),
    (Fc.BaseUpdater = void 0);
  const e = Ql,
    t = ty();
  let n = class extends t.AppUpdater {
    constructor(i, a) {
      super(i, a),
        (this.quitAndInstallCalled = !1),
        (this.quitHandlerAdded = !1);
    }
    quitAndInstall(i = !1, a = !1) {
      this._logger.info("Install on explicit quitAndInstall"),
        this.install(i, i ? a : this.autoRunAppAfterInstall)
          ? setImmediate(() => {
              xe.autoUpdater.emit("before-quit-for-update"), this.app.quit();
            })
          : (this.quitAndInstallCalled = !1);
    }
    executeDownload(i) {
      return super.executeDownload({
        ...i,
        done: (a) => (
          this.dispatchUpdateDownloaded(a),
          this.addQuitHandler(),
          Promise.resolve()
        ),
      });
    }
    install(i = !1, a = !1) {
      if (this.quitAndInstallCalled)
        return (
          this._logger.warn(
            "install call ignored: quitAndInstallCalled is set to true",
          ),
          !1
        );
      const s = this.downloadedUpdateHelper,
        o = s == null ? null : s.file,
        c = s == null ? null : s.downloadedFileInfo;
      if (o == null || c == null)
        return (
          this.dispatchError(
            new Error("No valid update available, can't quit and install"),
          ),
          !1
        );
      this.quitAndInstallCalled = !0;
      try {
        return (
          this._logger.info(`Install: isSilent: ${i}, isForceRunAfter: ${a}`),
          this.doInstall({
            installerPath: o,
            isSilent: i,
            isForceRunAfter: a,
            isAdminRightsRequired: c.isAdminRightsRequired,
          })
        );
      } catch (l) {
        return this.dispatchError(l), !1;
      }
    }
    addQuitHandler() {
      this.quitHandlerAdded ||
        !this.autoInstallOnAppQuit ||
        ((this.quitHandlerAdded = !0),
        this.app.onQuit((i) => {
          if (this.quitAndInstallCalled) {
            this._logger.info(
              "Update installer has already been triggered. Quitting application.",
            );
            return;
          }
          if (!this.autoInstallOnAppQuit) {
            this._logger.info(
              "Update will not be installed on quit because autoInstallOnAppQuit is set to false.",
            );
            return;
          }
          if (i !== 0) {
            this._logger.info(
              `Update will be not installed on quit because application is quitting with exit code ${i}`,
            );
            return;
          }
          this._logger.info("Auto install update on quit"),
            this.install(!0, !1);
        }));
    }
    wrapSudo() {
      const { name: i } = this.app,
        a = `"${i} would like to update"`,
        s = this.spawnSyncLog(
          "which gksudo || which kdesudo || which pkexec || which beesu",
        ),
        o = [s];
      return (
        /kdesudo/i.test(s)
          ? (o.push("--comment", a), o.push("-c"))
          : /gksudo/i.test(s)
          ? o.push("--message", a)
          : /pkexec/i.test(s) && o.push("--disable-internal-agent"),
        o.join(" ")
      );
    }
    spawnSyncLog(i, a = [], s = {}) {
      return (
        this._logger.info(`Executing: ${i} with args: ${a}`),
        (0, e.spawnSync)(i, a, {
          env: { ...process.env, ...s },
          encoding: "utf-8",
          shell: !0,
        }).stdout.trim()
      );
    }
    async spawnLog(i, a = [], s = void 0, o = "ignore") {
      return (
        this._logger.info(`Executing: ${i} with args: ${a}`),
        new Promise((c, l) => {
          try {
            const f = { stdio: o, env: s, detached: !0 },
              u = (0, e.spawn)(i, a, f);
            u.on("error", (d) => {
              l(d);
            }),
              u.unref(),
              u.pid !== void 0 && c(!0);
          } catch (f) {
            l(f);
          }
        })
      );
    }
  };
  return (Fc.BaseUpdater = n), Fc;
}
var su = {},
  ou = {},
  Us = {},
  Ep = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.computeOperations = e.OperationKind = void 0);
  var t;
  (function (o) {
    (o[(o.COPY = 0)] = "COPY"), (o[(o.DOWNLOAD = 1)] = "DOWNLOAD");
  })((t = e.OperationKind || (e.OperationKind = {})));
  function n(o, c, l) {
    const f = s(o.files),
      u = s(c.files);
    let d = null;
    const p = c.files[0],
      h = [],
      m = p.name,
      g = f.get(m);
    if (g == null) throw new Error(`no file ${m} in old blockmap`);
    const v = u.get(m);
    let y = 0;
    const { checksumToOffset: _, checksumToOldSize: E } = a(
      f.get(m),
      g.offset,
      l,
    );
    let R = p.offset;
    for (let A = 0; A < v.checksums.length; R += v.sizes[A], A++) {
      const I = v.sizes[A],
        S = v.checksums[A];
      let w = _.get(S);
      w != null &&
        E.get(S) !== I &&
        (l.warn(
          `Checksum ("${S}") matches, but size differs (old: ${E.get(
            S,
          )}, new: ${I})`,
        ),
        (w = void 0)),
        w === void 0
          ? (y++,
            d != null && d.kind === t.DOWNLOAD && d.end === R
              ? (d.end += I)
              : ((d = { kind: t.DOWNLOAD, start: R, end: R + I }),
                i(d, h, S, A)))
          : d != null && d.kind === t.COPY && d.end === w
          ? (d.end += I)
          : ((d = { kind: t.COPY, start: w, end: w + I }), i(d, h, S, A));
    }
    return (
      y > 0 &&
        l.info(
          `File${
            p.name === "file" ? "" : " " + p.name
          } has ${y} changed blocks`,
        ),
      h
    );
  }
  e.computeOperations = n;
  const r =
    process.env.DIFFERENTIAL_DOWNLOAD_PLAN_BUILDER_VALIDATE_RANGES === "true";
  function i(o, c, l, f) {
    if (r && c.length !== 0) {
      const u = c[c.length - 1];
      if (u.kind === o.kind && o.start < u.end && o.start > u.start) {
        const d = [u.start, u.end, o.start, o.end].reduce((p, h) =>
          p < h ? p : h,
        );
        throw new Error(`operation (block index: ${f}, checksum: ${l}, kind: ${
          t[o.kind]
        }) overlaps previous operation (checksum: ${l}):
abs: ${u.start} until ${u.end} and ${o.start} until ${o.end}
rel: ${u.start - d} until ${u.end - d} and ${o.start - d} until ${o.end - d}`);
      }
    }
    c.push(o);
  }
  function a(o, c, l) {
    const f = new Map(),
      u = new Map();
    let d = c;
    for (let p = 0; p < o.checksums.length; p++) {
      const h = o.checksums[p],
        m = o.sizes[p],
        g = u.get(h);
      if (g === void 0) f.set(h, d), u.set(h, m);
      else if (l.debug != null) {
        const v = g === m ? "(same size)" : `(size: ${g}, this size: ${m})`;
        l.debug(
          `${h} duplicated in blockmap ${v}, it doesn't lead to broken differential downloader, just corresponding block will be skipped)`,
        );
      }
      d += m;
    }
    return { checksumToOffset: f, checksumToOldSize: u };
  }
  function s(o) {
    const c = new Map();
    for (const l of o) c.set(l.name, l);
    return c;
  }
})(Ep);
Object.defineProperty(Us, "__esModule", { value: !0 });
Us.DataSplitter = Us.copyData = void 0;
const df = Ln(),
  OH = Xt,
  PH = Kr,
  DH = Ep,
  Jw = Buffer.from(`\r
\r
`);
var Ca;
(function (e) {
  (e[(e.INIT = 0)] = "INIT"),
    (e[(e.HEADER = 1)] = "HEADER"),
    (e[(e.BODY = 2)] = "BODY");
})(Ca || (Ca = {}));
function XC(e, t, n, r, i) {
  const a = (0, OH.createReadStream)("", {
    fd: n,
    autoClose: !1,
    start: e.start,
    end: e.end - 1,
  });
  a.on("error", r), a.once("end", i), a.pipe(t, { end: !1 });
}
Us.copyData = XC;
class LH extends PH.Writable {
  constructor(t, n, r, i, a, s) {
    super(),
      (this.out = t),
      (this.options = n),
      (this.partIndexToTaskIndex = r),
      (this.partIndexToLength = a),
      (this.finishHandler = s),
      (this.partIndex = -1),
      (this.headerListBuffer = null),
      (this.readState = Ca.INIT),
      (this.ignoreByteCount = 0),
      (this.remainingPartDataCount = 0),
      (this.actualPartLength = 0),
      (this.boundaryLength = i.length + 4),
      (this.ignoreByteCount = this.boundaryLength - 2);
  }
  get isFinished() {
    return this.partIndex === this.partIndexToLength.length;
  }
  _write(t, n, r) {
    if (this.isFinished) {
      console.error(`Trailing ignored data: ${t.length} bytes`);
      return;
    }
    this.handleData(t).then(r).catch(r);
  }
  async handleData(t) {
    let n = 0;
    if (this.ignoreByteCount !== 0 && this.remainingPartDataCount !== 0)
      throw (0, df.newError)(
        "Internal error",
        "ERR_DATA_SPLITTER_BYTE_COUNT_MISMATCH",
      );
    if (this.ignoreByteCount > 0) {
      const r = Math.min(this.ignoreByteCount, t.length);
      (this.ignoreByteCount -= r), (n = r);
    } else if (this.remainingPartDataCount > 0) {
      const r = Math.min(this.remainingPartDataCount, t.length);
      (this.remainingPartDataCount -= r),
        await this.processPartData(t, 0, r),
        (n = r);
    }
    if (n !== t.length) {
      if (this.readState === Ca.HEADER) {
        const r = this.searchHeaderListEnd(t, n);
        if (r === -1) return;
        (n = r), (this.readState = Ca.BODY), (this.headerListBuffer = null);
      }
      for (;;) {
        if (this.readState === Ca.BODY) this.readState = Ca.INIT;
        else {
          this.partIndex++;
          let s = this.partIndexToTaskIndex.get(this.partIndex);
          if (s == null)
            if (this.isFinished) s = this.options.end;
            else
              throw (0, df.newError)(
                "taskIndex is null",
                "ERR_DATA_SPLITTER_TASK_INDEX_IS_NULL",
              );
          const o =
            this.partIndex === 0
              ? this.options.start
              : this.partIndexToTaskIndex.get(this.partIndex - 1) + 1;
          if (o < s) await this.copyExistingData(o, s);
          else if (o > s)
            throw (0, df.newError)(
              "prevTaskIndex must be < taskIndex",
              "ERR_DATA_SPLITTER_TASK_INDEX_ASSERT_FAILED",
            );
          if (this.isFinished) {
            this.onPartEnd(), this.finishHandler();
            return;
          }
          if (((n = this.searchHeaderListEnd(t, n)), n === -1)) {
            this.readState = Ca.HEADER;
            return;
          }
        }
        const r = this.partIndexToLength[this.partIndex],
          i = n + r,
          a = Math.min(i, t.length);
        if (
          (await this.processPartStarted(t, n, a),
          (this.remainingPartDataCount = r - (a - n)),
          this.remainingPartDataCount > 0)
        )
          return;
        if (((n = i + this.boundaryLength), n >= t.length)) {
          this.ignoreByteCount = this.boundaryLength - (t.length - i);
          return;
        }
      }
    }
  }
  copyExistingData(t, n) {
    return new Promise((r, i) => {
      const a = () => {
        if (t === n) {
          r();
          return;
        }
        const s = this.options.tasks[t];
        if (s.kind !== DH.OperationKind.COPY) {
          i(new Error("Task kind must be COPY"));
          return;
        }
        XC(s, this.out, this.options.oldFileFd, i, () => {
          t++, a();
        });
      };
      a();
    });
  }
  searchHeaderListEnd(t, n) {
    const r = t.indexOf(Jw, n);
    if (r !== -1) return r + Jw.length;
    const i = n === 0 ? t : t.slice(n);
    return (
      this.headerListBuffer == null
        ? (this.headerListBuffer = i)
        : (this.headerListBuffer = Buffer.concat([this.headerListBuffer, i])),
      -1
    );
  }
  onPartEnd() {
    const t = this.partIndexToLength[this.partIndex - 1];
    if (this.actualPartLength !== t)
      throw (0, df.newError)(
        `Expected length: ${t} differs from actual: ${this.actualPartLength}`,
        "ERR_DATA_SPLITTER_LENGTH_MISMATCH",
      );
    this.actualPartLength = 0;
  }
  processPartStarted(t, n, r) {
    return (
      this.partIndex !== 0 && this.onPartEnd(), this.processPartData(t, n, r)
    );
  }
  processPartData(t, n, r) {
    this.actualPartLength += r - n;
    const i = this.out;
    return i.write(n === 0 && t.length === r ? t : t.slice(n, r))
      ? Promise.resolve()
      : new Promise((a, s) => {
          i.on("error", s),
            i.once("drain", () => {
              i.removeListener("error", s), a();
            });
        });
  }
}
Us.DataSplitter = LH;
var nc = {};
Object.defineProperty(nc, "__esModule", { value: !0 });
nc.checkIsRangesSupported = nc.executeTasksUsingMultipleRangeRequests = void 0;
const h0 = Ln(),
  Zw = Us,
  ex = Ep;
function BH(e, t, n, r, i) {
  const a = (s) => {
    if (s >= t.length) {
      e.fileMetadataBuffer != null && n.write(e.fileMetadataBuffer), n.end();
      return;
    }
    const o = s + 1e3;
    UH(
      e,
      { tasks: t, start: s, end: Math.min(t.length, o), oldFileFd: r },
      n,
      () => a(o),
      i,
    );
  };
  return a;
}
nc.executeTasksUsingMultipleRangeRequests = BH;
function UH(e, t, n, r, i) {
  let a = "bytes=",
    s = 0;
  const o = new Map(),
    c = [];
  for (let u = t.start; u < t.end; u++) {
    const d = t.tasks[u];
    d.kind === ex.OperationKind.DOWNLOAD &&
      ((a += `${d.start}-${d.end - 1}, `),
      o.set(s, u),
      s++,
      c.push(d.end - d.start));
  }
  if (s <= 1) {
    const u = (d) => {
      if (d >= t.end) {
        r();
        return;
      }
      const p = t.tasks[d++];
      if (p.kind === ex.OperationKind.COPY)
        (0, Zw.copyData)(p, n, t.oldFileFd, i, () => u(d));
      else {
        const h = e.createRequestOptions();
        h.headers.Range = `bytes=${p.start}-${p.end - 1}`;
        const m = e.httpExecutor.createRequest(h, (g) => {
          m0(g, i) && (g.pipe(n, { end: !1 }), g.once("end", () => u(d)));
        });
        e.httpExecutor.addErrorAndTimeoutHandlers(m, i), m.end();
      }
    };
    u(t.start);
    return;
  }
  const l = e.createRequestOptions();
  l.headers.Range = a.substring(0, a.length - 2);
  const f = e.httpExecutor.createRequest(l, (u) => {
    if (!m0(u, i)) return;
    const d = (0, h0.safeGetHeader)(u, "content-type"),
      p = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(d);
    if (p == null) {
      i(
        new Error(
          `Content-Type "multipart/byteranges" is expected, but got "${d}"`,
        ),
      );
      return;
    }
    const h = new Zw.DataSplitter(n, t, o, p[1] || p[2], c, r);
    h.on("error", i),
      u.pipe(h),
      u.on("end", () => {
        setTimeout(() => {
          f.abort(), i(new Error("Response ends without calling any handlers"));
        }, 1e4);
      });
  });
  e.httpExecutor.addErrorAndTimeoutHandlers(f, i), f.end();
}
function m0(e, t) {
  if (e.statusCode >= 400) return t((0, h0.createHttpError)(e)), !1;
  if (e.statusCode !== 206) {
    const n = (0, h0.safeGetHeader)(e, "accept-ranges");
    if (n == null || n === "none")
      return (
        t(
          new Error(
            `Server doesn't support Accept-Ranges (response code ${e.statusCode})`,
          ),
        ),
        !1
      );
  }
  return !0;
}
nc.checkIsRangesSupported = m0;
var wp = {};
Object.defineProperty(wp, "__esModule", { value: !0 });
wp.ProgressDifferentialDownloadCallbackTransform = void 0;
const FH = Kr;
var Ro;
(function (e) {
  (e[(e.COPY = 0)] = "COPY"), (e[(e.DOWNLOAD = 1)] = "DOWNLOAD");
})(Ro || (Ro = {}));
class jH extends FH.Transform {
  constructor(t, n, r) {
    super(),
      (this.progressDifferentialDownloadInfo = t),
      (this.cancellationToken = n),
      (this.onProgress = r),
      (this.start = Date.now()),
      (this.transferred = 0),
      (this.delta = 0),
      (this.expectedBytes = 0),
      (this.index = 0),
      (this.operationType = Ro.COPY),
      (this.nextUpdate = this.start + 1e3);
  }
  _transform(t, n, r) {
    if (this.cancellationToken.cancelled) {
      r(new Error("cancelled"), null);
      return;
    }
    if (this.operationType == Ro.COPY) {
      r(null, t);
      return;
    }
    (this.transferred += t.length), (this.delta += t.length);
    const i = Date.now();
    i >= this.nextUpdate &&
      this.transferred !== this.expectedBytes &&
      this.transferred !== this.progressDifferentialDownloadInfo.grandTotal &&
      ((this.nextUpdate = i + 1e3),
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent:
          (this.transferred /
            this.progressDifferentialDownloadInfo.grandTotal) *
          100,
        bytesPerSecond: Math.round(this.transferred / ((i - this.start) / 1e3)),
      }),
      (this.delta = 0)),
      r(null, t);
  }
  beginFileCopy() {
    this.operationType = Ro.COPY;
  }
  beginRangeDownload() {
    (this.operationType = Ro.DOWNLOAD),
      (this.expectedBytes +=
        this.progressDifferentialDownloadInfo.expectedByteCounts[this.index++]);
  }
  endRangeDownload() {
    this.transferred !== this.progressDifferentialDownloadInfo.grandTotal &&
      this.onProgress({
        total: this.progressDifferentialDownloadInfo.grandTotal,
        delta: this.delta,
        transferred: this.transferred,
        percent:
          (this.transferred /
            this.progressDifferentialDownloadInfo.grandTotal) *
          100,
        bytesPerSecond: Math.round(
          this.transferred / ((Date.now() - this.start) / 1e3),
        ),
      });
  }
  _flush(t) {
    if (this.cancellationToken.cancelled) {
      t(new Error("cancelled"));
      return;
    }
    this.onProgress({
      total: this.progressDifferentialDownloadInfo.grandTotal,
      delta: this.delta,
      transferred: this.transferred,
      percent: 100,
      bytesPerSecond: Math.round(
        this.transferred / ((Date.now() - this.start) / 1e3),
      ),
    }),
      (this.delta = 0),
      (this.transferred = 0),
      t(null);
  }
}
wp.ProgressDifferentialDownloadCallbackTransform = jH;
Object.defineProperty(ou, "__esModule", { value: !0 });
ou.DifferentialDownloader = void 0;
const jc = Ln(),
  Im = Za,
  MH = Xt,
  HH = Us,
  qH = Ya,
  pf = Ep,
  tx = nc,
  GH = wp;
class QH {
  constructor(t, n, r) {
    (this.blockAwareFileInfo = t),
      (this.httpExecutor = n),
      (this.options = r),
      (this.fileMetadataBuffer = null),
      (this.logger = r.logger);
  }
  createRequestOptions() {
    const t = { headers: { ...this.options.requestHeaders, accept: "*/*" } };
    return (
      (0, jc.configureRequestUrl)(this.options.newUrl, t),
      (0, jc.configureRequestOptions)(t),
      t
    );
  }
  doDownload(t, n) {
    if (t.version !== n.version)
      throw new Error(
        `version is different (${t.version} - ${n.version}), full download is required`,
      );
    const r = this.logger,
      i = (0, pf.computeOperations)(t, n, r);
    r.debug != null && r.debug(JSON.stringify(i, null, 2));
    let a = 0,
      s = 0;
    for (const c of i) {
      const l = c.end - c.start;
      c.kind === pf.OperationKind.DOWNLOAD ? (a += l) : (s += l);
    }
    const o = this.blockAwareFileInfo.size;
    if (
      a +
        s +
        (this.fileMetadataBuffer == null
          ? 0
          : this.fileMetadataBuffer.length) !==
      o
    )
      throw new Error(
        `Internal error, size mismatch: downloadSize: ${a}, copySize: ${s}, newSize: ${o}`,
      );
    return (
      r.info(
        `Full: ${nx(o)}, To download: ${nx(a)} (${Math.round(a / (o / 100))}%)`,
      ),
      this.downloadFile(i)
    );
  }
  downloadFile(t) {
    const n = [],
      r = () =>
        Promise.all(
          n.map((i) =>
            (0, Im.close)(i.descriptor).catch((a) => {
              this.logger.error(`cannot close file "${i.path}": ${a}`);
            }),
          ),
        );
    return this.doDownloadFile(t, n)
      .then(r)
      .catch((i) =>
        r()
          .catch((a) => {
            try {
              this.logger.error(`cannot close files: ${a}`);
            } catch (s) {
              try {
                console.error(s);
              } catch {}
            }
            throw i;
          })
          .then(() => {
            throw i;
          }),
      );
  }
  async doDownloadFile(t, n) {
    const r = await (0, Im.open)(this.options.oldFile, "r");
    n.push({ descriptor: r, path: this.options.oldFile });
    const i = await (0, Im.open)(this.options.newFile, "w");
    n.push({ descriptor: i, path: this.options.newFile });
    const a = (0, MH.createWriteStream)(this.options.newFile, { fd: i });
    await new Promise((s, o) => {
      const c = [];
      let l;
      if (!this.options.isUseMultipleRangeRequest && this.options.onProgress) {
        const v = [];
        let y = 0;
        for (const E of t)
          E.kind === pf.OperationKind.DOWNLOAD &&
            (v.push(E.end - E.start), (y += E.end - E.start));
        const _ = { expectedByteCounts: v, grandTotal: y };
        (l = new GH.ProgressDifferentialDownloadCallbackTransform(
          _,
          this.options.cancellationToken,
          this.options.onProgress,
        )),
          c.push(l);
      }
      const f = new jc.DigestTransform(this.blockAwareFileInfo.sha512);
      (f.isValidateOnEnd = !1),
        c.push(f),
        a.on("finish", () => {
          a.close(() => {
            n.splice(1, 1);
            try {
              f.validate();
            } catch (v) {
              o(v);
              return;
            }
            s(void 0);
          });
        }),
        c.push(a);
      let u = null;
      for (const v of c)
        v.on("error", o), u == null ? (u = v) : (u = u.pipe(v));
      const d = c[0];
      let p;
      if (this.options.isUseMultipleRangeRequest) {
        (p = (0, tx.executeTasksUsingMultipleRangeRequests)(this, t, d, r, o)),
          p(0);
        return;
      }
      let h = 0,
        m = null;
      this.logger.info(`Differential download: ${this.options.newUrl}`);
      const g = this.createRequestOptions();
      (g.redirect = "manual"),
        (p = (v) => {
          var y, _;
          if (v >= t.length) {
            this.fileMetadataBuffer != null && d.write(this.fileMetadataBuffer),
              d.end();
            return;
          }
          const E = t[v++];
          if (E.kind === pf.OperationKind.COPY) {
            l && l.beginFileCopy(), (0, HH.copyData)(E, d, r, o, () => p(v));
            return;
          }
          const R = `bytes=${E.start}-${E.end - 1}`;
          (g.headers.range = R),
            (_ =
              (y = this.logger) === null || y === void 0 ? void 0 : y.debug) ===
              null ||
              _ === void 0 ||
              _.call(y, `download range: ${R}`),
            l && l.beginRangeDownload();
          const A = this.httpExecutor.createRequest(g, (I) => {
            I.on("error", o),
              I.on("abort", () => {
                o(new Error("response has been aborted by the server"));
              }),
              I.statusCode >= 400 && o((0, jc.createHttpError)(I)),
              I.pipe(d, { end: !1 }),
              I.once("end", () => {
                l && l.endRangeDownload(),
                  ++h === 100 ? ((h = 0), setTimeout(() => p(v), 1e3)) : p(v);
              });
          });
          A.on("redirect", (I, S, w) => {
            this.logger.info(`Redirect to ${WH(w)}`),
              (m = w),
              (0, jc.configureRequestUrl)(new qH.URL(m), g),
              A.followRedirect();
          }),
            this.httpExecutor.addErrorAndTimeoutHandlers(A, o),
            A.end();
        }),
        p(0);
    });
  }
  async readRemoteBytes(t, n) {
    const r = Buffer.allocUnsafe(n + 1 - t),
      i = this.createRequestOptions();
    i.headers.range = `bytes=${t}-${n}`;
    let a = 0;
    if (
      (await this.request(i, (s) => {
        s.copy(r, a), (a += s.length);
      }),
      a !== r.length)
    )
      throw new Error(
        `Received data length ${a} is not equal to expected ${r.length}`,
      );
    return r;
  }
  request(t, n) {
    return new Promise((r, i) => {
      const a = this.httpExecutor.createRequest(t, (s) => {
        (0, tx.checkIsRangesSupported)(s, i) &&
          (s.on("data", n), s.on("end", () => r()));
      });
      this.httpExecutor.addErrorAndTimeoutHandlers(a, i), a.end();
    });
  }
}
ou.DifferentialDownloader = QH;
function nx(e, t = " KB") {
  return new Intl.NumberFormat("en").format((e / 1024).toFixed(2)) + t;
}
function WH(e) {
  const t = e.indexOf("?");
  return t < 0 ? e : e.substring(0, t);
}
Object.defineProperty(su, "__esModule", { value: !0 });
su.FileWithEmbeddedBlockMapDifferentialDownloader = void 0;
const lo = Za,
  zH = ou,
  KH = mc;
class VH extends zH.DifferentialDownloader {
  async download() {
    const t = this.blockAwareFileInfo,
      n = t.size,
      r = n - (t.blockMapSize + 4);
    this.fileMetadataBuffer = await this.readRemoteBytes(r, n - 1);
    const i = JC(
      this.fileMetadataBuffer.slice(0, this.fileMetadataBuffer.length - 4),
    );
    await this.doDownload(await YH(this.options.oldFile), i);
  }
}
su.FileWithEmbeddedBlockMapDifferentialDownloader = VH;
function JC(e) {
  return JSON.parse((0, KH.inflateRawSync)(e).toString());
}
async function YH(e) {
  const t = await (0, lo.open)(e, "r");
  try {
    const n = (await (0, lo.fstat)(t)).size,
      r = Buffer.allocUnsafe(4);
    await (0, lo.read)(t, r, 0, r.length, n - r.length);
    const i = Buffer.allocUnsafe(r.readUInt32BE(0));
    return (
      await (0, lo.read)(t, i, 0, i.length, n - r.length - i.length),
      await (0, lo.close)(t),
      JC(i)
    );
  } catch (n) {
    throw (await (0, lo.close)(t), n);
  }
}
var rx;
function ix() {
  if (rx) return Uc;
  (rx = 1),
    Object.defineProperty(Uc, "__esModule", { value: !0 }),
    (Uc.AppImageUpdater = void 0);
  const e = Ln(),
    t = Ql,
    n = Za,
    r = Xt,
    i = pt,
    a = _p(),
    s = su,
    o = xc(),
    c = In;
  let l = class extends a.BaseUpdater {
    constructor(u, d) {
      super(u, d);
    }
    isUpdaterActive() {
      return process.env.APPIMAGE == null
        ? (process.env.SNAP == null
            ? this._logger.warn(
                "APPIMAGE env is not defined, current application is not an AppImage",
              )
            : this._logger.info("SNAP env is defined, updater is disabled"),
          !1)
        : super.isUpdaterActive();
    }
    doDownloadUpdate(u) {
      const d = u.updateInfoAndProvider.provider,
        p = (0, c.findFile)(
          d.resolveFiles(u.updateInfoAndProvider.info),
          "AppImage",
          ["rpm", "deb"],
        );
      return this.executeDownload({
        fileExtension: "AppImage",
        fileInfo: p,
        downloadUpdateOptions: u,
        task: async (h, m) => {
          const g = process.env.APPIMAGE;
          if (g == null)
            throw (0, e.newError)(
              "APPIMAGE env is not defined",
              "ERR_UPDATER_OLD_FILE_NOT_FOUND",
            );
          let v = !1;
          try {
            const y = {
              newUrl: p.url,
              oldFile: g,
              logger: this._logger,
              newFile: h,
              isUseMultipleRangeRequest: d.isUseMultipleRangeRequest,
              requestHeaders: u.requestHeaders,
              cancellationToken: u.cancellationToken,
            };
            this.listenerCount(o.DOWNLOAD_PROGRESS) > 0 &&
              (y.onProgress = (_) => this.emit(o.DOWNLOAD_PROGRESS, _)),
              await new s.FileWithEmbeddedBlockMapDifferentialDownloader(
                p.info,
                this.httpExecutor,
                y,
              ).download();
          } catch (y) {
            this._logger.error(
              `Cannot download differentially, fallback to full download: ${
                y.stack || y
              }`,
            ),
              (v = process.platform === "linux");
          }
          v && (await this.httpExecutor.download(p.url, h, m)),
            await (0, n.chmod)(h, 493);
        },
      });
    }
    doInstall(u) {
      const d = process.env.APPIMAGE;
      if (d == null)
        throw (0, e.newError)(
          "APPIMAGE env is not defined",
          "ERR_UPDATER_OLD_FILE_NOT_FOUND",
        );
      (0, r.unlinkSync)(d);
      let p;
      const h = i.basename(d);
      i.basename(u.installerPath) === h || !/\d+\.\d+\.\d+/.test(h)
        ? (p = d)
        : (p = i.join(i.dirname(d), i.basename(u.installerPath))),
        (0, t.execFileSync)("mv", ["-f", u.installerPath, p]),
        p !== d && this.emit("appimage-filename-updated", p);
      const m = { ...process.env, APPIMAGE_SILENT_INSTALL: "true" };
      return (
        u.isForceRunAfter
          ? this.spawnLog(p, [], m)
          : ((m.APPIMAGE_EXIT_AFTER_INSTALL = "true"),
            (0, t.execFileSync)(p, [], { env: m })),
        !0
      );
    }
  };
  return (Uc.AppImageUpdater = l), Uc;
}
var Mc = {},
  ax;
function sx() {
  if (ax) return Mc;
  (ax = 1),
    Object.defineProperty(Mc, "__esModule", { value: !0 }),
    (Mc.DebUpdater = void 0);
  const e = _p(),
    t = xc(),
    n = In;
  let r = class extends e.BaseUpdater {
    constructor(a, s) {
      super(a, s);
    }
    doDownloadUpdate(a) {
      const s = a.updateInfoAndProvider.provider,
        o = (0, n.findFile)(
          s.resolveFiles(a.updateInfoAndProvider.info),
          "deb",
          ["AppImage", "rpm"],
        );
      return this.executeDownload({
        fileExtension: "deb",
        fileInfo: o,
        downloadUpdateOptions: a,
        task: async (c, l) => {
          this.listenerCount(t.DOWNLOAD_PROGRESS) > 0 &&
            (l.onProgress = (f) => this.emit(t.DOWNLOAD_PROGRESS, f)),
            await this.httpExecutor.download(o.url, c, l);
        },
      });
    }
    doInstall(a) {
      const s = this.wrapSudo(),
        o = /pkexec/i.test(s) ? "" : '"',
        c = [
          "dpkg",
          "-i",
          a.installerPath,
          "||",
          "apt-get",
          "install",
          "-f",
          "-y",
        ];
      return (
        this.spawnSyncLog(s, [`${o}/bin/bash`, "-c", `'${c.join(" ")}'${o}`]),
        a.isForceRunAfter && this.app.relaunch(),
        !0
      );
    }
  };
  return (Mc.DebUpdater = r), Mc;
}
var Hc = {},
  ox;
function cx() {
  if (ox) return Hc;
  (ox = 1),
    Object.defineProperty(Hc, "__esModule", { value: !0 }),
    (Hc.RpmUpdater = void 0);
  const e = _p(),
    t = xc(),
    n = In;
  let r = class extends e.BaseUpdater {
    constructor(a, s) {
      super(a, s);
    }
    doDownloadUpdate(a) {
      const s = a.updateInfoAndProvider.provider,
        o = (0, n.findFile)(
          s.resolveFiles(a.updateInfoAndProvider.info),
          "rpm",
          ["AppImage", "deb"],
        );
      return this.executeDownload({
        fileExtension: "rpm",
        fileInfo: o,
        downloadUpdateOptions: a,
        task: async (c, l) => {
          this.listenerCount(t.DOWNLOAD_PROGRESS) > 0 &&
            (l.onProgress = (f) => this.emit(t.DOWNLOAD_PROGRESS, f)),
            await this.httpExecutor.download(o.url, c, l);
        },
      });
    }
    doInstall(a) {
      const s = a.installerPath,
        o = this.wrapSudo(),
        c = /pkexec/i.test(o) ? "" : '"',
        l = this.spawnSyncLog("which zypper");
      let f;
      if (l)
        f = [
          l,
          "remove",
          "-y",
          `'${this.app.name}'`,
          ";",
          l,
          "clean",
          "--all",
          ";",
          l,
          "--no-refresh",
          "install",
          "--allow-unsigned-rpm",
          "-y",
          "-f",
          s,
        ];
      else {
        const u = this.spawnSyncLog("which dnf || which yum");
        f = [
          u,
          "-y",
          "remove",
          `'${this.app.name}'`,
          ";",
          u,
          "-y",
          "install",
          s,
        ];
      }
      return (
        this.spawnSyncLog(o, [`${c}/bin/bash`, "-c", `'${f.join(" ")}'${c}`]),
        a.isForceRunAfter && this.app.relaunch(),
        !0
      );
    }
  };
  return (Hc.RpmUpdater = r), Hc;
}
var qc = {},
  lx;
function ux() {
  if (lx) return qc;
  (lx = 1),
    Object.defineProperty(qc, "__esModule", { value: !0 }),
    (qc.MacUpdater = void 0);
  const e = Ln(),
    t = Za,
    n = Xt,
    r = Ws,
    i = ty(),
    a = In,
    s = Ql,
    o = pr;
  let c = class extends i.AppUpdater {
    constructor(f, u) {
      super(f, u),
        (this.nativeUpdater = xe.autoUpdater),
        (this.squirrelDownloadedUpdate = !1),
        this.nativeUpdater.on("error", (d) => {
          this._logger.warn(d), this.emit("error", d);
        }),
        this.nativeUpdater.on("update-downloaded", () => {
          this.squirrelDownloadedUpdate = !0;
        });
    }
    debug(f) {
      this._logger.debug != null && this._logger.debug(f);
    }
    async doDownloadUpdate(f) {
      let u = f.updateInfoAndProvider.provider.resolveFiles(
        f.updateInfoAndProvider.info,
      );
      const d = this._logger,
        p = "sysctl.proc_translated";
      let h = !1;
      try {
        this.debug("Checking for macOS Rosetta environment"),
          (h = (0, s.execFileSync)("sysctl", [p], {
            encoding: "utf8",
          }).includes(`${p}: 1`)),
          d.info(`Checked for macOS Rosetta environment (isRosetta=${h})`);
      } catch (y) {
        d.warn(
          `sysctl shell command to check for macOS Rosetta environment failed: ${y}`,
        );
      }
      let m = !1;
      try {
        this.debug("Checking for arm64 in uname");
        const _ = (0, s.execFileSync)("uname", ["-a"], {
          encoding: "utf8",
        }).includes("ARM");
        d.info(`Checked 'uname -a': arm64=${_}`), (m = m || _);
      } catch (y) {
        d.warn(`uname shell command to check for arm64 failed: ${y}`);
      }
      m = m || process.arch === "arm64" || h;
      const g = (y) => {
        var _;
        return (
          y.url.pathname.includes("arm64") ||
          ((_ = y.info.url) === null || _ === void 0
            ? void 0
            : _.includes("arm64"))
        );
      };
      m && u.some(g)
        ? (u = u.filter((y) => m === g(y)))
        : (u = u.filter((y) => !g(y)));
      const v = (0, a.findFile)(u, "zip", ["pkg", "dmg"]);
      if (v == null)
        throw (0, e.newError)(
          `ZIP file not provided: ${(0, e.safeStringifyJson)(u)}`,
          "ERR_UPDATER_ZIP_FILE_NOT_FOUND",
        );
      return this.executeDownload({
        fileExtension: "zip",
        fileInfo: v,
        downloadUpdateOptions: f,
        task: (y, _) => this.httpExecutor.download(v.url, y, _),
        done: (y) => this.updateDownloaded(v, y),
      });
    }
    async updateDownloaded(f, u) {
      var d, p;
      const h = u.downloadedFile,
        m =
          (d = f.info.size) !== null && d !== void 0
            ? d
            : (await (0, t.stat)(h)).size,
        g = this._logger,
        v = `fileToProxy=${f.url.href}`;
      this.debug(`Creating proxy server for native Squirrel.Mac (${v})`),
        (p = this.server) === null || p === void 0 || p.close(),
        (this.server = (0, r.createServer)()),
        this.debug(`Proxy server for native Squirrel.Mac is created (${v})`),
        this.server.on("close", () => {
          g.info(`Proxy server for native Squirrel.Mac is closed (${v})`);
        });
      const y = (_) => {
        const E = _.address();
        return typeof E == "string"
          ? E
          : `http://127.0.0.1:${E == null ? void 0 : E.port}`;
      };
      return await new Promise((_, E) => {
        const R = (0, o.randomBytes)(64)
            .toString("base64")
            .replace(/\//g, "_")
            .replace(/\+/g, "-"),
          A = Buffer.from(`autoupdater:${R}`, "ascii"),
          I = `/${(0, o.randomBytes)(64).toString("hex")}.zip`;
        this.server.on("request", (S, w) => {
          const O = S.url;
          if ((g.info(`${O} requested`), O === "/")) {
            if (
              !S.headers.authorization ||
              S.headers.authorization.indexOf("Basic ") === -1
            ) {
              (w.statusCode = 401),
                (w.statusMessage = "Invalid Authentication Credentials"),
                w.end(),
                g.warn("No authenthication info");
              return;
            }
            const H = S.headers.authorization.split(" ")[1],
              q = Buffer.from(H, "base64").toString("ascii"),
              [J, Z] = q.split(":");
            if (J !== "autoupdater" || Z !== R) {
              (w.statusCode = 401),
                (w.statusMessage = "Invalid Authentication Credentials"),
                w.end(),
                g.warn("Invalid authenthication credentials");
              return;
            }
            const z = Buffer.from(`{ "url": "${y(this.server)}${I}" }`);
            w.writeHead(200, {
              "Content-Type": "application/json",
              "Content-Length": z.length,
            }),
              w.end(z);
            return;
          }
          if (!O.startsWith(I)) {
            g.warn(`${O} requested, but not supported`),
              w.writeHead(404),
              w.end();
            return;
          }
          g.info(`${I} requested by Squirrel.Mac, pipe ${h}`);
          let Q = !1;
          w.on("finish", () => {
            Q || (this.nativeUpdater.removeListener("error", E), _([]));
          });
          const j = (0, n.createReadStream)(h);
          j.on("error", (H) => {
            try {
              w.end();
            } catch (q) {
              g.warn(`cannot end response: ${q}`);
            }
            (Q = !0),
              this.nativeUpdater.removeListener("error", E),
              E(new Error(`Cannot pipe "${h}": ${H}`));
          }),
            w.writeHead(200, {
              "Content-Type": "application/zip",
              "Content-Length": m,
            }),
            j.pipe(w);
        }),
          this.debug(
            `Proxy server for native Squirrel.Mac is starting to listen (${v})`,
          ),
          this.server.listen(0, "127.0.0.1", () => {
            this.debug(
              `Proxy server for native Squirrel.Mac is listening (address=${y(
                this.server,
              )}, ${v})`,
            ),
              this.nativeUpdater.setFeedURL({
                url: y(this.server),
                headers: {
                  "Cache-Control": "no-cache",
                  Authorization: `Basic ${A.toString("base64")}`,
                },
              }),
              this.dispatchUpdateDownloaded(u),
              this.autoInstallOnAppQuit
                ? (this.nativeUpdater.once("error", E),
                  this.nativeUpdater.checkForUpdates())
                : _([]);
          });
      });
    }
    quitAndInstall() {
      var f;
      this.squirrelDownloadedUpdate
        ? (this.nativeUpdater.quitAndInstall(),
          (f = this.server) === null || f === void 0 || f.close())
        : (this.nativeUpdater.on("update-downloaded", () => {
            var u;
            this.nativeUpdater.quitAndInstall(),
              (u = this.server) === null || u === void 0 || u.close();
          }),
          this.autoInstallOnAppQuit || this.nativeUpdater.checkForUpdates());
    }
  };
  return (qc.MacUpdater = c), qc;
}
var Gc = {},
  xp = {};
Object.defineProperty(xp, "__esModule", { value: !0 });
xp.GenericDifferentialDownloader = void 0;
const XH = ou;
class JH extends XH.DifferentialDownloader {
  download(t, n) {
    return this.doDownload(t, n);
  }
}
xp.GenericDifferentialDownloader = JH;
var Ap = {};
Object.defineProperty(Ap, "__esModule", { value: !0 });
Ap.verifySignature = void 0;
const fx = Ln(),
  ZC = Ql,
  ZH = Fr;
function eq(e, t, n) {
  return new Promise((r, i) => {
    const a = t.replace(/'/g, "''");
    (0, ZC.execFile)(
      "chcp 65001 >NUL & powershell.exe",
      [
        "-NoProfile",
        "-NonInteractive",
        "-InputFormat",
        "None",
        "-Command",
        `"Get-AuthenticodeSignature -LiteralPath '${a}' | ConvertTo-Json -Compress"`,
      ],
      { shell: !0, timeout: 20 * 1e3 },
      (s, o, c) => {
        try {
          if (s != null || c) {
            dx(n, s, c, i), r(null);
            return;
          }
          const l = tq(o);
          if (l.Status === 0) {
            const u = (0, fx.parseDn)(l.SignerCertificate.Subject);
            let d = !1;
            for (const p of e) {
              const h = (0, fx.parseDn)(p);
              if (
                (h.size
                  ? (d = Array.from(h.keys()).every(
                      (g) => h.get(g) === u.get(g),
                    ))
                  : p === u.get("CN") &&
                    (n.warn(
                      `Signature validated using only CN ${p}. Please add your full Distinguished Name (DN) to publisherNames configuration`,
                    ),
                    (d = !0)),
                d)
              ) {
                r(null);
                return;
              }
            }
          }
          const f =
            `publisherNames: ${e.join(" | ")}, raw info: ` +
            JSON.stringify(l, (u, d) => (u === "RawData" ? void 0 : d), 2);
          n.warn(
            `Sign verification failed, installer signed with incorrect certificate: ${f}`,
          ),
            r(f);
        } catch (l) {
          dx(n, l, null, i), r(null);
          return;
        }
      },
    );
  });
}
Ap.verifySignature = eq;
function tq(e) {
  const t = JSON.parse(e);
  delete t.PrivateKey, delete t.IsOSBinary, delete t.SignatureType;
  const n = t.SignerCertificate;
  return (
    n != null &&
      (delete n.Archived,
      delete n.Extensions,
      delete n.Handle,
      delete n.HasPrivateKey,
      delete n.SubjectName),
    delete t.Path,
    t
  );
}
function dx(e, t, n, r) {
  if (nq()) {
    e.warn(
      `Cannot execute Get-AuthenticodeSignature: ${
        t || n
      }. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`,
    );
    return;
  }
  try {
    (0, ZC.execFileSync)(
      "powershell.exe",
      ["-NoProfile", "-NonInteractive", "-Command", "ConvertTo-Json test"],
      { timeout: 10 * 1e3 },
    );
  } catch (i) {
    e.warn(
      `Cannot execute ConvertTo-Json: ${i.message}. Ignoring signature validation due to unsupported powershell version. Please upgrade to powershell 3 or higher.`,
    );
    return;
  }
  t != null && r(t),
    n &&
      r(
        new Error(
          `Cannot execute Get-AuthenticodeSignature, stderr: ${n}. Failing signature validation due to unknown stderr.`,
        ),
      );
}
function nq() {
  const e = ZH.release();
  return e.startsWith("6.") && !e.startsWith("6.3");
}
var px;
function hx() {
  if (px) return Gc;
  (px = 1),
    Object.defineProperty(Gc, "__esModule", { value: !0 }),
    (Gc.NsisUpdater = void 0);
  const e = Ln(),
    t = pt,
    n = _p(),
    r = su,
    i = xp,
    a = xc(),
    s = fr,
    o = In,
    c = Za,
    l = Ap,
    f = Ya,
    u = mc;
  let d = class extends n.BaseUpdater {
    constructor(h, m) {
      super(h, m),
        (this._verifyUpdateCodeSignature = (g, v) =>
          (0, l.verifySignature)(g, v, this._logger));
    }
    get verifyUpdateCodeSignature() {
      return this._verifyUpdateCodeSignature;
    }
    set verifyUpdateCodeSignature(h) {
      h && (this._verifyUpdateCodeSignature = h);
    }
    doDownloadUpdate(h) {
      const m = h.updateInfoAndProvider.provider,
        g = (0, o.findFile)(
          m.resolveFiles(h.updateInfoAndProvider.info),
          "exe",
        );
      return this.executeDownload({
        fileExtension: "exe",
        downloadUpdateOptions: h,
        fileInfo: g,
        task: async (v, y, _, E) => {
          const R = g.packageInfo,
            A = R != null && _ != null;
          if (A && h.disableWebInstaller)
            throw (0, e.newError)(
              `Unable to download new version ${h.updateInfoAndProvider.info.version}. Web Installers are disabled`,
              "ERR_UPDATER_WEB_INSTALLER_DISABLED",
            );
          !A &&
            !h.disableWebInstaller &&
            this._logger.warn(
              "disableWebInstaller is set to false, you should set it to true if you do not plan on using a web installer. This will default to true in a future version.",
            ),
            (A || (await this.differentialDownloadInstaller(g, h, v, m))) &&
              (await this.httpExecutor.download(g.url, v, y));
          const I = await this.verifySignature(v);
          if (I != null)
            throw (
              (await E(),
              (0, e.newError)(
                `New version ${h.updateInfoAndProvider.info.version} is not signed by the application owner: ${I}`,
                "ERR_UPDATER_INVALID_SIGNATURE",
              ))
            );
          if (A && (await this.differentialDownloadWebPackage(h, R, _, m)))
            try {
              await this.httpExecutor.download(new f.URL(R.path), _, {
                headers: h.requestHeaders,
                cancellationToken: h.cancellationToken,
                sha512: R.sha512,
              });
            } catch (S) {
              try {
                await (0, c.unlink)(_);
              } catch {}
              throw S;
            }
        },
      });
    }
    async verifySignature(h) {
      let m;
      try {
        if (((m = (await this.configOnDisk.value).publisherName), m == null))
          return null;
      } catch (g) {
        if (g.code === "ENOENT") return null;
        throw g;
      }
      return await this._verifyUpdateCodeSignature(
        Array.isArray(m) ? m : [m],
        h,
      );
    }
    doInstall(h) {
      const m = ["--updated"];
      h.isSilent && m.push("/S"),
        h.isForceRunAfter && m.push("--force-run"),
        this.installDirectory && m.push(`/D=${this.installDirectory}`);
      const g =
        this.downloadedUpdateHelper == null
          ? null
          : this.downloadedUpdateHelper.packageFile;
      g != null && m.push(`--package-file=${g}`);
      const v = () => {
        this.spawnLog(
          t.join(process.resourcesPath, "elevate.exe"),
          [h.installerPath].concat(m),
        ).catch((y) => this.dispatchError(y));
      };
      return h.isAdminRightsRequired
        ? (this._logger.info(
            "isAdminRightsRequired is set to true, run installer using elevate.exe",
          ),
          v(),
          !0)
        : (this.spawnLog(h.installerPath, m).catch((y) => {
            const _ = y.code;
            this._logger.info(
              `Cannot run installer: error code: ${_}, error message: "${y.message}", will be executed again using elevate if EACCES"`,
            ),
              _ === "UNKNOWN" || _ === "EACCES" ? v() : this.dispatchError(y);
          }),
          !0);
    }
    async differentialDownloadInstaller(h, m, g, v) {
      try {
        if (
          this._testOnlyOptions != null &&
          !this._testOnlyOptions.isUseDifferentialDownload
        )
          return !0;
        const y = (0, s.blockmapFiles)(
          h.url,
          this.app.version,
          m.updateInfoAndProvider.info.version,
        );
        this._logger.info(`Download block maps (old: "${y[0]}", new: ${y[1]})`);
        const _ = async (A) => {
            const I = await this.httpExecutor.downloadToBuffer(A, {
              headers: m.requestHeaders,
              cancellationToken: m.cancellationToken,
            });
            if (I == null || I.length === 0)
              throw new Error(`Blockmap "${A.href}" is empty`);
            try {
              return JSON.parse((0, u.gunzipSync)(I).toString());
            } catch (S) {
              throw new Error(`Cannot parse blockmap "${A.href}", error: ${S}`);
            }
          },
          E = {
            newUrl: h.url,
            oldFile: t.join(
              this.downloadedUpdateHelper.cacheDir,
              e.CURRENT_APP_INSTALLER_FILE_NAME,
            ),
            logger: this._logger,
            newFile: g,
            isUseMultipleRangeRequest: v.isUseMultipleRangeRequest,
            requestHeaders: m.requestHeaders,
            cancellationToken: m.cancellationToken,
          };
        this.listenerCount(a.DOWNLOAD_PROGRESS) > 0 &&
          (E.onProgress = (A) => this.emit(a.DOWNLOAD_PROGRESS, A));
        const R = await Promise.all(y.map((A) => _(A)));
        return (
          await new i.GenericDifferentialDownloader(
            h.info,
            this.httpExecutor,
            E,
          ).download(R[0], R[1]),
          !1
        );
      } catch (y) {
        if (
          (this._logger.error(
            `Cannot download differentially, fallback to full download: ${
              y.stack || y
            }`,
          ),
          this._testOnlyOptions != null)
        )
          throw y;
        return !0;
      }
    }
    async differentialDownloadWebPackage(h, m, g, v) {
      if (m.blockMapSize == null) return !0;
      try {
        const y = {
          newUrl: new f.URL(m.path),
          oldFile: t.join(
            this.downloadedUpdateHelper.cacheDir,
            e.CURRENT_APP_PACKAGE_FILE_NAME,
          ),
          logger: this._logger,
          newFile: g,
          requestHeaders: this.requestHeaders,
          isUseMultipleRangeRequest: v.isUseMultipleRangeRequest,
          cancellationToken: h.cancellationToken,
        };
        this.listenerCount(a.DOWNLOAD_PROGRESS) > 0 &&
          (y.onProgress = (_) => this.emit(a.DOWNLOAD_PROGRESS, _)),
          await new r.FileWithEmbeddedBlockMapDifferentialDownloader(
            m,
            this.httpExecutor,
            y,
          ).download();
      } catch (y) {
        return (
          this._logger.error(
            `Cannot download differentially, fallback to full download: ${
              y.stack || y
            }`,
          ),
          process.platform === "win32"
        );
      }
      return !1;
    }
  };
  return (Gc.NsisUpdater = d), Gc;
}
var mx;
function xc() {
  return (
    mx ||
      ((mx = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.UpdaterSignal =
            e.UPDATE_DOWNLOADED =
            e.DOWNLOAD_PROGRESS =
            e.NsisUpdater =
            e.MacUpdater =
            e.RpmUpdater =
            e.DebUpdater =
            e.AppImageUpdater =
            e.Provider =
            e.CancellationToken =
            e.NoOpLogger =
            e.AppUpdater =
              void 0);
        const t = Ln();
        Object.defineProperty(e, "CancellationToken", {
          enumerable: !0,
          get: function () {
            return t.CancellationToken;
          },
        });
        const n = Za,
          r = pt;
        var i = ty();
        Object.defineProperty(e, "AppUpdater", {
          enumerable: !0,
          get: function () {
            return i.AppUpdater;
          },
        }),
          Object.defineProperty(e, "NoOpLogger", {
            enumerable: !0,
            get: function () {
              return i.NoOpLogger;
            },
          });
        var a = In;
        Object.defineProperty(e, "Provider", {
          enumerable: !0,
          get: function () {
            return a.Provider;
          },
        });
        var s = ix();
        Object.defineProperty(e, "AppImageUpdater", {
          enumerable: !0,
          get: function () {
            return s.AppImageUpdater;
          },
        });
        var o = sx();
        Object.defineProperty(e, "DebUpdater", {
          enumerable: !0,
          get: function () {
            return o.DebUpdater;
          },
        });
        var c = cx();
        Object.defineProperty(e, "RpmUpdater", {
          enumerable: !0,
          get: function () {
            return c.RpmUpdater;
          },
        });
        var l = ux();
        Object.defineProperty(e, "MacUpdater", {
          enumerable: !0,
          get: function () {
            return l.MacUpdater;
          },
        });
        var f = hx();
        Object.defineProperty(e, "NsisUpdater", {
          enumerable: !0,
          get: function () {
            return f.NsisUpdater;
          },
        });
        let u;
        function d() {
          if (process.platform === "win32") u = new (hx().NsisUpdater)();
          else if (process.platform === "darwin") u = new (ux().MacUpdater)();
          else {
            u = new (ix().AppImageUpdater)();
            try {
              const m = r.join(process.resourcesPath, "package-type");
              if (!(0, n.existsSync)(m)) return u;
              console.info(
                "Checking for beta autoupdate feature for deb/rpm distributions",
              );
              const g = (0, n.readFileSync)(m).toString().trim();
              switch ((console.info("Found package-type:", g), g)) {
                case "deb":
                  u = new (sx().DebUpdater)();
                  break;
                case "rpm":
                  u = new (cx().RpmUpdater)();
                  break;
                default:
                  break;
              }
            } catch (m) {
              console.warn(
                "Unable to detect 'package-type' for autoUpdater (beta rpm/deb support). If you'd like to expand support, please consider contributing to electron-builder",
                m.message,
              );
            }
          }
          return u;
        }
        Object.defineProperty(e, "autoUpdater", {
          enumerable: !0,
          get: () => u || d(),
        }),
          (e.DOWNLOAD_PROGRESS = "download-progress"),
          (e.UPDATE_DOWNLOADED = "update-downloaded");
        class p {
          constructor(g) {
            this.emitter = g;
          }
          login(g) {
            h(this.emitter, "login", g);
          }
          progress(g) {
            h(this.emitter, e.DOWNLOAD_PROGRESS, g);
          }
          updateDownloaded(g) {
            h(this.emitter, e.UPDATE_DOWNLOADED, g);
          }
          updateCancelled(g) {
            h(this.emitter, "update-cancelled", g);
          }
        }
        e.UpdaterSignal = p;
        function h(m, g, v) {
          m.on(g, v);
        }
      })(Yh)),
    Yh
  );
}
var vs = xc(),
  g0 = { exports: {} },
  rq = (e) => {
    const t = typeof e;
    return e !== null && (t === "object" || t === "function");
  };
const ls = rq,
  iq = new Set(["__proto__", "prototype", "constructor"]),
  aq = (e) => !e.some((t) => iq.has(t));
function hf(e) {
  const t = e.split("."),
    n = [];
  for (let r = 0; r < t.length; r++) {
    let i = t[r];
    for (; i[i.length - 1] === "\\" && t[r + 1] !== void 0; )
      (i = i.slice(0, -1) + "."), (i += t[++r]);
    n.push(i);
  }
  return aq(n) ? n : [];
}
var sq = {
    get(e, t, n) {
      if (!ls(e) || typeof t != "string") return n === void 0 ? e : n;
      const r = hf(t);
      if (r.length !== 0) {
        for (let i = 0; i < r.length; i++)
          if (((e = e[r[i]]), e == null)) {
            if (i !== r.length - 1) return n;
            break;
          }
        return e === void 0 ? n : e;
      }
    },
    set(e, t, n) {
      if (!ls(e) || typeof t != "string") return e;
      const r = e,
        i = hf(t);
      for (let a = 0; a < i.length; a++) {
        const s = i[a];
        ls(e[s]) || (e[s] = {}), a === i.length - 1 && (e[s] = n), (e = e[s]);
      }
      return r;
    },
    delete(e, t) {
      if (!ls(e) || typeof t != "string") return !1;
      const n = hf(t);
      for (let r = 0; r < n.length; r++) {
        const i = n[r];
        if (r === n.length - 1) return delete e[i], !0;
        if (((e = e[i]), !ls(e))) return !1;
      }
    },
    has(e, t) {
      if (!ls(e) || typeof t != "string") return !1;
      const n = hf(t);
      if (n.length === 0) return !1;
      for (let r = 0; r < n.length; r++)
        if (ls(e)) {
          if (!(n[r] in e)) return !1;
          e = e[n[r]];
        } else return !1;
      return !0;
    },
  },
  ny = { exports: {} },
  ry = { exports: {} },
  iy = { exports: {} },
  ay = { exports: {} };
const e4 = Xt;
ay.exports = (e) =>
  new Promise((t) => {
    e4.access(e, (n) => {
      t(!n);
    });
  });
ay.exports.sync = (e) => {
  try {
    return e4.accessSync(e), !0;
  } catch {
    return !1;
  }
};
var oq = ay.exports,
  sy = { exports: {} },
  oy = { exports: {} };
const t4 = (e, ...t) =>
  new Promise((n) => {
    n(e(...t));
  });
oy.exports = t4;
oy.exports.default = t4;
var cq = oy.exports;
const lq = cq,
  n4 = (e) => {
    if (!((Number.isInteger(e) || e === 1 / 0) && e > 0))
      return Promise.reject(
        new TypeError("Expected `concurrency` to be a number from 1 and up"),
      );
    const t = [];
    let n = 0;
    const r = () => {
        n--, t.length > 0 && t.shift()();
      },
      i = (o, c, ...l) => {
        n++;
        const f = lq(o, ...l);
        c(f), f.then(r, r);
      },
      a = (o, c, ...l) => {
        n < e ? i(o, c, ...l) : t.push(i.bind(null, o, c, ...l));
      },
      s = (o, ...c) => new Promise((l) => a(o, l, ...c));
    return (
      Object.defineProperties(s, {
        activeCount: { get: () => n },
        pendingCount: { get: () => t.length },
        clearQueue: {
          value: () => {
            t.length = 0;
          },
        },
      }),
      s
    );
  };
sy.exports = n4;
sy.exports.default = n4;
var uq = sy.exports;
const gx = uq;
class r4 extends Error {
  constructor(t) {
    super(), (this.value = t);
  }
}
const fq = (e, t) => Promise.resolve(e).then(t),
  dq = (e) =>
    Promise.all(e).then((t) => t[1] === !0 && Promise.reject(new r4(t[0])));
var pq = (e, t, n) => {
  n = Object.assign({ concurrency: 1 / 0, preserveOrder: !0 }, n);
  const r = gx(n.concurrency),
    i = [...e].map((s) => [s, r(fq, s, t)]),
    a = gx(n.preserveOrder ? 1 : 1 / 0);
  return Promise.all(i.map((s) => a(dq, s)))
    .then(() => {})
    .catch((s) => (s instanceof r4 ? s.value : Promise.reject(s)));
};
const i4 = pt,
  a4 = oq,
  hq = pq;
iy.exports = (e, t) => (
  (t = Object.assign({ cwd: process.cwd() }, t)),
  hq(e, (n) => a4(i4.resolve(t.cwd, n)), t)
);
iy.exports.sync = (e, t) => {
  t = Object.assign({ cwd: process.cwd() }, t);
  for (const n of e) if (a4.sync(i4.resolve(t.cwd, n))) return n;
};
var mq = iy.exports;
const Ba = pt,
  s4 = mq;
ry.exports = (e, t = {}) => {
  const n = Ba.resolve(t.cwd || ""),
    { root: r } = Ba.parse(n),
    i = [].concat(e);
  return new Promise((a) => {
    (function s(o) {
      s4(i, { cwd: o }).then((c) => {
        c ? a(Ba.join(o, c)) : o === r ? a(null) : s(Ba.dirname(o));
      });
    })(n);
  });
};
ry.exports.sync = (e, t = {}) => {
  let n = Ba.resolve(t.cwd || "");
  const { root: r } = Ba.parse(n),
    i = [].concat(e);
  for (;;) {
    const a = s4.sync(i, { cwd: n });
    if (a) return Ba.join(n, a);
    if (n === r) return null;
    n = Ba.dirname(n);
  }
};
var gq = ry.exports;
const o4 = gq;
ny.exports = async ({ cwd: e } = {}) => o4("package.json", { cwd: e });
ny.exports.sync = ({ cwd: e } = {}) => o4.sync("package.json", { cwd: e });
var vq = ny.exports,
  cy = { exports: {} };
const wn = pt,
  c4 = Fr,
  Na = c4.homedir(),
  ly = c4.tmpdir(),
  { env: ko } = process,
  yq = (e) => {
    const t = wn.join(Na, "Library");
    return {
      data: wn.join(t, "Application Support", e),
      config: wn.join(t, "Preferences", e),
      cache: wn.join(t, "Caches", e),
      log: wn.join(t, "Logs", e),
      temp: wn.join(ly, e),
    };
  },
  bq = (e) => {
    const t = ko.APPDATA || wn.join(Na, "AppData", "Roaming"),
      n = ko.LOCALAPPDATA || wn.join(Na, "AppData", "Local");
    return {
      data: wn.join(n, e, "Data"),
      config: wn.join(t, e, "Config"),
      cache: wn.join(n, e, "Cache"),
      log: wn.join(n, e, "Log"),
      temp: wn.join(ly, e),
    };
  },
  _q = (e) => {
    const t = wn.basename(Na);
    return {
      data: wn.join(ko.XDG_DATA_HOME || wn.join(Na, ".local", "share"), e),
      config: wn.join(ko.XDG_CONFIG_HOME || wn.join(Na, ".config"), e),
      cache: wn.join(ko.XDG_CACHE_HOME || wn.join(Na, ".cache"), e),
      log: wn.join(ko.XDG_STATE_HOME || wn.join(Na, ".local", "state"), e),
      temp: wn.join(ly, t, e),
    };
  },
  l4 = (e, t) => {
    if (typeof e != "string")
      throw new TypeError(`Expected string, got ${typeof e}`);
    return (
      (t = Object.assign({ suffix: "nodejs" }, t)),
      t.suffix && (e += `-${t.suffix}`),
      process.platform === "darwin"
        ? yq(e)
        : process.platform === "win32"
        ? bq(e)
        : _q(e)
    );
  };
cy.exports = l4;
cy.exports.default = l4;
var Eq = cy.exports,
  Ui = {},
  Gt = {};
Object.defineProperty(Gt, "__esModule", { value: !0 });
Gt.NOOP =
  Gt.LIMIT_FILES_DESCRIPTORS =
  Gt.LIMIT_BASENAME_LENGTH =
  Gt.IS_USER_ROOT =
  Gt.IS_POSIX =
  Gt.DEFAULT_TIMEOUT_SYNC =
  Gt.DEFAULT_TIMEOUT_ASYNC =
  Gt.DEFAULT_WRITE_OPTIONS =
  Gt.DEFAULT_READ_OPTIONS =
  Gt.DEFAULT_FOLDER_MODE =
  Gt.DEFAULT_FILE_MODE =
  Gt.DEFAULT_ENCODING =
    void 0;
const wq = "utf8";
Gt.DEFAULT_ENCODING = wq;
const xq = 438;
Gt.DEFAULT_FILE_MODE = xq;
const Aq = 511;
Gt.DEFAULT_FOLDER_MODE = Aq;
const Sq = {};
Gt.DEFAULT_READ_OPTIONS = Sq;
const Iq = {};
Gt.DEFAULT_WRITE_OPTIONS = Iq;
const $q = 5e3;
Gt.DEFAULT_TIMEOUT_ASYNC = $q;
const Cq = 100;
Gt.DEFAULT_TIMEOUT_SYNC = Cq;
const Rq = !!process.getuid;
Gt.IS_POSIX = Rq;
const kq = process.getuid ? !process.getuid() : !1;
Gt.IS_USER_ROOT = kq;
const Tq = 128;
Gt.LIMIT_BASENAME_LENGTH = Tq;
const Nq = 1e4;
Gt.LIMIT_FILES_DESCRIPTORS = Nq;
const Oq = () => {};
Gt.NOOP = Oq;
var Sp = {},
  rc = {};
Object.defineProperty(rc, "__esModule", { value: !0 });
rc.attemptifySync = rc.attemptifyAsync = void 0;
const u4 = Gt,
  Pq = (e, t = u4.NOOP) =>
    function () {
      return e.apply(void 0, arguments).catch(t);
    };
rc.attemptifyAsync = Pq;
const Dq = (e, t = u4.NOOP) =>
  function () {
    try {
      return e.apply(void 0, arguments);
    } catch (n) {
      return t(n);
    }
  };
rc.attemptifySync = Dq;
var uy = {};
Object.defineProperty(uy, "__esModule", { value: !0 });
const Lq = Gt,
  f4 = {
    isChangeErrorOk: (e) => {
      const { code: t } = e;
      return (
        t === "ENOSYS" ||
        (!Lq.IS_USER_ROOT && (t === "EINVAL" || t === "EPERM"))
      );
    },
    isRetriableError: (e) => {
      const { code: t } = e;
      return (
        t === "EMFILE" ||
        t === "ENFILE" ||
        t === "EAGAIN" ||
        t === "EBUSY" ||
        t === "EACCESS" ||
        t === "EACCS" ||
        t === "EPERM"
      );
    },
    onChangeError: (e) => {
      if (!f4.isChangeErrorOk(e)) throw e;
    },
  };
uy.default = f4;
var ic = {},
  fy = {};
Object.defineProperty(fy, "__esModule", { value: !0 });
const Bq = Gt,
  on = {
    interval: 25,
    intervalId: void 0,
    limit: Bq.LIMIT_FILES_DESCRIPTORS,
    queueActive: new Set(),
    queueWaiting: new Set(),
    init: () => {
      on.intervalId || (on.intervalId = setInterval(on.tick, on.interval));
    },
    reset: () => {
      on.intervalId && (clearInterval(on.intervalId), delete on.intervalId);
    },
    add: (e) => {
      on.queueWaiting.add(e),
        on.queueActive.size < on.limit / 2 ? on.tick() : on.init();
    },
    remove: (e) => {
      on.queueWaiting.delete(e), on.queueActive.delete(e);
    },
    schedule: () =>
      new Promise((e) => {
        const t = () => on.remove(n),
          n = () => e(t);
        on.add(n);
      }),
    tick: () => {
      if (!(on.queueActive.size >= on.limit)) {
        if (!on.queueWaiting.size) return on.reset();
        for (const e of on.queueWaiting) {
          if (on.queueActive.size >= on.limit) break;
          on.queueWaiting.delete(e), on.queueActive.add(e), e();
        }
      }
    },
  };
fy.default = on;
Object.defineProperty(ic, "__esModule", { value: !0 });
ic.retryifySync = ic.retryifyAsync = void 0;
const Uq = fy,
  Fq = (e, t) =>
    function (n) {
      return function r() {
        return Uq.default.schedule().then((i) =>
          e.apply(void 0, arguments).then(
            (a) => (i(), a),
            (a) => {
              if ((i(), Date.now() >= n)) throw a;
              if (t(a)) {
                const s = Math.round(100 + 400 * Math.random());
                return new Promise((c) => setTimeout(c, s)).then(() =>
                  r.apply(void 0, arguments),
                );
              }
              throw a;
            },
          ),
        );
      };
    };
ic.retryifyAsync = Fq;
const jq = (e, t) =>
  function (n) {
    return function r() {
      try {
        return e.apply(void 0, arguments);
      } catch (i) {
        if (Date.now() > n) throw i;
        if (t(i)) return r.apply(void 0, arguments);
        throw i;
      }
    };
  };
ic.retryifySync = jq;
Object.defineProperty(Sp, "__esModule", { value: !0 });
const Kt = Xt,
  gr = wr,
  vr = rc,
  Hn = uy,
  Rr = ic,
  Mq = {
    chmodAttempt: vr.attemptifyAsync(
      gr.promisify(Kt.chmod),
      Hn.default.onChangeError,
    ),
    chownAttempt: vr.attemptifyAsync(
      gr.promisify(Kt.chown),
      Hn.default.onChangeError,
    ),
    closeAttempt: vr.attemptifyAsync(gr.promisify(Kt.close)),
    fsyncAttempt: vr.attemptifyAsync(gr.promisify(Kt.fsync)),
    mkdirAttempt: vr.attemptifyAsync(gr.promisify(Kt.mkdir)),
    realpathAttempt: vr.attemptifyAsync(gr.promisify(Kt.realpath)),
    statAttempt: vr.attemptifyAsync(gr.promisify(Kt.stat)),
    unlinkAttempt: vr.attemptifyAsync(gr.promisify(Kt.unlink)),
    closeRetry: Rr.retryifyAsync(
      gr.promisify(Kt.close),
      Hn.default.isRetriableError,
    ),
    fsyncRetry: Rr.retryifyAsync(
      gr.promisify(Kt.fsync),
      Hn.default.isRetriableError,
    ),
    openRetry: Rr.retryifyAsync(
      gr.promisify(Kt.open),
      Hn.default.isRetriableError,
    ),
    readFileRetry: Rr.retryifyAsync(
      gr.promisify(Kt.readFile),
      Hn.default.isRetriableError,
    ),
    renameRetry: Rr.retryifyAsync(
      gr.promisify(Kt.rename),
      Hn.default.isRetriableError,
    ),
    statRetry: Rr.retryifyAsync(
      gr.promisify(Kt.stat),
      Hn.default.isRetriableError,
    ),
    writeRetry: Rr.retryifyAsync(
      gr.promisify(Kt.write),
      Hn.default.isRetriableError,
    ),
    chmodSyncAttempt: vr.attemptifySync(Kt.chmodSync, Hn.default.onChangeError),
    chownSyncAttempt: vr.attemptifySync(Kt.chownSync, Hn.default.onChangeError),
    closeSyncAttempt: vr.attemptifySync(Kt.closeSync),
    mkdirSyncAttempt: vr.attemptifySync(Kt.mkdirSync),
    realpathSyncAttempt: vr.attemptifySync(Kt.realpathSync),
    statSyncAttempt: vr.attemptifySync(Kt.statSync),
    unlinkSyncAttempt: vr.attemptifySync(Kt.unlinkSync),
    closeSyncRetry: Rr.retryifySync(Kt.closeSync, Hn.default.isRetriableError),
    fsyncSyncRetry: Rr.retryifySync(Kt.fsyncSync, Hn.default.isRetriableError),
    openSyncRetry: Rr.retryifySync(Kt.openSync, Hn.default.isRetriableError),
    readFileSyncRetry: Rr.retryifySync(
      Kt.readFileSync,
      Hn.default.isRetriableError,
    ),
    renameSyncRetry: Rr.retryifySync(
      Kt.renameSync,
      Hn.default.isRetriableError,
    ),
    statSyncRetry: Rr.retryifySync(Kt.statSync, Hn.default.isRetriableError),
    writeSyncRetry: Rr.retryifySync(Kt.writeSync, Hn.default.isRetriableError),
  };
Sp.default = Mq;
var dy = {};
Object.defineProperty(dy, "__esModule", { value: !0 });
const Hq = {
  isFunction: (e) => typeof e == "function",
  isString: (e) => typeof e == "string",
  isUndefined: (e) => typeof e > "u",
};
dy.default = Hq;
var py = {};
Object.defineProperty(py, "__esModule", { value: !0 });
const mf = {},
  v0 = {
    next: (e) => {
      const t = mf[e];
      if (!t) return;
      t.shift();
      const n = t[0];
      n ? n(() => v0.next(e)) : delete mf[e];
    },
    schedule: (e) =>
      new Promise((t) => {
        let n = mf[e];
        n || (n = mf[e] = []),
          n.push(t),
          !(n.length > 1) && t(() => v0.next(e));
      }),
  };
py.default = v0;
var hy = {};
Object.defineProperty(hy, "__esModule", { value: !0 });
const qq = pt,
  vx = Gt,
  yx = Sp,
  Qr = {
    store: {},
    create: (e) => {
      const t = `000000${Math.floor(Math.random() * 16777215).toString(
          16,
        )}`.slice(-6),
        n = Date.now().toString().slice(-10),
        r = "tmp-",
        i = `.${r}${n}${t}`;
      return `${e}${i}`;
    },
    get: (e, t, n = !0) => {
      const r = Qr.truncate(t(e));
      return r in Qr.store
        ? Qr.get(e, t, n)
        : ((Qr.store[r] = n), [r, () => delete Qr.store[r]]);
    },
    purge: (e) => {
      Qr.store[e] && (delete Qr.store[e], yx.default.unlinkAttempt(e));
    },
    purgeSync: (e) => {
      Qr.store[e] && (delete Qr.store[e], yx.default.unlinkSyncAttempt(e));
    },
    purgeSyncAll: () => {
      for (const e in Qr.store) Qr.purgeSync(e);
    },
    truncate: (e) => {
      const t = qq.basename(e);
      if (t.length <= vx.LIMIT_BASENAME_LENGTH) return e;
      const n = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(
        t,
      );
      if (!n) return e;
      const r = t.length - vx.LIMIT_BASENAME_LENGTH;
      return `${e.slice(0, -t.length)}${n[1]}${n[2].slice(0, -r)}${n[3]}`;
    },
  };
process.on("exit", Qr.purgeSyncAll);
hy.default = Qr;
Object.defineProperty(Ui, "__esModule", { value: !0 });
Ui.writeFileSync = Ui.writeFile = Ui.readFileSync = Ui.readFile = void 0;
const d4 = pt,
  tr = Gt,
  qt = Sp,
  Wr = dy,
  Gq = py,
  Ua = hy;
function p4(e, t = tr.DEFAULT_READ_OPTIONS) {
  var n;
  if (Wr.default.isString(t)) return p4(e, { encoding: t });
  const r =
    Date.now() +
    ((n = t.timeout) !== null && n !== void 0 ? n : tr.DEFAULT_TIMEOUT_ASYNC);
  return qt.default.readFileRetry(r)(e, t);
}
Ui.readFile = p4;
function h4(e, t = tr.DEFAULT_READ_OPTIONS) {
  var n;
  if (Wr.default.isString(t)) return h4(e, { encoding: t });
  const r =
    Date.now() +
    ((n = t.timeout) !== null && n !== void 0 ? n : tr.DEFAULT_TIMEOUT_SYNC);
  return qt.default.readFileSyncRetry(r)(e, t);
}
Ui.readFileSync = h4;
const m4 = (e, t, n, r) => {
  if (Wr.default.isFunction(n)) return m4(e, t, tr.DEFAULT_WRITE_OPTIONS, n);
  const i = g4(e, t, n);
  return r && i.then(r, r), i;
};
Ui.writeFile = m4;
const g4 = async (e, t, n = tr.DEFAULT_WRITE_OPTIONS) => {
    var r;
    if (Wr.default.isString(n)) return g4(e, t, { encoding: n });
    const i =
      Date.now() +
      ((r = n.timeout) !== null && r !== void 0 ? r : tr.DEFAULT_TIMEOUT_ASYNC);
    let a = null,
      s = null,
      o = null,
      c = null,
      l = null;
    try {
      n.schedule && (a = await n.schedule(e)),
        (s = await Gq.default.schedule(e)),
        (e = (await qt.default.realpathAttempt(e)) || e),
        ([c, o] = Ua.default.get(
          e,
          n.tmpCreate || Ua.default.create,
          n.tmpPurge !== !1,
        ));
      const f = tr.IS_POSIX && Wr.default.isUndefined(n.chown),
        u = Wr.default.isUndefined(n.mode);
      if (f || u) {
        const p = await qt.default.statAttempt(e);
        p &&
          ((n = { ...n }),
          f && (n.chown = { uid: p.uid, gid: p.gid }),
          u && (n.mode = p.mode));
      }
      const d = d4.dirname(e);
      await qt.default.mkdirAttempt(d, {
        mode: tr.DEFAULT_FOLDER_MODE,
        recursive: !0,
      }),
        (l = await qt.default.openRetry(i)(
          c,
          "w",
          n.mode || tr.DEFAULT_FILE_MODE,
        )),
        n.tmpCreated && n.tmpCreated(c),
        Wr.default.isString(t)
          ? await qt.default.writeRetry(i)(
              l,
              t,
              0,
              n.encoding || tr.DEFAULT_ENCODING,
            )
          : Wr.default.isUndefined(t) ||
            (await qt.default.writeRetry(i)(l, t, 0, t.length, 0)),
        n.fsync !== !1 &&
          (n.fsyncWait !== !1
            ? await qt.default.fsyncRetry(i)(l)
            : qt.default.fsyncAttempt(l)),
        await qt.default.closeRetry(i)(l),
        (l = null),
        n.chown && (await qt.default.chownAttempt(c, n.chown.uid, n.chown.gid)),
        n.mode && (await qt.default.chmodAttempt(c, n.mode));
      try {
        await qt.default.renameRetry(i)(c, e);
      } catch (p) {
        if (p.code !== "ENAMETOOLONG") throw p;
        await qt.default.renameRetry(i)(c, Ua.default.truncate(e));
      }
      o(), (c = null);
    } finally {
      l && (await qt.default.closeAttempt(l)),
        c && Ua.default.purge(c),
        a && a(),
        s && s();
    }
  },
  v4 = (e, t, n = tr.DEFAULT_WRITE_OPTIONS) => {
    var r;
    if (Wr.default.isString(n)) return v4(e, t, { encoding: n });
    const i =
      Date.now() +
      ((r = n.timeout) !== null && r !== void 0 ? r : tr.DEFAULT_TIMEOUT_SYNC);
    let a = null,
      s = null,
      o = null;
    try {
      (e = qt.default.realpathSyncAttempt(e) || e),
        ([s, a] = Ua.default.get(
          e,
          n.tmpCreate || Ua.default.create,
          n.tmpPurge !== !1,
        ));
      const c = tr.IS_POSIX && Wr.default.isUndefined(n.chown),
        l = Wr.default.isUndefined(n.mode);
      if (c || l) {
        const u = qt.default.statSyncAttempt(e);
        u &&
          ((n = { ...n }),
          c && (n.chown = { uid: u.uid, gid: u.gid }),
          l && (n.mode = u.mode));
      }
      const f = d4.dirname(e);
      qt.default.mkdirSyncAttempt(f, {
        mode: tr.DEFAULT_FOLDER_MODE,
        recursive: !0,
      }),
        (o = qt.default.openSyncRetry(i)(
          s,
          "w",
          n.mode || tr.DEFAULT_FILE_MODE,
        )),
        n.tmpCreated && n.tmpCreated(s),
        Wr.default.isString(t)
          ? qt.default.writeSyncRetry(i)(
              o,
              t,
              0,
              n.encoding || tr.DEFAULT_ENCODING,
            )
          : Wr.default.isUndefined(t) ||
            qt.default.writeSyncRetry(i)(o, t, 0, t.length, 0),
        n.fsync !== !1 &&
          (n.fsyncWait !== !1
            ? qt.default.fsyncSyncRetry(i)(o)
            : qt.default.fsyncAttempt(o)),
        qt.default.closeSyncRetry(i)(o),
        (o = null),
        n.chown && qt.default.chownSyncAttempt(s, n.chown.uid, n.chown.gid),
        n.mode && qt.default.chmodSyncAttempt(s, n.mode);
      try {
        qt.default.renameSyncRetry(i)(s, e);
      } catch (u) {
        if (u.code !== "ENAMETOOLONG") throw u;
        qt.default.renameSyncRetry(i)(s, Ua.default.truncate(e));
      }
      a(), (s = null);
    } finally {
      o && qt.default.closeSyncAttempt(o), s && Ua.default.purge(s);
    }
  };
Ui.writeFileSync = v4;
var y0 = { exports: {} },
  y4 = {},
  yi = {},
  ac = {},
  cu = {},
  $t = {},
  Ml = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.regexpCode =
      e.getEsmExportName =
      e.getProperty =
      e.safeStringify =
      e.stringify =
      e.strConcat =
      e.addCodeArg =
      e.str =
      e._ =
      e.nil =
      e._Code =
      e.Name =
      e.IDENTIFIER =
      e._CodeOrName =
        void 0);
  class t {}
  (e._CodeOrName = t), (e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i);
  class n extends t {
    constructor(y) {
      if ((super(), !e.IDENTIFIER.test(y)))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = y;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = n;
  class r extends t {
    constructor(y) {
      super(), (this._items = typeof y == "string" ? [y] : y);
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1) return !1;
      const y = this._items[0];
      return y === "" || y === '""';
    }
    get str() {
      var y;
      return (y = this._str) !== null && y !== void 0
        ? y
        : (this._str = this._items.reduce((_, E) => `${_}${E}`, ""));
    }
    get names() {
      var y;
      return (y = this._names) !== null && y !== void 0
        ? y
        : (this._names = this._items.reduce(
            (_, E) => (E instanceof n && (_[E.str] = (_[E.str] || 0) + 1), _),
            {},
          ));
    }
  }
  (e._Code = r), (e.nil = new r(""));
  function i(v, ...y) {
    const _ = [v[0]];
    let E = 0;
    for (; E < y.length; ) o(_, y[E]), _.push(v[++E]);
    return new r(_);
  }
  e._ = i;
  const a = new r("+");
  function s(v, ...y) {
    const _ = [p(v[0])];
    let E = 0;
    for (; E < y.length; ) _.push(a), o(_, y[E]), _.push(a, p(v[++E]));
    return c(_), new r(_);
  }
  e.str = s;
  function o(v, y) {
    y instanceof r
      ? v.push(...y._items)
      : y instanceof n
      ? v.push(y)
      : v.push(u(y));
  }
  e.addCodeArg = o;
  function c(v) {
    let y = 1;
    for (; y < v.length - 1; ) {
      if (v[y] === a) {
        const _ = l(v[y - 1], v[y + 1]);
        if (_ !== void 0) {
          v.splice(y - 1, 3, _);
          continue;
        }
        v[y++] = "+";
      }
      y++;
    }
  }
  function l(v, y) {
    if (y === '""') return v;
    if (v === '""') return y;
    if (typeof v == "string")
      return y instanceof n || v[v.length - 1] !== '"'
        ? void 0
        : typeof y != "string"
        ? `${v.slice(0, -1)}${y}"`
        : y[0] === '"'
        ? v.slice(0, -1) + y.slice(1)
        : void 0;
    if (typeof y == "string" && y[0] === '"' && !(v instanceof n))
      return `"${v}${y.slice(1)}`;
  }
  function f(v, y) {
    return y.emptyStr() ? v : v.emptyStr() ? y : s`${v}${y}`;
  }
  e.strConcat = f;
  function u(v) {
    return typeof v == "number" || typeof v == "boolean" || v === null
      ? v
      : p(Array.isArray(v) ? v.join(",") : v);
  }
  function d(v) {
    return new r(p(v));
  }
  e.stringify = d;
  function p(v) {
    return JSON.stringify(v)
      .replace(/\u2028/g, "\\u2028")
      .replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = p;
  function h(v) {
    return typeof v == "string" && e.IDENTIFIER.test(v)
      ? new r(`.${v}`)
      : i`[${v}]`;
  }
  e.getProperty = h;
  function m(v) {
    if (typeof v == "string" && e.IDENTIFIER.test(v)) return new r(`${v}`);
    throw new Error(
      `CodeGen: invalid export name: ${v}, use explicit $id name mapping`,
    );
  }
  e.getEsmExportName = m;
  function g(v) {
    return new r(v.toString());
  }
  e.regexpCode = g;
})(Ml);
var b0 = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.ValueScope =
      e.ValueScopeName =
      e.Scope =
      e.varKinds =
      e.UsedValueState =
        void 0);
  const t = Ml;
  class n extends Error {
    constructor(l) {
      super(`CodeGen: "code" for ${l} not defined`), (this.value = l.value);
    }
  }
  var r;
  (function (c) {
    (c[(c.Started = 0)] = "Started"), (c[(c.Completed = 1)] = "Completed");
  })((r = e.UsedValueState || (e.UsedValueState = {}))),
    (e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var"),
    });
  class i {
    constructor({ prefixes: l, parent: f } = {}) {
      (this._names = {}), (this._prefixes = l), (this._parent = f);
    }
    toName(l) {
      return l instanceof t.Name ? l : this.name(l);
    }
    name(l) {
      return new t.Name(this._newName(l));
    }
    _newName(l) {
      const f = this._names[l] || this._nameGroup(l);
      return `${l}${f.index++}`;
    }
    _nameGroup(l) {
      var f, u;
      if (
        (!(
          (u =
            (f = this._parent) === null || f === void 0
              ? void 0
              : f._prefixes) === null || u === void 0
        ) &&
          u.has(l)) ||
        (this._prefixes && !this._prefixes.has(l))
      )
        throw new Error(`CodeGen: prefix "${l}" is not allowed in this scope`);
      return (this._names[l] = { prefix: l, index: 0 });
    }
  }
  e.Scope = i;
  class a extends t.Name {
    constructor(l, f) {
      super(f), (this.prefix = l);
    }
    setValue(l, { property: f, itemIndex: u }) {
      (this.value = l), (this.scopePath = (0, t._)`.${new t.Name(f)}[${u}]`);
    }
  }
  e.ValueScopeName = a;
  const s = (0, t._)`\n`;
  class o extends i {
    constructor(l) {
      super(l),
        (this._values = {}),
        (this._scope = l.scope),
        (this.opts = { ...l, _n: l.lines ? s : t.nil });
    }
    get() {
      return this._scope;
    }
    name(l) {
      return new a(l, this._newName(l));
    }
    value(l, f) {
      var u;
      if (f.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const d = this.toName(l),
        { prefix: p } = d,
        h = (u = f.key) !== null && u !== void 0 ? u : f.ref;
      let m = this._values[p];
      if (m) {
        const y = m.get(h);
        if (y) return y;
      } else m = this._values[p] = new Map();
      m.set(h, d);
      const g = this._scope[p] || (this._scope[p] = []),
        v = g.length;
      return (g[v] = f.ref), d.setValue(f, { property: p, itemIndex: v }), d;
    }
    getValue(l, f) {
      const u = this._values[l];
      if (u) return u.get(f);
    }
    scopeRefs(l, f = this._values) {
      return this._reduceValues(f, (u) => {
        if (u.scopePath === void 0)
          throw new Error(`CodeGen: name "${u}" has no value`);
        return (0, t._)`${l}${u.scopePath}`;
      });
    }
    scopeCode(l = this._values, f, u) {
      return this._reduceValues(
        l,
        (d) => {
          if (d.value === void 0)
            throw new Error(`CodeGen: name "${d}" has no value`);
          return d.value.code;
        },
        f,
        u,
      );
    }
    _reduceValues(l, f, u = {}, d) {
      let p = t.nil;
      for (const h in l) {
        const m = l[h];
        if (!m) continue;
        const g = (u[h] = u[h] || new Map());
        m.forEach((v) => {
          if (g.has(v)) return;
          g.set(v, r.Started);
          let y = f(v);
          if (y) {
            const _ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            p = (0, t._)`${p}${_} ${v} = ${y};${this.opts._n}`;
          } else if ((y = d == null ? void 0 : d(v)))
            p = (0, t._)`${p}${y}${this.opts._n}`;
          else throw new n(v);
          g.set(v, r.Completed);
        });
      }
      return p;
    }
  }
  e.ValueScope = o;
})(b0);
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.or =
      e.and =
      e.not =
      e.CodeGen =
      e.operators =
      e.varKinds =
      e.ValueScopeName =
      e.ValueScope =
      e.Scope =
      e.Name =
      e.regexpCode =
      e.stringify =
      e.getProperty =
      e.nil =
      e.strConcat =
      e.str =
      e._ =
        void 0);
  const t = Ml,
    n = b0;
  var r = Ml;
  Object.defineProperty(e, "_", {
    enumerable: !0,
    get: function () {
      return r._;
    },
  }),
    Object.defineProperty(e, "str", {
      enumerable: !0,
      get: function () {
        return r.str;
      },
    }),
    Object.defineProperty(e, "strConcat", {
      enumerable: !0,
      get: function () {
        return r.strConcat;
      },
    }),
    Object.defineProperty(e, "nil", {
      enumerable: !0,
      get: function () {
        return r.nil;
      },
    }),
    Object.defineProperty(e, "getProperty", {
      enumerable: !0,
      get: function () {
        return r.getProperty;
      },
    }),
    Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function () {
        return r.stringify;
      },
    }),
    Object.defineProperty(e, "regexpCode", {
      enumerable: !0,
      get: function () {
        return r.regexpCode;
      },
    }),
    Object.defineProperty(e, "Name", {
      enumerable: !0,
      get: function () {
        return r.Name;
      },
    });
  var i = b0;
  Object.defineProperty(e, "Scope", {
    enumerable: !0,
    get: function () {
      return i.Scope;
    },
  }),
    Object.defineProperty(e, "ValueScope", {
      enumerable: !0,
      get: function () {
        return i.ValueScope;
      },
    }),
    Object.defineProperty(e, "ValueScopeName", {
      enumerable: !0,
      get: function () {
        return i.ValueScopeName;
      },
    }),
    Object.defineProperty(e, "varKinds", {
      enumerable: !0,
      get: function () {
        return i.varKinds;
      },
    }),
    (e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+"),
    });
  class a {
    optimizeNodes() {
      return this;
    }
    optimizeNames(x, T) {
      return this;
    }
  }
  class s extends a {
    constructor(x, T, V) {
      super(), (this.varKind = x), (this.name = T), (this.rhs = V);
    }
    render({ es5: x, _n: T }) {
      const V = x ? n.varKinds.var : this.varKind,
        B = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${V} ${this.name}${B};` + T;
    }
    optimizeNames(x, T) {
      if (x[this.name.str])
        return this.rhs && (this.rhs = q(this.rhs, x, T)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class o extends a {
    constructor(x, T, V) {
      super(), (this.lhs = x), (this.rhs = T), (this.sideEffects = V);
    }
    render({ _n: x }) {
      return `${this.lhs} = ${this.rhs};` + x;
    }
    optimizeNames(x, T) {
      if (
        !(this.lhs instanceof t.Name && !x[this.lhs.str] && !this.sideEffects)
      )
        return (this.rhs = q(this.rhs, x, T)), this;
    }
    get names() {
      const x = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return H(x, this.rhs);
    }
  }
  class c extends o {
    constructor(x, T, V, B) {
      super(x, V, B), (this.op = T);
    }
    render({ _n: x }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + x;
    }
  }
  class l extends a {
    constructor(x) {
      super(), (this.label = x), (this.names = {});
    }
    render({ _n: x }) {
      return `${this.label}:` + x;
    }
  }
  class f extends a {
    constructor(x) {
      super(), (this.label = x), (this.names = {});
    }
    render({ _n: x }) {
      return `break${this.label ? ` ${this.label}` : ""};` + x;
    }
  }
  class u extends a {
    constructor(x) {
      super(), (this.error = x);
    }
    render({ _n: x }) {
      return `throw ${this.error};` + x;
    }
    get names() {
      return this.error.names;
    }
  }
  class d extends a {
    constructor(x) {
      super(), (this.code = x);
    }
    render({ _n: x }) {
      return `${this.code};` + x;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(x, T) {
      return (this.code = q(this.code, x, T)), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class p extends a {
    constructor(x = []) {
      super(), (this.nodes = x);
    }
    render(x) {
      return this.nodes.reduce((T, V) => T + V.render(x), "");
    }
    optimizeNodes() {
      const { nodes: x } = this;
      let T = x.length;
      for (; T--; ) {
        const V = x[T].optimizeNodes();
        Array.isArray(V)
          ? x.splice(T, 1, ...V)
          : V
          ? (x[T] = V)
          : x.splice(T, 1);
      }
      return x.length > 0 ? this : void 0;
    }
    optimizeNames(x, T) {
      const { nodes: V } = this;
      let B = V.length;
      for (; B--; ) {
        const N = V[B];
        N.optimizeNames(x, T) || (J(x, N.names), V.splice(B, 1));
      }
      return V.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((x, T) => j(x, T.names), {});
    }
  }
  class h extends p {
    render(x) {
      return "{" + x._n + super.render(x) + "}" + x._n;
    }
  }
  class m extends p {}
  class g extends h {}
  g.kind = "else";
  class v extends h {
    constructor(x, T) {
      super(T), (this.condition = x);
    }
    render(x) {
      let T = `if(${this.condition})` + super.render(x);
      return this.else && (T += "else " + this.else.render(x)), T;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const x = this.condition;
      if (x === !0) return this.nodes;
      let T = this.else;
      if (T) {
        const V = T.optimizeNodes();
        T = this.else = Array.isArray(V) ? new g(V) : V;
      }
      if (T)
        return x === !1
          ? T instanceof v
            ? T
            : T.nodes
          : this.nodes.length
          ? this
          : new v(Z(x), T instanceof v ? [T] : T.nodes);
      if (!(x === !1 || !this.nodes.length)) return this;
    }
    optimizeNames(x, T) {
      var V;
      if (
        ((this.else =
          (V = this.else) === null || V === void 0
            ? void 0
            : V.optimizeNames(x, T)),
        !!(super.optimizeNames(x, T) || this.else))
      )
        return (this.condition = q(this.condition, x, T)), this;
    }
    get names() {
      const x = super.names;
      return H(x, this.condition), this.else && j(x, this.else.names), x;
    }
  }
  v.kind = "if";
  class y extends h {}
  y.kind = "for";
  class _ extends y {
    constructor(x) {
      super(), (this.iteration = x);
    }
    render(x) {
      return `for(${this.iteration})` + super.render(x);
    }
    optimizeNames(x, T) {
      if (super.optimizeNames(x, T))
        return (this.iteration = q(this.iteration, x, T)), this;
    }
    get names() {
      return j(super.names, this.iteration.names);
    }
  }
  class E extends y {
    constructor(x, T, V, B) {
      super(),
        (this.varKind = x),
        (this.name = T),
        (this.from = V),
        (this.to = B);
    }
    render(x) {
      const T = x.es5 ? n.varKinds.var : this.varKind,
        { name: V, from: B, to: N } = this;
      return `for(${T} ${V}=${B}; ${V}<${N}; ${V}++)` + super.render(x);
    }
    get names() {
      const x = H(super.names, this.from);
      return H(x, this.to);
    }
  }
  class R extends y {
    constructor(x, T, V, B) {
      super(),
        (this.loop = x),
        (this.varKind = T),
        (this.name = V),
        (this.iterable = B);
    }
    render(x) {
      return (
        `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
        super.render(x)
      );
    }
    optimizeNames(x, T) {
      if (super.optimizeNames(x, T))
        return (this.iterable = q(this.iterable, x, T)), this;
    }
    get names() {
      return j(super.names, this.iterable.names);
    }
  }
  class A extends h {
    constructor(x, T, V) {
      super(), (this.name = x), (this.args = T), (this.async = V);
    }
    render(x) {
      return (
        `${this.async ? "async " : ""}function ${this.name}(${this.args})` +
        super.render(x)
      );
    }
  }
  A.kind = "func";
  class I extends p {
    render(x) {
      return "return " + super.render(x);
    }
  }
  I.kind = "return";
  class S extends h {
    render(x) {
      let T = "try" + super.render(x);
      return (
        this.catch && (T += this.catch.render(x)),
        this.finally && (T += this.finally.render(x)),
        T
      );
    }
    optimizeNodes() {
      var x, T;
      return (
        super.optimizeNodes(),
        (x = this.catch) === null || x === void 0 || x.optimizeNodes(),
        (T = this.finally) === null || T === void 0 || T.optimizeNodes(),
        this
      );
    }
    optimizeNames(x, T) {
      var V, B;
      return (
        super.optimizeNames(x, T),
        (V = this.catch) === null || V === void 0 || V.optimizeNames(x, T),
        (B = this.finally) === null || B === void 0 || B.optimizeNames(x, T),
        this
      );
    }
    get names() {
      const x = super.names;
      return (
        this.catch && j(x, this.catch.names),
        this.finally && j(x, this.finally.names),
        x
      );
    }
  }
  class w extends h {
    constructor(x) {
      super(), (this.error = x);
    }
    render(x) {
      return `catch(${this.error})` + super.render(x);
    }
  }
  w.kind = "catch";
  class O extends h {
    render(x) {
      return "finally" + super.render(x);
    }
  }
  O.kind = "finally";
  class Q {
    constructor(x, T = {}) {
      (this._values = {}),
        (this._blockStarts = []),
        (this._constants = {}),
        (this.opts = {
          ...T,
          _n: T.lines
            ? `
`
            : "",
        }),
        (this._extScope = x),
        (this._scope = new n.Scope({ parent: x })),
        (this._nodes = [new m()]);
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(x) {
      return this._scope.name(x);
    }
    scopeName(x) {
      return this._extScope.name(x);
    }
    scopeValue(x, T) {
      const V = this._extScope.value(x, T);
      return (
        (this._values[V.prefix] || (this._values[V.prefix] = new Set())).add(V),
        V
      );
    }
    getScopeValue(x, T) {
      return this._extScope.getValue(x, T);
    }
    scopeRefs(x) {
      return this._extScope.scopeRefs(x, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(x, T, V, B) {
      const N = this._scope.toName(T);
      return (
        V !== void 0 && B && (this._constants[N.str] = V),
        this._leafNode(new s(x, N, V)),
        N
      );
    }
    const(x, T, V) {
      return this._def(n.varKinds.const, x, T, V);
    }
    let(x, T, V) {
      return this._def(n.varKinds.let, x, T, V);
    }
    var(x, T, V) {
      return this._def(n.varKinds.var, x, T, V);
    }
    assign(x, T, V) {
      return this._leafNode(new o(x, T, V));
    }
    add(x, T) {
      return this._leafNode(new c(x, e.operators.ADD, T));
    }
    code(x) {
      return (
        typeof x == "function" ? x() : x !== t.nil && this._leafNode(new d(x)),
        this
      );
    }
    object(...x) {
      const T = ["{"];
      for (const [V, B] of x)
        T.length > 1 && T.push(","),
          T.push(V),
          (V !== B || this.opts.es5) && (T.push(":"), (0, t.addCodeArg)(T, B));
      return T.push("}"), new t._Code(T);
    }
    if(x, T, V) {
      if ((this._blockNode(new v(x)), T && V))
        this.code(T).else().code(V).endIf();
      else if (T) this.code(T).endIf();
      else if (V) throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    elseIf(x) {
      return this._elseNode(new v(x));
    }
    else() {
      return this._elseNode(new g());
    }
    endIf() {
      return this._endBlockNode(v, g);
    }
    _for(x, T) {
      return this._blockNode(x), T && this.code(T).endFor(), this;
    }
    for(x, T) {
      return this._for(new _(x), T);
    }
    forRange(x, T, V, B, N = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
      const ce = this._scope.toName(x);
      return this._for(new E(N, ce, T, V), () => B(ce));
    }
    forOf(x, T, V, B = n.varKinds.const) {
      const N = this._scope.toName(x);
      if (this.opts.es5) {
        const ce = T instanceof t.Name ? T : this.var("_arr", T);
        return this.forRange("_i", 0, (0, t._)`${ce}.length`, (re) => {
          this.var(N, (0, t._)`${ce}[${re}]`), V(N);
        });
      }
      return this._for(new R("of", B, N, T), () => V(N));
    }
    forIn(x, T, V, B = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(x, (0, t._)`Object.keys(${T})`, V);
      const N = this._scope.toName(x);
      return this._for(new R("in", B, N, T), () => V(N));
    }
    endFor() {
      return this._endBlockNode(y);
    }
    label(x) {
      return this._leafNode(new l(x));
    }
    break(x) {
      return this._leafNode(new f(x));
    }
    return(x) {
      const T = new I();
      if ((this._blockNode(T), this.code(x), T.nodes.length !== 1))
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(I);
    }
    try(x, T, V) {
      if (!T && !V)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const B = new S();
      if ((this._blockNode(B), this.code(x), T)) {
        const N = this.name("e");
        (this._currNode = B.catch = new w(N)), T(N);
      }
      return (
        V && ((this._currNode = B.finally = new O()), this.code(V)),
        this._endBlockNode(w, O)
      );
    }
    throw(x) {
      return this._leafNode(new u(x));
    }
    block(x, T) {
      return (
        this._blockStarts.push(this._nodes.length),
        x && this.code(x).endBlock(T),
        this
      );
    }
    endBlock(x) {
      const T = this._blockStarts.pop();
      if (T === void 0) throw new Error("CodeGen: not in self-balancing block");
      const V = this._nodes.length - T;
      if (V < 0 || (x !== void 0 && V !== x))
        throw new Error(
          `CodeGen: wrong number of nodes: ${V} vs ${x} expected`,
        );
      return (this._nodes.length = T), this;
    }
    func(x, T = t.nil, V, B) {
      return this._blockNode(new A(x, T, V)), B && this.code(B).endFunc(), this;
    }
    endFunc() {
      return this._endBlockNode(A);
    }
    optimize(x = 1) {
      for (; x-- > 0; )
        this._root.optimizeNodes(),
          this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(x) {
      return this._currNode.nodes.push(x), this;
    }
    _blockNode(x) {
      this._currNode.nodes.push(x), this._nodes.push(x);
    }
    _endBlockNode(x, T) {
      const V = this._currNode;
      if (V instanceof x || (T && V instanceof T))
        return this._nodes.pop(), this;
      throw new Error(
        `CodeGen: not in block "${T ? `${x.kind}/${T.kind}` : x.kind}"`,
      );
    }
    _elseNode(x) {
      const T = this._currNode;
      if (!(T instanceof v)) throw new Error('CodeGen: "else" without "if"');
      return (this._currNode = T.else = x), this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const x = this._nodes;
      return x[x.length - 1];
    }
    set _currNode(x) {
      const T = this._nodes;
      T[T.length - 1] = x;
    }
  }
  e.CodeGen = Q;
  function j(F, x) {
    for (const T in x) F[T] = (F[T] || 0) + (x[T] || 0);
    return F;
  }
  function H(F, x) {
    return x instanceof t._CodeOrName ? j(F, x.names) : F;
  }
  function q(F, x, T) {
    if (F instanceof t.Name) return V(F);
    if (!B(F)) return F;
    return new t._Code(
      F._items.reduce(
        (N, ce) => (
          ce instanceof t.Name && (ce = V(ce)),
          ce instanceof t._Code ? N.push(...ce._items) : N.push(ce),
          N
        ),
        [],
      ),
    );
    function V(N) {
      const ce = T[N.str];
      return ce === void 0 || x[N.str] !== 1 ? N : (delete x[N.str], ce);
    }
    function B(N) {
      return (
        N instanceof t._Code &&
        N._items.some(
          (ce) =>
            ce instanceof t.Name && x[ce.str] === 1 && T[ce.str] !== void 0,
        )
      );
    }
  }
  function J(F, x) {
    for (const T in x) F[T] = (F[T] || 0) - (x[T] || 0);
  }
  function Z(F) {
    return typeof F == "boolean" || typeof F == "number" || F === null
      ? !F
      : (0, t._)`!${W(F)}`;
  }
  e.not = Z;
  const z = k(e.operators.AND);
  function U(...F) {
    return F.reduce(z);
  }
  e.and = U;
  const G = k(e.operators.OR);
  function L(...F) {
    return F.reduce(G);
  }
  e.or = L;
  function k(F) {
    return (x, T) =>
      x === t.nil ? T : T === t.nil ? x : (0, t._)`${W(x)} ${F} ${W(T)}`;
  }
  function W(F) {
    return F instanceof t.Name ? F : (0, t._)`(${F})`;
  }
})($t);
var Ut = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.checkStrictMode =
      e.getErrorPath =
      e.Type =
      e.useFunc =
      e.setEvaluated =
      e.evaluatedPropsToName =
      e.mergeEvaluated =
      e.eachItem =
      e.unescapeJsonPointer =
      e.escapeJsonPointer =
      e.escapeFragment =
      e.unescapeFragment =
      e.schemaRefOrVal =
      e.schemaHasRulesButRef =
      e.schemaHasRules =
      e.checkUnknownRules =
      e.alwaysValidSchema =
      e.toHash =
        void 0);
  const t = $t,
    n = Ml;
  function r(A) {
    const I = {};
    for (const S of A) I[S] = !0;
    return I;
  }
  e.toHash = r;
  function i(A, I) {
    return typeof I == "boolean"
      ? I
      : Object.keys(I).length === 0
      ? !0
      : (a(A, I), !s(I, A.self.RULES.all));
  }
  e.alwaysValidSchema = i;
  function a(A, I = A.schema) {
    const { opts: S, self: w } = A;
    if (!S.strictSchema || typeof I == "boolean") return;
    const O = w.RULES.keywords;
    for (const Q in I) O[Q] || R(A, `unknown keyword: "${Q}"`);
  }
  e.checkUnknownRules = a;
  function s(A, I) {
    if (typeof A == "boolean") return !A;
    for (const S in A) if (I[S]) return !0;
    return !1;
  }
  e.schemaHasRules = s;
  function o(A, I) {
    if (typeof A == "boolean") return !A;
    for (const S in A) if (S !== "$ref" && I.all[S]) return !0;
    return !1;
  }
  e.schemaHasRulesButRef = o;
  function c({ topSchemaRef: A, schemaPath: I }, S, w, O) {
    if (!O) {
      if (typeof S == "number" || typeof S == "boolean") return S;
      if (typeof S == "string") return (0, t._)`${S}`;
    }
    return (0, t._)`${A}${I}${(0, t.getProperty)(w)}`;
  }
  e.schemaRefOrVal = c;
  function l(A) {
    return d(decodeURIComponent(A));
  }
  e.unescapeFragment = l;
  function f(A) {
    return encodeURIComponent(u(A));
  }
  e.escapeFragment = f;
  function u(A) {
    return typeof A == "number"
      ? `${A}`
      : A.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  e.escapeJsonPointer = u;
  function d(A) {
    return A.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  e.unescapeJsonPointer = d;
  function p(A, I) {
    if (Array.isArray(A)) for (const S of A) I(S);
    else I(A);
  }
  e.eachItem = p;
  function h({
    mergeNames: A,
    mergeToName: I,
    mergeValues: S,
    resultToName: w,
  }) {
    return (O, Q, j, H) => {
      const q =
        j === void 0
          ? Q
          : j instanceof t.Name
          ? (Q instanceof t.Name ? A(O, Q, j) : I(O, Q, j), j)
          : Q instanceof t.Name
          ? (I(O, j, Q), Q)
          : S(Q, j);
      return H === t.Name && !(q instanceof t.Name) ? w(O, q) : q;
    };
  }
  e.mergeEvaluated = {
    props: h({
      mergeNames: (A, I, S) =>
        A.if((0, t._)`${S} !== true && ${I} !== undefined`, () => {
          A.if(
            (0, t._)`${I} === true`,
            () => A.assign(S, !0),
            () =>
              A.assign(S, (0, t._)`${S} || {}`).code(
                (0, t._)`Object.assign(${S}, ${I})`,
              ),
          );
        }),
      mergeToName: (A, I, S) =>
        A.if((0, t._)`${S} !== true`, () => {
          I === !0
            ? A.assign(S, !0)
            : (A.assign(S, (0, t._)`${S} || {}`), g(A, S, I));
        }),
      mergeValues: (A, I) => (A === !0 ? !0 : { ...A, ...I }),
      resultToName: m,
    }),
    items: h({
      mergeNames: (A, I, S) =>
        A.if((0, t._)`${S} !== true && ${I} !== undefined`, () =>
          A.assign(
            S,
            (0, t._)`${I} === true ? true : ${S} > ${I} ? ${S} : ${I}`,
          ),
        ),
      mergeToName: (A, I, S) =>
        A.if((0, t._)`${S} !== true`, () =>
          A.assign(S, I === !0 ? !0 : (0, t._)`${S} > ${I} ? ${S} : ${I}`),
        ),
      mergeValues: (A, I) => (A === !0 ? !0 : Math.max(A, I)),
      resultToName: (A, I) => A.var("items", I),
    }),
  };
  function m(A, I) {
    if (I === !0) return A.var("props", !0);
    const S = A.var("props", (0, t._)`{}`);
    return I !== void 0 && g(A, S, I), S;
  }
  e.evaluatedPropsToName = m;
  function g(A, I, S) {
    Object.keys(S).forEach((w) =>
      A.assign((0, t._)`${I}${(0, t.getProperty)(w)}`, !0),
    );
  }
  e.setEvaluated = g;
  const v = {};
  function y(A, I) {
    return A.scopeValue("func", {
      ref: I,
      code: v[I.code] || (v[I.code] = new n._Code(I.code)),
    });
  }
  e.useFunc = y;
  var _;
  (function (A) {
    (A[(A.Num = 0)] = "Num"), (A[(A.Str = 1)] = "Str");
  })((_ = e.Type || (e.Type = {})));
  function E(A, I, S) {
    if (A instanceof t.Name) {
      const w = I === _.Num;
      return S
        ? w
          ? (0, t._)`"[" + ${A} + "]"`
          : (0, t._)`"['" + ${A} + "']"`
        : w
        ? (0, t._)`"/" + ${A}`
        : (0, t._)`"/" + ${A}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return S ? (0, t.getProperty)(A).toString() : "/" + u(A);
  }
  e.getErrorPath = E;
  function R(A, I, S = A.opts.strictSchema) {
    if (S) {
      if (((I = `strict mode: ${I}`), S === !0)) throw new Error(I);
      A.self.logger.warn(I);
    }
  }
  e.checkStrictMode = R;
})(Ut);
var Wi = {};
Object.defineProperty(Wi, "__esModule", { value: !0 });
const or = $t,
  Qq = {
    data: new or.Name("data"),
    valCxt: new or.Name("valCxt"),
    instancePath: new or.Name("instancePath"),
    parentData: new or.Name("parentData"),
    parentDataProperty: new or.Name("parentDataProperty"),
    rootData: new or.Name("rootData"),
    dynamicAnchors: new or.Name("dynamicAnchors"),
    vErrors: new or.Name("vErrors"),
    errors: new or.Name("errors"),
    this: new or.Name("this"),
    self: new or.Name("self"),
    scope: new or.Name("scope"),
    json: new or.Name("json"),
    jsonPos: new or.Name("jsonPos"),
    jsonLen: new or.Name("jsonLen"),
    jsonPart: new or.Name("jsonPart"),
  };
Wi.default = Qq;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.extendErrors =
      e.resetErrorsCount =
      e.reportExtraError =
      e.reportError =
      e.keyword$DataError =
      e.keywordError =
        void 0);
  const t = $t,
    n = Ut,
    r = Wi;
  (e.keywordError = {
    message: ({ keyword: g }) =>
      (0, t.str)`must pass "${g}" keyword validation`,
  }),
    (e.keyword$DataError = {
      message: ({ keyword: g, schemaType: v }) =>
        v
          ? (0, t.str)`"${g}" keyword must be ${v} ($data)`
          : (0, t.str)`"${g}" keyword is invalid ($data)`,
    });
  function i(g, v = e.keywordError, y, _) {
    const { it: E } = g,
      { gen: R, compositeRule: A, allErrors: I } = E,
      S = u(g, v, y);
    _ ?? (A || I) ? c(R, S) : l(E, (0, t._)`[${S}]`);
  }
  e.reportError = i;
  function a(g, v = e.keywordError, y) {
    const { it: _ } = g,
      { gen: E, compositeRule: R, allErrors: A } = _,
      I = u(g, v, y);
    c(E, I), R || A || l(_, r.default.vErrors);
  }
  e.reportExtraError = a;
  function s(g, v) {
    g.assign(r.default.errors, v),
      g.if((0, t._)`${r.default.vErrors} !== null`, () =>
        g.if(
          v,
          () => g.assign((0, t._)`${r.default.vErrors}.length`, v),
          () => g.assign(r.default.vErrors, null),
        ),
      );
  }
  e.resetErrorsCount = s;
  function o({
    gen: g,
    keyword: v,
    schemaValue: y,
    data: _,
    errsCount: E,
    it: R,
  }) {
    if (E === void 0) throw new Error("ajv implementation error");
    const A = g.name("err");
    g.forRange("i", E, r.default.errors, (I) => {
      g.const(A, (0, t._)`${r.default.vErrors}[${I}]`),
        g.if((0, t._)`${A}.instancePath === undefined`, () =>
          g.assign(
            (0, t._)`${A}.instancePath`,
            (0, t.strConcat)(r.default.instancePath, R.errorPath),
          ),
        ),
        g.assign(
          (0, t._)`${A}.schemaPath`,
          (0, t.str)`${R.errSchemaPath}/${v}`,
        ),
        R.opts.verbose &&
          (g.assign((0, t._)`${A}.schema`, y),
          g.assign((0, t._)`${A}.data`, _));
    });
  }
  e.extendErrors = o;
  function c(g, v) {
    const y = g.const("err", v);
    g.if(
      (0, t._)`${r.default.vErrors} === null`,
      () => g.assign(r.default.vErrors, (0, t._)`[${y}]`),
      (0, t._)`${r.default.vErrors}.push(${y})`,
    ),
      g.code((0, t._)`${r.default.errors}++`);
  }
  function l(g, v) {
    const { gen: y, validateName: _, schemaEnv: E } = g;
    E.$async
      ? y.throw((0, t._)`new ${g.ValidationError}(${v})`)
      : (y.assign((0, t._)`${_}.errors`, v), y.return(!1));
  }
  const f = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema"),
  };
  function u(g, v, y) {
    const { createErrors: _ } = g.it;
    return _ === !1 ? (0, t._)`{}` : d(g, v, y);
  }
  function d(g, v, y = {}) {
    const { gen: _, it: E } = g,
      R = [p(E, y), h(g, y)];
    return m(g, v, R), _.object(...R);
  }
  function p({ errorPath: g }, { instancePath: v }) {
    const y = v ? (0, t.str)`${g}${(0, n.getErrorPath)(v, n.Type.Str)}` : g;
    return [
      r.default.instancePath,
      (0, t.strConcat)(r.default.instancePath, y),
    ];
  }
  function h(
    { keyword: g, it: { errSchemaPath: v } },
    { schemaPath: y, parentSchema: _ },
  ) {
    let E = _ ? v : (0, t.str)`${v}/${g}`;
    return (
      y && (E = (0, t.str)`${E}${(0, n.getErrorPath)(y, n.Type.Str)}`),
      [f.schemaPath, E]
    );
  }
  function m(g, { params: v, message: y }, _) {
    const { keyword: E, data: R, schemaValue: A, it: I } = g,
      { opts: S, propertyName: w, topSchemaRef: O, schemaPath: Q } = I;
    _.push(
      [f.keyword, E],
      [f.params, typeof v == "function" ? v(g) : v || (0, t._)`{}`],
    ),
      S.messages && _.push([f.message, typeof y == "function" ? y(g) : y]),
      S.verbose &&
        _.push(
          [f.schema, A],
          [f.parentSchema, (0, t._)`${O}${Q}`],
          [r.default.data, R],
        ),
      w && _.push([f.propertyName, w]);
  }
})(cu);
Object.defineProperty(ac, "__esModule", { value: !0 });
ac.boolOrEmptySchema = ac.topBoolOrEmptySchema = void 0;
const Wq = cu,
  zq = $t,
  Kq = Wi,
  Vq = { message: "boolean schema is false" };
function Yq(e) {
  const { gen: t, schema: n, validateName: r } = e;
  n === !1
    ? b4(e, !1)
    : typeof n == "object" && n.$async === !0
    ? t.return(Kq.default.data)
    : (t.assign((0, zq._)`${r}.errors`, null), t.return(!0));
}
ac.topBoolOrEmptySchema = Yq;
function Xq(e, t) {
  const { gen: n, schema: r } = e;
  r === !1 ? (n.var(t, !1), b4(e)) : n.var(t, !0);
}
ac.boolOrEmptySchema = Xq;
function b4(e, t) {
  const { gen: n, data: r } = e,
    i = {
      gen: n,
      keyword: "false schema",
      data: r,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: e,
    };
  (0, Wq.reportError)(i, Vq, void 0, t);
}
var lu = {},
  Fs = {};
Object.defineProperty(Fs, "__esModule", { value: !0 });
Fs.getRules = Fs.isJSONType = void 0;
const Jq = [
    "string",
    "number",
    "integer",
    "boolean",
    "null",
    "object",
    "array",
  ],
  Zq = new Set(Jq);
function eG(e) {
  return typeof e == "string" && Zq.has(e);
}
Fs.isJSONType = eG;
function tG() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] },
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {},
  };
}
Fs.getRules = tG;
var la = {};
Object.defineProperty(la, "__esModule", { value: !0 });
la.shouldUseRule = la.shouldUseGroup = la.schemaHasRulesForType = void 0;
function nG({ schema: e, self: t }, n) {
  const r = t.RULES.types[n];
  return r && r !== !0 && _4(e, r);
}
la.schemaHasRulesForType = nG;
function _4(e, t) {
  return t.rules.some((n) => E4(e, n));
}
la.shouldUseGroup = _4;
function E4(e, t) {
  var n;
  return (
    e[t.keyword] !== void 0 ||
    ((n = t.definition.implements) === null || n === void 0
      ? void 0
      : n.some((r) => e[r] !== void 0))
  );
}
la.shouldUseRule = E4;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.reportTypeError =
      e.checkDataTypes =
      e.checkDataType =
      e.coerceAndCheckDataType =
      e.getJSONTypes =
      e.getSchemaTypes =
      e.DataType =
        void 0);
  const t = Fs,
    n = la,
    r = cu,
    i = $t,
    a = Ut;
  var s;
  (function (_) {
    (_[(_.Correct = 0)] = "Correct"), (_[(_.Wrong = 1)] = "Wrong");
  })((s = e.DataType || (e.DataType = {})));
  function o(_) {
    const E = c(_.type);
    if (E.includes("null")) {
      if (_.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!E.length && _.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      _.nullable === !0 && E.push("null");
    }
    return E;
  }
  e.getSchemaTypes = o;
  function c(_) {
    const E = Array.isArray(_) ? _ : _ ? [_] : [];
    if (E.every(t.isJSONType)) return E;
    throw new Error("type must be JSONType or JSONType[]: " + E.join(","));
  }
  e.getJSONTypes = c;
  function l(_, E) {
    const { gen: R, data: A, opts: I } = _,
      S = u(E, I.coerceTypes),
      w =
        E.length > 0 &&
        !(
          S.length === 0 &&
          E.length === 1 &&
          (0, n.schemaHasRulesForType)(_, E[0])
        );
    if (w) {
      const O = m(E, A, I.strictNumbers, s.Wrong);
      R.if(O, () => {
        S.length ? d(_, E, S) : v(_);
      });
    }
    return w;
  }
  e.coerceAndCheckDataType = l;
  const f = new Set(["string", "number", "integer", "boolean", "null"]);
  function u(_, E) {
    return E
      ? _.filter((R) => f.has(R) || (E === "array" && R === "array"))
      : [];
  }
  function d(_, E, R) {
    const { gen: A, data: I, opts: S } = _,
      w = A.let("dataType", (0, i._)`typeof ${I}`),
      O = A.let("coerced", (0, i._)`undefined`);
    S.coerceTypes === "array" &&
      A.if(
        (0, i._)`${w} == 'object' && Array.isArray(${I}) && ${I}.length == 1`,
        () =>
          A.assign(I, (0, i._)`${I}[0]`)
            .assign(w, (0, i._)`typeof ${I}`)
            .if(m(E, I, S.strictNumbers), () => A.assign(O, I)),
      ),
      A.if((0, i._)`${O} !== undefined`);
    for (const j of R)
      (f.has(j) || (j === "array" && S.coerceTypes === "array")) && Q(j);
    A.else(),
      v(_),
      A.endIf(),
      A.if((0, i._)`${O} !== undefined`, () => {
        A.assign(I, O), p(_, O);
      });
    function Q(j) {
      switch (j) {
        case "string":
          A.elseIf((0, i._)`${w} == "number" || ${w} == "boolean"`)
            .assign(O, (0, i._)`"" + ${I}`)
            .elseIf((0, i._)`${I} === null`)
            .assign(O, (0, i._)`""`);
          return;
        case "number":
          A.elseIf(
            (0, i._)`${w} == "boolean" || ${I} === null
              || (${w} == "string" && ${I} && ${I} == +${I})`,
          ).assign(O, (0, i._)`+${I}`);
          return;
        case "integer":
          A.elseIf(
            (0, i._)`${w} === "boolean" || ${I} === null
              || (${w} === "string" && ${I} && ${I} == +${I} && !(${I} % 1))`,
          ).assign(O, (0, i._)`+${I}`);
          return;
        case "boolean":
          A.elseIf((0, i._)`${I} === "false" || ${I} === 0 || ${I} === null`)
            .assign(O, !1)
            .elseIf((0, i._)`${I} === "true" || ${I} === 1`)
            .assign(O, !0);
          return;
        case "null":
          A.elseIf((0, i._)`${I} === "" || ${I} === 0 || ${I} === false`),
            A.assign(O, null);
          return;
        case "array":
          A.elseIf(
            (0, i._)`${w} === "string" || ${w} === "number"
              || ${w} === "boolean" || ${I} === null`,
          ).assign(O, (0, i._)`[${I}]`);
      }
    }
  }
  function p({ gen: _, parentData: E, parentDataProperty: R }, A) {
    _.if((0, i._)`${E} !== undefined`, () => _.assign((0, i._)`${E}[${R}]`, A));
  }
  function h(_, E, R, A = s.Correct) {
    const I = A === s.Correct ? i.operators.EQ : i.operators.NEQ;
    let S;
    switch (_) {
      case "null":
        return (0, i._)`${E} ${I} null`;
      case "array":
        S = (0, i._)`Array.isArray(${E})`;
        break;
      case "object":
        S = (0, i._)`${E} && typeof ${E} == "object" && !Array.isArray(${E})`;
        break;
      case "integer":
        S = w((0, i._)`!(${E} % 1) && !isNaN(${E})`);
        break;
      case "number":
        S = w();
        break;
      default:
        return (0, i._)`typeof ${E} ${I} ${_}`;
    }
    return A === s.Correct ? S : (0, i.not)(S);
    function w(O = i.nil) {
      return (0, i.and)(
        (0, i._)`typeof ${E} == "number"`,
        O,
        R ? (0, i._)`isFinite(${E})` : i.nil,
      );
    }
  }
  e.checkDataType = h;
  function m(_, E, R, A) {
    if (_.length === 1) return h(_[0], E, R, A);
    let I;
    const S = (0, a.toHash)(_);
    if (S.array && S.object) {
      const w = (0, i._)`typeof ${E} != "object"`;
      (I = S.null ? w : (0, i._)`!${E} || ${w}`),
        delete S.null,
        delete S.array,
        delete S.object;
    } else I = i.nil;
    S.number && delete S.integer;
    for (const w in S) I = (0, i.and)(I, h(w, E, R, A));
    return I;
  }
  e.checkDataTypes = m;
  const g = {
    message: ({ schema: _ }) => `must be ${_}`,
    params: ({ schema: _, schemaValue: E }) =>
      typeof _ == "string" ? (0, i._)`{type: ${_}}` : (0, i._)`{type: ${E}}`,
  };
  function v(_) {
    const E = y(_);
    (0, r.reportError)(E, g);
  }
  e.reportTypeError = v;
  function y(_) {
    const { gen: E, data: R, schema: A } = _,
      I = (0, a.schemaRefOrVal)(_, A, "type");
    return {
      gen: E,
      keyword: "type",
      data: R,
      schema: A.type,
      schemaCode: I,
      schemaValue: I,
      parentSchema: A,
      params: {},
      it: _,
    };
  }
})(lu);
var Ip = {};
Object.defineProperty(Ip, "__esModule", { value: !0 });
Ip.assignDefaults = void 0;
const uo = $t,
  rG = Ut;
function iG(e, t) {
  const { properties: n, items: r } = e.schema;
  if (t === "object" && n) for (const i in n) bx(e, i, n[i].default);
  else
    t === "array" &&
      Array.isArray(r) &&
      r.forEach((i, a) => bx(e, a, i.default));
}
Ip.assignDefaults = iG;
function bx(e, t, n) {
  const { gen: r, compositeRule: i, data: a, opts: s } = e;
  if (n === void 0) return;
  const o = (0, uo._)`${a}${(0, uo.getProperty)(t)}`;
  if (i) {
    (0, rG.checkStrictMode)(e, `default is ignored for: ${o}`);
    return;
  }
  let c = (0, uo._)`${o} === undefined`;
  s.useDefaults === "empty" &&
    (c = (0, uo._)`${c} || ${o} === null || ${o} === ""`),
    r.if(c, (0, uo._)`${o} = ${(0, uo.stringify)(n)}`);
}
var Fi = {},
  St = {};
Object.defineProperty(St, "__esModule", { value: !0 });
St.validateUnion =
  St.validateArray =
  St.usePattern =
  St.callValidateCode =
  St.schemaProperties =
  St.allSchemaProperties =
  St.noPropertyInData =
  St.propertyInData =
  St.isOwnProperty =
  St.hasPropFunc =
  St.reportMissingProp =
  St.checkMissingProp =
  St.checkReportMissingProp =
    void 0;
const dn = $t,
  my = Ut,
  _a = Wi,
  aG = Ut;
function sG(e, t) {
  const { gen: n, data: r, it: i } = e;
  n.if(vy(n, r, t, i.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, dn._)`${t}` }, !0), e.error();
  });
}
St.checkReportMissingProp = sG;
function oG({ gen: e, data: t, it: { opts: n } }, r, i) {
  return (0, dn.or)(
    ...r.map((a) =>
      (0, dn.and)(vy(e, t, a, n.ownProperties), (0, dn._)`${i} = ${a}`),
    ),
  );
}
St.checkMissingProp = oG;
function cG(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
St.reportMissingProp = cG;
function w4(e) {
  return e.scopeValue("func", {
    ref: Object.prototype.hasOwnProperty,
    code: (0, dn._)`Object.prototype.hasOwnProperty`,
  });
}
St.hasPropFunc = w4;
function gy(e, t, n) {
  return (0, dn._)`${w4(e)}.call(${t}, ${n})`;
}
St.isOwnProperty = gy;
function lG(e, t, n, r) {
  const i = (0, dn._)`${t}${(0, dn.getProperty)(n)} !== undefined`;
  return r ? (0, dn._)`${i} && ${gy(e, t, n)}` : i;
}
St.propertyInData = lG;
function vy(e, t, n, r) {
  const i = (0, dn._)`${t}${(0, dn.getProperty)(n)} === undefined`;
  return r ? (0, dn.or)(i, (0, dn.not)(gy(e, t, n))) : i;
}
St.noPropertyInData = vy;
function x4(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
St.allSchemaProperties = x4;
function uG(e, t) {
  return x4(t).filter((n) => !(0, my.alwaysValidSchema)(e, t[n]));
}
St.schemaProperties = uG;
function fG(
  {
    schemaCode: e,
    data: t,
    it: { gen: n, topSchemaRef: r, schemaPath: i, errorPath: a },
    it: s,
  },
  o,
  c,
  l,
) {
  const f = l ? (0, dn._)`${e}, ${t}, ${r}${i}` : t,
    u = [
      [_a.default.instancePath, (0, dn.strConcat)(_a.default.instancePath, a)],
      [_a.default.parentData, s.parentData],
      [_a.default.parentDataProperty, s.parentDataProperty],
      [_a.default.rootData, _a.default.rootData],
    ];
  s.opts.dynamicRef &&
    u.push([_a.default.dynamicAnchors, _a.default.dynamicAnchors]);
  const d = (0, dn._)`${f}, ${n.object(...u)}`;
  return c !== dn.nil
    ? (0, dn._)`${o}.call(${c}, ${d})`
    : (0, dn._)`${o}(${d})`;
}
St.callValidateCode = fG;
const dG = (0, dn._)`new RegExp`;
function pG({ gen: e, it: { opts: t } }, n) {
  const r = t.unicodeRegExp ? "u" : "",
    { regExp: i } = t.code,
    a = i(n, r);
  return e.scopeValue("pattern", {
    key: a.toString(),
    ref: a,
    code: (0, dn._)`${
      i.code === "new RegExp" ? dG : (0, aG.useFunc)(e, i)
    }(${n}, ${r})`,
  });
}
St.usePattern = pG;
function hG(e) {
  const { gen: t, data: n, keyword: r, it: i } = e,
    a = t.name("valid");
  if (i.allErrors) {
    const o = t.let("valid", !0);
    return s(() => t.assign(o, !1)), o;
  }
  return t.var(a, !0), s(() => t.break()), a;
  function s(o) {
    const c = t.const("len", (0, dn._)`${n}.length`);
    t.forRange("i", 0, c, (l) => {
      e.subschema({ keyword: r, dataProp: l, dataPropType: my.Type.Num }, a),
        t.if((0, dn.not)(a), o);
    });
  }
}
St.validateArray = hG;
function mG(e) {
  const { gen: t, schema: n, keyword: r, it: i } = e;
  if (!Array.isArray(n)) throw new Error("ajv implementation error");
  if (n.some((c) => (0, my.alwaysValidSchema)(i, c)) && !i.opts.unevaluated)
    return;
  const s = t.let("valid", !1),
    o = t.name("_valid");
  t.block(() =>
    n.forEach((c, l) => {
      const f = e.subschema(
        { keyword: r, schemaProp: l, compositeRule: !0 },
        o,
      );
      t.assign(s, (0, dn._)`${s} || ${o}`),
        e.mergeValidEvaluated(f, o) || t.if((0, dn.not)(s));
    }),
  ),
    e.result(
      s,
      () => e.reset(),
      () => e.error(!0),
    );
}
St.validateUnion = mG;
Object.defineProperty(Fi, "__esModule", { value: !0 });
Fi.validateKeywordUsage =
  Fi.validSchemaType =
  Fi.funcKeywordCode =
  Fi.macroKeywordCode =
    void 0;
const br = $t,
  ys = Wi,
  gG = St,
  vG = cu;
function yG(e, t) {
  const { gen: n, keyword: r, schema: i, parentSchema: a, it: s } = e,
    o = t.macro.call(s.self, i, a, s),
    c = A4(n, r, o);
  s.opts.validateSchema !== !1 && s.self.validateSchema(o, !0);
  const l = n.name("valid");
  e.subschema(
    {
      schema: o,
      schemaPath: br.nil,
      errSchemaPath: `${s.errSchemaPath}/${r}`,
      topSchemaRef: c,
      compositeRule: !0,
    },
    l,
  ),
    e.pass(l, () => e.error(!0));
}
Fi.macroKeywordCode = yG;
function bG(e, t) {
  var n;
  const { gen: r, keyword: i, schema: a, parentSchema: s, $data: o, it: c } = e;
  EG(c, t);
  const l = !o && t.compile ? t.compile.call(c.self, a, s, c) : t.validate,
    f = A4(r, i, l),
    u = r.let("valid");
  e.block$data(u, d), e.ok((n = t.valid) !== null && n !== void 0 ? n : u);
  function d() {
    if (t.errors === !1) m(), t.modifying && _x(e), g(() => e.error());
    else {
      const v = t.async ? p() : h();
      t.modifying && _x(e), g(() => _G(e, v));
    }
  }
  function p() {
    const v = r.let("ruleErrs", null);
    return (
      r.try(
        () => m((0, br._)`await `),
        (y) =>
          r.assign(u, !1).if(
            (0, br._)`${y} instanceof ${c.ValidationError}`,
            () => r.assign(v, (0, br._)`${y}.errors`),
            () => r.throw(y),
          ),
      ),
      v
    );
  }
  function h() {
    const v = (0, br._)`${f}.errors`;
    return r.assign(v, null), m(br.nil), v;
  }
  function m(v = t.async ? (0, br._)`await ` : br.nil) {
    const y = c.opts.passContext ? ys.default.this : ys.default.self,
      _ = !(("compile" in t && !o) || t.schema === !1);
    r.assign(
      u,
      (0, br._)`${v}${(0, gG.callValidateCode)(e, f, y, _)}`,
      t.modifying,
    );
  }
  function g(v) {
    var y;
    r.if((0, br.not)((y = t.valid) !== null && y !== void 0 ? y : u), v);
  }
}
Fi.funcKeywordCode = bG;
function _x(e) {
  const { gen: t, data: n, it: r } = e;
  t.if(r.parentData, () =>
    t.assign(n, (0, br._)`${r.parentData}[${r.parentDataProperty}]`),
  );
}
function _G(e, t) {
  const { gen: n } = e;
  n.if(
    (0, br._)`Array.isArray(${t})`,
    () => {
      n
        .assign(
          ys.default.vErrors,
          (0,
          br._)`${ys.default.vErrors} === null ? ${t} : ${ys.default.vErrors}.concat(${t})`,
        )
        .assign(ys.default.errors, (0, br._)`${ys.default.vErrors}.length`),
        (0, vG.extendErrors)(e);
    },
    () => e.error(),
  );
}
function EG({ schemaEnv: e }, t) {
  if (t.async && !e.$async) throw new Error("async keyword in sync schema");
}
function A4(e, t, n) {
  if (n === void 0) throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue(
    "keyword",
    typeof n == "function"
      ? { ref: n }
      : { ref: n, code: (0, br.stringify)(n) },
  );
}
function wG(e, t, n = !1) {
  return (
    !t.length ||
    t.some((r) =>
      r === "array"
        ? Array.isArray(e)
        : r === "object"
        ? e && typeof e == "object" && !Array.isArray(e)
        : typeof e == r || (n && typeof e > "u"),
    )
  );
}
Fi.validSchemaType = wG;
function xG({ schema: e, opts: t, self: n, errSchemaPath: r }, i, a) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(a) : i.keyword !== a)
    throw new Error("ajv implementation error");
  const s = i.dependencies;
  if (s != null && s.some((o) => !Object.prototype.hasOwnProperty.call(e, o)))
    throw new Error(
      `parent schema must have dependencies of ${a}: ${s.join(",")}`,
    );
  if (i.validateSchema && !i.validateSchema(e[a])) {
    const c =
      `keyword "${a}" value is invalid at path "${r}": ` +
      n.errorsText(i.validateSchema.errors);
    if (t.validateSchema === "log") n.logger.error(c);
    else throw new Error(c);
  }
}
Fi.validateKeywordUsage = xG;
var Ga = {};
Object.defineProperty(Ga, "__esModule", { value: !0 });
Ga.extendSubschemaMode = Ga.extendSubschemaData = Ga.getSubschema = void 0;
const Di = $t,
  S4 = Ut;
function AG(
  e,
  {
    keyword: t,
    schemaProp: n,
    schema: r,
    schemaPath: i,
    errSchemaPath: a,
    topSchemaRef: s,
  },
) {
  if (t !== void 0 && r !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const o = e.schema[t];
    return n === void 0
      ? {
          schema: o,
          schemaPath: (0, Di._)`${e.schemaPath}${(0, Di.getProperty)(t)}`,
          errSchemaPath: `${e.errSchemaPath}/${t}`,
        }
      : {
          schema: o[n],
          schemaPath: (0, Di._)`${e.schemaPath}${(0, Di.getProperty)(t)}${(0,
          Di.getProperty)(n)}`,
          errSchemaPath: `${e.errSchemaPath}/${t}/${(0, S4.escapeFragment)(n)}`,
        };
  }
  if (r !== void 0) {
    if (i === void 0 || a === void 0 || s === void 0)
      throw new Error(
        '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"',
      );
    return { schema: r, schemaPath: i, topSchemaRef: s, errSchemaPath: a };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
Ga.getSubschema = AG;
function SG(
  e,
  t,
  { dataProp: n, dataPropType: r, data: i, dataTypes: a, propertyName: s },
) {
  if (i !== void 0 && n !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: o } = t;
  if (n !== void 0) {
    const { errorPath: l, dataPathArr: f, opts: u } = t,
      d = o.let("data", (0, Di._)`${t.data}${(0, Di.getProperty)(n)}`, !0);
    c(d),
      (e.errorPath = (0, Di.str)`${l}${(0, S4.getErrorPath)(
        n,
        r,
        u.jsPropertySyntax,
      )}`),
      (e.parentDataProperty = (0, Di._)`${n}`),
      (e.dataPathArr = [...f, e.parentDataProperty]);
  }
  if (i !== void 0) {
    const l = i instanceof Di.Name ? i : o.let("data", i, !0);
    c(l), s !== void 0 && (e.propertyName = s);
  }
  a && (e.dataTypes = a);
  function c(l) {
    (e.data = l),
      (e.dataLevel = t.dataLevel + 1),
      (e.dataTypes = []),
      (t.definedProperties = new Set()),
      (e.parentData = t.data),
      (e.dataNames = [...t.dataNames, l]);
  }
}
Ga.extendSubschemaData = SG;
function IG(
  e,
  {
    jtdDiscriminator: t,
    jtdMetadata: n,
    compositeRule: r,
    createErrors: i,
    allErrors: a,
  },
) {
  r !== void 0 && (e.compositeRule = r),
    i !== void 0 && (e.createErrors = i),
    a !== void 0 && (e.allErrors = a),
    (e.jtdDiscriminator = t),
    (e.jtdMetadata = n);
}
Ga.extendSubschemaMode = IG;
var nr = {},
  $p = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, i, a;
      if (Array.isArray(t)) {
        if (((r = t.length), r != n.length)) return !1;
        for (i = r; i-- !== 0; ) if (!e(t[i], n[i])) return !1;
        return !0;
      }
      if (t.constructor === RegExp)
        return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf)
        return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString)
        return t.toString() === n.toString();
      if (((a = Object.keys(t)), (r = a.length), r !== Object.keys(n).length))
        return !1;
      for (i = r; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(n, a[i])) return !1;
      for (i = r; i-- !== 0; ) {
        var s = a[i];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  },
  I4 = { exports: {} },
  Fa = (I4.exports = function (e, t, n) {
    typeof t == "function" && ((n = t), (t = {})), (n = t.cb || n);
    var r = typeof n == "function" ? n : n.pre || function () {},
      i = n.post || function () {};
    Mf(t, r, i, e, "", e);
  });
Fa.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0,
};
Fa.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 };
Fa.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0,
};
Fa.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0,
};
function Mf(e, t, n, r, i, a, s, o, c, l) {
  if (r && typeof r == "object" && !Array.isArray(r)) {
    t(r, i, a, s, o, c, l);
    for (var f in r) {
      var u = r[f];
      if (Array.isArray(u)) {
        if (f in Fa.arrayKeywords)
          for (var d = 0; d < u.length; d++)
            Mf(e, t, n, u[d], i + "/" + f + "/" + d, a, i, f, r, d);
      } else if (f in Fa.propsKeywords) {
        if (u && typeof u == "object")
          for (var p in u)
            Mf(e, t, n, u[p], i + "/" + f + "/" + $G(p), a, i, f, r, p);
      } else
        (f in Fa.keywords || (e.allKeys && !(f in Fa.skipKeywords))) &&
          Mf(e, t, n, u, i + "/" + f, a, i, f, r);
    }
    n(r, i, a, s, o, c, l);
  }
}
function $G(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var CG = I4.exports;
Object.defineProperty(nr, "__esModule", { value: !0 });
nr.getSchemaRefs =
  nr.resolveUrl =
  nr.normalizeId =
  nr._getFullPath =
  nr.getFullPath =
  nr.inlineRef =
    void 0;
const RG = Ut,
  kG = $p,
  TG = CG,
  NG = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
  ]);
function OG(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !_0(e) : t ? $4(e) <= t : !1;
}
nr.inlineRef = OG;
const PG = new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor",
]);
function _0(e) {
  for (const t in e) {
    if (PG.has(t)) return !0;
    const n = e[t];
    if ((Array.isArray(n) && n.some(_0)) || (typeof n == "object" && _0(n)))
      return !0;
  }
  return !1;
}
function $4(e) {
  let t = 0;
  for (const n in e) {
    if (n === "$ref") return 1 / 0;
    if (
      (t++,
      !NG.has(n) &&
        (typeof e[n] == "object" && (0, RG.eachItem)(e[n], (r) => (t += $4(r))),
        t === 1 / 0))
    )
      return 1 / 0;
  }
  return t;
}
function C4(e, t = "", n) {
  n !== !1 && (t = Bo(t));
  const r = e.parse(t);
  return R4(e, r);
}
nr.getFullPath = C4;
function R4(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
nr._getFullPath = R4;
const DG = /#\/?$/;
function Bo(e) {
  return e ? e.replace(DG, "") : "";
}
nr.normalizeId = Bo;
function LG(e, t, n) {
  return (n = Bo(n)), e.resolve(t, n);
}
nr.resolveUrl = LG;
const BG = /^[a-z_][-a-z0-9._]*$/i;
function UG(e, t) {
  if (typeof e == "boolean") return {};
  const { schemaId: n, uriResolver: r } = this.opts,
    i = Bo(e[n] || t),
    a = { "": i },
    s = C4(r, i, !1),
    o = {},
    c = new Set();
  return (
    TG(e, { allKeys: !0 }, (u, d, p, h) => {
      if (h === void 0) return;
      const m = s + d;
      let g = a[h];
      typeof u[n] == "string" && (g = v.call(this, u[n])),
        y.call(this, u.$anchor),
        y.call(this, u.$dynamicAnchor),
        (a[d] = g);
      function v(_) {
        const E = this.opts.uriResolver.resolve;
        if (((_ = Bo(g ? E(g, _) : _)), c.has(_))) throw f(_);
        c.add(_);
        let R = this.refs[_];
        return (
          typeof R == "string" && (R = this.refs[R]),
          typeof R == "object"
            ? l(u, R.schema, _)
            : _ !== Bo(m) &&
              (_[0] === "#" ? (l(u, o[_], _), (o[_] = u)) : (this.refs[_] = m)),
          _
        );
      }
      function y(_) {
        if (typeof _ == "string") {
          if (!BG.test(_)) throw new Error(`invalid anchor "${_}"`);
          v.call(this, `#${_}`);
        }
      }
    }),
    o
  );
  function l(u, d, p) {
    if (d !== void 0 && !kG(u, d)) throw f(p);
  }
  function f(u) {
    return new Error(`reference "${u}" resolves to more than one schema`);
  }
}
nr.getSchemaRefs = UG;
Object.defineProperty(yi, "__esModule", { value: !0 });
yi.getData = yi.KeywordCxt = yi.validateFunctionCode = void 0;
const k4 = ac,
  Ex = lu,
  yy = la,
  bd = lu,
  FG = Ip,
  vl = Fi,
  $m = Ga,
  Ye = $t,
  gt = Wi,
  jG = nr,
  ua = Ut,
  Qc = cu;
function MG(e) {
  if (O4(e) && (P4(e), N4(e))) {
    GG(e);
    return;
  }
  T4(e, () => (0, k4.topBoolOrEmptySchema)(e));
}
yi.validateFunctionCode = MG;
function T4({ gen: e, validateName: t, schema: n, schemaEnv: r, opts: i }, a) {
  i.code.es5
    ? e.func(
        t,
        (0, Ye._)`${gt.default.data}, ${gt.default.valCxt}`,
        r.$async,
        () => {
          e.code((0, Ye._)`"use strict"; ${wx(n, i)}`), qG(e, i), e.code(a);
        },
      )
    : e.func(t, (0, Ye._)`${gt.default.data}, ${HG(i)}`, r.$async, () =>
        e.code(wx(n, i)).code(a),
      );
}
function HG(e) {
  return (0, Ye._)`{${gt.default.instancePath}="", ${gt.default.parentData}, ${
    gt.default.parentDataProperty
  }, ${gt.default.rootData}=${gt.default.data}${
    e.dynamicRef ? (0, Ye._)`, ${gt.default.dynamicAnchors}={}` : Ye.nil
  }}={}`;
}
function qG(e, t) {
  e.if(
    gt.default.valCxt,
    () => {
      e.var(
        gt.default.instancePath,
        (0, Ye._)`${gt.default.valCxt}.${gt.default.instancePath}`,
      ),
        e.var(
          gt.default.parentData,
          (0, Ye._)`${gt.default.valCxt}.${gt.default.parentData}`,
        ),
        e.var(
          gt.default.parentDataProperty,
          (0, Ye._)`${gt.default.valCxt}.${gt.default.parentDataProperty}`,
        ),
        e.var(
          gt.default.rootData,
          (0, Ye._)`${gt.default.valCxt}.${gt.default.rootData}`,
        ),
        t.dynamicRef &&
          e.var(
            gt.default.dynamicAnchors,
            (0, Ye._)`${gt.default.valCxt}.${gt.default.dynamicAnchors}`,
          );
    },
    () => {
      e.var(gt.default.instancePath, (0, Ye._)`""`),
        e.var(gt.default.parentData, (0, Ye._)`undefined`),
        e.var(gt.default.parentDataProperty, (0, Ye._)`undefined`),
        e.var(gt.default.rootData, gt.default.data),
        t.dynamicRef && e.var(gt.default.dynamicAnchors, (0, Ye._)`{}`);
    },
  );
}
function GG(e) {
  const { schema: t, opts: n, gen: r } = e;
  T4(e, () => {
    n.$comment && t.$comment && L4(e),
      VG(e),
      r.let(gt.default.vErrors, null),
      r.let(gt.default.errors, 0),
      n.unevaluated && QG(e),
      D4(e),
      JG(e);
  });
}
function QG(e) {
  const { gen: t, validateName: n } = e;
  (e.evaluated = t.const("evaluated", (0, Ye._)`${n}.evaluated`)),
    t.if((0, Ye._)`${e.evaluated}.dynamicProps`, () =>
      t.assign((0, Ye._)`${e.evaluated}.props`, (0, Ye._)`undefined`),
    ),
    t.if((0, Ye._)`${e.evaluated}.dynamicItems`, () =>
      t.assign((0, Ye._)`${e.evaluated}.items`, (0, Ye._)`undefined`),
    );
}
function wx(e, t) {
  const n = typeof e == "object" && e[t.schemaId];
  return n && (t.code.source || t.code.process)
    ? (0, Ye._)`/*# sourceURL=${n} */`
    : Ye.nil;
}
function WG(e, t) {
  if (O4(e) && (P4(e), N4(e))) {
    zG(e, t);
    return;
  }
  (0, k4.boolOrEmptySchema)(e, t);
}
function N4({ schema: e, self: t }) {
  if (typeof e == "boolean") return !e;
  for (const n in e) if (t.RULES.all[n]) return !0;
  return !1;
}
function O4(e) {
  return typeof e.schema != "boolean";
}
function zG(e, t) {
  const { schema: n, gen: r, opts: i } = e;
  i.$comment && n.$comment && L4(e), YG(e), XG(e);
  const a = r.const("_errs", gt.default.errors);
  D4(e, a), r.var(t, (0, Ye._)`${a} === ${gt.default.errors}`);
}
function P4(e) {
  (0, ua.checkUnknownRules)(e), KG(e);
}
function D4(e, t) {
  if (e.opts.jtd) return xx(e, [], !1, t);
  const n = (0, Ex.getSchemaTypes)(e.schema),
    r = (0, Ex.coerceAndCheckDataType)(e, n);
  xx(e, n, !r, t);
}
function KG(e) {
  const { schema: t, errSchemaPath: n, opts: r, self: i } = e;
  t.$ref &&
    r.ignoreKeywordsWithRef &&
    (0, ua.schemaHasRulesButRef)(t, i.RULES) &&
    i.logger.warn(`$ref: keywords ignored in schema at path "${n}"`);
}
function VG(e) {
  const { schema: t, opts: n } = e;
  t.default !== void 0 &&
    n.useDefaults &&
    n.strictSchema &&
    (0, ua.checkStrictMode)(e, "default is ignored in the schema root");
}
function YG(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, jG.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function XG(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function L4({ gen: e, schemaEnv: t, schema: n, errSchemaPath: r, opts: i }) {
  const a = n.$comment;
  if (i.$comment === !0) e.code((0, Ye._)`${gt.default.self}.logger.log(${a})`);
  else if (typeof i.$comment == "function") {
    const s = (0, Ye.str)`${r}/$comment`,
      o = e.scopeValue("root", { ref: t.root });
    e.code(
      (0, Ye._)`${gt.default.self}.opts.$comment(${a}, ${s}, ${o}.schema)`,
    );
  }
}
function JG(e) {
  const {
    gen: t,
    schemaEnv: n,
    validateName: r,
    ValidationError: i,
    opts: a,
  } = e;
  n.$async
    ? t.if(
        (0, Ye._)`${gt.default.errors} === 0`,
        () => t.return(gt.default.data),
        () => t.throw((0, Ye._)`new ${i}(${gt.default.vErrors})`),
      )
    : (t.assign((0, Ye._)`${r}.errors`, gt.default.vErrors),
      a.unevaluated && ZG(e),
      t.return((0, Ye._)`${gt.default.errors} === 0`));
}
function ZG({ gen: e, evaluated: t, props: n, items: r }) {
  n instanceof Ye.Name && e.assign((0, Ye._)`${t}.props`, n),
    r instanceof Ye.Name && e.assign((0, Ye._)`${t}.items`, r);
}
function xx(e, t, n, r) {
  const { gen: i, schema: a, data: s, allErrors: o, opts: c, self: l } = e,
    { RULES: f } = l;
  if (
    a.$ref &&
    (c.ignoreKeywordsWithRef || !(0, ua.schemaHasRulesButRef)(a, f))
  ) {
    i.block(() => F4(e, "$ref", f.all.$ref.definition));
    return;
  }
  c.jtd || eQ(e, t),
    i.block(() => {
      for (const d of f.rules) u(d);
      u(f.post);
    });
  function u(d) {
    (0, yy.shouldUseGroup)(a, d) &&
      (d.type
        ? (i.if((0, bd.checkDataType)(d.type, s, c.strictNumbers)),
          Ax(e, d),
          t.length === 1 &&
            t[0] === d.type &&
            n &&
            (i.else(), (0, bd.reportTypeError)(e)),
          i.endIf())
        : Ax(e, d),
      o || i.if((0, Ye._)`${gt.default.errors} === ${r || 0}`));
  }
}
function Ax(e, t) {
  const {
    gen: n,
    schema: r,
    opts: { useDefaults: i },
  } = e;
  i && (0, FG.assignDefaults)(e, t.type),
    n.block(() => {
      for (const a of t.rules)
        (0, yy.shouldUseRule)(r, a) && F4(e, a.keyword, a.definition, t.type);
    });
}
function eQ(e, t) {
  e.schemaEnv.meta ||
    !e.opts.strictTypes ||
    (tQ(e, t), e.opts.allowUnionTypes || nQ(e, t), rQ(e, e.dataTypes));
}
function tQ(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((n) => {
      B4(e.dataTypes, n) ||
        by(e, `type "${n}" not allowed by context "${e.dataTypes.join(",")}"`);
    }),
      aQ(e, t);
  }
}
function nQ(e, t) {
  t.length > 1 &&
    !(t.length === 2 && t.includes("null")) &&
    by(e, "use allowUnionTypes to allow union type keyword");
}
function rQ(e, t) {
  const n = e.self.RULES.all;
  for (const r in n) {
    const i = n[r];
    if (typeof i == "object" && (0, yy.shouldUseRule)(e.schema, i)) {
      const { type: a } = i.definition;
      a.length &&
        !a.some((s) => iQ(t, s)) &&
        by(e, `missing type "${a.join(",")}" for keyword "${r}"`);
    }
  }
}
function iQ(e, t) {
  return e.includes(t) || (t === "number" && e.includes("integer"));
}
function B4(e, t) {
  return e.includes(t) || (t === "integer" && e.includes("number"));
}
function aQ(e, t) {
  const n = [];
  for (const r of e.dataTypes)
    B4(t, r)
      ? n.push(r)
      : t.includes("integer") && r === "number" && n.push("integer");
  e.dataTypes = n;
}
function by(e, t) {
  const n = e.schemaEnv.baseId + e.errSchemaPath;
  (t += ` at "${n}" (strictTypes)`),
    (0, ua.checkStrictMode)(e, t, e.opts.strictTypes);
}
let U4 = class {
  constructor(t, n, r) {
    if (
      ((0, vl.validateKeywordUsage)(t, n, r),
      (this.gen = t.gen),
      (this.allErrors = t.allErrors),
      (this.keyword = r),
      (this.data = t.data),
      (this.schema = t.schema[r]),
      (this.$data =
        n.$data && t.opts.$data && this.schema && this.schema.$data),
      (this.schemaValue = (0, ua.schemaRefOrVal)(
        t,
        this.schema,
        r,
        this.$data,
      )),
      (this.schemaType = n.schemaType),
      (this.parentSchema = t.schema),
      (this.params = {}),
      (this.it = t),
      (this.def = n),
      this.$data)
    )
      this.schemaCode = t.gen.const("vSchema", j4(this.$data, t));
    else if (
      ((this.schemaCode = this.schemaValue),
      !(0, vl.validSchemaType)(this.schema, n.schemaType, n.allowUndefined))
    )
      throw new Error(`${r} value must be ${JSON.stringify(n.schemaType)}`);
    ("code" in n ? n.trackErrors : n.errors !== !1) &&
      (this.errsCount = t.gen.const("_errs", gt.default.errors));
  }
  result(t, n, r) {
    this.failResult((0, Ye.not)(t), n, r);
  }
  failResult(t, n, r) {
    this.gen.if(t),
      r ? r() : this.error(),
      n
        ? (this.gen.else(), n(), this.allErrors && this.gen.endIf())
        : this.allErrors
        ? this.gen.endIf()
        : this.gen.else();
  }
  pass(t, n) {
    this.failResult((0, Ye.not)(t), void 0, n);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t),
      this.error(),
      this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data) return this.fail(t);
    const { schemaCode: n } = this;
    this.fail(
      (0, Ye._)`${n} !== undefined && (${(0, Ye.or)(this.invalid$data(), t)})`,
    );
  }
  error(t, n, r) {
    if (n) {
      this.setParams(n), this._error(t, r), this.setParams({});
      return;
    }
    this._error(t, r);
  }
  _error(t, n) {
    (t ? Qc.reportExtraError : Qc.reportError)(this, this.def.error, n);
  }
  $dataError() {
    (0, Qc.reportError)(this, this.def.$dataError || Qc.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, Qc.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, n) {
    n ? Object.assign(this.params, t) : (this.params = t);
  }
  block$data(t, n, r = Ye.nil) {
    this.gen.block(() => {
      this.check$data(t, r), n();
    });
  }
  check$data(t = Ye.nil, n = Ye.nil) {
    if (!this.$data) return;
    const { gen: r, schemaCode: i, schemaType: a, def: s } = this;
    r.if((0, Ye.or)((0, Ye._)`${i} === undefined`, n)),
      t !== Ye.nil && r.assign(t, !0),
      (a.length || s.validateSchema) &&
        (r.elseIf(this.invalid$data()),
        this.$dataError(),
        t !== Ye.nil && r.assign(t, !1)),
      r.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: n, schemaType: r, def: i, it: a } = this;
    return (0, Ye.or)(s(), o());
    function s() {
      if (r.length) {
        if (!(n instanceof Ye.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(r) ? r : [r];
        return (0, Ye._)`${(0, bd.checkDataTypes)(
          c,
          n,
          a.opts.strictNumbers,
          bd.DataType.Wrong,
        )}`;
      }
      return Ye.nil;
    }
    function o() {
      if (i.validateSchema) {
        const c = t.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, Ye._)`!${c}(${n})`;
      }
      return Ye.nil;
    }
  }
  subschema(t, n) {
    const r = (0, $m.getSubschema)(this.it, t);
    (0, $m.extendSubschemaData)(r, this.it, t),
      (0, $m.extendSubschemaMode)(r, t);
    const i = { ...this.it, ...r, items: void 0, props: void 0 };
    return WG(i, n), i;
  }
  mergeEvaluated(t, n) {
    const { it: r, gen: i } = this;
    r.opts.unevaluated &&
      (r.props !== !0 &&
        t.props !== void 0 &&
        (r.props = ua.mergeEvaluated.props(i, t.props, r.props, n)),
      r.items !== !0 &&
        t.items !== void 0 &&
        (r.items = ua.mergeEvaluated.items(i, t.items, r.items, n)));
  }
  mergeValidEvaluated(t, n) {
    const { it: r, gen: i } = this;
    if (r.opts.unevaluated && (r.props !== !0 || r.items !== !0))
      return i.if(n, () => this.mergeEvaluated(t, Ye.Name)), !0;
  }
};
yi.KeywordCxt = U4;
function F4(e, t, n, r) {
  const i = new U4(e, n, t);
  "code" in n
    ? n.code(i, r)
    : i.$data && n.validate
    ? (0, vl.funcKeywordCode)(i, n)
    : "macro" in n
    ? (0, vl.macroKeywordCode)(i, n)
    : (n.compile || n.validate) && (0, vl.funcKeywordCode)(i, n);
}
const sQ = /^\/(?:[^~]|~0|~1)*$/,
  oQ = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function j4(e, { dataLevel: t, dataNames: n, dataPathArr: r }) {
  let i, a;
  if (e === "") return gt.default.rootData;
  if (e[0] === "/") {
    if (!sQ.test(e)) throw new Error(`Invalid JSON-pointer: ${e}`);
    (i = e), (a = gt.default.rootData);
  } else {
    const l = oQ.exec(e);
    if (!l) throw new Error(`Invalid JSON-pointer: ${e}`);
    const f = +l[1];
    if (((i = l[2]), i === "#")) {
      if (f >= t) throw new Error(c("property/index", f));
      return r[t - f];
    }
    if (f > t) throw new Error(c("data", f));
    if (((a = n[t - f]), !i)) return a;
  }
  let s = a;
  const o = i.split("/");
  for (const l of o)
    l &&
      ((a = (0, Ye._)`${a}${(0, Ye.getProperty)(
        (0, ua.unescapeJsonPointer)(l),
      )}`),
      (s = (0, Ye._)`${s} && ${a}`));
  return s;
  function c(l, f) {
    return `Cannot access ${l} ${f} levels up, current level is ${t}`;
  }
}
yi.getData = j4;
var uu = {};
Object.defineProperty(uu, "__esModule", { value: !0 });
let cQ = class extends Error {
  constructor(t) {
    super("validation failed"),
      (this.errors = t),
      (this.ajv = this.validation = !0);
  }
};
uu.default = cQ;
var fu = {};
Object.defineProperty(fu, "__esModule", { value: !0 });
const Cm = nr;
let lQ = class extends Error {
  constructor(t, n, r, i) {
    super(i || `can't resolve reference ${r} from id ${n}`),
      (this.missingRef = (0, Cm.resolveUrl)(t, n, r)),
      (this.missingSchema = (0, Cm.normalizeId)(
        (0, Cm.getFullPath)(t, this.missingRef),
      ));
  }
};
fu.default = lQ;
var Dr = {};
Object.defineProperty(Dr, "__esModule", { value: !0 });
Dr.resolveSchema =
  Dr.getCompilingSchema =
  Dr.resolveRef =
  Dr.compileSchema =
  Dr.SchemaEnv =
    void 0;
const ii = $t,
  uQ = uu,
  us = Wi,
  hi = nr,
  Sx = Ut,
  fQ = yi;
let Cp = class {
  constructor(t) {
    var n;
    (this.refs = {}), (this.dynamicAnchors = {});
    let r;
    typeof t.schema == "object" && (r = t.schema),
      (this.schema = t.schema),
      (this.schemaId = t.schemaId),
      (this.root = t.root || this),
      (this.baseId =
        (n = t.baseId) !== null && n !== void 0
          ? n
          : (0, hi.normalizeId)(r == null ? void 0 : r[t.schemaId || "$id"])),
      (this.schemaPath = t.schemaPath),
      (this.localRefs = t.localRefs),
      (this.meta = t.meta),
      (this.$async = r == null ? void 0 : r.$async),
      (this.refs = {});
  }
};
Dr.SchemaEnv = Cp;
function _y(e) {
  const t = M4.call(this, e);
  if (t) return t;
  const n = (0, hi.getFullPath)(this.opts.uriResolver, e.root.baseId),
    { es5: r, lines: i } = this.opts.code,
    { ownProperties: a } = this.opts,
    s = new ii.CodeGen(this.scope, { es5: r, lines: i, ownProperties: a });
  let o;
  e.$async &&
    (o = s.scopeValue("Error", {
      ref: uQ.default,
      code: (0, ii._)`require("ajv/dist/runtime/validation_error").default`,
    }));
  const c = s.scopeName("validate");
  e.validateName = c;
  const l = {
    gen: s,
    allErrors: this.opts.allErrors,
    data: us.default.data,
    parentData: us.default.parentData,
    parentDataProperty: us.default.parentDataProperty,
    dataNames: [us.default.data],
    dataPathArr: [ii.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: new Set(),
    topSchemaRef: s.scopeValue(
      "schema",
      this.opts.code.source === !0
        ? { ref: e.schema, code: (0, ii.stringify)(e.schema) }
        : { ref: e.schema },
    ),
    validateName: c,
    ValidationError: o,
    schema: e.schema,
    schemaEnv: e,
    rootId: n,
    baseId: e.baseId || n,
    schemaPath: ii.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, ii._)`""`,
    opts: this.opts,
    self: this,
  };
  let f;
  try {
    this._compilations.add(e),
      (0, fQ.validateFunctionCode)(l),
      s.optimize(this.opts.code.optimize);
    const u = s.toString();
    (f = `${s.scopeRefs(us.default.scope)}return ${u}`),
      this.opts.code.process && (f = this.opts.code.process(f, e));
    const p = new Function(`${us.default.self}`, `${us.default.scope}`, f)(
      this,
      this.scope.get(),
    );
    if (
      (this.scope.value(c, { ref: p }),
      (p.errors = null),
      (p.schema = e.schema),
      (p.schemaEnv = e),
      e.$async && (p.$async = !0),
      this.opts.code.source === !0 &&
        (p.source = {
          validateName: c,
          validateCode: u,
          scopeValues: s._values,
        }),
      this.opts.unevaluated)
    ) {
      const { props: h, items: m } = l;
      (p.evaluated = {
        props: h instanceof ii.Name ? void 0 : h,
        items: m instanceof ii.Name ? void 0 : m,
        dynamicProps: h instanceof ii.Name,
        dynamicItems: m instanceof ii.Name,
      }),
        p.source && (p.source.evaluated = (0, ii.stringify)(p.evaluated));
    }
    return (e.validate = p), e;
  } catch (u) {
    throw (
      (delete e.validate,
      delete e.validateName,
      f && this.logger.error("Error compiling schema, function code:", f),
      u)
    );
  } finally {
    this._compilations.delete(e);
  }
}
Dr.compileSchema = _y;
function dQ(e, t, n) {
  var r;
  n = (0, hi.resolveUrl)(this.opts.uriResolver, t, n);
  const i = e.refs[n];
  if (i) return i;
  let a = mQ.call(this, e, n);
  if (a === void 0) {
    const s = (r = e.localRefs) === null || r === void 0 ? void 0 : r[n],
      { schemaId: o } = this.opts;
    s && (a = new Cp({ schema: s, schemaId: o, root: e, baseId: t }));
  }
  if (a !== void 0) return (e.refs[n] = pQ.call(this, a));
}
Dr.resolveRef = dQ;
function pQ(e) {
  return (0, hi.inlineRef)(e.schema, this.opts.inlineRefs)
    ? e.schema
    : e.validate
    ? e
    : _y.call(this, e);
}
function M4(e) {
  for (const t of this._compilations) if (hQ(t, e)) return t;
}
Dr.getCompilingSchema = M4;
function hQ(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function mQ(e, t) {
  let n;
  for (; typeof (n = this.refs[t]) == "string"; ) t = n;
  return n || this.schemas[t] || Rp.call(this, e, t);
}
function Rp(e, t) {
  const n = this.opts.uriResolver.parse(t),
    r = (0, hi._getFullPath)(this.opts.uriResolver, n);
  let i = (0, hi.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && r === i) return Rm.call(this, n, e);
  const a = (0, hi.normalizeId)(r),
    s = this.refs[a] || this.schemas[a];
  if (typeof s == "string") {
    const o = Rp.call(this, e, s);
    return typeof (o == null ? void 0 : o.schema) != "object"
      ? void 0
      : Rm.call(this, n, o);
  }
  if (typeof (s == null ? void 0 : s.schema) == "object") {
    if ((s.validate || _y.call(this, s), a === (0, hi.normalizeId)(t))) {
      const { schema: o } = s,
        { schemaId: c } = this.opts,
        l = o[c];
      return (
        l && (i = (0, hi.resolveUrl)(this.opts.uriResolver, i, l)),
        new Cp({ schema: o, schemaId: c, root: e, baseId: i })
      );
    }
    return Rm.call(this, n, s);
  }
}
Dr.resolveSchema = Rp;
const gQ = new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions",
]);
function Rm(e, { baseId: t, schema: n, root: r }) {
  var i;
  if (((i = e.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
    return;
  for (const o of e.fragment.slice(1).split("/")) {
    if (typeof n == "boolean") return;
    const c = n[(0, Sx.unescapeFragment)(o)];
    if (c === void 0) return;
    n = c;
    const l = typeof n == "object" && n[this.opts.schemaId];
    !gQ.has(o) && l && (t = (0, hi.resolveUrl)(this.opts.uriResolver, t, l));
  }
  let a;
  if (
    typeof n != "boolean" &&
    n.$ref &&
    !(0, Sx.schemaHasRulesButRef)(n, this.RULES)
  ) {
    const o = (0, hi.resolveUrl)(this.opts.uriResolver, t, n.$ref);
    a = Rp.call(this, r, o);
  }
  const { schemaId: s } = this.opts;
  if (
    ((a = a || new Cp({ schema: n, schemaId: s, root: r, baseId: t })),
    a.schema !== a.root.schema)
  )
    return a;
}
const vQ =
    "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
  yQ = "Meta-schema for $data reference (JSON AnySchema extension proposal)",
  bQ = "object",
  _Q = ["$data"],
  EQ = {
    $data: {
      type: "string",
      anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }],
    },
  },
  wQ = !1,
  xQ = {
    $id: vQ,
    description: yQ,
    type: bQ,
    required: _Q,
    properties: EQ,
    additionalProperties: wQ,
  };
var Ey = {},
  E0 = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */ (function (
  e,
  t,
) {
  (function (n, r) {
    r(t);
  })(Tn, function (n) {
    function r() {
      for (var C = arguments.length, $ = Array(C), b = 0; b < C; b++)
        $[b] = arguments[b];
      if ($.length > 1) {
        $[0] = $[0].slice(0, -1);
        for (var D = $.length - 1, K = 1; K < D; ++K) $[K] = $[K].slice(1, -1);
        return ($[D] = $[D].slice(1)), $.join("");
      } else return $[0];
    }
    function i(C) {
      return "(?:" + C + ")";
    }
    function a(C) {
      return C === void 0
        ? "undefined"
        : C === null
        ? "null"
        : Object.prototype.toString
            .call(C)
            .split(" ")
            .pop()
            .split("]")
            .shift()
            .toLowerCase();
    }
    function s(C) {
      return C.toUpperCase();
    }
    function o(C) {
      return C != null
        ? C instanceof Array
          ? C
          : typeof C.length != "number" || C.split || C.setInterval || C.call
          ? [C]
          : Array.prototype.slice.call(C)
        : [];
    }
    function c(C, $) {
      var b = C;
      if ($) for (var D in $) b[D] = $[D];
      return b;
    }
    function l(C) {
      var $ = "[A-Za-z]",
        b = "[0-9]",
        D = r(b, "[A-Fa-f]"),
        K = i(
          i("%[EFef]" + D + "%" + D + D + "%" + D + D) +
            "|" +
            i("%[89A-Fa-f]" + D + "%" + D + D) +
            "|" +
            i("%" + D + D),
        ),
        se = "[\\:\\/\\?\\#\\[\\]\\@]",
        pe = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        we = r(se, pe),
        Re = C
          ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]"
          : "[]",
        ke = C ? "[\\uE000-\\uF8FF]" : "[]",
        je = r($, b, "[\\-\\.\\_\\~]", Re);
      i($ + r($, b, "[\\+\\-\\.]") + "*"),
        i(i(K + "|" + r(je, pe, "[\\:]")) + "*");
      var Te = i(
          i("25[0-5]") +
            "|" +
            i("2[0-4]" + b) +
            "|" +
            i("1" + b + b) +
            "|" +
            i("0?[1-9]" + b) +
            "|0?0?" +
            b,
        ),
        Me = i(Te + "\\." + Te + "\\." + Te + "\\." + Te),
        Ne = i(D + "{1,4}"),
        Ue = i(i(Ne + "\\:" + Ne) + "|" + Me),
        qe = i(i(Ne + "\\:") + "{6}" + Ue),
        Fe = i("\\:\\:" + i(Ne + "\\:") + "{5}" + Ue),
        Je = i(i(Ne) + "?\\:\\:" + i(Ne + "\\:") + "{4}" + Ue),
        Ke = i(
          i(i(Ne + "\\:") + "{0,1}" + Ne) +
            "?\\:\\:" +
            i(Ne + "\\:") +
            "{3}" +
            Ue,
        ),
        Be = i(
          i(i(Ne + "\\:") + "{0,2}" + Ne) +
            "?\\:\\:" +
            i(Ne + "\\:") +
            "{2}" +
            Ue,
        ),
        He = i(i(i(Ne + "\\:") + "{0,3}" + Ne) + "?\\:\\:" + Ne + "\\:" + Ue),
        De = i(i(i(Ne + "\\:") + "{0,4}" + Ne) + "?\\:\\:" + Ue),
        Le = i(i(i(Ne + "\\:") + "{0,5}" + Ne) + "?\\:\\:" + Ne),
        Pe = i(i(i(Ne + "\\:") + "{0,6}" + Ne) + "?\\:\\:"),
        Oe = i([qe, Fe, Je, Ke, Be, He, De, Le, Pe].join("|")),
        ge = i(i(je + "|" + K) + "+");
      i("[vV]" + D + "+\\." + r(je, pe, "[\\:]") + "+"),
        i(i(K + "|" + r(je, pe)) + "*");
      var ve = i(K + "|" + r(je, pe, "[\\:\\@]"));
      return (
        i(i(K + "|" + r(je, pe, "[\\@]")) + "+"),
        i(i(ve + "|" + r("[\\/\\?]", ke)) + "*"),
        {
          NOT_SCHEME: new RegExp(r("[^]", $, b, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(r("[^\\%\\:]", je, pe), "g"),
          NOT_HOST: new RegExp(r("[^\\%\\[\\]\\:]", je, pe), "g"),
          NOT_PATH: new RegExp(r("[^\\%\\/\\:\\@]", je, pe), "g"),
          NOT_PATH_NOSCHEME: new RegExp(r("[^\\%\\/\\@]", je, pe), "g"),
          NOT_QUERY: new RegExp(r("[^\\%]", je, pe, "[\\:\\@\\/\\?]", ke), "g"),
          NOT_FRAGMENT: new RegExp(r("[^\\%]", je, pe, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(r("[^]", je, pe), "g"),
          UNRESERVED: new RegExp(je, "g"),
          OTHER_CHARS: new RegExp(r("[^\\%]", je, we), "g"),
          PCT_ENCODED: new RegExp(K, "g"),
          IPV4ADDRESS: new RegExp("^(" + Me + ")$"),
          IPV6ADDRESS: new RegExp(
            "^\\[?(" +
              Oe +
              ")" +
              i(i("\\%25|\\%(?!" + D + "{2})") + "(" + ge + ")") +
              "?\\]?$",
          ),
        }
      );
    }
    var f = l(!1),
      u = l(!0),
      d = (function () {
        function C($, b) {
          var D = [],
            K = !0,
            se = !1,
            pe = void 0;
          try {
            for (
              var we = $[Symbol.iterator](), Re;
              !(K = (Re = we.next()).done) &&
              (D.push(Re.value), !(b && D.length === b));
              K = !0
            );
          } catch (ke) {
            (se = !0), (pe = ke);
          } finally {
            try {
              !K && we.return && we.return();
            } finally {
              if (se) throw pe;
            }
          }
          return D;
        }
        return function ($, b) {
          if (Array.isArray($)) return $;
          if (Symbol.iterator in Object($)) return C($, b);
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance",
          );
        };
      })(),
      p = function (C) {
        if (Array.isArray(C)) {
          for (var $ = 0, b = Array(C.length); $ < C.length; $++) b[$] = C[$];
          return b;
        } else return Array.from(C);
      },
      h = 2147483647,
      m = 36,
      g = 1,
      v = 26,
      y = 38,
      _ = 700,
      E = 72,
      R = 128,
      A = "-",
      I = /^xn--/,
      S = /[^\0-\x7E]/,
      w = /[\x2E\u3002\uFF0E\uFF61]/g,
      O = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input",
      },
      Q = m - g,
      j = Math.floor,
      H = String.fromCharCode;
    function q(C) {
      throw new RangeError(O[C]);
    }
    function J(C, $) {
      for (var b = [], D = C.length; D--; ) b[D] = $(C[D]);
      return b;
    }
    function Z(C, $) {
      var b = C.split("@"),
        D = "";
      b.length > 1 && ((D = b[0] + "@"), (C = b[1])), (C = C.replace(w, "."));
      var K = C.split("."),
        se = J(K, $).join(".");
      return D + se;
    }
    function z(C) {
      for (var $ = [], b = 0, D = C.length; b < D; ) {
        var K = C.charCodeAt(b++);
        if (K >= 55296 && K <= 56319 && b < D) {
          var se = C.charCodeAt(b++);
          (se & 64512) == 56320
            ? $.push(((K & 1023) << 10) + (se & 1023) + 65536)
            : ($.push(K), b--);
        } else $.push(K);
      }
      return $;
    }
    var U = function ($) {
        return String.fromCodePoint.apply(String, p($));
      },
      G = function ($) {
        return $ - 48 < 10
          ? $ - 22
          : $ - 65 < 26
          ? $ - 65
          : $ - 97 < 26
          ? $ - 97
          : m;
      },
      L = function ($, b) {
        return $ + 22 + 75 * ($ < 26) - ((b != 0) << 5);
      },
      k = function ($, b, D) {
        var K = 0;
        for ($ = D ? j($ / _) : $ >> 1, $ += j($ / b); $ > (Q * v) >> 1; K += m)
          $ = j($ / Q);
        return j(K + ((Q + 1) * $) / ($ + y));
      },
      W = function ($) {
        var b = [],
          D = $.length,
          K = 0,
          se = R,
          pe = E,
          we = $.lastIndexOf(A);
        we < 0 && (we = 0);
        for (var Re = 0; Re < we; ++Re)
          $.charCodeAt(Re) >= 128 && q("not-basic"), b.push($.charCodeAt(Re));
        for (var ke = we > 0 ? we + 1 : 0; ke < D; ) {
          for (var je = K, Te = 1, Me = m; ; Me += m) {
            ke >= D && q("invalid-input");
            var Ne = G($.charCodeAt(ke++));
            (Ne >= m || Ne > j((h - K) / Te)) && q("overflow"), (K += Ne * Te);
            var Ue = Me <= pe ? g : Me >= pe + v ? v : Me - pe;
            if (Ne < Ue) break;
            var qe = m - Ue;
            Te > j(h / qe) && q("overflow"), (Te *= qe);
          }
          var Fe = b.length + 1;
          (pe = k(K - je, Fe, je == 0)),
            j(K / Fe) > h - se && q("overflow"),
            (se += j(K / Fe)),
            (K %= Fe),
            b.splice(K++, 0, se);
        }
        return String.fromCodePoint.apply(String, b);
      },
      F = function ($) {
        var b = [];
        $ = z($);
        var D = $.length,
          K = R,
          se = 0,
          pe = E,
          we = !0,
          Re = !1,
          ke = void 0;
        try {
          for (
            var je = $[Symbol.iterator](), Te;
            !(we = (Te = je.next()).done);
            we = !0
          ) {
            var Me = Te.value;
            Me < 128 && b.push(H(Me));
          }
        } catch (at) {
          (Re = !0), (ke = at);
        } finally {
          try {
            !we && je.return && je.return();
          } finally {
            if (Re) throw ke;
          }
        }
        var Ne = b.length,
          Ue = Ne;
        for (Ne && b.push(A); Ue < D; ) {
          var qe = h,
            Fe = !0,
            Je = !1,
            Ke = void 0;
          try {
            for (
              var Be = $[Symbol.iterator](), He;
              !(Fe = (He = Be.next()).done);
              Fe = !0
            ) {
              var De = He.value;
              De >= K && De < qe && (qe = De);
            }
          } catch (at) {
            (Je = !0), (Ke = at);
          } finally {
            try {
              !Fe && Be.return && Be.return();
            } finally {
              if (Je) throw Ke;
            }
          }
          var Le = Ue + 1;
          qe - K > j((h - se) / Le) && q("overflow"),
            (se += (qe - K) * Le),
            (K = qe);
          var Pe = !0,
            Oe = !1,
            ge = void 0;
          try {
            for (
              var ve = $[Symbol.iterator](), Ie;
              !(Pe = (Ie = ve.next()).done);
              Pe = !0
            ) {
              var Se = Ie.value;
              if ((Se < K && ++se > h && q("overflow"), Se == K)) {
                for (var Ae = se, Ce = m; ; Ce += m) {
                  var Ve = Ce <= pe ? g : Ce >= pe + v ? v : Ce - pe;
                  if (Ae < Ve) break;
                  var it = Ae - Ve,
                    mt = m - Ve;
                  b.push(H(L(Ve + (it % mt), 0))), (Ae = j(it / mt));
                }
                b.push(H(L(Ae, 0))), (pe = k(se, Le, Ue == Ne)), (se = 0), ++Ue;
              }
            }
          } catch (at) {
            (Oe = !0), (ge = at);
          } finally {
            try {
              !Pe && ve.return && ve.return();
            } finally {
              if (Oe) throw ge;
            }
          }
          ++se, ++K;
        }
        return b.join("");
      },
      x = function ($) {
        return Z($, function (b) {
          return I.test(b) ? W(b.slice(4).toLowerCase()) : b;
        });
      },
      T = function ($) {
        return Z($, function (b) {
          return S.test(b) ? "xn--" + F(b) : b;
        });
      },
      V = {
        version: "2.1.0",
        ucs2: { decode: z, encode: U },
        decode: W,
        encode: F,
        toASCII: T,
        toUnicode: x,
      },
      B = {};
    function N(C) {
      var $ = C.charCodeAt(0),
        b = void 0;
      return (
        $ < 16
          ? (b = "%0" + $.toString(16).toUpperCase())
          : $ < 128
          ? (b = "%" + $.toString(16).toUpperCase())
          : $ < 2048
          ? (b =
              "%" +
              (($ >> 6) | 192).toString(16).toUpperCase() +
              "%" +
              (($ & 63) | 128).toString(16).toUpperCase())
          : (b =
              "%" +
              (($ >> 12) | 224).toString(16).toUpperCase() +
              "%" +
              ((($ >> 6) & 63) | 128).toString(16).toUpperCase() +
              "%" +
              (($ & 63) | 128).toString(16).toUpperCase()),
        b
      );
    }
    function ce(C) {
      for (var $ = "", b = 0, D = C.length; b < D; ) {
        var K = parseInt(C.substr(b + 1, 2), 16);
        if (K < 128) ($ += String.fromCharCode(K)), (b += 3);
        else if (K >= 194 && K < 224) {
          if (D - b >= 6) {
            var se = parseInt(C.substr(b + 4, 2), 16);
            $ += String.fromCharCode(((K & 31) << 6) | (se & 63));
          } else $ += C.substr(b, 6);
          b += 6;
        } else if (K >= 224) {
          if (D - b >= 9) {
            var pe = parseInt(C.substr(b + 4, 2), 16),
              we = parseInt(C.substr(b + 7, 2), 16);
            $ += String.fromCharCode(
              ((K & 15) << 12) | ((pe & 63) << 6) | (we & 63),
            );
          } else $ += C.substr(b, 9);
          b += 9;
        } else ($ += C.substr(b, 3)), (b += 3);
      }
      return $;
    }
    function re(C, $) {
      function b(D) {
        var K = ce(D);
        return K.match($.UNRESERVED) ? K : D;
      }
      return (
        C.scheme &&
          (C.scheme = String(C.scheme)
            .replace($.PCT_ENCODED, b)
            .toLowerCase()
            .replace($.NOT_SCHEME, "")),
        C.userinfo !== void 0 &&
          (C.userinfo = String(C.userinfo)
            .replace($.PCT_ENCODED, b)
            .replace($.NOT_USERINFO, N)
            .replace($.PCT_ENCODED, s)),
        C.host !== void 0 &&
          (C.host = String(C.host)
            .replace($.PCT_ENCODED, b)
            .toLowerCase()
            .replace($.NOT_HOST, N)
            .replace($.PCT_ENCODED, s)),
        C.path !== void 0 &&
          (C.path = String(C.path)
            .replace($.PCT_ENCODED, b)
            .replace(C.scheme ? $.NOT_PATH : $.NOT_PATH_NOSCHEME, N)
            .replace($.PCT_ENCODED, s)),
        C.query !== void 0 &&
          (C.query = String(C.query)
            .replace($.PCT_ENCODED, b)
            .replace($.NOT_QUERY, N)
            .replace($.PCT_ENCODED, s)),
        C.fragment !== void 0 &&
          (C.fragment = String(C.fragment)
            .replace($.PCT_ENCODED, b)
            .replace($.NOT_FRAGMENT, N)
            .replace($.PCT_ENCODED, s)),
        C
      );
    }
    function ne(C) {
      return C.replace(/^0*(.*)/, "$1") || "0";
    }
    function Y(C, $) {
      var b = C.match($.IPV4ADDRESS) || [],
        D = d(b, 2),
        K = D[1];
      return K ? K.split(".").map(ne).join(".") : C;
    }
    function M(C, $) {
      var b = C.match($.IPV6ADDRESS) || [],
        D = d(b, 3),
        K = D[1],
        se = D[2];
      if (K) {
        for (
          var pe = K.toLowerCase().split("::").reverse(),
            we = d(pe, 2),
            Re = we[0],
            ke = we[1],
            je = ke ? ke.split(":").map(ne) : [],
            Te = Re.split(":").map(ne),
            Me = $.IPV4ADDRESS.test(Te[Te.length - 1]),
            Ne = Me ? 7 : 8,
            Ue = Te.length - Ne,
            qe = Array(Ne),
            Fe = 0;
          Fe < Ne;
          ++Fe
        )
          qe[Fe] = je[Fe] || Te[Ue + Fe] || "";
        Me && (qe[Ne - 1] = Y(qe[Ne - 1], $));
        var Je = qe.reduce(function (Le, Pe, Oe) {
            if (!Pe || Pe === "0") {
              var ge = Le[Le.length - 1];
              ge && ge.index + ge.length === Oe
                ? ge.length++
                : Le.push({ index: Oe, length: 1 });
            }
            return Le;
          }, []),
          Ke = Je.sort(function (Le, Pe) {
            return Pe.length - Le.length;
          })[0],
          Be = void 0;
        if (Ke && Ke.length > 1) {
          var He = qe.slice(0, Ke.index),
            De = qe.slice(Ke.index + Ke.length);
          Be = He.join(":") + "::" + De.join(":");
        } else Be = qe.join(":");
        return se && (Be += "%" + se), Be;
      } else return C;
    }
    var oe =
        /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,
      Ee = "".match(/(){0}/)[1] === void 0;
    function le(C) {
      var $ =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        b = {},
        D = $.iri !== !1 ? u : f;
      $.reference === "suffix" &&
        (C = ($.scheme ? $.scheme + ":" : "") + "//" + C);
      var K = C.match(oe);
      if (K) {
        Ee
          ? ((b.scheme = K[1]),
            (b.userinfo = K[3]),
            (b.host = K[4]),
            (b.port = parseInt(K[5], 10)),
            (b.path = K[6] || ""),
            (b.query = K[7]),
            (b.fragment = K[8]),
            isNaN(b.port) && (b.port = K[5]))
          : ((b.scheme = K[1] || void 0),
            (b.userinfo = C.indexOf("@") !== -1 ? K[3] : void 0),
            (b.host = C.indexOf("//") !== -1 ? K[4] : void 0),
            (b.port = parseInt(K[5], 10)),
            (b.path = K[6] || ""),
            (b.query = C.indexOf("?") !== -1 ? K[7] : void 0),
            (b.fragment = C.indexOf("#") !== -1 ? K[8] : void 0),
            isNaN(b.port) &&
              (b.port = C.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)
                ? K[4]
                : void 0)),
          b.host && (b.host = M(Y(b.host, D), D)),
          b.scheme === void 0 &&
          b.userinfo === void 0 &&
          b.host === void 0 &&
          b.port === void 0 &&
          !b.path &&
          b.query === void 0
            ? (b.reference = "same-document")
            : b.scheme === void 0
            ? (b.reference = "relative")
            : b.fragment === void 0
            ? (b.reference = "absolute")
            : (b.reference = "uri"),
          $.reference &&
            $.reference !== "suffix" &&
            $.reference !== b.reference &&
            (b.error =
              b.error || "URI is not a " + $.reference + " reference.");
        var se = B[($.scheme || b.scheme || "").toLowerCase()];
        if (!$.unicodeSupport && (!se || !se.unicodeSupport)) {
          if (b.host && ($.domainHost || (se && se.domainHost)))
            try {
              b.host = V.toASCII(
                b.host.replace(D.PCT_ENCODED, ce).toLowerCase(),
              );
            } catch (pe) {
              b.error =
                b.error ||
                "Host's domain name can not be converted to ASCII via punycode: " +
                  pe;
            }
          re(b, f);
        } else re(b, D);
        se && se.parse && se.parse(b, $);
      } else b.error = b.error || "URI can not be parsed.";
      return b;
    }
    function te(C, $) {
      var b = $.iri !== !1 ? u : f,
        D = [];
      return (
        C.userinfo !== void 0 && (D.push(C.userinfo), D.push("@")),
        C.host !== void 0 &&
          D.push(
            M(Y(String(C.host), b), b).replace(
              b.IPV6ADDRESS,
              function (K, se, pe) {
                return "[" + se + (pe ? "%25" + pe : "") + "]";
              },
            ),
          ),
        (typeof C.port == "number" || typeof C.port == "string") &&
          (D.push(":"), D.push(String(C.port))),
        D.length ? D.join("") : void 0
      );
    }
    var ie = /^\.\.?\//,
      X = /^\/\.(\/|$)/,
      he = /^\/\.\.(\/|$)/,
      be = /^\/?(?:.|\n)*?(?=\/|$)/;
    function ye(C) {
      for (var $ = []; C.length; )
        if (C.match(ie)) C = C.replace(ie, "");
        else if (C.match(X)) C = C.replace(X, "/");
        else if (C.match(he)) (C = C.replace(he, "/")), $.pop();
        else if (C === "." || C === "..") C = "";
        else {
          var b = C.match(be);
          if (b) {
            var D = b[0];
            (C = C.slice(D.length)), $.push(D);
          } else throw new Error("Unexpected dot segment condition");
        }
      return $.join("");
    }
    function Qe(C) {
      var $ =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
        b = $.iri ? u : f,
        D = [],
        K = B[($.scheme || C.scheme || "").toLowerCase()];
      if (
        (K && K.serialize && K.serialize(C, $),
        C.host && !b.IPV6ADDRESS.test(C.host))
      ) {
        if ($.domainHost || (K && K.domainHost))
          try {
            C.host = $.iri
              ? V.toUnicode(C.host)
              : V.toASCII(C.host.replace(b.PCT_ENCODED, ce).toLowerCase());
          } catch (we) {
            C.error =
              C.error ||
              "Host's domain name can not be converted to " +
                ($.iri ? "Unicode" : "ASCII") +
                " via punycode: " +
                we;
          }
      }
      re(C, b),
        $.reference !== "suffix" && C.scheme && (D.push(C.scheme), D.push(":"));
      var se = te(C, $);
      if (
        (se !== void 0 &&
          ($.reference !== "suffix" && D.push("//"),
          D.push(se),
          C.path && C.path.charAt(0) !== "/" && D.push("/")),
        C.path !== void 0)
      ) {
        var pe = C.path;
        !$.absolutePath && (!K || !K.absolutePath) && (pe = ye(pe)),
          se === void 0 && (pe = pe.replace(/^\/\//, "/%2F")),
          D.push(pe);
      }
      return (
        C.query !== void 0 && (D.push("?"), D.push(C.query)),
        C.fragment !== void 0 && (D.push("#"), D.push(C.fragment)),
        D.join("")
      );
    }
    function lt(C, $) {
      var b =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        D = arguments[3],
        K = {};
      return (
        D || ((C = le(Qe(C, b), b)), ($ = le(Qe($, b), b))),
        (b = b || {}),
        !b.tolerant && $.scheme
          ? ((K.scheme = $.scheme),
            (K.userinfo = $.userinfo),
            (K.host = $.host),
            (K.port = $.port),
            (K.path = ye($.path || "")),
            (K.query = $.query))
          : ($.userinfo !== void 0 || $.host !== void 0 || $.port !== void 0
              ? ((K.userinfo = $.userinfo),
                (K.host = $.host),
                (K.port = $.port),
                (K.path = ye($.path || "")),
                (K.query = $.query))
              : ($.path
                  ? ($.path.charAt(0) === "/"
                      ? (K.path = ye($.path))
                      : ((C.userinfo !== void 0 ||
                          C.host !== void 0 ||
                          C.port !== void 0) &&
                        !C.path
                          ? (K.path = "/" + $.path)
                          : C.path
                          ? (K.path =
                              C.path.slice(0, C.path.lastIndexOf("/") + 1) +
                              $.path)
                          : (K.path = $.path),
                        (K.path = ye(K.path))),
                    (K.query = $.query))
                  : ((K.path = C.path),
                    $.query !== void 0
                      ? (K.query = $.query)
                      : (K.query = C.query)),
                (K.userinfo = C.userinfo),
                (K.host = C.host),
                (K.port = C.port)),
            (K.scheme = C.scheme)),
        (K.fragment = $.fragment),
        K
      );
    }
    function Lt(C, $, b) {
      var D = c({ scheme: "null" }, b);
      return Qe(lt(le(C, D), le($, D), D, !0), D);
    }
    function We(C, $) {
      return (
        typeof C == "string"
          ? (C = Qe(le(C, $), $))
          : a(C) === "object" && (C = le(Qe(C, $), $)),
        C
      );
    }
    function bt(C, $, b) {
      return (
        typeof C == "string"
          ? (C = Qe(le(C, b), b))
          : a(C) === "object" && (C = Qe(C, b)),
        typeof $ == "string"
          ? ($ = Qe(le($, b), b))
          : a($) === "object" && ($ = Qe($, b)),
        C === $
      );
    }
    function wt(C, $) {
      return C && C.toString().replace(!$ || !$.iri ? f.ESCAPE : u.ESCAPE, N);
    }
    function ct(C, $) {
      return (
        C &&
        C.toString().replace(!$ || !$.iri ? f.PCT_ENCODED : u.PCT_ENCODED, ce)
      );
    }
    var ze = {
        scheme: "http",
        domainHost: !0,
        parse: function ($, b) {
          return (
            $.host || ($.error = $.error || "HTTP URIs must have a host."), $
          );
        },
        serialize: function ($, b) {
          var D = String($.scheme).toLowerCase() === "https";
          return (
            ($.port === (D ? 443 : 80) || $.port === "") && ($.port = void 0),
            $.path || ($.path = "/"),
            $
          );
        },
      },
      dt = {
        scheme: "https",
        domainHost: ze.domainHost,
        parse: ze.parse,
        serialize: ze.serialize,
      };
    function ht(C) {
      return typeof C.secure == "boolean"
        ? C.secure
        : String(C.scheme).toLowerCase() === "wss";
    }
    var an = {
        scheme: "ws",
        domainHost: !0,
        parse: function ($, b) {
          var D = $;
          return (
            (D.secure = ht(D)),
            (D.resourceName = (D.path || "/") + (D.query ? "?" + D.query : "")),
            (D.path = void 0),
            (D.query = void 0),
            D
          );
        },
        serialize: function ($, b) {
          if (
            (($.port === (ht($) ? 443 : 80) || $.port === "") &&
              ($.port = void 0),
            typeof $.secure == "boolean" &&
              (($.scheme = $.secure ? "wss" : "ws"), ($.secure = void 0)),
            $.resourceName)
          ) {
            var D = $.resourceName.split("?"),
              K = d(D, 2),
              se = K[0],
              pe = K[1];
            ($.path = se && se !== "/" ? se : void 0),
              ($.query = pe),
              ($.resourceName = void 0);
          }
          return ($.fragment = void 0), $;
        },
      },
      $n = {
        scheme: "wss",
        domainHost: an.domainHost,
        parse: an.parse,
        serialize: an.serialize,
      },
      Wt = {},
      Jt =
        "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]",
      Zt = "[0-9A-Fa-f]",
      jr = i(
        i("%[EFef]" + Zt + "%" + Zt + Zt + "%" + Zt + Zt) +
          "|" +
          i("%[89A-Fa-f]" + Zt + "%" + Zt + Zt) +
          "|" +
          i("%" + Zt + Zt),
      ),
      Nn = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]",
      Vr = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",
      Vi = r(Vr, '[\\"\\\\]'),
      On = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]",
      ni = new RegExp(Jt, "g"),
      An = new RegExp(jr, "g"),
      Mr = new RegExp(r("[^]", Nn, "[\\.]", '[\\"]', Vi), "g"),
      Hr = new RegExp(r("[^]", Jt, On), "g"),
      Yi = Hr;
    function qr(C) {
      var $ = ce(C);
      return $.match(ni) ? $ : C;
    }
    var ns = {
        scheme: "mailto",
        parse: function ($, b) {
          var D = $,
            K = (D.to = D.path ? D.path.split(",") : []);
          if (((D.path = void 0), D.query)) {
            for (
              var se = !1,
                pe = {},
                we = D.query.split("&"),
                Re = 0,
                ke = we.length;
              Re < ke;
              ++Re
            ) {
              var je = we[Re].split("=");
              switch (je[0]) {
                case "to":
                  for (
                    var Te = je[1].split(","), Me = 0, Ne = Te.length;
                    Me < Ne;
                    ++Me
                  )
                    K.push(Te[Me]);
                  break;
                case "subject":
                  D.subject = ct(je[1], b);
                  break;
                case "body":
                  D.body = ct(je[1], b);
                  break;
                default:
                  (se = !0), (pe[ct(je[0], b)] = ct(je[1], b));
                  break;
              }
            }
            se && (D.headers = pe);
          }
          D.query = void 0;
          for (var Ue = 0, qe = K.length; Ue < qe; ++Ue) {
            var Fe = K[Ue].split("@");
            if (((Fe[0] = ct(Fe[0])), b.unicodeSupport))
              Fe[1] = ct(Fe[1], b).toLowerCase();
            else
              try {
                Fe[1] = V.toASCII(ct(Fe[1], b).toLowerCase());
              } catch (Je) {
                D.error =
                  D.error ||
                  "Email address's domain name can not be converted to ASCII via punycode: " +
                    Je;
              }
            K[Ue] = Fe.join("@");
          }
          return D;
        },
        serialize: function ($, b) {
          var D = $,
            K = o($.to);
          if (K) {
            for (var se = 0, pe = K.length; se < pe; ++se) {
              var we = String(K[se]),
                Re = we.lastIndexOf("@"),
                ke = we
                  .slice(0, Re)
                  .replace(An, qr)
                  .replace(An, s)
                  .replace(Mr, N),
                je = we.slice(Re + 1);
              try {
                je = b.iri
                  ? V.toUnicode(je)
                  : V.toASCII(ct(je, b).toLowerCase());
              } catch (Ue) {
                D.error =
                  D.error ||
                  "Email address's domain name can not be converted to " +
                    (b.iri ? "Unicode" : "ASCII") +
                    " via punycode: " +
                    Ue;
              }
              K[se] = ke + "@" + je;
            }
            D.path = K.join(",");
          }
          var Te = ($.headers = $.headers || {});
          $.subject && (Te.subject = $.subject), $.body && (Te.body = $.body);
          var Me = [];
          for (var Ne in Te)
            Te[Ne] !== Wt[Ne] &&
              Me.push(
                Ne.replace(An, qr).replace(An, s).replace(Hr, N) +
                  "=" +
                  Te[Ne].replace(An, qr).replace(An, s).replace(Yi, N),
              );
          return Me.length && (D.query = Me.join("&")), D;
        },
      },
      kc = /^([^\:]+)\:(.*)/,
      Bn = {
        scheme: "urn",
        parse: function ($, b) {
          var D = $.path && $.path.match(kc),
            K = $;
          if (D) {
            var se = b.scheme || K.scheme || "urn",
              pe = D[1].toLowerCase(),
              we = D[2],
              Re = se + ":" + (b.nid || pe),
              ke = B[Re];
            (K.nid = pe),
              (K.nss = we),
              (K.path = void 0),
              ke && (K = ke.parse(K, b));
          } else K.error = K.error || "URN can not be parsed.";
          return K;
        },
        serialize: function ($, b) {
          var D = b.scheme || $.scheme || "urn",
            K = $.nid,
            se = D + ":" + (b.nid || K),
            pe = B[se];
          pe && ($ = pe.serialize($, b));
          var we = $,
            Re = $.nss;
          return (we.path = (K || b.nid) + ":" + Re), we;
        },
      },
      no = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,
      P = {
        scheme: "urn:uuid",
        parse: function ($, b) {
          var D = $;
          return (
            (D.uuid = D.nss),
            (D.nss = void 0),
            !b.tolerant &&
              (!D.uuid || !D.uuid.match(no)) &&
              (D.error = D.error || "UUID is not valid."),
            D
          );
        },
        serialize: function ($, b) {
          var D = $;
          return (D.nss = ($.uuid || "").toLowerCase()), D;
        },
      };
    (B[ze.scheme] = ze),
      (B[dt.scheme] = dt),
      (B[an.scheme] = an),
      (B[$n.scheme] = $n),
      (B[ns.scheme] = ns),
      (B[Bn.scheme] = Bn),
      (B[P.scheme] = P),
      (n.SCHEMES = B),
      (n.pctEncChar = N),
      (n.pctDecChars = ce),
      (n.parse = le),
      (n.removeDotSegments = ye),
      (n.serialize = Qe),
      (n.resolveComponents = lt),
      (n.resolve = Lt),
      (n.normalize = We),
      (n.equal = bt),
      (n.escapeComponent = wt),
      (n.unescapeComponent = ct),
      Object.defineProperty(n, "__esModule", { value: !0 });
  });
})(E0, E0.exports);
var H4 = E0.exports;
Object.defineProperty(Ey, "__esModule", { value: !0 });
const q4 = H4;
q4.code = 'require("ajv/dist/runtime/uri").default';
Ey.default = q4;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.CodeGen =
      e.Name =
      e.nil =
      e.stringify =
      e.str =
      e._ =
      e.KeywordCxt =
        void 0);
  var t = yi;
  Object.defineProperty(e, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return t.KeywordCxt;
    },
  });
  var n = $t;
  Object.defineProperty(e, "_", {
    enumerable: !0,
    get: function () {
      return n._;
    },
  }),
    Object.defineProperty(e, "str", {
      enumerable: !0,
      get: function () {
        return n.str;
      },
    }),
    Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function () {
        return n.stringify;
      },
    }),
    Object.defineProperty(e, "nil", {
      enumerable: !0,
      get: function () {
        return n.nil;
      },
    }),
    Object.defineProperty(e, "Name", {
      enumerable: !0,
      get: function () {
        return n.Name;
      },
    }),
    Object.defineProperty(e, "CodeGen", {
      enumerable: !0,
      get: function () {
        return n.CodeGen;
      },
    });
  const r = uu,
    i = fu,
    a = Fs,
    s = Dr,
    o = $t,
    c = nr,
    l = lu,
    f = Ut,
    u = xQ,
    d = Ey,
    p = (L, k) => new RegExp(L, k);
  p.code = "new RegExp";
  const h = ["removeAdditional", "useDefaults", "coerceTypes"],
    m = new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error",
    ]),
    g = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs:
        "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode:
        "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats:
        "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now.",
    },
    v = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode:
        '"minLength"/"maxLength" account for unicode characters by default.',
    },
    y = 200;
  function _(L) {
    var k,
      W,
      F,
      x,
      T,
      V,
      B,
      N,
      ce,
      re,
      ne,
      Y,
      M,
      oe,
      Ee,
      le,
      te,
      ie,
      X,
      he,
      be,
      ye,
      Qe,
      lt,
      Lt;
    const We = L.strict,
      bt = (k = L.code) === null || k === void 0 ? void 0 : k.optimize,
      wt = bt === !0 || bt === void 0 ? 1 : bt || 0,
      ct =
        (F = (W = L.code) === null || W === void 0 ? void 0 : W.regExp) !==
          null && F !== void 0
          ? F
          : p,
      ze = (x = L.uriResolver) !== null && x !== void 0 ? x : d.default;
    return {
      strictSchema:
        (V = (T = L.strictSchema) !== null && T !== void 0 ? T : We) !== null &&
        V !== void 0
          ? V
          : !0,
      strictNumbers:
        (N = (B = L.strictNumbers) !== null && B !== void 0 ? B : We) !==
          null && N !== void 0
          ? N
          : !0,
      strictTypes:
        (re = (ce = L.strictTypes) !== null && ce !== void 0 ? ce : We) !==
          null && re !== void 0
          ? re
          : "log",
      strictTuples:
        (Y = (ne = L.strictTuples) !== null && ne !== void 0 ? ne : We) !==
          null && Y !== void 0
          ? Y
          : "log",
      strictRequired:
        (oe = (M = L.strictRequired) !== null && M !== void 0 ? M : We) !==
          null && oe !== void 0
          ? oe
          : !1,
      code: L.code
        ? { ...L.code, optimize: wt, regExp: ct }
        : { optimize: wt, regExp: ct },
      loopRequired: (Ee = L.loopRequired) !== null && Ee !== void 0 ? Ee : y,
      loopEnum: (le = L.loopEnum) !== null && le !== void 0 ? le : y,
      meta: (te = L.meta) !== null && te !== void 0 ? te : !0,
      messages: (ie = L.messages) !== null && ie !== void 0 ? ie : !0,
      inlineRefs: (X = L.inlineRefs) !== null && X !== void 0 ? X : !0,
      schemaId: (he = L.schemaId) !== null && he !== void 0 ? he : "$id",
      addUsedSchema: (be = L.addUsedSchema) !== null && be !== void 0 ? be : !0,
      validateSchema:
        (ye = L.validateSchema) !== null && ye !== void 0 ? ye : !0,
      validateFormats:
        (Qe = L.validateFormats) !== null && Qe !== void 0 ? Qe : !0,
      unicodeRegExp: (lt = L.unicodeRegExp) !== null && lt !== void 0 ? lt : !0,
      int32range: (Lt = L.int32range) !== null && Lt !== void 0 ? Lt : !0,
      uriResolver: ze,
    };
  }
  class E {
    constructor(k = {}) {
      (this.schemas = {}),
        (this.refs = {}),
        (this.formats = {}),
        (this._compilations = new Set()),
        (this._loading = {}),
        (this._cache = new Map()),
        (k = this.opts = { ...k, ..._(k) });
      const { es5: W, lines: F } = this.opts.code;
      (this.scope = new o.ValueScope({
        scope: {},
        prefixes: m,
        es5: W,
        lines: F,
      })),
        (this.logger = j(k.logger));
      const x = k.validateFormats;
      (k.validateFormats = !1),
        (this.RULES = (0, a.getRules)()),
        R.call(this, g, k, "NOT SUPPORTED"),
        R.call(this, v, k, "DEPRECATED", "warn"),
        (this._metaOpts = O.call(this)),
        k.formats && S.call(this),
        this._addVocabularies(),
        this._addDefaultMetaSchema(),
        k.keywords && w.call(this, k.keywords),
        typeof k.meta == "object" && this.addMetaSchema(k.meta),
        I.call(this),
        (k.validateFormats = x);
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: k, meta: W, schemaId: F } = this.opts;
      let x = u;
      F === "id" && ((x = { ...u }), (x.id = x.$id), delete x.$id),
        W && k && this.addMetaSchema(x, x[F], !1);
    }
    defaultMeta() {
      const { meta: k, schemaId: W } = this.opts;
      return (this.opts.defaultMeta =
        typeof k == "object" ? k[W] || k : void 0);
    }
    validate(k, W) {
      let F;
      if (typeof k == "string") {
        if (((F = this.getSchema(k)), !F))
          throw new Error(`no schema with key or ref "${k}"`);
      } else F = this.compile(k);
      const x = F(W);
      return "$async" in F || (this.errors = F.errors), x;
    }
    compile(k, W) {
      const F = this._addSchema(k, W);
      return F.validate || this._compileSchemaEnv(F);
    }
    compileAsync(k, W) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: F } = this.opts;
      return x.call(this, k, W);
      async function x(re, ne) {
        await T.call(this, re.$schema);
        const Y = this._addSchema(re, ne);
        return Y.validate || V.call(this, Y);
      }
      async function T(re) {
        re && !this.getSchema(re) && (await x.call(this, { $ref: re }, !0));
      }
      async function V(re) {
        try {
          return this._compileSchemaEnv(re);
        } catch (ne) {
          if (!(ne instanceof i.default)) throw ne;
          return (
            B.call(this, ne),
            await N.call(this, ne.missingSchema),
            V.call(this, re)
          );
        }
      }
      function B({ missingSchema: re, missingRef: ne }) {
        if (this.refs[re])
          throw new Error(
            `AnySchema ${re} is loaded but ${ne} cannot be resolved`,
          );
      }
      async function N(re) {
        const ne = await ce.call(this, re);
        this.refs[re] || (await T.call(this, ne.$schema)),
          this.refs[re] || this.addSchema(ne, re, W);
      }
      async function ce(re) {
        const ne = this._loading[re];
        if (ne) return ne;
        try {
          return await (this._loading[re] = F(re));
        } finally {
          delete this._loading[re];
        }
      }
    }
    addSchema(k, W, F, x = this.opts.validateSchema) {
      if (Array.isArray(k)) {
        for (const V of k) this.addSchema(V, void 0, F, x);
        return this;
      }
      let T;
      if (typeof k == "object") {
        const { schemaId: V } = this.opts;
        if (((T = k[V]), T !== void 0 && typeof T != "string"))
          throw new Error(`schema ${V} must be string`);
      }
      return (
        (W = (0, c.normalizeId)(W || T)),
        this._checkUnique(W),
        (this.schemas[W] = this._addSchema(k, F, W, x, !0)),
        this
      );
    }
    addMetaSchema(k, W, F = this.opts.validateSchema) {
      return this.addSchema(k, W, !0, F), this;
    }
    validateSchema(k, W) {
      if (typeof k == "boolean") return !0;
      let F;
      if (((F = k.$schema), F !== void 0 && typeof F != "string"))
        throw new Error("$schema must be a string");
      if (((F = F || this.opts.defaultMeta || this.defaultMeta()), !F))
        return (
          this.logger.warn("meta-schema not available"),
          (this.errors = null),
          !0
        );
      const x = this.validate(F, k);
      if (!x && W) {
        const T = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log") this.logger.error(T);
        else throw new Error(T);
      }
      return x;
    }
    getSchema(k) {
      let W;
      for (; typeof (W = A.call(this, k)) == "string"; ) k = W;
      if (W === void 0) {
        const { schemaId: F } = this.opts,
          x = new s.SchemaEnv({ schema: {}, schemaId: F });
        if (((W = s.resolveSchema.call(this, x, k)), !W)) return;
        this.refs[k] = W;
      }
      return W.validate || this._compileSchemaEnv(W);
    }
    removeSchema(k) {
      if (k instanceof RegExp)
        return (
          this._removeAllSchemas(this.schemas, k),
          this._removeAllSchemas(this.refs, k),
          this
        );
      switch (typeof k) {
        case "undefined":
          return (
            this._removeAllSchemas(this.schemas),
            this._removeAllSchemas(this.refs),
            this._cache.clear(),
            this
          );
        case "string": {
          const W = A.call(this, k);
          return (
            typeof W == "object" && this._cache.delete(W.schema),
            delete this.schemas[k],
            delete this.refs[k],
            this
          );
        }
        case "object": {
          const W = k;
          this._cache.delete(W);
          let F = k[this.opts.schemaId];
          return (
            F &&
              ((F = (0, c.normalizeId)(F)),
              delete this.schemas[F],
              delete this.refs[F]),
            this
          );
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(k) {
      for (const W of k) this.addKeyword(W);
      return this;
    }
    addKeyword(k, W) {
      let F;
      if (typeof k == "string")
        (F = k),
          typeof W == "object" &&
            (this.logger.warn(
              "these parameters are deprecated, see docs for addKeyword",
            ),
            (W.keyword = F));
      else if (typeof k == "object" && W === void 0) {
        if (((W = k), (F = W.keyword), Array.isArray(F) && !F.length))
          throw new Error(
            "addKeywords: keyword must be string or non-empty array",
          );
      } else throw new Error("invalid addKeywords parameters");
      if ((q.call(this, F, W), !W))
        return (0, f.eachItem)(F, (T) => J.call(this, T)), this;
      z.call(this, W);
      const x = {
        ...W,
        type: (0, l.getJSONTypes)(W.type),
        schemaType: (0, l.getJSONTypes)(W.schemaType),
      };
      return (
        (0, f.eachItem)(
          F,
          x.type.length === 0
            ? (T) => J.call(this, T, x)
            : (T) => x.type.forEach((V) => J.call(this, T, x, V)),
        ),
        this
      );
    }
    getKeyword(k) {
      const W = this.RULES.all[k];
      return typeof W == "object" ? W.definition : !!W;
    }
    removeKeyword(k) {
      const { RULES: W } = this;
      delete W.keywords[k], delete W.all[k];
      for (const F of W.rules) {
        const x = F.rules.findIndex((T) => T.keyword === k);
        x >= 0 && F.rules.splice(x, 1);
      }
      return this;
    }
    addFormat(k, W) {
      return (
        typeof W == "string" && (W = new RegExp(W)), (this.formats[k] = W), this
      );
    }
    errorsText(
      k = this.errors,
      { separator: W = ", ", dataVar: F = "data" } = {},
    ) {
      return !k || k.length === 0
        ? "No errors"
        : k
            .map((x) => `${F}${x.instancePath} ${x.message}`)
            .reduce((x, T) => x + W + T);
    }
    $dataMetaSchema(k, W) {
      const F = this.RULES.all;
      k = JSON.parse(JSON.stringify(k));
      for (const x of W) {
        const T = x.split("/").slice(1);
        let V = k;
        for (const B of T) V = V[B];
        for (const B in F) {
          const N = F[B];
          if (typeof N != "object") continue;
          const { $data: ce } = N.definition,
            re = V[B];
          ce && re && (V[B] = G(re));
        }
      }
      return k;
    }
    _removeAllSchemas(k, W) {
      for (const F in k) {
        const x = k[F];
        (!W || W.test(F)) &&
          (typeof x == "string"
            ? delete k[F]
            : x && !x.meta && (this._cache.delete(x.schema), delete k[F]));
      }
    }
    _addSchema(
      k,
      W,
      F,
      x = this.opts.validateSchema,
      T = this.opts.addUsedSchema,
    ) {
      let V;
      const { schemaId: B } = this.opts;
      if (typeof k == "object") V = k[B];
      else {
        if (this.opts.jtd) throw new Error("schema must be object");
        if (typeof k != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let N = this._cache.get(k);
      if (N !== void 0) return N;
      F = (0, c.normalizeId)(V || F);
      const ce = c.getSchemaRefs.call(this, k, F);
      return (
        (N = new s.SchemaEnv({
          schema: k,
          schemaId: B,
          meta: W,
          baseId: F,
          localRefs: ce,
        })),
        this._cache.set(N.schema, N),
        T &&
          !F.startsWith("#") &&
          (F && this._checkUnique(F), (this.refs[F] = N)),
        x && this.validateSchema(k, !0),
        N
      );
    }
    _checkUnique(k) {
      if (this.schemas[k] || this.refs[k])
        throw new Error(`schema with key or id "${k}" already exists`);
    }
    _compileSchemaEnv(k) {
      if (
        (k.meta ? this._compileMetaSchema(k) : s.compileSchema.call(this, k),
        !k.validate)
      )
        throw new Error("ajv implementation error");
      return k.validate;
    }
    _compileMetaSchema(k) {
      const W = this.opts;
      this.opts = this._metaOpts;
      try {
        s.compileSchema.call(this, k);
      } finally {
        this.opts = W;
      }
    }
  }
  (e.default = E),
    (E.ValidationError = r.default),
    (E.MissingRefError = i.default);
  function R(L, k, W, F = "error") {
    for (const x in L) {
      const T = x;
      T in k && this.logger[F](`${W}: option ${x}. ${L[T]}`);
    }
  }
  function A(L) {
    return (L = (0, c.normalizeId)(L)), this.schemas[L] || this.refs[L];
  }
  function I() {
    const L = this.opts.schemas;
    if (L)
      if (Array.isArray(L)) this.addSchema(L);
      else for (const k in L) this.addSchema(L[k], k);
  }
  function S() {
    for (const L in this.opts.formats) {
      const k = this.opts.formats[L];
      k && this.addFormat(L, k);
    }
  }
  function w(L) {
    if (Array.isArray(L)) {
      this.addVocabulary(L);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const k in L) {
      const W = L[k];
      W.keyword || (W.keyword = k), this.addKeyword(W);
    }
  }
  function O() {
    const L = { ...this.opts };
    for (const k of h) delete L[k];
    return L;
  }
  const Q = { log() {}, warn() {}, error() {} };
  function j(L) {
    if (L === !1) return Q;
    if (L === void 0) return console;
    if (L.log && L.warn && L.error) return L;
    throw new Error("logger must implement log, warn and error methods");
  }
  const H = /^[a-z_$][a-z0-9_$:-]*$/i;
  function q(L, k) {
    const { RULES: W } = this;
    if (
      ((0, f.eachItem)(L, (F) => {
        if (W.keywords[F]) throw new Error(`Keyword ${F} is already defined`);
        if (!H.test(F)) throw new Error(`Keyword ${F} has invalid name`);
      }),
      !!k && k.$data && !("code" in k || "validate" in k))
    )
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function J(L, k, W) {
    var F;
    const x = k == null ? void 0 : k.post;
    if (W && x) throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: T } = this;
    let V = x ? T.post : T.rules.find(({ type: N }) => N === W);
    if (
      (V || ((V = { type: W, rules: [] }), T.rules.push(V)),
      (T.keywords[L] = !0),
      !k)
    )
      return;
    const B = {
      keyword: L,
      definition: {
        ...k,
        type: (0, l.getJSONTypes)(k.type),
        schemaType: (0, l.getJSONTypes)(k.schemaType),
      },
    };
    k.before ? Z.call(this, V, B, k.before) : V.rules.push(B),
      (T.all[L] = B),
      (F = k.implements) === null ||
        F === void 0 ||
        F.forEach((N) => this.addKeyword(N));
  }
  function Z(L, k, W) {
    const F = L.rules.findIndex((x) => x.keyword === W);
    F >= 0
      ? L.rules.splice(F, 0, k)
      : (L.rules.push(k), this.logger.warn(`rule ${W} is not defined`));
  }
  function z(L) {
    let { metaSchema: k } = L;
    k !== void 0 &&
      (L.$data && this.opts.$data && (k = G(k)),
      (L.validateSchema = this.compile(k, !0)));
  }
  const U = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
  };
  function G(L) {
    return { anyOf: [L, U] };
  }
})(y4);
var wy = {},
  xy = {},
  Ay = {};
Object.defineProperty(Ay, "__esModule", { value: !0 });
const AQ = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  },
};
Ay.default = AQ;
var js = {};
Object.defineProperty(js, "__esModule", { value: !0 });
js.callRef = js.getValidate = void 0;
const SQ = fu,
  Ix = St,
  Nr = $t,
  fo = Wi,
  $x = Dr,
  gf = Ut,
  IQ = {
    keyword: "$ref",
    schemaType: "string",
    code(e) {
      const { gen: t, schema: n, it: r } = e,
        { baseId: i, schemaEnv: a, validateName: s, opts: o, self: c } = r,
        { root: l } = a;
      if ((n === "#" || n === "#/") && i === l.baseId) return u();
      const f = $x.resolveRef.call(c, l, i, n);
      if (f === void 0) throw new SQ.default(r.opts.uriResolver, i, n);
      if (f instanceof $x.SchemaEnv) return d(f);
      return p(f);
      function u() {
        if (a === l) return Hf(e, s, a, a.$async);
        const h = t.scopeValue("root", { ref: l });
        return Hf(e, (0, Nr._)`${h}.validate`, l, l.$async);
      }
      function d(h) {
        const m = G4(e, h);
        Hf(e, m, h, h.$async);
      }
      function p(h) {
        const m = t.scopeValue(
            "schema",
            o.code.source === !0
              ? { ref: h, code: (0, Nr.stringify)(h) }
              : { ref: h },
          ),
          g = t.name("valid"),
          v = e.subschema(
            {
              schema: h,
              dataTypes: [],
              schemaPath: Nr.nil,
              topSchemaRef: m,
              errSchemaPath: n,
            },
            g,
          );
        e.mergeEvaluated(v), e.ok(g);
      }
    },
  };
function G4(e, t) {
  const { gen: n } = e;
  return t.validate
    ? n.scopeValue("validate", { ref: t.validate })
    : (0, Nr._)`${n.scopeValue("wrapper", { ref: t })}.validate`;
}
js.getValidate = G4;
function Hf(e, t, n, r) {
  const { gen: i, it: a } = e,
    { allErrors: s, schemaEnv: o, opts: c } = a,
    l = c.passContext ? fo.default.this : Nr.nil;
  r ? f() : u();
  function f() {
    if (!o.$async) throw new Error("async schema referenced by sync schema");
    const h = i.let("valid");
    i.try(
      () => {
        i.code((0, Nr._)`await ${(0, Ix.callValidateCode)(e, t, l)}`),
          p(t),
          s || i.assign(h, !0);
      },
      (m) => {
        i.if((0, Nr._)`!(${m} instanceof ${a.ValidationError})`, () =>
          i.throw(m),
        ),
          d(m),
          s || i.assign(h, !1);
      },
    ),
      e.ok(h);
  }
  function u() {
    e.result(
      (0, Ix.callValidateCode)(e, t, l),
      () => p(t),
      () => d(t),
    );
  }
  function d(h) {
    const m = (0, Nr._)`${h}.errors`;
    i.assign(
      fo.default.vErrors,
      (0,
      Nr._)`${fo.default.vErrors} === null ? ${m} : ${fo.default.vErrors}.concat(${m})`,
    ),
      i.assign(fo.default.errors, (0, Nr._)`${fo.default.vErrors}.length`);
  }
  function p(h) {
    var m;
    if (!a.opts.unevaluated) return;
    const g =
      (m = n == null ? void 0 : n.validate) === null || m === void 0
        ? void 0
        : m.evaluated;
    if (a.props !== !0)
      if (g && !g.dynamicProps)
        g.props !== void 0 &&
          (a.props = gf.mergeEvaluated.props(i, g.props, a.props));
      else {
        const v = i.var("props", (0, Nr._)`${h}.evaluated.props`);
        a.props = gf.mergeEvaluated.props(i, v, a.props, Nr.Name);
      }
    if (a.items !== !0)
      if (g && !g.dynamicItems)
        g.items !== void 0 &&
          (a.items = gf.mergeEvaluated.items(i, g.items, a.items));
      else {
        const v = i.var("items", (0, Nr._)`${h}.evaluated.items`);
        a.items = gf.mergeEvaluated.items(i, v, a.items, Nr.Name);
      }
  }
}
js.callRef = Hf;
js.default = IQ;
Object.defineProperty(xy, "__esModule", { value: !0 });
const $Q = Ay,
  CQ = js,
  RQ = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    $Q.default,
    CQ.default,
  ];
xy.default = RQ;
var Sy = {},
  Iy = {};
Object.defineProperty(Iy, "__esModule", { value: !0 });
const _d = $t,
  Ea = _d.operators,
  Ed = {
    maximum: { okStr: "<=", ok: Ea.LTE, fail: Ea.GT },
    minimum: { okStr: ">=", ok: Ea.GTE, fail: Ea.LT },
    exclusiveMaximum: { okStr: "<", ok: Ea.LT, fail: Ea.GTE },
    exclusiveMinimum: { okStr: ">", ok: Ea.GT, fail: Ea.LTE },
  },
  kQ = {
    message: ({ keyword: e, schemaCode: t }) =>
      (0, _d.str)`must be ${Ed[e].okStr} ${t}`,
    params: ({ keyword: e, schemaCode: t }) =>
      (0, _d._)`{comparison: ${Ed[e].okStr}, limit: ${t}}`,
  },
  TQ = {
    keyword: Object.keys(Ed),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: kQ,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e;
      e.fail$data((0, _d._)`${n} ${Ed[t].fail} ${r} || isNaN(${n})`);
    },
  };
Iy.default = TQ;
var $y = {};
Object.defineProperty($y, "__esModule", { value: !0 });
const yl = $t,
  NQ = {
    message: ({ schemaCode: e }) => (0, yl.str)`must be multiple of ${e}`,
    params: ({ schemaCode: e }) => (0, yl._)`{multipleOf: ${e}}`,
  },
  OQ = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: NQ,
    code(e) {
      const { gen: t, data: n, schemaCode: r, it: i } = e,
        a = i.opts.multipleOfPrecision,
        s = t.let("res"),
        o = a
          ? (0, yl._)`Math.abs(Math.round(${s}) - ${s}) > 1e-${a}`
          : (0, yl._)`${s} !== parseInt(${s})`;
      e.fail$data((0, yl._)`(${r} === 0 || (${s} = ${n}/${r}, ${o}))`);
    },
  };
$y.default = OQ;
var Cy = {},
  Ry = {};
Object.defineProperty(Ry, "__esModule", { value: !0 });
function Q4(e) {
  const t = e.length;
  let n = 0,
    r = 0,
    i;
  for (; r < t; )
    n++,
      (i = e.charCodeAt(r++)),
      i >= 55296 &&
        i <= 56319 &&
        r < t &&
        ((i = e.charCodeAt(r)), (i & 64512) === 56320 && r++);
  return n;
}
Ry.default = Q4;
Q4.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(Cy, "__esModule", { value: !0 });
const bs = $t,
  PQ = Ut,
  DQ = Ry,
  LQ = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxLength" ? "more" : "fewer";
      return (0, bs.str)`must NOT have ${n} than ${t} characters`;
    },
    params: ({ schemaCode: e }) => (0, bs._)`{limit: ${e}}`,
  },
  BQ = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: LQ,
    code(e) {
      const { keyword: t, data: n, schemaCode: r, it: i } = e,
        a = t === "maxLength" ? bs.operators.GT : bs.operators.LT,
        s =
          i.opts.unicode === !1
            ? (0, bs._)`${n}.length`
            : (0, bs._)`${(0, PQ.useFunc)(e.gen, DQ.default)}(${n})`;
      e.fail$data((0, bs._)`${s} ${a} ${r}`);
    },
  };
Cy.default = BQ;
var ky = {};
Object.defineProperty(ky, "__esModule", { value: !0 });
const UQ = St,
  wd = $t,
  FQ = {
    message: ({ schemaCode: e }) => (0, wd.str)`must match pattern "${e}"`,
    params: ({ schemaCode: e }) => (0, wd._)`{pattern: ${e}}`,
  },
  jQ = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: FQ,
    code(e) {
      const { data: t, $data: n, schema: r, schemaCode: i, it: a } = e,
        s = a.opts.unicodeRegExp ? "u" : "",
        o = n ? (0, wd._)`(new RegExp(${i}, ${s}))` : (0, UQ.usePattern)(e, r);
      e.fail$data((0, wd._)`!${o}.test(${t})`);
    },
  };
ky.default = jQ;
var Ty = {};
Object.defineProperty(Ty, "__esModule", { value: !0 });
const bl = $t,
  MQ = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxProperties" ? "more" : "fewer";
      return (0, bl.str)`must NOT have ${n} than ${t} properties`;
    },
    params: ({ schemaCode: e }) => (0, bl._)`{limit: ${e}}`,
  },
  HQ = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: MQ,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e,
        i = t === "maxProperties" ? bl.operators.GT : bl.operators.LT;
      e.fail$data((0, bl._)`Object.keys(${n}).length ${i} ${r}`);
    },
  };
Ty.default = HQ;
var Ny = {};
Object.defineProperty(Ny, "__esModule", { value: !0 });
const Wc = St,
  _l = $t,
  qQ = Ut,
  GQ = {
    message: ({ params: { missingProperty: e } }) =>
      (0, _l.str)`must have required property '${e}'`,
    params: ({ params: { missingProperty: e } }) =>
      (0, _l._)`{missingProperty: ${e}}`,
  },
  QQ = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: GQ,
    code(e) {
      const { gen: t, schema: n, schemaCode: r, data: i, $data: a, it: s } = e,
        { opts: o } = s;
      if (!a && n.length === 0) return;
      const c = n.length >= o.loopRequired;
      if ((s.allErrors ? l() : f(), o.strictRequired)) {
        const p = e.parentSchema.properties,
          { definedProperties: h } = e.it;
        for (const m of n)
          if ((p == null ? void 0 : p[m]) === void 0 && !h.has(m)) {
            const g = s.schemaEnv.baseId + s.errSchemaPath,
              v = `required property "${m}" is not defined at "${g}" (strictRequired)`;
            (0, qQ.checkStrictMode)(s, v, s.opts.strictRequired);
          }
      }
      function l() {
        if (c || a) e.block$data(_l.nil, u);
        else for (const p of n) (0, Wc.checkReportMissingProp)(e, p);
      }
      function f() {
        const p = t.let("missing");
        if (c || a) {
          const h = t.let("valid", !0);
          e.block$data(h, () => d(p, h)), e.ok(h);
        } else
          t.if((0, Wc.checkMissingProp)(e, n, p)),
            (0, Wc.reportMissingProp)(e, p),
            t.else();
      }
      function u() {
        t.forOf("prop", r, (p) => {
          e.setParams({ missingProperty: p }),
            t.if((0, Wc.noPropertyInData)(t, i, p, o.ownProperties), () =>
              e.error(),
            );
        });
      }
      function d(p, h) {
        e.setParams({ missingProperty: p }),
          t.forOf(
            p,
            r,
            () => {
              t.assign(h, (0, Wc.propertyInData)(t, i, p, o.ownProperties)),
                t.if((0, _l.not)(h), () => {
                  e.error(), t.break();
                });
            },
            _l.nil,
          );
      }
    },
  };
Ny.default = QQ;
var Oy = {};
Object.defineProperty(Oy, "__esModule", { value: !0 });
const El = $t,
  WQ = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxItems" ? "more" : "fewer";
      return (0, El.str)`must NOT have ${n} than ${t} items`;
    },
    params: ({ schemaCode: e }) => (0, El._)`{limit: ${e}}`,
  },
  zQ = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: WQ,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e,
        i = t === "maxItems" ? El.operators.GT : El.operators.LT;
      e.fail$data((0, El._)`${n}.length ${i} ${r}`);
    },
  };
Oy.default = zQ;
var Py = {},
  du = {};
Object.defineProperty(du, "__esModule", { value: !0 });
const W4 = $p;
W4.code = 'require("ajv/dist/runtime/equal").default';
du.default = W4;
Object.defineProperty(Py, "__esModule", { value: !0 });
const km = lu,
  Xn = $t,
  KQ = Ut,
  VQ = du,
  YQ = {
    message: ({ params: { i: e, j: t } }) =>
      (0,
      Xn.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
    params: ({ params: { i: e, j: t } }) => (0, Xn._)`{i: ${e}, j: ${t}}`,
  },
  XQ = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: YQ,
    code(e) {
      const {
        gen: t,
        data: n,
        $data: r,
        schema: i,
        parentSchema: a,
        schemaCode: s,
        it: o,
      } = e;
      if (!r && !i) return;
      const c = t.let("valid"),
        l = a.items ? (0, km.getSchemaTypes)(a.items) : [];
      e.block$data(c, f, (0, Xn._)`${s} === false`), e.ok(c);
      function f() {
        const h = t.let("i", (0, Xn._)`${n}.length`),
          m = t.let("j");
        e.setParams({ i: h, j: m }),
          t.assign(c, !0),
          t.if((0, Xn._)`${h} > 1`, () => (u() ? d : p)(h, m));
      }
      function u() {
        return l.length > 0 && !l.some((h) => h === "object" || h === "array");
      }
      function d(h, m) {
        const g = t.name("item"),
          v = (0, km.checkDataTypes)(
            l,
            g,
            o.opts.strictNumbers,
            km.DataType.Wrong,
          ),
          y = t.const("indices", (0, Xn._)`{}`);
        t.for((0, Xn._)`;${h}--;`, () => {
          t.let(g, (0, Xn._)`${n}[${h}]`),
            t.if(v, (0, Xn._)`continue`),
            l.length > 1 &&
              t.if((0, Xn._)`typeof ${g} == "string"`, (0, Xn._)`${g} += "_"`),
            t
              .if((0, Xn._)`typeof ${y}[${g}] == "number"`, () => {
                t.assign(m, (0, Xn._)`${y}[${g}]`),
                  e.error(),
                  t.assign(c, !1).break();
              })
              .code((0, Xn._)`${y}[${g}] = ${h}`);
        });
      }
      function p(h, m) {
        const g = (0, KQ.useFunc)(t, VQ.default),
          v = t.name("outer");
        t.label(v).for((0, Xn._)`;${h}--;`, () =>
          t.for((0, Xn._)`${m} = ${h}; ${m}--;`, () =>
            t.if((0, Xn._)`${g}(${n}[${h}], ${n}[${m}])`, () => {
              e.error(), t.assign(c, !1).break(v);
            }),
          ),
        );
      }
    },
  };
Py.default = XQ;
var Dy = {};
Object.defineProperty(Dy, "__esModule", { value: !0 });
const w0 = $t,
  JQ = Ut,
  ZQ = du,
  eW = {
    message: "must be equal to constant",
    params: ({ schemaCode: e }) => (0, w0._)`{allowedValue: ${e}}`,
  },
  tW = {
    keyword: "const",
    $data: !0,
    error: eW,
    code(e) {
      const { gen: t, data: n, $data: r, schemaCode: i, schema: a } = e;
      r || (a && typeof a == "object")
        ? e.fail$data((0, w0._)`!${(0, JQ.useFunc)(t, ZQ.default)}(${n}, ${i})`)
        : e.fail((0, w0._)`${a} !== ${n}`);
    },
  };
Dy.default = tW;
var Ly = {};
Object.defineProperty(Ly, "__esModule", { value: !0 });
const il = $t,
  nW = Ut,
  rW = du,
  iW = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode: e }) => (0, il._)`{allowedValues: ${e}}`,
  },
  aW = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: iW,
    code(e) {
      const { gen: t, data: n, $data: r, schema: i, schemaCode: a, it: s } = e;
      if (!r && i.length === 0)
        throw new Error("enum must have non-empty array");
      const o = i.length >= s.opts.loopEnum;
      let c;
      const l = () => c ?? (c = (0, nW.useFunc)(t, rW.default));
      let f;
      if (o || r) (f = t.let("valid")), e.block$data(f, u);
      else {
        if (!Array.isArray(i)) throw new Error("ajv implementation error");
        const p = t.const("vSchema", a);
        f = (0, il.or)(...i.map((h, m) => d(p, m)));
      }
      e.pass(f);
      function u() {
        t.assign(f, !1),
          t.forOf("v", a, (p) =>
            t.if((0, il._)`${l()}(${n}, ${p})`, () => t.assign(f, !0).break()),
          );
      }
      function d(p, h) {
        const m = i[h];
        return typeof m == "object" && m !== null
          ? (0, il._)`${l()}(${n}, ${p}[${h}])`
          : (0, il._)`${n} === ${m}`;
      }
    },
  };
Ly.default = aW;
Object.defineProperty(Sy, "__esModule", { value: !0 });
const sW = Iy,
  oW = $y,
  cW = Cy,
  lW = ky,
  uW = Ty,
  fW = Ny,
  dW = Oy,
  pW = Py,
  hW = Dy,
  mW = Ly,
  gW = [
    sW.default,
    oW.default,
    cW.default,
    lW.default,
    uW.default,
    fW.default,
    dW.default,
    pW.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    hW.default,
    mW.default,
  ];
Sy.default = gW;
var By = {},
  Ac = {};
Object.defineProperty(Ac, "__esModule", { value: !0 });
Ac.validateAdditionalItems = void 0;
const _s = $t,
  x0 = Ut,
  vW = {
    message: ({ params: { len: e } }) =>
      (0, _s.str)`must NOT have more than ${e} items`,
    params: ({ params: { len: e } }) => (0, _s._)`{limit: ${e}}`,
  },
  yW = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: vW,
    code(e) {
      const { parentSchema: t, it: n } = e,
        { items: r } = t;
      if (!Array.isArray(r)) {
        (0, x0.checkStrictMode)(
          n,
          '"additionalItems" is ignored when "items" is not an array of schemas',
        );
        return;
      }
      z4(e, r);
    },
  };
function z4(e, t) {
  const { gen: n, schema: r, data: i, keyword: a, it: s } = e;
  s.items = !0;
  const o = n.const("len", (0, _s._)`${i}.length`);
  if (r === !1)
    e.setParams({ len: t.length }), e.pass((0, _s._)`${o} <= ${t.length}`);
  else if (typeof r == "object" && !(0, x0.alwaysValidSchema)(s, r)) {
    const l = n.var("valid", (0, _s._)`${o} <= ${t.length}`);
    n.if((0, _s.not)(l), () => c(l)), e.ok(l);
  }
  function c(l) {
    n.forRange("i", t.length, o, (f) => {
      e.subschema({ keyword: a, dataProp: f, dataPropType: x0.Type.Num }, l),
        s.allErrors || n.if((0, _s.not)(l), () => n.break());
    });
  }
}
Ac.validateAdditionalItems = z4;
Ac.default = yW;
var Uy = {},
  Sc = {};
Object.defineProperty(Sc, "__esModule", { value: !0 });
Sc.validateTuple = void 0;
const Cx = $t,
  qf = Ut,
  bW = St,
  _W = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(e) {
      const { schema: t, it: n } = e;
      if (Array.isArray(t)) return K4(e, "additionalItems", t);
      (n.items = !0),
        !(0, qf.alwaysValidSchema)(n, t) && e.ok((0, bW.validateArray)(e));
    },
  };
function K4(e, t, n = e.schema) {
  const { gen: r, parentSchema: i, data: a, keyword: s, it: o } = e;
  f(i),
    o.opts.unevaluated &&
      n.length &&
      o.items !== !0 &&
      (o.items = qf.mergeEvaluated.items(r, n.length, o.items));
  const c = r.name("valid"),
    l = r.const("len", (0, Cx._)`${a}.length`);
  n.forEach((u, d) => {
    (0, qf.alwaysValidSchema)(o, u) ||
      (r.if((0, Cx._)`${l} > ${d}`, () =>
        e.subschema({ keyword: s, schemaProp: d, dataProp: d }, c),
      ),
      e.ok(c));
  });
  function f(u) {
    const { opts: d, errSchemaPath: p } = o,
      h = n.length,
      m = h === u.minItems && (h === u.maxItems || u[t] === !1);
    if (d.strictTuples && !m) {
      const g = `"${s}" is ${h}-tuple, but minItems or maxItems/${t} are not specified or different at path "${p}"`;
      (0, qf.checkStrictMode)(o, g, d.strictTuples);
    }
  }
}
Sc.validateTuple = K4;
Sc.default = _W;
Object.defineProperty(Uy, "__esModule", { value: !0 });
const EW = Sc,
  wW = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (e) => (0, EW.validateTuple)(e, "items"),
  };
Uy.default = wW;
var Fy = {};
Object.defineProperty(Fy, "__esModule", { value: !0 });
const Rx = $t,
  xW = Ut,
  AW = St,
  SW = Ac,
  IW = {
    message: ({ params: { len: e } }) =>
      (0, Rx.str)`must NOT have more than ${e} items`,
    params: ({ params: { len: e } }) => (0, Rx._)`{limit: ${e}}`,
  },
  $W = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: IW,
    code(e) {
      const { schema: t, parentSchema: n, it: r } = e,
        { prefixItems: i } = n;
      (r.items = !0),
        !(0, xW.alwaysValidSchema)(r, t) &&
          (i
            ? (0, SW.validateAdditionalItems)(e, i)
            : e.ok((0, AW.validateArray)(e)));
    },
  };
Fy.default = $W;
var jy = {};
Object.defineProperty(jy, "__esModule", { value: !0 });
const Jr = $t,
  vf = Ut,
  CW = {
    message: ({ params: { min: e, max: t } }) =>
      t === void 0
        ? (0, Jr.str)`must contain at least ${e} valid item(s)`
        : (0,
          Jr.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
    params: ({ params: { min: e, max: t } }) =>
      t === void 0
        ? (0, Jr._)`{minContains: ${e}}`
        : (0, Jr._)`{minContains: ${e}, maxContains: ${t}}`,
  },
  RW = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: CW,
    code(e) {
      const { gen: t, schema: n, parentSchema: r, data: i, it: a } = e;
      let s, o;
      const { minContains: c, maxContains: l } = r;
      a.opts.next ? ((s = c === void 0 ? 1 : c), (o = l)) : (s = 1);
      const f = t.const("len", (0, Jr._)`${i}.length`);
      if ((e.setParams({ min: s, max: o }), o === void 0 && s === 0)) {
        (0, vf.checkStrictMode)(
          a,
          '"minContains" == 0 without "maxContains": "contains" keyword ignored',
        );
        return;
      }
      if (o !== void 0 && s > o) {
        (0, vf.checkStrictMode)(
          a,
          '"minContains" > "maxContains" is always invalid',
        ),
          e.fail();
        return;
      }
      if ((0, vf.alwaysValidSchema)(a, n)) {
        let m = (0, Jr._)`${f} >= ${s}`;
        o !== void 0 && (m = (0, Jr._)`${m} && ${f} <= ${o}`), e.pass(m);
        return;
      }
      a.items = !0;
      const u = t.name("valid");
      o === void 0 && s === 1
        ? p(u, () => t.if(u, () => t.break()))
        : s === 0
        ? (t.let(u, !0), o !== void 0 && t.if((0, Jr._)`${i}.length > 0`, d))
        : (t.let(u, !1), d()),
        e.result(u, () => e.reset());
      function d() {
        const m = t.name("_valid"),
          g = t.let("count", 0);
        p(m, () => t.if(m, () => h(g)));
      }
      function p(m, g) {
        t.forRange("i", 0, f, (v) => {
          e.subschema(
            {
              keyword: "contains",
              dataProp: v,
              dataPropType: vf.Type.Num,
              compositeRule: !0,
            },
            m,
          ),
            g();
        });
      }
      function h(m) {
        t.code((0, Jr._)`${m}++`),
          o === void 0
            ? t.if((0, Jr._)`${m} >= ${s}`, () => t.assign(u, !0).break())
            : (t.if((0, Jr._)`${m} > ${o}`, () => t.assign(u, !1).break()),
              s === 1
                ? t.assign(u, !0)
                : t.if((0, Jr._)`${m} >= ${s}`, () => t.assign(u, !0)));
      }
    },
  };
jy.default = RW;
var V4 = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0);
  const t = $t,
    n = Ut,
    r = St;
  e.error = {
    message: ({ params: { property: c, depsCount: l, deps: f } }) => {
      const u = l === 1 ? "property" : "properties";
      return (0, t.str)`must have ${u} ${f} when property ${c} is present`;
    },
    params: ({
      params: { property: c, depsCount: l, deps: f, missingProperty: u },
    }) => (0, t._)`{property: ${c},
    missingProperty: ${u},
    depsCount: ${l},
    deps: ${f}}`,
  };
  const i = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(c) {
      const [l, f] = a(c);
      s(c, l), o(c, f);
    },
  };
  function a({ schema: c }) {
    const l = {},
      f = {};
    for (const u in c) {
      if (u === "__proto__") continue;
      const d = Array.isArray(c[u]) ? l : f;
      d[u] = c[u];
    }
    return [l, f];
  }
  function s(c, l = c.schema) {
    const { gen: f, data: u, it: d } = c;
    if (Object.keys(l).length === 0) return;
    const p = f.let("missing");
    for (const h in l) {
      const m = l[h];
      if (m.length === 0) continue;
      const g = (0, r.propertyInData)(f, u, h, d.opts.ownProperties);
      c.setParams({ property: h, depsCount: m.length, deps: m.join(", ") }),
        d.allErrors
          ? f.if(g, () => {
              for (const v of m) (0, r.checkReportMissingProp)(c, v);
            })
          : (f.if((0, t._)`${g} && (${(0, r.checkMissingProp)(c, m, p)})`),
            (0, r.reportMissingProp)(c, p),
            f.else());
    }
  }
  e.validatePropertyDeps = s;
  function o(c, l = c.schema) {
    const { gen: f, data: u, keyword: d, it: p } = c,
      h = f.name("valid");
    for (const m in l)
      (0, n.alwaysValidSchema)(p, l[m]) ||
        (f.if(
          (0, r.propertyInData)(f, u, m, p.opts.ownProperties),
          () => {
            const g = c.subschema({ keyword: d, schemaProp: m }, h);
            c.mergeValidEvaluated(g, h);
          },
          () => f.var(h, !0),
        ),
        c.ok(h));
  }
  (e.validateSchemaDeps = o), (e.default = i);
})(V4);
var My = {};
Object.defineProperty(My, "__esModule", { value: !0 });
const Y4 = $t,
  kW = Ut,
  TW = {
    message: "property name must be valid",
    params: ({ params: e }) => (0, Y4._)`{propertyName: ${e.propertyName}}`,
  },
  NW = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: TW,
    code(e) {
      const { gen: t, schema: n, data: r, it: i } = e;
      if ((0, kW.alwaysValidSchema)(i, n)) return;
      const a = t.name("valid");
      t.forIn("key", r, (s) => {
        e.setParams({ propertyName: s }),
          e.subschema(
            {
              keyword: "propertyNames",
              data: s,
              dataTypes: ["string"],
              propertyName: s,
              compositeRule: !0,
            },
            a,
          ),
          t.if((0, Y4.not)(a), () => {
            e.error(!0), i.allErrors || t.break();
          });
      }),
        e.ok(a);
    },
  };
My.default = NW;
var kp = {};
Object.defineProperty(kp, "__esModule", { value: !0 });
const yf = St,
  oi = $t,
  OW = Wi,
  bf = Ut,
  PW = {
    message: "must NOT have additional properties",
    params: ({ params: e }) =>
      (0, oi._)`{additionalProperty: ${e.additionalProperty}}`,
  },
  DW = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: PW,
    code(e) {
      const {
        gen: t,
        schema: n,
        parentSchema: r,
        data: i,
        errsCount: a,
        it: s,
      } = e;
      if (!a) throw new Error("ajv implementation error");
      const { allErrors: o, opts: c } = s;
      if (
        ((s.props = !0),
        c.removeAdditional !== "all" && (0, bf.alwaysValidSchema)(s, n))
      )
        return;
      const l = (0, yf.allSchemaProperties)(r.properties),
        f = (0, yf.allSchemaProperties)(r.patternProperties);
      u(), e.ok((0, oi._)`${a} === ${OW.default.errors}`);
      function u() {
        t.forIn("key", i, (g) => {
          !l.length && !f.length ? h(g) : t.if(d(g), () => h(g));
        });
      }
      function d(g) {
        let v;
        if (l.length > 8) {
          const y = (0, bf.schemaRefOrVal)(s, r.properties, "properties");
          v = (0, yf.isOwnProperty)(t, y, g);
        } else
          l.length
            ? (v = (0, oi.or)(...l.map((y) => (0, oi._)`${g} === ${y}`)))
            : (v = oi.nil);
        return (
          f.length &&
            (v = (0, oi.or)(
              v,
              ...f.map(
                (y) => (0, oi._)`${(0, yf.usePattern)(e, y)}.test(${g})`,
              ),
            )),
          (0, oi.not)(v)
        );
      }
      function p(g) {
        t.code((0, oi._)`delete ${i}[${g}]`);
      }
      function h(g) {
        if (c.removeAdditional === "all" || (c.removeAdditional && n === !1)) {
          p(g);
          return;
        }
        if (n === !1) {
          e.setParams({ additionalProperty: g }), e.error(), o || t.break();
          return;
        }
        if (typeof n == "object" && !(0, bf.alwaysValidSchema)(s, n)) {
          const v = t.name("valid");
          c.removeAdditional === "failing"
            ? (m(g, v, !1),
              t.if((0, oi.not)(v), () => {
                e.reset(), p(g);
              }))
            : (m(g, v), o || t.if((0, oi.not)(v), () => t.break()));
        }
      }
      function m(g, v, y) {
        const _ = {
          keyword: "additionalProperties",
          dataProp: g,
          dataPropType: bf.Type.Str,
        };
        y === !1 &&
          Object.assign(_, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1,
          }),
          e.subschema(_, v);
      }
    },
  };
kp.default = DW;
var Hy = {};
Object.defineProperty(Hy, "__esModule", { value: !0 });
const LW = yi,
  kx = St,
  Tm = Ut,
  Tx = kp,
  BW = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(e) {
      const { gen: t, schema: n, parentSchema: r, data: i, it: a } = e;
      a.opts.removeAdditional === "all" &&
        r.additionalProperties === void 0 &&
        Tx.default.code(
          new LW.KeywordCxt(a, Tx.default, "additionalProperties"),
        );
      const s = (0, kx.allSchemaProperties)(n);
      for (const u of s) a.definedProperties.add(u);
      a.opts.unevaluated &&
        s.length &&
        a.props !== !0 &&
        (a.props = Tm.mergeEvaluated.props(t, (0, Tm.toHash)(s), a.props));
      const o = s.filter((u) => !(0, Tm.alwaysValidSchema)(a, n[u]));
      if (o.length === 0) return;
      const c = t.name("valid");
      for (const u of o)
        l(u)
          ? f(u)
          : (t.if((0, kx.propertyInData)(t, i, u, a.opts.ownProperties)),
            f(u),
            a.allErrors || t.else().var(c, !0),
            t.endIf()),
          e.it.definedProperties.add(u),
          e.ok(c);
      function l(u) {
        return (
          a.opts.useDefaults && !a.compositeRule && n[u].default !== void 0
        );
      }
      function f(u) {
        e.subschema({ keyword: "properties", schemaProp: u, dataProp: u }, c);
      }
    },
  };
Hy.default = BW;
var qy = {};
Object.defineProperty(qy, "__esModule", { value: !0 });
const Nx = St,
  _f = $t,
  Ox = Ut,
  Px = Ut,
  UW = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(e) {
      const { gen: t, schema: n, data: r, parentSchema: i, it: a } = e,
        { opts: s } = a,
        o = (0, Nx.allSchemaProperties)(n),
        c = o.filter((m) => (0, Ox.alwaysValidSchema)(a, n[m]));
      if (
        o.length === 0 ||
        (c.length === o.length && (!a.opts.unevaluated || a.props === !0))
      )
        return;
      const l = s.strictSchema && !s.allowMatchingProperties && i.properties,
        f = t.name("valid");
      a.props !== !0 &&
        !(a.props instanceof _f.Name) &&
        (a.props = (0, Px.evaluatedPropsToName)(t, a.props));
      const { props: u } = a;
      d();
      function d() {
        for (const m of o)
          l && p(m), a.allErrors ? h(m) : (t.var(f, !0), h(m), t.if(f));
      }
      function p(m) {
        for (const g in l)
          new RegExp(m).test(g) &&
            (0, Ox.checkStrictMode)(
              a,
              `property ${g} matches pattern ${m} (use allowMatchingProperties)`,
            );
      }
      function h(m) {
        t.forIn("key", r, (g) => {
          t.if((0, _f._)`${(0, Nx.usePattern)(e, m)}.test(${g})`, () => {
            const v = c.includes(m);
            v ||
              e.subschema(
                {
                  keyword: "patternProperties",
                  schemaProp: m,
                  dataProp: g,
                  dataPropType: Px.Type.Str,
                },
                f,
              ),
              a.opts.unevaluated && u !== !0
                ? t.assign((0, _f._)`${u}[${g}]`, !0)
                : !v && !a.allErrors && t.if((0, _f.not)(f), () => t.break());
          });
        });
      }
    },
  };
qy.default = UW;
var Gy = {};
Object.defineProperty(Gy, "__esModule", { value: !0 });
const FW = Ut,
  jW = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(e) {
      const { gen: t, schema: n, it: r } = e;
      if ((0, FW.alwaysValidSchema)(r, n)) {
        e.fail();
        return;
      }
      const i = t.name("valid");
      e.subschema(
        { keyword: "not", compositeRule: !0, createErrors: !1, allErrors: !1 },
        i,
      ),
        e.failResult(
          i,
          () => e.reset(),
          () => e.error(),
        );
    },
    error: { message: "must NOT be valid" },
  };
Gy.default = jW;
var Qy = {};
Object.defineProperty(Qy, "__esModule", { value: !0 });
const MW = St,
  HW = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: MW.validateUnion,
    error: { message: "must match a schema in anyOf" },
  };
Qy.default = HW;
var Wy = {};
Object.defineProperty(Wy, "__esModule", { value: !0 });
const Gf = $t,
  qW = Ut,
  GW = {
    message: "must match exactly one schema in oneOf",
    params: ({ params: e }) => (0, Gf._)`{passingSchemas: ${e.passing}}`,
  },
  QW = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: GW,
    code(e) {
      const { gen: t, schema: n, parentSchema: r, it: i } = e;
      if (!Array.isArray(n)) throw new Error("ajv implementation error");
      if (i.opts.discriminator && r.discriminator) return;
      const a = n,
        s = t.let("valid", !1),
        o = t.let("passing", null),
        c = t.name("_valid");
      e.setParams({ passing: o }),
        t.block(l),
        e.result(
          s,
          () => e.reset(),
          () => e.error(!0),
        );
      function l() {
        a.forEach((f, u) => {
          let d;
          (0, qW.alwaysValidSchema)(i, f)
            ? t.var(c, !0)
            : (d = e.subschema(
                { keyword: "oneOf", schemaProp: u, compositeRule: !0 },
                c,
              )),
            u > 0 &&
              t
                .if((0, Gf._)`${c} && ${s}`)
                .assign(s, !1)
                .assign(o, (0, Gf._)`[${o}, ${u}]`)
                .else(),
            t.if(c, () => {
              t.assign(s, !0),
                t.assign(o, u),
                d && e.mergeEvaluated(d, Gf.Name);
            });
        });
      }
    },
  };
Wy.default = QW;
var zy = {};
Object.defineProperty(zy, "__esModule", { value: !0 });
const WW = Ut,
  zW = {
    keyword: "allOf",
    schemaType: "array",
    code(e) {
      const { gen: t, schema: n, it: r } = e;
      if (!Array.isArray(n)) throw new Error("ajv implementation error");
      const i = t.name("valid");
      n.forEach((a, s) => {
        if ((0, WW.alwaysValidSchema)(r, a)) return;
        const o = e.subschema({ keyword: "allOf", schemaProp: s }, i);
        e.ok(i), e.mergeEvaluated(o);
      });
    },
  };
zy.default = zW;
var Ky = {};
Object.defineProperty(Ky, "__esModule", { value: !0 });
const xd = $t,
  X4 = Ut,
  KW = {
    message: ({ params: e }) => (0, xd.str)`must match "${e.ifClause}" schema`,
    params: ({ params: e }) => (0, xd._)`{failingKeyword: ${e.ifClause}}`,
  },
  VW = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: KW,
    code(e) {
      const { gen: t, parentSchema: n, it: r } = e;
      n.then === void 0 &&
        n.else === void 0 &&
        (0, X4.checkStrictMode)(r, '"if" without "then" and "else" is ignored');
      const i = Dx(r, "then"),
        a = Dx(r, "else");
      if (!i && !a) return;
      const s = t.let("valid", !0),
        o = t.name("_valid");
      if ((c(), e.reset(), i && a)) {
        const f = t.let("ifClause");
        e.setParams({ ifClause: f }), t.if(o, l("then", f), l("else", f));
      } else i ? t.if(o, l("then")) : t.if((0, xd.not)(o), l("else"));
      e.pass(s, () => e.error(!0));
      function c() {
        const f = e.subschema(
          { keyword: "if", compositeRule: !0, createErrors: !1, allErrors: !1 },
          o,
        );
        e.mergeEvaluated(f);
      }
      function l(f, u) {
        return () => {
          const d = e.subschema({ keyword: f }, o);
          t.assign(s, o),
            e.mergeValidEvaluated(d, s),
            u ? t.assign(u, (0, xd._)`${f}`) : e.setParams({ ifClause: f });
        };
      }
    },
  };
function Dx(e, t) {
  const n = e.schema[t];
  return n !== void 0 && !(0, X4.alwaysValidSchema)(e, n);
}
Ky.default = VW;
var Vy = {};
Object.defineProperty(Vy, "__esModule", { value: !0 });
const YW = Ut,
  XW = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: e, parentSchema: t, it: n }) {
      t.if === void 0 &&
        (0, YW.checkStrictMode)(n, `"${e}" without "if" is ignored`);
    },
  };
Vy.default = XW;
Object.defineProperty(By, "__esModule", { value: !0 });
const JW = Ac,
  ZW = Uy,
  ez = Sc,
  tz = Fy,
  nz = jy,
  rz = V4,
  iz = My,
  az = kp,
  sz = Hy,
  oz = qy,
  cz = Gy,
  lz = Qy,
  uz = Wy,
  fz = zy,
  dz = Ky,
  pz = Vy;
function hz(e = !1) {
  const t = [
    cz.default,
    lz.default,
    uz.default,
    fz.default,
    dz.default,
    pz.default,
    iz.default,
    az.default,
    rz.default,
    sz.default,
    oz.default,
  ];
  return (
    e ? t.push(ZW.default, tz.default) : t.push(JW.default, ez.default),
    t.push(nz.default),
    t
  );
}
By.default = hz;
var Yy = {},
  Xy = {};
Object.defineProperty(Xy, "__esModule", { value: !0 });
const Cn = $t,
  mz = {
    message: ({ schemaCode: e }) => (0, Cn.str)`must match format "${e}"`,
    params: ({ schemaCode: e }) => (0, Cn._)`{format: ${e}}`,
  },
  gz = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: mz,
    code(e, t) {
      const { gen: n, data: r, $data: i, schema: a, schemaCode: s, it: o } = e,
        { opts: c, errSchemaPath: l, schemaEnv: f, self: u } = o;
      if (!c.validateFormats) return;
      i ? d() : p();
      function d() {
        const h = n.scopeValue("formats", {
            ref: u.formats,
            code: c.code.formats,
          }),
          m = n.const("fDef", (0, Cn._)`${h}[${s}]`),
          g = n.let("fType"),
          v = n.let("format");
        n.if(
          (0, Cn._)`typeof ${m} == "object" && !(${m} instanceof RegExp)`,
          () =>
            n
              .assign(g, (0, Cn._)`${m}.type || "string"`)
              .assign(v, (0, Cn._)`${m}.validate`),
          () => n.assign(g, (0, Cn._)`"string"`).assign(v, m),
        ),
          e.fail$data((0, Cn.or)(y(), _()));
        function y() {
          return c.strictSchema === !1 ? Cn.nil : (0, Cn._)`${s} && !${v}`;
        }
        function _() {
          const E = f.$async
              ? (0, Cn._)`(${m}.async ? await ${v}(${r}) : ${v}(${r}))`
              : (0, Cn._)`${v}(${r})`,
            R = (0, Cn._)`(typeof ${v} == "function" ? ${E} : ${v}.test(${r}))`;
          return (0, Cn._)`${v} && ${v} !== true && ${g} === ${t} && !${R}`;
        }
      }
      function p() {
        const h = u.formats[a];
        if (!h) {
          y();
          return;
        }
        if (h === !0) return;
        const [m, g, v] = _(h);
        m === t && e.pass(E());
        function y() {
          if (c.strictSchema === !1) {
            u.logger.warn(R());
            return;
          }
          throw new Error(R());
          function R() {
            return `unknown format "${a}" ignored in schema at path "${l}"`;
          }
        }
        function _(R) {
          const A =
              R instanceof RegExp
                ? (0, Cn.regexpCode)(R)
                : c.code.formats
                ? (0, Cn._)`${c.code.formats}${(0, Cn.getProperty)(a)}`
                : void 0,
            I = n.scopeValue("formats", { key: a, ref: R, code: A });
          return typeof R == "object" && !(R instanceof RegExp)
            ? [R.type || "string", R.validate, (0, Cn._)`${I}.validate`]
            : ["string", R, I];
        }
        function E() {
          if (typeof h == "object" && !(h instanceof RegExp) && h.async) {
            if (!f.$async) throw new Error("async format in sync schema");
            return (0, Cn._)`await ${v}(${r})`;
          }
          return typeof g == "function"
            ? (0, Cn._)`${v}(${r})`
            : (0, Cn._)`${v}.test(${r})`;
        }
      }
    },
  };
Xy.default = gz;
Object.defineProperty(Yy, "__esModule", { value: !0 });
const vz = Xy,
  yz = [vz.default];
Yy.default = yz;
var sc = {};
Object.defineProperty(sc, "__esModule", { value: !0 });
sc.contentVocabulary = sc.metadataVocabulary = void 0;
sc.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples",
];
sc.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
Object.defineProperty(wy, "__esModule", { value: !0 });
const bz = xy,
  _z = Sy,
  Ez = By,
  wz = Yy,
  Lx = sc,
  xz = [
    bz.default,
    _z.default,
    (0, Ez.default)(),
    wz.default,
    Lx.metadataVocabulary,
    Lx.contentVocabulary,
  ];
wy.default = xz;
var Jy = {},
  J4 = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.DiscrError = void 0),
    (function (t) {
      (t.Tag = "tag"), (t.Mapping = "mapping");
    })(e.DiscrError || (e.DiscrError = {}));
})(J4);
Object.defineProperty(Jy, "__esModule", { value: !0 });
const Ao = $t,
  A0 = J4,
  Bx = Dr,
  Az = Ut,
  Sz = {
    message: ({ params: { discrError: e, tagName: t } }) =>
      e === A0.DiscrError.Tag
        ? `tag "${t}" must be string`
        : `value of tag "${t}" must be in oneOf`,
    params: ({ params: { discrError: e, tag: t, tagName: n } }) =>
      (0, Ao._)`{error: ${e}, tag: ${n}, tagValue: ${t}}`,
  },
  Iz = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: Sz,
    code(e) {
      const { gen: t, data: n, schema: r, parentSchema: i, it: a } = e,
        { oneOf: s } = i;
      if (!a.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const o = r.propertyName;
      if (typeof o != "string")
        throw new Error("discriminator: requires propertyName");
      if (r.mapping) throw new Error("discriminator: mapping is not supported");
      if (!s) throw new Error("discriminator: requires oneOf keyword");
      const c = t.let("valid", !1),
        l = t.const("tag", (0, Ao._)`${n}${(0, Ao.getProperty)(o)}`);
      t.if(
        (0, Ao._)`typeof ${l} == "string"`,
        () => f(),
        () =>
          e.error(!1, { discrError: A0.DiscrError.Tag, tag: l, tagName: o }),
      ),
        e.ok(c);
      function f() {
        const p = d();
        t.if(!1);
        for (const h in p)
          t.elseIf((0, Ao._)`${l} === ${h}`), t.assign(c, u(p[h]));
        t.else(),
          e.error(!1, {
            discrError: A0.DiscrError.Mapping,
            tag: l,
            tagName: o,
          }),
          t.endIf();
      }
      function u(p) {
        const h = t.name("valid"),
          m = e.subschema({ keyword: "oneOf", schemaProp: p }, h);
        return e.mergeEvaluated(m, Ao.Name), h;
      }
      function d() {
        var p;
        const h = {},
          m = v(i);
        let g = !0;
        for (let E = 0; E < s.length; E++) {
          let R = s[E];
          R != null &&
            R.$ref &&
            !(0, Az.schemaHasRulesButRef)(R, a.self.RULES) &&
            ((R = Bx.resolveRef.call(
              a.self,
              a.schemaEnv.root,
              a.baseId,
              R == null ? void 0 : R.$ref,
            )),
            R instanceof Bx.SchemaEnv && (R = R.schema));
          const A =
            (p = R == null ? void 0 : R.properties) === null || p === void 0
              ? void 0
              : p[o];
          if (typeof A != "object")
            throw new Error(
              `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${o}"`,
            );
          (g = g && (m || v(R))), y(A, E);
        }
        if (!g) throw new Error(`discriminator: "${o}" must be required`);
        return h;
        function v({ required: E }) {
          return Array.isArray(E) && E.includes(o);
        }
        function y(E, R) {
          if (E.const) _(E.const, R);
          else if (E.enum) for (const A of E.enum) _(A, R);
          else
            throw new Error(
              `discriminator: "properties/${o}" must have "const" or "enum"`,
            );
        }
        function _(E, R) {
          if (typeof E != "string" || E in h)
            throw new Error(
              `discriminator: "${o}" values must be unique strings`,
            );
          h[E] = R;
        }
      }
    },
  };
Jy.default = Iz;
const $z = "http://json-schema.org/draft-07/schema#",
  Cz = "http://json-schema.org/draft-07/schema#",
  Rz = "Core schema meta-schema",
  kz = {
    schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
    nonNegativeInteger: { type: "integer", minimum: 0 },
    nonNegativeIntegerDefault0: {
      allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string",
      ],
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: [],
    },
  },
  Tz = ["object", "boolean"],
  Nz = {
    $id: { type: "string", format: "uri-reference" },
    $schema: { type: "string", format: "uri" },
    $ref: { type: "string", format: "uri-reference" },
    $comment: { type: "string" },
    title: { type: "string" },
    description: { type: "string" },
    default: !0,
    readOnly: { type: "boolean", default: !1 },
    examples: { type: "array", items: !0 },
    multipleOf: { type: "number", exclusiveMinimum: 0 },
    maximum: { type: "number" },
    exclusiveMaximum: { type: "number" },
    minimum: { type: "number" },
    exclusiveMinimum: { type: "number" },
    maxLength: { $ref: "#/definitions/nonNegativeInteger" },
    minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    pattern: { type: "string", format: "regex" },
    additionalItems: { $ref: "#" },
    items: {
      anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
      default: !0,
    },
    maxItems: { $ref: "#/definitions/nonNegativeInteger" },
    minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    uniqueItems: { type: "boolean", default: !1 },
    contains: { $ref: "#" },
    maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
    minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    required: { $ref: "#/definitions/stringArray" },
    additionalProperties: { $ref: "#" },
    definitions: {
      type: "object",
      additionalProperties: { $ref: "#" },
      default: {},
    },
    properties: {
      type: "object",
      additionalProperties: { $ref: "#" },
      default: {},
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $ref: "#" },
      propertyNames: { format: "regex" },
      default: {},
    },
    dependencies: {
      type: "object",
      additionalProperties: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
      },
    },
    propertyNames: { $ref: "#" },
    const: !0,
    enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
    type: {
      anyOf: [
        { $ref: "#/definitions/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/definitions/simpleTypes" },
          minItems: 1,
          uniqueItems: !0,
        },
      ],
    },
    format: { type: "string" },
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    if: { $ref: "#" },
    then: { $ref: "#" },
    else: { $ref: "#" },
    allOf: { $ref: "#/definitions/schemaArray" },
    anyOf: { $ref: "#/definitions/schemaArray" },
    oneOf: { $ref: "#/definitions/schemaArray" },
    not: { $ref: "#" },
  },
  Oz = {
    $schema: $z,
    $id: Cz,
    title: Rz,
    definitions: kz,
    type: Tz,
    properties: Nz,
    default: !0,
  };
(function (e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.MissingRefError =
      t.ValidationError =
      t.CodeGen =
      t.Name =
      t.nil =
      t.stringify =
      t.str =
      t._ =
      t.KeywordCxt =
        void 0);
  const n = y4,
    r = wy,
    i = Jy,
    a = Oz,
    s = ["/properties"],
    o = "http://json-schema.org/draft-07/schema";
  class c extends n.default {
    _addVocabularies() {
      super._addVocabularies(),
        r.default.forEach((h) => this.addVocabulary(h)),
        this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      if ((super._addDefaultMetaSchema(), !this.opts.meta)) return;
      const h = this.opts.$data ? this.$dataMetaSchema(a, s) : a;
      this.addMetaSchema(h, o, !1),
        (this.refs["http://json-schema.org/schema"] = o);
    }
    defaultMeta() {
      return (this.opts.defaultMeta =
        super.defaultMeta() || (this.getSchema(o) ? o : void 0));
    }
  }
  (e.exports = t = c),
    Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.default = c);
  var l = yi;
  Object.defineProperty(t, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return l.KeywordCxt;
    },
  });
  var f = $t;
  Object.defineProperty(t, "_", {
    enumerable: !0,
    get: function () {
      return f._;
    },
  }),
    Object.defineProperty(t, "str", {
      enumerable: !0,
      get: function () {
        return f.str;
      },
    }),
    Object.defineProperty(t, "stringify", {
      enumerable: !0,
      get: function () {
        return f.stringify;
      },
    }),
    Object.defineProperty(t, "nil", {
      enumerable: !0,
      get: function () {
        return f.nil;
      },
    }),
    Object.defineProperty(t, "Name", {
      enumerable: !0,
      get: function () {
        return f.Name;
      },
    }),
    Object.defineProperty(t, "CodeGen", {
      enumerable: !0,
      get: function () {
        return f.CodeGen;
      },
    });
  var u = uu;
  Object.defineProperty(t, "ValidationError", {
    enumerable: !0,
    get: function () {
      return u.default;
    },
  });
  var d = fu;
  Object.defineProperty(t, "MissingRefError", {
    enumerable: !0,
    get: function () {
      return d.default;
    },
  });
})(y0, y0.exports);
var Pz = y0.exports,
  S0 = { exports: {} },
  Z4 = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.formatNames = e.fastFormats = e.fullFormats = void 0);
  function t(w, O) {
    return { validate: w, compare: O };
  }
  (e.fullFormats = {
    date: t(a, s),
    time: t(c, l),
    "date-time": t(u, d),
    duration:
      /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: m,
    "uri-reference":
      /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template":
      /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email:
      /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname:
      /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: S,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment":
      /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte: v,
    int32: { type: "number", validate: E },
    int64: { type: "number", validate: R },
    float: { type: "number", validate: A },
    double: { type: "number", validate: A },
    password: !0,
    binary: !0,
  }),
    (e.fastFormats = {
      ...e.fullFormats,
      date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, s),
      time: t(
        /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
        l,
      ),
      "date-time": t(
        /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
        d,
      ),
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference":
        /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      email:
        /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    }),
    (e.formatNames = Object.keys(e.fullFormats));
  function n(w) {
    return w % 4 === 0 && (w % 100 !== 0 || w % 400 === 0);
  }
  const r = /^(\d\d\d\d)-(\d\d)-(\d\d)$/,
    i = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function a(w) {
    const O = r.exec(w);
    if (!O) return !1;
    const Q = +O[1],
      j = +O[2],
      H = +O[3];
    return j >= 1 && j <= 12 && H >= 1 && H <= (j === 2 && n(Q) ? 29 : i[j]);
  }
  function s(w, O) {
    if (w && O) return w > O ? 1 : w < O ? -1 : 0;
  }
  const o = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  function c(w, O) {
    const Q = o.exec(w);
    if (!Q) return !1;
    const j = +Q[1],
      H = +Q[2],
      q = +Q[3],
      J = Q[5];
    return (
      ((j <= 23 && H <= 59 && q <= 59) || (j === 23 && H === 59 && q === 60)) &&
      (!O || J !== "")
    );
  }
  function l(w, O) {
    if (!(w && O)) return;
    const Q = o.exec(w),
      j = o.exec(O);
    if (Q && j)
      return (
        (w = Q[1] + Q[2] + Q[3] + (Q[4] || "")),
        (O = j[1] + j[2] + j[3] + (j[4] || "")),
        w > O ? 1 : w < O ? -1 : 0
      );
  }
  const f = /t|\s/i;
  function u(w) {
    const O = w.split(f);
    return O.length === 2 && a(O[0]) && c(O[1], !0);
  }
  function d(w, O) {
    if (!(w && O)) return;
    const [Q, j] = w.split(f),
      [H, q] = O.split(f),
      J = s(Q, H);
    if (J !== void 0) return J || l(j, q);
  }
  const p = /\/|:/,
    h =
      /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function m(w) {
    return p.test(w) && h.test(w);
  }
  const g =
    /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function v(w) {
    return (g.lastIndex = 0), g.test(w);
  }
  const y = -(2 ** 31),
    _ = 2 ** 31 - 1;
  function E(w) {
    return Number.isInteger(w) && w <= _ && w >= y;
  }
  function R(w) {
    return Number.isInteger(w);
  }
  function A() {
    return !0;
  }
  const I = /[^\\]\\Z/;
  function S(w) {
    if (I.test(w)) return !1;
    try {
      return new RegExp(w), !0;
    } catch {
      return !1;
    }
  }
})(Z4);
var eR = {},
  I0 = { exports: {} },
  tR = {},
  bi = {},
  oc = {},
  pu = {},
  xt = {},
  Hl = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.regexpCode =
      e.getEsmExportName =
      e.getProperty =
      e.safeStringify =
      e.stringify =
      e.strConcat =
      e.addCodeArg =
      e.str =
      e._ =
      e.nil =
      e._Code =
      e.Name =
      e.IDENTIFIER =
      e._CodeOrName =
        void 0);
  class t {}
  (e._CodeOrName = t), (e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i);
  class n extends t {
    constructor(y) {
      if ((super(), !e.IDENTIFIER.test(y)))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = y;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  e.Name = n;
  class r extends t {
    constructor(y) {
      super(), (this._items = typeof y == "string" ? [y] : y);
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1) return !1;
      const y = this._items[0];
      return y === "" || y === '""';
    }
    get str() {
      var y;
      return (y = this._str) !== null && y !== void 0
        ? y
        : (this._str = this._items.reduce((_, E) => `${_}${E}`, ""));
    }
    get names() {
      var y;
      return (y = this._names) !== null && y !== void 0
        ? y
        : (this._names = this._items.reduce(
            (_, E) => (E instanceof n && (_[E.str] = (_[E.str] || 0) + 1), _),
            {},
          ));
    }
  }
  (e._Code = r), (e.nil = new r(""));
  function i(v, ...y) {
    const _ = [v[0]];
    let E = 0;
    for (; E < y.length; ) o(_, y[E]), _.push(v[++E]);
    return new r(_);
  }
  e._ = i;
  const a = new r("+");
  function s(v, ...y) {
    const _ = [p(v[0])];
    let E = 0;
    for (; E < y.length; ) _.push(a), o(_, y[E]), _.push(a, p(v[++E]));
    return c(_), new r(_);
  }
  e.str = s;
  function o(v, y) {
    y instanceof r
      ? v.push(...y._items)
      : y instanceof n
      ? v.push(y)
      : v.push(u(y));
  }
  e.addCodeArg = o;
  function c(v) {
    let y = 1;
    for (; y < v.length - 1; ) {
      if (v[y] === a) {
        const _ = l(v[y - 1], v[y + 1]);
        if (_ !== void 0) {
          v.splice(y - 1, 3, _);
          continue;
        }
        v[y++] = "+";
      }
      y++;
    }
  }
  function l(v, y) {
    if (y === '""') return v;
    if (v === '""') return y;
    if (typeof v == "string")
      return y instanceof n || v[v.length - 1] !== '"'
        ? void 0
        : typeof y != "string"
        ? `${v.slice(0, -1)}${y}"`
        : y[0] === '"'
        ? v.slice(0, -1) + y.slice(1)
        : void 0;
    if (typeof y == "string" && y[0] === '"' && !(v instanceof n))
      return `"${v}${y.slice(1)}`;
  }
  function f(v, y) {
    return y.emptyStr() ? v : v.emptyStr() ? y : s`${v}${y}`;
  }
  e.strConcat = f;
  function u(v) {
    return typeof v == "number" || typeof v == "boolean" || v === null
      ? v
      : p(Array.isArray(v) ? v.join(",") : v);
  }
  function d(v) {
    return new r(p(v));
  }
  e.stringify = d;
  function p(v) {
    return JSON.stringify(v)
      .replace(/\u2028/g, "\\u2028")
      .replace(/\u2029/g, "\\u2029");
  }
  e.safeStringify = p;
  function h(v) {
    return typeof v == "string" && e.IDENTIFIER.test(v)
      ? new r(`.${v}`)
      : i`[${v}]`;
  }
  e.getProperty = h;
  function m(v) {
    if (typeof v == "string" && e.IDENTIFIER.test(v)) return new r(`${v}`);
    throw new Error(
      `CodeGen: invalid export name: ${v}, use explicit $id name mapping`,
    );
  }
  e.getEsmExportName = m;
  function g(v) {
    return new r(v.toString());
  }
  e.regexpCode = g;
})(Hl);
var $0 = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.ValueScope =
      e.ValueScopeName =
      e.Scope =
      e.varKinds =
      e.UsedValueState =
        void 0);
  const t = Hl;
  class n extends Error {
    constructor(l) {
      super(`CodeGen: "code" for ${l} not defined`), (this.value = l.value);
    }
  }
  var r;
  (function (c) {
    (c[(c.Started = 0)] = "Started"), (c[(c.Completed = 1)] = "Completed");
  })((r = e.UsedValueState || (e.UsedValueState = {}))),
    (e.varKinds = {
      const: new t.Name("const"),
      let: new t.Name("let"),
      var: new t.Name("var"),
    });
  class i {
    constructor({ prefixes: l, parent: f } = {}) {
      (this._names = {}), (this._prefixes = l), (this._parent = f);
    }
    toName(l) {
      return l instanceof t.Name ? l : this.name(l);
    }
    name(l) {
      return new t.Name(this._newName(l));
    }
    _newName(l) {
      const f = this._names[l] || this._nameGroup(l);
      return `${l}${f.index++}`;
    }
    _nameGroup(l) {
      var f, u;
      if (
        (!(
          (u =
            (f = this._parent) === null || f === void 0
              ? void 0
              : f._prefixes) === null || u === void 0
        ) &&
          u.has(l)) ||
        (this._prefixes && !this._prefixes.has(l))
      )
        throw new Error(`CodeGen: prefix "${l}" is not allowed in this scope`);
      return (this._names[l] = { prefix: l, index: 0 });
    }
  }
  e.Scope = i;
  class a extends t.Name {
    constructor(l, f) {
      super(f), (this.prefix = l);
    }
    setValue(l, { property: f, itemIndex: u }) {
      (this.value = l), (this.scopePath = (0, t._)`.${new t.Name(f)}[${u}]`);
    }
  }
  e.ValueScopeName = a;
  const s = (0, t._)`\n`;
  class o extends i {
    constructor(l) {
      super(l),
        (this._values = {}),
        (this._scope = l.scope),
        (this.opts = { ...l, _n: l.lines ? s : t.nil });
    }
    get() {
      return this._scope;
    }
    name(l) {
      return new a(l, this._newName(l));
    }
    value(l, f) {
      var u;
      if (f.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const d = this.toName(l),
        { prefix: p } = d,
        h = (u = f.key) !== null && u !== void 0 ? u : f.ref;
      let m = this._values[p];
      if (m) {
        const y = m.get(h);
        if (y) return y;
      } else m = this._values[p] = new Map();
      m.set(h, d);
      const g = this._scope[p] || (this._scope[p] = []),
        v = g.length;
      return (g[v] = f.ref), d.setValue(f, { property: p, itemIndex: v }), d;
    }
    getValue(l, f) {
      const u = this._values[l];
      if (u) return u.get(f);
    }
    scopeRefs(l, f = this._values) {
      return this._reduceValues(f, (u) => {
        if (u.scopePath === void 0)
          throw new Error(`CodeGen: name "${u}" has no value`);
        return (0, t._)`${l}${u.scopePath}`;
      });
    }
    scopeCode(l = this._values, f, u) {
      return this._reduceValues(
        l,
        (d) => {
          if (d.value === void 0)
            throw new Error(`CodeGen: name "${d}" has no value`);
          return d.value.code;
        },
        f,
        u,
      );
    }
    _reduceValues(l, f, u = {}, d) {
      let p = t.nil;
      for (const h in l) {
        const m = l[h];
        if (!m) continue;
        const g = (u[h] = u[h] || new Map());
        m.forEach((v) => {
          if (g.has(v)) return;
          g.set(v, r.Started);
          let y = f(v);
          if (y) {
            const _ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
            p = (0, t._)`${p}${_} ${v} = ${y};${this.opts._n}`;
          } else if ((y = d == null ? void 0 : d(v)))
            p = (0, t._)`${p}${y}${this.opts._n}`;
          else throw new n(v);
          g.set(v, r.Completed);
        });
      }
      return p;
    }
  }
  e.ValueScope = o;
})($0);
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.or =
      e.and =
      e.not =
      e.CodeGen =
      e.operators =
      e.varKinds =
      e.ValueScopeName =
      e.ValueScope =
      e.Scope =
      e.Name =
      e.regexpCode =
      e.stringify =
      e.getProperty =
      e.nil =
      e.strConcat =
      e.str =
      e._ =
        void 0);
  const t = Hl,
    n = $0;
  var r = Hl;
  Object.defineProperty(e, "_", {
    enumerable: !0,
    get: function () {
      return r._;
    },
  }),
    Object.defineProperty(e, "str", {
      enumerable: !0,
      get: function () {
        return r.str;
      },
    }),
    Object.defineProperty(e, "strConcat", {
      enumerable: !0,
      get: function () {
        return r.strConcat;
      },
    }),
    Object.defineProperty(e, "nil", {
      enumerable: !0,
      get: function () {
        return r.nil;
      },
    }),
    Object.defineProperty(e, "getProperty", {
      enumerable: !0,
      get: function () {
        return r.getProperty;
      },
    }),
    Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function () {
        return r.stringify;
      },
    }),
    Object.defineProperty(e, "regexpCode", {
      enumerable: !0,
      get: function () {
        return r.regexpCode;
      },
    }),
    Object.defineProperty(e, "Name", {
      enumerable: !0,
      get: function () {
        return r.Name;
      },
    });
  var i = $0;
  Object.defineProperty(e, "Scope", {
    enumerable: !0,
    get: function () {
      return i.Scope;
    },
  }),
    Object.defineProperty(e, "ValueScope", {
      enumerable: !0,
      get: function () {
        return i.ValueScope;
      },
    }),
    Object.defineProperty(e, "ValueScopeName", {
      enumerable: !0,
      get: function () {
        return i.ValueScopeName;
      },
    }),
    Object.defineProperty(e, "varKinds", {
      enumerable: !0,
      get: function () {
        return i.varKinds;
      },
    }),
    (e.operators = {
      GT: new t._Code(">"),
      GTE: new t._Code(">="),
      LT: new t._Code("<"),
      LTE: new t._Code("<="),
      EQ: new t._Code("==="),
      NEQ: new t._Code("!=="),
      NOT: new t._Code("!"),
      OR: new t._Code("||"),
      AND: new t._Code("&&"),
      ADD: new t._Code("+"),
    });
  class a {
    optimizeNodes() {
      return this;
    }
    optimizeNames(x, T) {
      return this;
    }
  }
  class s extends a {
    constructor(x, T, V) {
      super(), (this.varKind = x), (this.name = T), (this.rhs = V);
    }
    render({ es5: x, _n: T }) {
      const V = x ? n.varKinds.var : this.varKind,
        B = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${V} ${this.name}${B};` + T;
    }
    optimizeNames(x, T) {
      if (x[this.name.str])
        return this.rhs && (this.rhs = q(this.rhs, x, T)), this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class o extends a {
    constructor(x, T, V) {
      super(), (this.lhs = x), (this.rhs = T), (this.sideEffects = V);
    }
    render({ _n: x }) {
      return `${this.lhs} = ${this.rhs};` + x;
    }
    optimizeNames(x, T) {
      if (
        !(this.lhs instanceof t.Name && !x[this.lhs.str] && !this.sideEffects)
      )
        return (this.rhs = q(this.rhs, x, T)), this;
    }
    get names() {
      const x = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return H(x, this.rhs);
    }
  }
  class c extends o {
    constructor(x, T, V, B) {
      super(x, V, B), (this.op = T);
    }
    render({ _n: x }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + x;
    }
  }
  class l extends a {
    constructor(x) {
      super(), (this.label = x), (this.names = {});
    }
    render({ _n: x }) {
      return `${this.label}:` + x;
    }
  }
  class f extends a {
    constructor(x) {
      super(), (this.label = x), (this.names = {});
    }
    render({ _n: x }) {
      return `break${this.label ? ` ${this.label}` : ""};` + x;
    }
  }
  class u extends a {
    constructor(x) {
      super(), (this.error = x);
    }
    render({ _n: x }) {
      return `throw ${this.error};` + x;
    }
    get names() {
      return this.error.names;
    }
  }
  class d extends a {
    constructor(x) {
      super(), (this.code = x);
    }
    render({ _n: x }) {
      return `${this.code};` + x;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(x, T) {
      return (this.code = q(this.code, x, T)), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class p extends a {
    constructor(x = []) {
      super(), (this.nodes = x);
    }
    render(x) {
      return this.nodes.reduce((T, V) => T + V.render(x), "");
    }
    optimizeNodes() {
      const { nodes: x } = this;
      let T = x.length;
      for (; T--; ) {
        const V = x[T].optimizeNodes();
        Array.isArray(V)
          ? x.splice(T, 1, ...V)
          : V
          ? (x[T] = V)
          : x.splice(T, 1);
      }
      return x.length > 0 ? this : void 0;
    }
    optimizeNames(x, T) {
      const { nodes: V } = this;
      let B = V.length;
      for (; B--; ) {
        const N = V[B];
        N.optimizeNames(x, T) || (J(x, N.names), V.splice(B, 1));
      }
      return V.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((x, T) => j(x, T.names), {});
    }
  }
  class h extends p {
    render(x) {
      return "{" + x._n + super.render(x) + "}" + x._n;
    }
  }
  class m extends p {}
  class g extends h {}
  g.kind = "else";
  class v extends h {
    constructor(x, T) {
      super(T), (this.condition = x);
    }
    render(x) {
      let T = `if(${this.condition})` + super.render(x);
      return this.else && (T += "else " + this.else.render(x)), T;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const x = this.condition;
      if (x === !0) return this.nodes;
      let T = this.else;
      if (T) {
        const V = T.optimizeNodes();
        T = this.else = Array.isArray(V) ? new g(V) : V;
      }
      if (T)
        return x === !1
          ? T instanceof v
            ? T
            : T.nodes
          : this.nodes.length
          ? this
          : new v(Z(x), T instanceof v ? [T] : T.nodes);
      if (!(x === !1 || !this.nodes.length)) return this;
    }
    optimizeNames(x, T) {
      var V;
      if (
        ((this.else =
          (V = this.else) === null || V === void 0
            ? void 0
            : V.optimizeNames(x, T)),
        !!(super.optimizeNames(x, T) || this.else))
      )
        return (this.condition = q(this.condition, x, T)), this;
    }
    get names() {
      const x = super.names;
      return H(x, this.condition), this.else && j(x, this.else.names), x;
    }
  }
  v.kind = "if";
  class y extends h {}
  y.kind = "for";
  class _ extends y {
    constructor(x) {
      super(), (this.iteration = x);
    }
    render(x) {
      return `for(${this.iteration})` + super.render(x);
    }
    optimizeNames(x, T) {
      if (super.optimizeNames(x, T))
        return (this.iteration = q(this.iteration, x, T)), this;
    }
    get names() {
      return j(super.names, this.iteration.names);
    }
  }
  class E extends y {
    constructor(x, T, V, B) {
      super(),
        (this.varKind = x),
        (this.name = T),
        (this.from = V),
        (this.to = B);
    }
    render(x) {
      const T = x.es5 ? n.varKinds.var : this.varKind,
        { name: V, from: B, to: N } = this;
      return `for(${T} ${V}=${B}; ${V}<${N}; ${V}++)` + super.render(x);
    }
    get names() {
      const x = H(super.names, this.from);
      return H(x, this.to);
    }
  }
  class R extends y {
    constructor(x, T, V, B) {
      super(),
        (this.loop = x),
        (this.varKind = T),
        (this.name = V),
        (this.iterable = B);
    }
    render(x) {
      return (
        `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` +
        super.render(x)
      );
    }
    optimizeNames(x, T) {
      if (super.optimizeNames(x, T))
        return (this.iterable = q(this.iterable, x, T)), this;
    }
    get names() {
      return j(super.names, this.iterable.names);
    }
  }
  class A extends h {
    constructor(x, T, V) {
      super(), (this.name = x), (this.args = T), (this.async = V);
    }
    render(x) {
      return (
        `${this.async ? "async " : ""}function ${this.name}(${this.args})` +
        super.render(x)
      );
    }
  }
  A.kind = "func";
  class I extends p {
    render(x) {
      return "return " + super.render(x);
    }
  }
  I.kind = "return";
  class S extends h {
    render(x) {
      let T = "try" + super.render(x);
      return (
        this.catch && (T += this.catch.render(x)),
        this.finally && (T += this.finally.render(x)),
        T
      );
    }
    optimizeNodes() {
      var x, T;
      return (
        super.optimizeNodes(),
        (x = this.catch) === null || x === void 0 || x.optimizeNodes(),
        (T = this.finally) === null || T === void 0 || T.optimizeNodes(),
        this
      );
    }
    optimizeNames(x, T) {
      var V, B;
      return (
        super.optimizeNames(x, T),
        (V = this.catch) === null || V === void 0 || V.optimizeNames(x, T),
        (B = this.finally) === null || B === void 0 || B.optimizeNames(x, T),
        this
      );
    }
    get names() {
      const x = super.names;
      return (
        this.catch && j(x, this.catch.names),
        this.finally && j(x, this.finally.names),
        x
      );
    }
  }
  class w extends h {
    constructor(x) {
      super(), (this.error = x);
    }
    render(x) {
      return `catch(${this.error})` + super.render(x);
    }
  }
  w.kind = "catch";
  class O extends h {
    render(x) {
      return "finally" + super.render(x);
    }
  }
  O.kind = "finally";
  class Q {
    constructor(x, T = {}) {
      (this._values = {}),
        (this._blockStarts = []),
        (this._constants = {}),
        (this.opts = {
          ...T,
          _n: T.lines
            ? `
`
            : "",
        }),
        (this._extScope = x),
        (this._scope = new n.Scope({ parent: x })),
        (this._nodes = [new m()]);
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(x) {
      return this._scope.name(x);
    }
    scopeName(x) {
      return this._extScope.name(x);
    }
    scopeValue(x, T) {
      const V = this._extScope.value(x, T);
      return (
        (this._values[V.prefix] || (this._values[V.prefix] = new Set())).add(V),
        V
      );
    }
    getScopeValue(x, T) {
      return this._extScope.getValue(x, T);
    }
    scopeRefs(x) {
      return this._extScope.scopeRefs(x, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(x, T, V, B) {
      const N = this._scope.toName(T);
      return (
        V !== void 0 && B && (this._constants[N.str] = V),
        this._leafNode(new s(x, N, V)),
        N
      );
    }
    const(x, T, V) {
      return this._def(n.varKinds.const, x, T, V);
    }
    let(x, T, V) {
      return this._def(n.varKinds.let, x, T, V);
    }
    var(x, T, V) {
      return this._def(n.varKinds.var, x, T, V);
    }
    assign(x, T, V) {
      return this._leafNode(new o(x, T, V));
    }
    add(x, T) {
      return this._leafNode(new c(x, e.operators.ADD, T));
    }
    code(x) {
      return (
        typeof x == "function" ? x() : x !== t.nil && this._leafNode(new d(x)),
        this
      );
    }
    object(...x) {
      const T = ["{"];
      for (const [V, B] of x)
        T.length > 1 && T.push(","),
          T.push(V),
          (V !== B || this.opts.es5) && (T.push(":"), (0, t.addCodeArg)(T, B));
      return T.push("}"), new t._Code(T);
    }
    if(x, T, V) {
      if ((this._blockNode(new v(x)), T && V))
        this.code(T).else().code(V).endIf();
      else if (T) this.code(T).endIf();
      else if (V) throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    elseIf(x) {
      return this._elseNode(new v(x));
    }
    else() {
      return this._elseNode(new g());
    }
    endIf() {
      return this._endBlockNode(v, g);
    }
    _for(x, T) {
      return this._blockNode(x), T && this.code(T).endFor(), this;
    }
    for(x, T) {
      return this._for(new _(x), T);
    }
    forRange(x, T, V, B, N = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
      const ce = this._scope.toName(x);
      return this._for(new E(N, ce, T, V), () => B(ce));
    }
    forOf(x, T, V, B = n.varKinds.const) {
      const N = this._scope.toName(x);
      if (this.opts.es5) {
        const ce = T instanceof t.Name ? T : this.var("_arr", T);
        return this.forRange("_i", 0, (0, t._)`${ce}.length`, (re) => {
          this.var(N, (0, t._)`${ce}[${re}]`), V(N);
        });
      }
      return this._for(new R("of", B, N, T), () => V(N));
    }
    forIn(x, T, V, B = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(x, (0, t._)`Object.keys(${T})`, V);
      const N = this._scope.toName(x);
      return this._for(new R("in", B, N, T), () => V(N));
    }
    endFor() {
      return this._endBlockNode(y);
    }
    label(x) {
      return this._leafNode(new l(x));
    }
    break(x) {
      return this._leafNode(new f(x));
    }
    return(x) {
      const T = new I();
      if ((this._blockNode(T), this.code(x), T.nodes.length !== 1))
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(I);
    }
    try(x, T, V) {
      if (!T && !V)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const B = new S();
      if ((this._blockNode(B), this.code(x), T)) {
        const N = this.name("e");
        (this._currNode = B.catch = new w(N)), T(N);
      }
      return (
        V && ((this._currNode = B.finally = new O()), this.code(V)),
        this._endBlockNode(w, O)
      );
    }
    throw(x) {
      return this._leafNode(new u(x));
    }
    block(x, T) {
      return (
        this._blockStarts.push(this._nodes.length),
        x && this.code(x).endBlock(T),
        this
      );
    }
    endBlock(x) {
      const T = this._blockStarts.pop();
      if (T === void 0) throw new Error("CodeGen: not in self-balancing block");
      const V = this._nodes.length - T;
      if (V < 0 || (x !== void 0 && V !== x))
        throw new Error(
          `CodeGen: wrong number of nodes: ${V} vs ${x} expected`,
        );
      return (this._nodes.length = T), this;
    }
    func(x, T = t.nil, V, B) {
      return this._blockNode(new A(x, T, V)), B && this.code(B).endFunc(), this;
    }
    endFunc() {
      return this._endBlockNode(A);
    }
    optimize(x = 1) {
      for (; x-- > 0; )
        this._root.optimizeNodes(),
          this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(x) {
      return this._currNode.nodes.push(x), this;
    }
    _blockNode(x) {
      this._currNode.nodes.push(x), this._nodes.push(x);
    }
    _endBlockNode(x, T) {
      const V = this._currNode;
      if (V instanceof x || (T && V instanceof T))
        return this._nodes.pop(), this;
      throw new Error(
        `CodeGen: not in block "${T ? `${x.kind}/${T.kind}` : x.kind}"`,
      );
    }
    _elseNode(x) {
      const T = this._currNode;
      if (!(T instanceof v)) throw new Error('CodeGen: "else" without "if"');
      return (this._currNode = T.else = x), this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const x = this._nodes;
      return x[x.length - 1];
    }
    set _currNode(x) {
      const T = this._nodes;
      T[T.length - 1] = x;
    }
  }
  e.CodeGen = Q;
  function j(F, x) {
    for (const T in x) F[T] = (F[T] || 0) + (x[T] || 0);
    return F;
  }
  function H(F, x) {
    return x instanceof t._CodeOrName ? j(F, x.names) : F;
  }
  function q(F, x, T) {
    if (F instanceof t.Name) return V(F);
    if (!B(F)) return F;
    return new t._Code(
      F._items.reduce(
        (N, ce) => (
          ce instanceof t.Name && (ce = V(ce)),
          ce instanceof t._Code ? N.push(...ce._items) : N.push(ce),
          N
        ),
        [],
      ),
    );
    function V(N) {
      const ce = T[N.str];
      return ce === void 0 || x[N.str] !== 1 ? N : (delete x[N.str], ce);
    }
    function B(N) {
      return (
        N instanceof t._Code &&
        N._items.some(
          (ce) =>
            ce instanceof t.Name && x[ce.str] === 1 && T[ce.str] !== void 0,
        )
      );
    }
  }
  function J(F, x) {
    for (const T in x) F[T] = (F[T] || 0) - (x[T] || 0);
  }
  function Z(F) {
    return typeof F == "boolean" || typeof F == "number" || F === null
      ? !F
      : (0, t._)`!${W(F)}`;
  }
  e.not = Z;
  const z = k(e.operators.AND);
  function U(...F) {
    return F.reduce(z);
  }
  e.and = U;
  const G = k(e.operators.OR);
  function L(...F) {
    return F.reduce(G);
  }
  e.or = L;
  function k(F) {
    return (x, T) =>
      x === t.nil ? T : T === t.nil ? x : (0, t._)`${W(x)} ${F} ${W(T)}`;
  }
  function W(F) {
    return F instanceof t.Name ? F : (0, t._)`(${F})`;
  }
})(xt);
var Ft = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.checkStrictMode =
      e.getErrorPath =
      e.Type =
      e.useFunc =
      e.setEvaluated =
      e.evaluatedPropsToName =
      e.mergeEvaluated =
      e.eachItem =
      e.unescapeJsonPointer =
      e.escapeJsonPointer =
      e.escapeFragment =
      e.unescapeFragment =
      e.schemaRefOrVal =
      e.schemaHasRulesButRef =
      e.schemaHasRules =
      e.checkUnknownRules =
      e.alwaysValidSchema =
      e.toHash =
        void 0);
  const t = xt,
    n = Hl;
  function r(A) {
    const I = {};
    for (const S of A) I[S] = !0;
    return I;
  }
  e.toHash = r;
  function i(A, I) {
    return typeof I == "boolean"
      ? I
      : Object.keys(I).length === 0
      ? !0
      : (a(A, I), !s(I, A.self.RULES.all));
  }
  e.alwaysValidSchema = i;
  function a(A, I = A.schema) {
    const { opts: S, self: w } = A;
    if (!S.strictSchema || typeof I == "boolean") return;
    const O = w.RULES.keywords;
    for (const Q in I) O[Q] || R(A, `unknown keyword: "${Q}"`);
  }
  e.checkUnknownRules = a;
  function s(A, I) {
    if (typeof A == "boolean") return !A;
    for (const S in A) if (I[S]) return !0;
    return !1;
  }
  e.schemaHasRules = s;
  function o(A, I) {
    if (typeof A == "boolean") return !A;
    for (const S in A) if (S !== "$ref" && I.all[S]) return !0;
    return !1;
  }
  e.schemaHasRulesButRef = o;
  function c({ topSchemaRef: A, schemaPath: I }, S, w, O) {
    if (!O) {
      if (typeof S == "number" || typeof S == "boolean") return S;
      if (typeof S == "string") return (0, t._)`${S}`;
    }
    return (0, t._)`${A}${I}${(0, t.getProperty)(w)}`;
  }
  e.schemaRefOrVal = c;
  function l(A) {
    return d(decodeURIComponent(A));
  }
  e.unescapeFragment = l;
  function f(A) {
    return encodeURIComponent(u(A));
  }
  e.escapeFragment = f;
  function u(A) {
    return typeof A == "number"
      ? `${A}`
      : A.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  e.escapeJsonPointer = u;
  function d(A) {
    return A.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  e.unescapeJsonPointer = d;
  function p(A, I) {
    if (Array.isArray(A)) for (const S of A) I(S);
    else I(A);
  }
  e.eachItem = p;
  function h({
    mergeNames: A,
    mergeToName: I,
    mergeValues: S,
    resultToName: w,
  }) {
    return (O, Q, j, H) => {
      const q =
        j === void 0
          ? Q
          : j instanceof t.Name
          ? (Q instanceof t.Name ? A(O, Q, j) : I(O, Q, j), j)
          : Q instanceof t.Name
          ? (I(O, j, Q), Q)
          : S(Q, j);
      return H === t.Name && !(q instanceof t.Name) ? w(O, q) : q;
    };
  }
  e.mergeEvaluated = {
    props: h({
      mergeNames: (A, I, S) =>
        A.if((0, t._)`${S} !== true && ${I} !== undefined`, () => {
          A.if(
            (0, t._)`${I} === true`,
            () => A.assign(S, !0),
            () =>
              A.assign(S, (0, t._)`${S} || {}`).code(
                (0, t._)`Object.assign(${S}, ${I})`,
              ),
          );
        }),
      mergeToName: (A, I, S) =>
        A.if((0, t._)`${S} !== true`, () => {
          I === !0
            ? A.assign(S, !0)
            : (A.assign(S, (0, t._)`${S} || {}`), g(A, S, I));
        }),
      mergeValues: (A, I) => (A === !0 ? !0 : { ...A, ...I }),
      resultToName: m,
    }),
    items: h({
      mergeNames: (A, I, S) =>
        A.if((0, t._)`${S} !== true && ${I} !== undefined`, () =>
          A.assign(
            S,
            (0, t._)`${I} === true ? true : ${S} > ${I} ? ${S} : ${I}`,
          ),
        ),
      mergeToName: (A, I, S) =>
        A.if((0, t._)`${S} !== true`, () =>
          A.assign(S, I === !0 ? !0 : (0, t._)`${S} > ${I} ? ${S} : ${I}`),
        ),
      mergeValues: (A, I) => (A === !0 ? !0 : Math.max(A, I)),
      resultToName: (A, I) => A.var("items", I),
    }),
  };
  function m(A, I) {
    if (I === !0) return A.var("props", !0);
    const S = A.var("props", (0, t._)`{}`);
    return I !== void 0 && g(A, S, I), S;
  }
  e.evaluatedPropsToName = m;
  function g(A, I, S) {
    Object.keys(S).forEach((w) =>
      A.assign((0, t._)`${I}${(0, t.getProperty)(w)}`, !0),
    );
  }
  e.setEvaluated = g;
  const v = {};
  function y(A, I) {
    return A.scopeValue("func", {
      ref: I,
      code: v[I.code] || (v[I.code] = new n._Code(I.code)),
    });
  }
  e.useFunc = y;
  var _;
  (function (A) {
    (A[(A.Num = 0)] = "Num"), (A[(A.Str = 1)] = "Str");
  })((_ = e.Type || (e.Type = {})));
  function E(A, I, S) {
    if (A instanceof t.Name) {
      const w = I === _.Num;
      return S
        ? w
          ? (0, t._)`"[" + ${A} + "]"`
          : (0, t._)`"['" + ${A} + "']"`
        : w
        ? (0, t._)`"/" + ${A}`
        : (0, t._)`"/" + ${A}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return S ? (0, t.getProperty)(A).toString() : "/" + u(A);
  }
  e.getErrorPath = E;
  function R(A, I, S = A.opts.strictSchema) {
    if (S) {
      if (((I = `strict mode: ${I}`), S === !0)) throw new Error(I);
      A.self.logger.warn(I);
    }
  }
  e.checkStrictMode = R;
})(Ft);
var zi = {};
Object.defineProperty(zi, "__esModule", { value: !0 });
const cr = xt,
  Dz = {
    data: new cr.Name("data"),
    valCxt: new cr.Name("valCxt"),
    instancePath: new cr.Name("instancePath"),
    parentData: new cr.Name("parentData"),
    parentDataProperty: new cr.Name("parentDataProperty"),
    rootData: new cr.Name("rootData"),
    dynamicAnchors: new cr.Name("dynamicAnchors"),
    vErrors: new cr.Name("vErrors"),
    errors: new cr.Name("errors"),
    this: new cr.Name("this"),
    self: new cr.Name("self"),
    scope: new cr.Name("scope"),
    json: new cr.Name("json"),
    jsonPos: new cr.Name("jsonPos"),
    jsonLen: new cr.Name("jsonLen"),
    jsonPart: new cr.Name("jsonPart"),
  };
zi.default = Dz;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.extendErrors =
      e.resetErrorsCount =
      e.reportExtraError =
      e.reportError =
      e.keyword$DataError =
      e.keywordError =
        void 0);
  const t = xt,
    n = Ft,
    r = zi;
  (e.keywordError = {
    message: ({ keyword: g }) =>
      (0, t.str)`must pass "${g}" keyword validation`,
  }),
    (e.keyword$DataError = {
      message: ({ keyword: g, schemaType: v }) =>
        v
          ? (0, t.str)`"${g}" keyword must be ${v} ($data)`
          : (0, t.str)`"${g}" keyword is invalid ($data)`,
    });
  function i(g, v = e.keywordError, y, _) {
    const { it: E } = g,
      { gen: R, compositeRule: A, allErrors: I } = E,
      S = u(g, v, y);
    _ ?? (A || I) ? c(R, S) : l(E, (0, t._)`[${S}]`);
  }
  e.reportError = i;
  function a(g, v = e.keywordError, y) {
    const { it: _ } = g,
      { gen: E, compositeRule: R, allErrors: A } = _,
      I = u(g, v, y);
    c(E, I), R || A || l(_, r.default.vErrors);
  }
  e.reportExtraError = a;
  function s(g, v) {
    g.assign(r.default.errors, v),
      g.if((0, t._)`${r.default.vErrors} !== null`, () =>
        g.if(
          v,
          () => g.assign((0, t._)`${r.default.vErrors}.length`, v),
          () => g.assign(r.default.vErrors, null),
        ),
      );
  }
  e.resetErrorsCount = s;
  function o({
    gen: g,
    keyword: v,
    schemaValue: y,
    data: _,
    errsCount: E,
    it: R,
  }) {
    if (E === void 0) throw new Error("ajv implementation error");
    const A = g.name("err");
    g.forRange("i", E, r.default.errors, (I) => {
      g.const(A, (0, t._)`${r.default.vErrors}[${I}]`),
        g.if((0, t._)`${A}.instancePath === undefined`, () =>
          g.assign(
            (0, t._)`${A}.instancePath`,
            (0, t.strConcat)(r.default.instancePath, R.errorPath),
          ),
        ),
        g.assign(
          (0, t._)`${A}.schemaPath`,
          (0, t.str)`${R.errSchemaPath}/${v}`,
        ),
        R.opts.verbose &&
          (g.assign((0, t._)`${A}.schema`, y),
          g.assign((0, t._)`${A}.data`, _));
    });
  }
  e.extendErrors = o;
  function c(g, v) {
    const y = g.const("err", v);
    g.if(
      (0, t._)`${r.default.vErrors} === null`,
      () => g.assign(r.default.vErrors, (0, t._)`[${y}]`),
      (0, t._)`${r.default.vErrors}.push(${y})`,
    ),
      g.code((0, t._)`${r.default.errors}++`);
  }
  function l(g, v) {
    const { gen: y, validateName: _, schemaEnv: E } = g;
    E.$async
      ? y.throw((0, t._)`new ${g.ValidationError}(${v})`)
      : (y.assign((0, t._)`${_}.errors`, v), y.return(!1));
  }
  const f = {
    keyword: new t.Name("keyword"),
    schemaPath: new t.Name("schemaPath"),
    params: new t.Name("params"),
    propertyName: new t.Name("propertyName"),
    message: new t.Name("message"),
    schema: new t.Name("schema"),
    parentSchema: new t.Name("parentSchema"),
  };
  function u(g, v, y) {
    const { createErrors: _ } = g.it;
    return _ === !1 ? (0, t._)`{}` : d(g, v, y);
  }
  function d(g, v, y = {}) {
    const { gen: _, it: E } = g,
      R = [p(E, y), h(g, y)];
    return m(g, v, R), _.object(...R);
  }
  function p({ errorPath: g }, { instancePath: v }) {
    const y = v ? (0, t.str)`${g}${(0, n.getErrorPath)(v, n.Type.Str)}` : g;
    return [
      r.default.instancePath,
      (0, t.strConcat)(r.default.instancePath, y),
    ];
  }
  function h(
    { keyword: g, it: { errSchemaPath: v } },
    { schemaPath: y, parentSchema: _ },
  ) {
    let E = _ ? v : (0, t.str)`${v}/${g}`;
    return (
      y && (E = (0, t.str)`${E}${(0, n.getErrorPath)(y, n.Type.Str)}`),
      [f.schemaPath, E]
    );
  }
  function m(g, { params: v, message: y }, _) {
    const { keyword: E, data: R, schemaValue: A, it: I } = g,
      { opts: S, propertyName: w, topSchemaRef: O, schemaPath: Q } = I;
    _.push(
      [f.keyword, E],
      [f.params, typeof v == "function" ? v(g) : v || (0, t._)`{}`],
    ),
      S.messages && _.push([f.message, typeof y == "function" ? y(g) : y]),
      S.verbose &&
        _.push(
          [f.schema, A],
          [f.parentSchema, (0, t._)`${O}${Q}`],
          [r.default.data, R],
        ),
      w && _.push([f.propertyName, w]);
  }
})(pu);
Object.defineProperty(oc, "__esModule", { value: !0 });
oc.boolOrEmptySchema = oc.topBoolOrEmptySchema = void 0;
const Lz = pu,
  Bz = xt,
  Uz = zi,
  Fz = { message: "boolean schema is false" };
function jz(e) {
  const { gen: t, schema: n, validateName: r } = e;
  n === !1
    ? nR(e, !1)
    : typeof n == "object" && n.$async === !0
    ? t.return(Uz.default.data)
    : (t.assign((0, Bz._)`${r}.errors`, null), t.return(!0));
}
oc.topBoolOrEmptySchema = jz;
function Mz(e, t) {
  const { gen: n, schema: r } = e;
  r === !1 ? (n.var(t, !1), nR(e)) : n.var(t, !0);
}
oc.boolOrEmptySchema = Mz;
function nR(e, t) {
  const { gen: n, data: r } = e,
    i = {
      gen: n,
      keyword: "false schema",
      data: r,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: e,
    };
  (0, Lz.reportError)(i, Fz, void 0, t);
}
var hu = {},
  Ms = {};
Object.defineProperty(Ms, "__esModule", { value: !0 });
Ms.getRules = Ms.isJSONType = void 0;
const Hz = [
    "string",
    "number",
    "integer",
    "boolean",
    "null",
    "object",
    "array",
  ],
  qz = new Set(Hz);
function Gz(e) {
  return typeof e == "string" && qz.has(e);
}
Ms.isJSONType = Gz;
function Qz() {
  const e = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] },
  };
  return {
    types: { ...e, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, e.number, e.string, e.array, e.object],
    post: { rules: [] },
    all: {},
    keywords: {},
  };
}
Ms.getRules = Qz;
var fa = {};
Object.defineProperty(fa, "__esModule", { value: !0 });
fa.shouldUseRule = fa.shouldUseGroup = fa.schemaHasRulesForType = void 0;
function Wz({ schema: e, self: t }, n) {
  const r = t.RULES.types[n];
  return r && r !== !0 && rR(e, r);
}
fa.schemaHasRulesForType = Wz;
function rR(e, t) {
  return t.rules.some((n) => iR(e, n));
}
fa.shouldUseGroup = rR;
function iR(e, t) {
  var n;
  return (
    e[t.keyword] !== void 0 ||
    ((n = t.definition.implements) === null || n === void 0
      ? void 0
      : n.some((r) => e[r] !== void 0))
  );
}
fa.shouldUseRule = iR;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.reportTypeError =
      e.checkDataTypes =
      e.checkDataType =
      e.coerceAndCheckDataType =
      e.getJSONTypes =
      e.getSchemaTypes =
      e.DataType =
        void 0);
  const t = Ms,
    n = fa,
    r = pu,
    i = xt,
    a = Ft;
  var s;
  (function (_) {
    (_[(_.Correct = 0)] = "Correct"), (_[(_.Wrong = 1)] = "Wrong");
  })((s = e.DataType || (e.DataType = {})));
  function o(_) {
    const E = c(_.type);
    if (E.includes("null")) {
      if (_.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!E.length && _.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      _.nullable === !0 && E.push("null");
    }
    return E;
  }
  e.getSchemaTypes = o;
  function c(_) {
    const E = Array.isArray(_) ? _ : _ ? [_] : [];
    if (E.every(t.isJSONType)) return E;
    throw new Error("type must be JSONType or JSONType[]: " + E.join(","));
  }
  e.getJSONTypes = c;
  function l(_, E) {
    const { gen: R, data: A, opts: I } = _,
      S = u(E, I.coerceTypes),
      w =
        E.length > 0 &&
        !(
          S.length === 0 &&
          E.length === 1 &&
          (0, n.schemaHasRulesForType)(_, E[0])
        );
    if (w) {
      const O = m(E, A, I.strictNumbers, s.Wrong);
      R.if(O, () => {
        S.length ? d(_, E, S) : v(_);
      });
    }
    return w;
  }
  e.coerceAndCheckDataType = l;
  const f = new Set(["string", "number", "integer", "boolean", "null"]);
  function u(_, E) {
    return E
      ? _.filter((R) => f.has(R) || (E === "array" && R === "array"))
      : [];
  }
  function d(_, E, R) {
    const { gen: A, data: I, opts: S } = _,
      w = A.let("dataType", (0, i._)`typeof ${I}`),
      O = A.let("coerced", (0, i._)`undefined`);
    S.coerceTypes === "array" &&
      A.if(
        (0, i._)`${w} == 'object' && Array.isArray(${I}) && ${I}.length == 1`,
        () =>
          A.assign(I, (0, i._)`${I}[0]`)
            .assign(w, (0, i._)`typeof ${I}`)
            .if(m(E, I, S.strictNumbers), () => A.assign(O, I)),
      ),
      A.if((0, i._)`${O} !== undefined`);
    for (const j of R)
      (f.has(j) || (j === "array" && S.coerceTypes === "array")) && Q(j);
    A.else(),
      v(_),
      A.endIf(),
      A.if((0, i._)`${O} !== undefined`, () => {
        A.assign(I, O), p(_, O);
      });
    function Q(j) {
      switch (j) {
        case "string":
          A.elseIf((0, i._)`${w} == "number" || ${w} == "boolean"`)
            .assign(O, (0, i._)`"" + ${I}`)
            .elseIf((0, i._)`${I} === null`)
            .assign(O, (0, i._)`""`);
          return;
        case "number":
          A.elseIf(
            (0, i._)`${w} == "boolean" || ${I} === null
              || (${w} == "string" && ${I} && ${I} == +${I})`,
          ).assign(O, (0, i._)`+${I}`);
          return;
        case "integer":
          A.elseIf(
            (0, i._)`${w} === "boolean" || ${I} === null
              || (${w} === "string" && ${I} && ${I} == +${I} && !(${I} % 1))`,
          ).assign(O, (0, i._)`+${I}`);
          return;
        case "boolean":
          A.elseIf((0, i._)`${I} === "false" || ${I} === 0 || ${I} === null`)
            .assign(O, !1)
            .elseIf((0, i._)`${I} === "true" || ${I} === 1`)
            .assign(O, !0);
          return;
        case "null":
          A.elseIf((0, i._)`${I} === "" || ${I} === 0 || ${I} === false`),
            A.assign(O, null);
          return;
        case "array":
          A.elseIf(
            (0, i._)`${w} === "string" || ${w} === "number"
              || ${w} === "boolean" || ${I} === null`,
          ).assign(O, (0, i._)`[${I}]`);
      }
    }
  }
  function p({ gen: _, parentData: E, parentDataProperty: R }, A) {
    _.if((0, i._)`${E} !== undefined`, () => _.assign((0, i._)`${E}[${R}]`, A));
  }
  function h(_, E, R, A = s.Correct) {
    const I = A === s.Correct ? i.operators.EQ : i.operators.NEQ;
    let S;
    switch (_) {
      case "null":
        return (0, i._)`${E} ${I} null`;
      case "array":
        S = (0, i._)`Array.isArray(${E})`;
        break;
      case "object":
        S = (0, i._)`${E} && typeof ${E} == "object" && !Array.isArray(${E})`;
        break;
      case "integer":
        S = w((0, i._)`!(${E} % 1) && !isNaN(${E})`);
        break;
      case "number":
        S = w();
        break;
      default:
        return (0, i._)`typeof ${E} ${I} ${_}`;
    }
    return A === s.Correct ? S : (0, i.not)(S);
    function w(O = i.nil) {
      return (0, i.and)(
        (0, i._)`typeof ${E} == "number"`,
        O,
        R ? (0, i._)`isFinite(${E})` : i.nil,
      );
    }
  }
  e.checkDataType = h;
  function m(_, E, R, A) {
    if (_.length === 1) return h(_[0], E, R, A);
    let I;
    const S = (0, a.toHash)(_);
    if (S.array && S.object) {
      const w = (0, i._)`typeof ${E} != "object"`;
      (I = S.null ? w : (0, i._)`!${E} || ${w}`),
        delete S.null,
        delete S.array,
        delete S.object;
    } else I = i.nil;
    S.number && delete S.integer;
    for (const w in S) I = (0, i.and)(I, h(w, E, R, A));
    return I;
  }
  e.checkDataTypes = m;
  const g = {
    message: ({ schema: _ }) => `must be ${_}`,
    params: ({ schema: _, schemaValue: E }) =>
      typeof _ == "string" ? (0, i._)`{type: ${_}}` : (0, i._)`{type: ${E}}`,
  };
  function v(_) {
    const E = y(_);
    (0, r.reportError)(E, g);
  }
  e.reportTypeError = v;
  function y(_) {
    const { gen: E, data: R, schema: A } = _,
      I = (0, a.schemaRefOrVal)(_, A, "type");
    return {
      gen: E,
      keyword: "type",
      data: R,
      schema: A.type,
      schemaCode: I,
      schemaValue: I,
      parentSchema: A,
      params: {},
      it: _,
    };
  }
})(hu);
var Tp = {};
Object.defineProperty(Tp, "__esModule", { value: !0 });
Tp.assignDefaults = void 0;
const po = xt,
  zz = Ft;
function Kz(e, t) {
  const { properties: n, items: r } = e.schema;
  if (t === "object" && n) for (const i in n) Ux(e, i, n[i].default);
  else
    t === "array" &&
      Array.isArray(r) &&
      r.forEach((i, a) => Ux(e, a, i.default));
}
Tp.assignDefaults = Kz;
function Ux(e, t, n) {
  const { gen: r, compositeRule: i, data: a, opts: s } = e;
  if (n === void 0) return;
  const o = (0, po._)`${a}${(0, po.getProperty)(t)}`;
  if (i) {
    (0, zz.checkStrictMode)(e, `default is ignored for: ${o}`);
    return;
  }
  let c = (0, po._)`${o} === undefined`;
  s.useDefaults === "empty" &&
    (c = (0, po._)`${c} || ${o} === null || ${o} === ""`),
    r.if(c, (0, po._)`${o} = ${(0, po.stringify)(n)}`);
}
var ji = {},
  It = {};
Object.defineProperty(It, "__esModule", { value: !0 });
It.validateUnion =
  It.validateArray =
  It.usePattern =
  It.callValidateCode =
  It.schemaProperties =
  It.allSchemaProperties =
  It.noPropertyInData =
  It.propertyInData =
  It.isOwnProperty =
  It.hasPropFunc =
  It.reportMissingProp =
  It.checkMissingProp =
  It.checkReportMissingProp =
    void 0;
const pn = xt,
  Zy = Ft,
  wa = zi,
  Vz = Ft;
function Yz(e, t) {
  const { gen: n, data: r, it: i } = e;
  n.if(tb(n, r, t, i.opts.ownProperties), () => {
    e.setParams({ missingProperty: (0, pn._)`${t}` }, !0), e.error();
  });
}
It.checkReportMissingProp = Yz;
function Xz({ gen: e, data: t, it: { opts: n } }, r, i) {
  return (0, pn.or)(
    ...r.map((a) =>
      (0, pn.and)(tb(e, t, a, n.ownProperties), (0, pn._)`${i} = ${a}`),
    ),
  );
}
It.checkMissingProp = Xz;
function Jz(e, t) {
  e.setParams({ missingProperty: t }, !0), e.error();
}
It.reportMissingProp = Jz;
function aR(e) {
  return e.scopeValue("func", {
    ref: Object.prototype.hasOwnProperty,
    code: (0, pn._)`Object.prototype.hasOwnProperty`,
  });
}
It.hasPropFunc = aR;
function eb(e, t, n) {
  return (0, pn._)`${aR(e)}.call(${t}, ${n})`;
}
It.isOwnProperty = eb;
function Zz(e, t, n, r) {
  const i = (0, pn._)`${t}${(0, pn.getProperty)(n)} !== undefined`;
  return r ? (0, pn._)`${i} && ${eb(e, t, n)}` : i;
}
It.propertyInData = Zz;
function tb(e, t, n, r) {
  const i = (0, pn._)`${t}${(0, pn.getProperty)(n)} === undefined`;
  return r ? (0, pn.or)(i, (0, pn.not)(eb(e, t, n))) : i;
}
It.noPropertyInData = tb;
function sR(e) {
  return e ? Object.keys(e).filter((t) => t !== "__proto__") : [];
}
It.allSchemaProperties = sR;
function eK(e, t) {
  return sR(t).filter((n) => !(0, Zy.alwaysValidSchema)(e, t[n]));
}
It.schemaProperties = eK;
function tK(
  {
    schemaCode: e,
    data: t,
    it: { gen: n, topSchemaRef: r, schemaPath: i, errorPath: a },
    it: s,
  },
  o,
  c,
  l,
) {
  const f = l ? (0, pn._)`${e}, ${t}, ${r}${i}` : t,
    u = [
      [wa.default.instancePath, (0, pn.strConcat)(wa.default.instancePath, a)],
      [wa.default.parentData, s.parentData],
      [wa.default.parentDataProperty, s.parentDataProperty],
      [wa.default.rootData, wa.default.rootData],
    ];
  s.opts.dynamicRef &&
    u.push([wa.default.dynamicAnchors, wa.default.dynamicAnchors]);
  const d = (0, pn._)`${f}, ${n.object(...u)}`;
  return c !== pn.nil
    ? (0, pn._)`${o}.call(${c}, ${d})`
    : (0, pn._)`${o}(${d})`;
}
It.callValidateCode = tK;
const nK = (0, pn._)`new RegExp`;
function rK({ gen: e, it: { opts: t } }, n) {
  const r = t.unicodeRegExp ? "u" : "",
    { regExp: i } = t.code,
    a = i(n, r);
  return e.scopeValue("pattern", {
    key: a.toString(),
    ref: a,
    code: (0, pn._)`${
      i.code === "new RegExp" ? nK : (0, Vz.useFunc)(e, i)
    }(${n}, ${r})`,
  });
}
It.usePattern = rK;
function iK(e) {
  const { gen: t, data: n, keyword: r, it: i } = e,
    a = t.name("valid");
  if (i.allErrors) {
    const o = t.let("valid", !0);
    return s(() => t.assign(o, !1)), o;
  }
  return t.var(a, !0), s(() => t.break()), a;
  function s(o) {
    const c = t.const("len", (0, pn._)`${n}.length`);
    t.forRange("i", 0, c, (l) => {
      e.subschema({ keyword: r, dataProp: l, dataPropType: Zy.Type.Num }, a),
        t.if((0, pn.not)(a), o);
    });
  }
}
It.validateArray = iK;
function aK(e) {
  const { gen: t, schema: n, keyword: r, it: i } = e;
  if (!Array.isArray(n)) throw new Error("ajv implementation error");
  if (n.some((c) => (0, Zy.alwaysValidSchema)(i, c)) && !i.opts.unevaluated)
    return;
  const s = t.let("valid", !1),
    o = t.name("_valid");
  t.block(() =>
    n.forEach((c, l) => {
      const f = e.subschema(
        { keyword: r, schemaProp: l, compositeRule: !0 },
        o,
      );
      t.assign(s, (0, pn._)`${s} || ${o}`),
        e.mergeValidEvaluated(f, o) || t.if((0, pn.not)(s));
    }),
  ),
    e.result(
      s,
      () => e.reset(),
      () => e.error(!0),
    );
}
It.validateUnion = aK;
Object.defineProperty(ji, "__esModule", { value: !0 });
ji.validateKeywordUsage =
  ji.validSchemaType =
  ji.funcKeywordCode =
  ji.macroKeywordCode =
    void 0;
const _r = xt,
  Es = zi,
  sK = It,
  oK = pu;
function cK(e, t) {
  const { gen: n, keyword: r, schema: i, parentSchema: a, it: s } = e,
    o = t.macro.call(s.self, i, a, s),
    c = oR(n, r, o);
  s.opts.validateSchema !== !1 && s.self.validateSchema(o, !0);
  const l = n.name("valid");
  e.subschema(
    {
      schema: o,
      schemaPath: _r.nil,
      errSchemaPath: `${s.errSchemaPath}/${r}`,
      topSchemaRef: c,
      compositeRule: !0,
    },
    l,
  ),
    e.pass(l, () => e.error(!0));
}
ji.macroKeywordCode = cK;
function lK(e, t) {
  var n;
  const { gen: r, keyword: i, schema: a, parentSchema: s, $data: o, it: c } = e;
  fK(c, t);
  const l = !o && t.compile ? t.compile.call(c.self, a, s, c) : t.validate,
    f = oR(r, i, l),
    u = r.let("valid");
  e.block$data(u, d), e.ok((n = t.valid) !== null && n !== void 0 ? n : u);
  function d() {
    if (t.errors === !1) m(), t.modifying && Fx(e), g(() => e.error());
    else {
      const v = t.async ? p() : h();
      t.modifying && Fx(e), g(() => uK(e, v));
    }
  }
  function p() {
    const v = r.let("ruleErrs", null);
    return (
      r.try(
        () => m((0, _r._)`await `),
        (y) =>
          r.assign(u, !1).if(
            (0, _r._)`${y} instanceof ${c.ValidationError}`,
            () => r.assign(v, (0, _r._)`${y}.errors`),
            () => r.throw(y),
          ),
      ),
      v
    );
  }
  function h() {
    const v = (0, _r._)`${f}.errors`;
    return r.assign(v, null), m(_r.nil), v;
  }
  function m(v = t.async ? (0, _r._)`await ` : _r.nil) {
    const y = c.opts.passContext ? Es.default.this : Es.default.self,
      _ = !(("compile" in t && !o) || t.schema === !1);
    r.assign(
      u,
      (0, _r._)`${v}${(0, sK.callValidateCode)(e, f, y, _)}`,
      t.modifying,
    );
  }
  function g(v) {
    var y;
    r.if((0, _r.not)((y = t.valid) !== null && y !== void 0 ? y : u), v);
  }
}
ji.funcKeywordCode = lK;
function Fx(e) {
  const { gen: t, data: n, it: r } = e;
  t.if(r.parentData, () =>
    t.assign(n, (0, _r._)`${r.parentData}[${r.parentDataProperty}]`),
  );
}
function uK(e, t) {
  const { gen: n } = e;
  n.if(
    (0, _r._)`Array.isArray(${t})`,
    () => {
      n
        .assign(
          Es.default.vErrors,
          (0,
          _r._)`${Es.default.vErrors} === null ? ${t} : ${Es.default.vErrors}.concat(${t})`,
        )
        .assign(Es.default.errors, (0, _r._)`${Es.default.vErrors}.length`),
        (0, oK.extendErrors)(e);
    },
    () => e.error(),
  );
}
function fK({ schemaEnv: e }, t) {
  if (t.async && !e.$async) throw new Error("async keyword in sync schema");
}
function oR(e, t, n) {
  if (n === void 0) throw new Error(`keyword "${t}" failed to compile`);
  return e.scopeValue(
    "keyword",
    typeof n == "function"
      ? { ref: n }
      : { ref: n, code: (0, _r.stringify)(n) },
  );
}
function dK(e, t, n = !1) {
  return (
    !t.length ||
    t.some((r) =>
      r === "array"
        ? Array.isArray(e)
        : r === "object"
        ? e && typeof e == "object" && !Array.isArray(e)
        : typeof e == r || (n && typeof e > "u"),
    )
  );
}
ji.validSchemaType = dK;
function pK({ schema: e, opts: t, self: n, errSchemaPath: r }, i, a) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(a) : i.keyword !== a)
    throw new Error("ajv implementation error");
  const s = i.dependencies;
  if (s != null && s.some((o) => !Object.prototype.hasOwnProperty.call(e, o)))
    throw new Error(
      `parent schema must have dependencies of ${a}: ${s.join(",")}`,
    );
  if (i.validateSchema && !i.validateSchema(e[a])) {
    const c =
      `keyword "${a}" value is invalid at path "${r}": ` +
      n.errorsText(i.validateSchema.errors);
    if (t.validateSchema === "log") n.logger.error(c);
    else throw new Error(c);
  }
}
ji.validateKeywordUsage = pK;
var Qa = {};
Object.defineProperty(Qa, "__esModule", { value: !0 });
Qa.extendSubschemaMode = Qa.extendSubschemaData = Qa.getSubschema = void 0;
const Li = xt,
  cR = Ft;
function hK(
  e,
  {
    keyword: t,
    schemaProp: n,
    schema: r,
    schemaPath: i,
    errSchemaPath: a,
    topSchemaRef: s,
  },
) {
  if (t !== void 0 && r !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (t !== void 0) {
    const o = e.schema[t];
    return n === void 0
      ? {
          schema: o,
          schemaPath: (0, Li._)`${e.schemaPath}${(0, Li.getProperty)(t)}`,
          errSchemaPath: `${e.errSchemaPath}/${t}`,
        }
      : {
          schema: o[n],
          schemaPath: (0, Li._)`${e.schemaPath}${(0, Li.getProperty)(t)}${(0,
          Li.getProperty)(n)}`,
          errSchemaPath: `${e.errSchemaPath}/${t}/${(0, cR.escapeFragment)(n)}`,
        };
  }
  if (r !== void 0) {
    if (i === void 0 || a === void 0 || s === void 0)
      throw new Error(
        '"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"',
      );
    return { schema: r, schemaPath: i, topSchemaRef: s, errSchemaPath: a };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
Qa.getSubschema = hK;
function mK(
  e,
  t,
  { dataProp: n, dataPropType: r, data: i, dataTypes: a, propertyName: s },
) {
  if (i !== void 0 && n !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: o } = t;
  if (n !== void 0) {
    const { errorPath: l, dataPathArr: f, opts: u } = t,
      d = o.let("data", (0, Li._)`${t.data}${(0, Li.getProperty)(n)}`, !0);
    c(d),
      (e.errorPath = (0, Li.str)`${l}${(0, cR.getErrorPath)(
        n,
        r,
        u.jsPropertySyntax,
      )}`),
      (e.parentDataProperty = (0, Li._)`${n}`),
      (e.dataPathArr = [...f, e.parentDataProperty]);
  }
  if (i !== void 0) {
    const l = i instanceof Li.Name ? i : o.let("data", i, !0);
    c(l), s !== void 0 && (e.propertyName = s);
  }
  a && (e.dataTypes = a);
  function c(l) {
    (e.data = l),
      (e.dataLevel = t.dataLevel + 1),
      (e.dataTypes = []),
      (t.definedProperties = new Set()),
      (e.parentData = t.data),
      (e.dataNames = [...t.dataNames, l]);
  }
}
Qa.extendSubschemaData = mK;
function gK(
  e,
  {
    jtdDiscriminator: t,
    jtdMetadata: n,
    compositeRule: r,
    createErrors: i,
    allErrors: a,
  },
) {
  r !== void 0 && (e.compositeRule = r),
    i !== void 0 && (e.createErrors = i),
    a !== void 0 && (e.allErrors = a),
    (e.jtdDiscriminator = t),
    (e.jtdMetadata = n);
}
Qa.extendSubschemaMode = gK;
var rr = {},
  lR = { exports: {} },
  ja = (lR.exports = function (e, t, n) {
    typeof t == "function" && ((n = t), (t = {})), (n = t.cb || n);
    var r = typeof n == "function" ? n : n.pre || function () {},
      i = n.post || function () {};
    Qf(t, r, i, e, "", e);
  });
ja.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0,
};
ja.arrayKeywords = { items: !0, allOf: !0, anyOf: !0, oneOf: !0 };
ja.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0,
};
ja.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0,
};
function Qf(e, t, n, r, i, a, s, o, c, l) {
  if (r && typeof r == "object" && !Array.isArray(r)) {
    t(r, i, a, s, o, c, l);
    for (var f in r) {
      var u = r[f];
      if (Array.isArray(u)) {
        if (f in ja.arrayKeywords)
          for (var d = 0; d < u.length; d++)
            Qf(e, t, n, u[d], i + "/" + f + "/" + d, a, i, f, r, d);
      } else if (f in ja.propsKeywords) {
        if (u && typeof u == "object")
          for (var p in u)
            Qf(e, t, n, u[p], i + "/" + f + "/" + vK(p), a, i, f, r, p);
      } else
        (f in ja.keywords || (e.allKeys && !(f in ja.skipKeywords))) &&
          Qf(e, t, n, u, i + "/" + f, a, i, f, r);
    }
    n(r, i, a, s, o, c, l);
  }
}
function vK(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
var yK = lR.exports;
Object.defineProperty(rr, "__esModule", { value: !0 });
rr.getSchemaRefs =
  rr.resolveUrl =
  rr.normalizeId =
  rr._getFullPath =
  rr.getFullPath =
  rr.inlineRef =
    void 0;
const bK = Ft,
  _K = $p,
  EK = yK,
  wK = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const",
  ]);
function xK(e, t = !0) {
  return typeof e == "boolean" ? !0 : t === !0 ? !C0(e) : t ? uR(e) <= t : !1;
}
rr.inlineRef = xK;
const AK = new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor",
]);
function C0(e) {
  for (const t in e) {
    if (AK.has(t)) return !0;
    const n = e[t];
    if ((Array.isArray(n) && n.some(C0)) || (typeof n == "object" && C0(n)))
      return !0;
  }
  return !1;
}
function uR(e) {
  let t = 0;
  for (const n in e) {
    if (n === "$ref") return 1 / 0;
    if (
      (t++,
      !wK.has(n) &&
        (typeof e[n] == "object" && (0, bK.eachItem)(e[n], (r) => (t += uR(r))),
        t === 1 / 0))
    )
      return 1 / 0;
  }
  return t;
}
function fR(e, t = "", n) {
  n !== !1 && (t = Uo(t));
  const r = e.parse(t);
  return dR(e, r);
}
rr.getFullPath = fR;
function dR(e, t) {
  return e.serialize(t).split("#")[0] + "#";
}
rr._getFullPath = dR;
const SK = /#\/?$/;
function Uo(e) {
  return e ? e.replace(SK, "") : "";
}
rr.normalizeId = Uo;
function IK(e, t, n) {
  return (n = Uo(n)), e.resolve(t, n);
}
rr.resolveUrl = IK;
const $K = /^[a-z_][-a-z0-9._]*$/i;
function CK(e, t) {
  if (typeof e == "boolean") return {};
  const { schemaId: n, uriResolver: r } = this.opts,
    i = Uo(e[n] || t),
    a = { "": i },
    s = fR(r, i, !1),
    o = {},
    c = new Set();
  return (
    EK(e, { allKeys: !0 }, (u, d, p, h) => {
      if (h === void 0) return;
      const m = s + d;
      let g = a[h];
      typeof u[n] == "string" && (g = v.call(this, u[n])),
        y.call(this, u.$anchor),
        y.call(this, u.$dynamicAnchor),
        (a[d] = g);
      function v(_) {
        const E = this.opts.uriResolver.resolve;
        if (((_ = Uo(g ? E(g, _) : _)), c.has(_))) throw f(_);
        c.add(_);
        let R = this.refs[_];
        return (
          typeof R == "string" && (R = this.refs[R]),
          typeof R == "object"
            ? l(u, R.schema, _)
            : _ !== Uo(m) &&
              (_[0] === "#" ? (l(u, o[_], _), (o[_] = u)) : (this.refs[_] = m)),
          _
        );
      }
      function y(_) {
        if (typeof _ == "string") {
          if (!$K.test(_)) throw new Error(`invalid anchor "${_}"`);
          v.call(this, `#${_}`);
        }
      }
    }),
    o
  );
  function l(u, d, p) {
    if (d !== void 0 && !_K(u, d)) throw f(p);
  }
  function f(u) {
    return new Error(`reference "${u}" resolves to more than one schema`);
  }
}
rr.getSchemaRefs = CK;
Object.defineProperty(bi, "__esModule", { value: !0 });
bi.getData = bi.KeywordCxt = bi.validateFunctionCode = void 0;
const pR = oc,
  jx = hu,
  nb = fa,
  Ad = hu,
  RK = Tp,
  wl = ji,
  Nm = Qa,
  Xe = xt,
  vt = zi,
  kK = rr,
  da = Ft,
  zc = pu;
function TK(e) {
  if (gR(e) && (vR(e), mR(e))) {
    PK(e);
    return;
  }
  hR(e, () => (0, pR.topBoolOrEmptySchema)(e));
}
bi.validateFunctionCode = TK;
function hR({ gen: e, validateName: t, schema: n, schemaEnv: r, opts: i }, a) {
  i.code.es5
    ? e.func(
        t,
        (0, Xe._)`${vt.default.data}, ${vt.default.valCxt}`,
        r.$async,
        () => {
          e.code((0, Xe._)`"use strict"; ${Mx(n, i)}`), OK(e, i), e.code(a);
        },
      )
    : e.func(t, (0, Xe._)`${vt.default.data}, ${NK(i)}`, r.$async, () =>
        e.code(Mx(n, i)).code(a),
      );
}
function NK(e) {
  return (0, Xe._)`{${vt.default.instancePath}="", ${vt.default.parentData}, ${
    vt.default.parentDataProperty
  }, ${vt.default.rootData}=${vt.default.data}${
    e.dynamicRef ? (0, Xe._)`, ${vt.default.dynamicAnchors}={}` : Xe.nil
  }}={}`;
}
function OK(e, t) {
  e.if(
    vt.default.valCxt,
    () => {
      e.var(
        vt.default.instancePath,
        (0, Xe._)`${vt.default.valCxt}.${vt.default.instancePath}`,
      ),
        e.var(
          vt.default.parentData,
          (0, Xe._)`${vt.default.valCxt}.${vt.default.parentData}`,
        ),
        e.var(
          vt.default.parentDataProperty,
          (0, Xe._)`${vt.default.valCxt}.${vt.default.parentDataProperty}`,
        ),
        e.var(
          vt.default.rootData,
          (0, Xe._)`${vt.default.valCxt}.${vt.default.rootData}`,
        ),
        t.dynamicRef &&
          e.var(
            vt.default.dynamicAnchors,
            (0, Xe._)`${vt.default.valCxt}.${vt.default.dynamicAnchors}`,
          );
    },
    () => {
      e.var(vt.default.instancePath, (0, Xe._)`""`),
        e.var(vt.default.parentData, (0, Xe._)`undefined`),
        e.var(vt.default.parentDataProperty, (0, Xe._)`undefined`),
        e.var(vt.default.rootData, vt.default.data),
        t.dynamicRef && e.var(vt.default.dynamicAnchors, (0, Xe._)`{}`);
    },
  );
}
function PK(e) {
  const { schema: t, opts: n, gen: r } = e;
  hR(e, () => {
    n.$comment && t.$comment && bR(e),
      FK(e),
      r.let(vt.default.vErrors, null),
      r.let(vt.default.errors, 0),
      n.unevaluated && DK(e),
      yR(e),
      HK(e);
  });
}
function DK(e) {
  const { gen: t, validateName: n } = e;
  (e.evaluated = t.const("evaluated", (0, Xe._)`${n}.evaluated`)),
    t.if((0, Xe._)`${e.evaluated}.dynamicProps`, () =>
      t.assign((0, Xe._)`${e.evaluated}.props`, (0, Xe._)`undefined`),
    ),
    t.if((0, Xe._)`${e.evaluated}.dynamicItems`, () =>
      t.assign((0, Xe._)`${e.evaluated}.items`, (0, Xe._)`undefined`),
    );
}
function Mx(e, t) {
  const n = typeof e == "object" && e[t.schemaId];
  return n && (t.code.source || t.code.process)
    ? (0, Xe._)`/*# sourceURL=${n} */`
    : Xe.nil;
}
function LK(e, t) {
  if (gR(e) && (vR(e), mR(e))) {
    BK(e, t);
    return;
  }
  (0, pR.boolOrEmptySchema)(e, t);
}
function mR({ schema: e, self: t }) {
  if (typeof e == "boolean") return !e;
  for (const n in e) if (t.RULES.all[n]) return !0;
  return !1;
}
function gR(e) {
  return typeof e.schema != "boolean";
}
function BK(e, t) {
  const { schema: n, gen: r, opts: i } = e;
  i.$comment && n.$comment && bR(e), jK(e), MK(e);
  const a = r.const("_errs", vt.default.errors);
  yR(e, a), r.var(t, (0, Xe._)`${a} === ${vt.default.errors}`);
}
function vR(e) {
  (0, da.checkUnknownRules)(e), UK(e);
}
function yR(e, t) {
  if (e.opts.jtd) return Hx(e, [], !1, t);
  const n = (0, jx.getSchemaTypes)(e.schema),
    r = (0, jx.coerceAndCheckDataType)(e, n);
  Hx(e, n, !r, t);
}
function UK(e) {
  const { schema: t, errSchemaPath: n, opts: r, self: i } = e;
  t.$ref &&
    r.ignoreKeywordsWithRef &&
    (0, da.schemaHasRulesButRef)(t, i.RULES) &&
    i.logger.warn(`$ref: keywords ignored in schema at path "${n}"`);
}
function FK(e) {
  const { schema: t, opts: n } = e;
  t.default !== void 0 &&
    n.useDefaults &&
    n.strictSchema &&
    (0, da.checkStrictMode)(e, "default is ignored in the schema root");
}
function jK(e) {
  const t = e.schema[e.opts.schemaId];
  t && (e.baseId = (0, kK.resolveUrl)(e.opts.uriResolver, e.baseId, t));
}
function MK(e) {
  if (e.schema.$async && !e.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function bR({ gen: e, schemaEnv: t, schema: n, errSchemaPath: r, opts: i }) {
  const a = n.$comment;
  if (i.$comment === !0) e.code((0, Xe._)`${vt.default.self}.logger.log(${a})`);
  else if (typeof i.$comment == "function") {
    const s = (0, Xe.str)`${r}/$comment`,
      o = e.scopeValue("root", { ref: t.root });
    e.code(
      (0, Xe._)`${vt.default.self}.opts.$comment(${a}, ${s}, ${o}.schema)`,
    );
  }
}
function HK(e) {
  const {
    gen: t,
    schemaEnv: n,
    validateName: r,
    ValidationError: i,
    opts: a,
  } = e;
  n.$async
    ? t.if(
        (0, Xe._)`${vt.default.errors} === 0`,
        () => t.return(vt.default.data),
        () => t.throw((0, Xe._)`new ${i}(${vt.default.vErrors})`),
      )
    : (t.assign((0, Xe._)`${r}.errors`, vt.default.vErrors),
      a.unevaluated && qK(e),
      t.return((0, Xe._)`${vt.default.errors} === 0`));
}
function qK({ gen: e, evaluated: t, props: n, items: r }) {
  n instanceof Xe.Name && e.assign((0, Xe._)`${t}.props`, n),
    r instanceof Xe.Name && e.assign((0, Xe._)`${t}.items`, r);
}
function Hx(e, t, n, r) {
  const { gen: i, schema: a, data: s, allErrors: o, opts: c, self: l } = e,
    { RULES: f } = l;
  if (
    a.$ref &&
    (c.ignoreKeywordsWithRef || !(0, da.schemaHasRulesButRef)(a, f))
  ) {
    i.block(() => wR(e, "$ref", f.all.$ref.definition));
    return;
  }
  c.jtd || GK(e, t),
    i.block(() => {
      for (const d of f.rules) u(d);
      u(f.post);
    });
  function u(d) {
    (0, nb.shouldUseGroup)(a, d) &&
      (d.type
        ? (i.if((0, Ad.checkDataType)(d.type, s, c.strictNumbers)),
          qx(e, d),
          t.length === 1 &&
            t[0] === d.type &&
            n &&
            (i.else(), (0, Ad.reportTypeError)(e)),
          i.endIf())
        : qx(e, d),
      o || i.if((0, Xe._)`${vt.default.errors} === ${r || 0}`));
  }
}
function qx(e, t) {
  const {
    gen: n,
    schema: r,
    opts: { useDefaults: i },
  } = e;
  i && (0, RK.assignDefaults)(e, t.type),
    n.block(() => {
      for (const a of t.rules)
        (0, nb.shouldUseRule)(r, a) && wR(e, a.keyword, a.definition, t.type);
    });
}
function GK(e, t) {
  e.schemaEnv.meta ||
    !e.opts.strictTypes ||
    (QK(e, t), e.opts.allowUnionTypes || WK(e, t), zK(e, e.dataTypes));
}
function QK(e, t) {
  if (t.length) {
    if (!e.dataTypes.length) {
      e.dataTypes = t;
      return;
    }
    t.forEach((n) => {
      _R(e.dataTypes, n) ||
        rb(e, `type "${n}" not allowed by context "${e.dataTypes.join(",")}"`);
    }),
      VK(e, t);
  }
}
function WK(e, t) {
  t.length > 1 &&
    !(t.length === 2 && t.includes("null")) &&
    rb(e, "use allowUnionTypes to allow union type keyword");
}
function zK(e, t) {
  const n = e.self.RULES.all;
  for (const r in n) {
    const i = n[r];
    if (typeof i == "object" && (0, nb.shouldUseRule)(e.schema, i)) {
      const { type: a } = i.definition;
      a.length &&
        !a.some((s) => KK(t, s)) &&
        rb(e, `missing type "${a.join(",")}" for keyword "${r}"`);
    }
  }
}
function KK(e, t) {
  return e.includes(t) || (t === "number" && e.includes("integer"));
}
function _R(e, t) {
  return e.includes(t) || (t === "integer" && e.includes("number"));
}
function VK(e, t) {
  const n = [];
  for (const r of e.dataTypes)
    _R(t, r)
      ? n.push(r)
      : t.includes("integer") && r === "number" && n.push("integer");
  e.dataTypes = n;
}
function rb(e, t) {
  const n = e.schemaEnv.baseId + e.errSchemaPath;
  (t += ` at "${n}" (strictTypes)`),
    (0, da.checkStrictMode)(e, t, e.opts.strictTypes);
}
class ER {
  constructor(t, n, r) {
    if (
      ((0, wl.validateKeywordUsage)(t, n, r),
      (this.gen = t.gen),
      (this.allErrors = t.allErrors),
      (this.keyword = r),
      (this.data = t.data),
      (this.schema = t.schema[r]),
      (this.$data =
        n.$data && t.opts.$data && this.schema && this.schema.$data),
      (this.schemaValue = (0, da.schemaRefOrVal)(
        t,
        this.schema,
        r,
        this.$data,
      )),
      (this.schemaType = n.schemaType),
      (this.parentSchema = t.schema),
      (this.params = {}),
      (this.it = t),
      (this.def = n),
      this.$data)
    )
      this.schemaCode = t.gen.const("vSchema", xR(this.$data, t));
    else if (
      ((this.schemaCode = this.schemaValue),
      !(0, wl.validSchemaType)(this.schema, n.schemaType, n.allowUndefined))
    )
      throw new Error(`${r} value must be ${JSON.stringify(n.schemaType)}`);
    ("code" in n ? n.trackErrors : n.errors !== !1) &&
      (this.errsCount = t.gen.const("_errs", vt.default.errors));
  }
  result(t, n, r) {
    this.failResult((0, Xe.not)(t), n, r);
  }
  failResult(t, n, r) {
    this.gen.if(t),
      r ? r() : this.error(),
      n
        ? (this.gen.else(), n(), this.allErrors && this.gen.endIf())
        : this.allErrors
        ? this.gen.endIf()
        : this.gen.else();
  }
  pass(t, n) {
    this.failResult((0, Xe.not)(t), void 0, n);
  }
  fail(t) {
    if (t === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(t),
      this.error(),
      this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(t) {
    if (!this.$data) return this.fail(t);
    const { schemaCode: n } = this;
    this.fail(
      (0, Xe._)`${n} !== undefined && (${(0, Xe.or)(this.invalid$data(), t)})`,
    );
  }
  error(t, n, r) {
    if (n) {
      this.setParams(n), this._error(t, r), this.setParams({});
      return;
    }
    this._error(t, r);
  }
  _error(t, n) {
    (t ? zc.reportExtraError : zc.reportError)(this, this.def.error, n);
  }
  $dataError() {
    (0, zc.reportError)(this, this.def.$dataError || zc.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, zc.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(t) {
    this.allErrors || this.gen.if(t);
  }
  setParams(t, n) {
    n ? Object.assign(this.params, t) : (this.params = t);
  }
  block$data(t, n, r = Xe.nil) {
    this.gen.block(() => {
      this.check$data(t, r), n();
    });
  }
  check$data(t = Xe.nil, n = Xe.nil) {
    if (!this.$data) return;
    const { gen: r, schemaCode: i, schemaType: a, def: s } = this;
    r.if((0, Xe.or)((0, Xe._)`${i} === undefined`, n)),
      t !== Xe.nil && r.assign(t, !0),
      (a.length || s.validateSchema) &&
        (r.elseIf(this.invalid$data()),
        this.$dataError(),
        t !== Xe.nil && r.assign(t, !1)),
      r.else();
  }
  invalid$data() {
    const { gen: t, schemaCode: n, schemaType: r, def: i, it: a } = this;
    return (0, Xe.or)(s(), o());
    function s() {
      if (r.length) {
        if (!(n instanceof Xe.Name))
          throw new Error("ajv implementation error");
        const c = Array.isArray(r) ? r : [r];
        return (0, Xe._)`${(0, Ad.checkDataTypes)(
          c,
          n,
          a.opts.strictNumbers,
          Ad.DataType.Wrong,
        )}`;
      }
      return Xe.nil;
    }
    function o() {
      if (i.validateSchema) {
        const c = t.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, Xe._)`!${c}(${n})`;
      }
      return Xe.nil;
    }
  }
  subschema(t, n) {
    const r = (0, Nm.getSubschema)(this.it, t);
    (0, Nm.extendSubschemaData)(r, this.it, t),
      (0, Nm.extendSubschemaMode)(r, t);
    const i = { ...this.it, ...r, items: void 0, props: void 0 };
    return LK(i, n), i;
  }
  mergeEvaluated(t, n) {
    const { it: r, gen: i } = this;
    r.opts.unevaluated &&
      (r.props !== !0 &&
        t.props !== void 0 &&
        (r.props = da.mergeEvaluated.props(i, t.props, r.props, n)),
      r.items !== !0 &&
        t.items !== void 0 &&
        (r.items = da.mergeEvaluated.items(i, t.items, r.items, n)));
  }
  mergeValidEvaluated(t, n) {
    const { it: r, gen: i } = this;
    if (r.opts.unevaluated && (r.props !== !0 || r.items !== !0))
      return i.if(n, () => this.mergeEvaluated(t, Xe.Name)), !0;
  }
}
bi.KeywordCxt = ER;
function wR(e, t, n, r) {
  const i = new ER(e, n, t);
  "code" in n
    ? n.code(i, r)
    : i.$data && n.validate
    ? (0, wl.funcKeywordCode)(i, n)
    : "macro" in n
    ? (0, wl.macroKeywordCode)(i, n)
    : (n.compile || n.validate) && (0, wl.funcKeywordCode)(i, n);
}
const YK = /^\/(?:[^~]|~0|~1)*$/,
  XK = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function xR(e, { dataLevel: t, dataNames: n, dataPathArr: r }) {
  let i, a;
  if (e === "") return vt.default.rootData;
  if (e[0] === "/") {
    if (!YK.test(e)) throw new Error(`Invalid JSON-pointer: ${e}`);
    (i = e), (a = vt.default.rootData);
  } else {
    const l = XK.exec(e);
    if (!l) throw new Error(`Invalid JSON-pointer: ${e}`);
    const f = +l[1];
    if (((i = l[2]), i === "#")) {
      if (f >= t) throw new Error(c("property/index", f));
      return r[t - f];
    }
    if (f > t) throw new Error(c("data", f));
    if (((a = n[t - f]), !i)) return a;
  }
  let s = a;
  const o = i.split("/");
  for (const l of o)
    l &&
      ((a = (0, Xe._)`${a}${(0, Xe.getProperty)(
        (0, da.unescapeJsonPointer)(l),
      )}`),
      (s = (0, Xe._)`${s} && ${a}`));
  return s;
  function c(l, f) {
    return `Cannot access ${l} ${f} levels up, current level is ${t}`;
  }
}
bi.getData = xR;
var mu = {};
Object.defineProperty(mu, "__esModule", { value: !0 });
class JK extends Error {
  constructor(t) {
    super("validation failed"),
      (this.errors = t),
      (this.ajv = this.validation = !0);
  }
}
mu.default = JK;
var gu = {};
Object.defineProperty(gu, "__esModule", { value: !0 });
const Om = rr;
class ZK extends Error {
  constructor(t, n, r, i) {
    super(i || `can't resolve reference ${r} from id ${n}`),
      (this.missingRef = (0, Om.resolveUrl)(t, n, r)),
      (this.missingSchema = (0, Om.normalizeId)(
        (0, Om.getFullPath)(t, this.missingRef),
      ));
  }
}
gu.default = ZK;
var Lr = {};
Object.defineProperty(Lr, "__esModule", { value: !0 });
Lr.resolveSchema =
  Lr.getCompilingSchema =
  Lr.resolveRef =
  Lr.compileSchema =
  Lr.SchemaEnv =
    void 0;
const ai = xt,
  eV = mu,
  fs = zi,
  mi = rr,
  Gx = Ft,
  tV = bi;
class Np {
  constructor(t) {
    var n;
    (this.refs = {}), (this.dynamicAnchors = {});
    let r;
    typeof t.schema == "object" && (r = t.schema),
      (this.schema = t.schema),
      (this.schemaId = t.schemaId),
      (this.root = t.root || this),
      (this.baseId =
        (n = t.baseId) !== null && n !== void 0
          ? n
          : (0, mi.normalizeId)(r == null ? void 0 : r[t.schemaId || "$id"])),
      (this.schemaPath = t.schemaPath),
      (this.localRefs = t.localRefs),
      (this.meta = t.meta),
      (this.$async = r == null ? void 0 : r.$async),
      (this.refs = {});
  }
}
Lr.SchemaEnv = Np;
function ib(e) {
  const t = AR.call(this, e);
  if (t) return t;
  const n = (0, mi.getFullPath)(this.opts.uriResolver, e.root.baseId),
    { es5: r, lines: i } = this.opts.code,
    { ownProperties: a } = this.opts,
    s = new ai.CodeGen(this.scope, { es5: r, lines: i, ownProperties: a });
  let o;
  e.$async &&
    (o = s.scopeValue("Error", {
      ref: eV.default,
      code: (0, ai._)`require("ajv/dist/runtime/validation_error").default`,
    }));
  const c = s.scopeName("validate");
  e.validateName = c;
  const l = {
    gen: s,
    allErrors: this.opts.allErrors,
    data: fs.default.data,
    parentData: fs.default.parentData,
    parentDataProperty: fs.default.parentDataProperty,
    dataNames: [fs.default.data],
    dataPathArr: [ai.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: new Set(),
    topSchemaRef: s.scopeValue(
      "schema",
      this.opts.code.source === !0
        ? { ref: e.schema, code: (0, ai.stringify)(e.schema) }
        : { ref: e.schema },
    ),
    validateName: c,
    ValidationError: o,
    schema: e.schema,
    schemaEnv: e,
    rootId: n,
    baseId: e.baseId || n,
    schemaPath: ai.nil,
    errSchemaPath: e.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, ai._)`""`,
    opts: this.opts,
    self: this,
  };
  let f;
  try {
    this._compilations.add(e),
      (0, tV.validateFunctionCode)(l),
      s.optimize(this.opts.code.optimize);
    const u = s.toString();
    (f = `${s.scopeRefs(fs.default.scope)}return ${u}`),
      this.opts.code.process && (f = this.opts.code.process(f, e));
    const p = new Function(`${fs.default.self}`, `${fs.default.scope}`, f)(
      this,
      this.scope.get(),
    );
    if (
      (this.scope.value(c, { ref: p }),
      (p.errors = null),
      (p.schema = e.schema),
      (p.schemaEnv = e),
      e.$async && (p.$async = !0),
      this.opts.code.source === !0 &&
        (p.source = {
          validateName: c,
          validateCode: u,
          scopeValues: s._values,
        }),
      this.opts.unevaluated)
    ) {
      const { props: h, items: m } = l;
      (p.evaluated = {
        props: h instanceof ai.Name ? void 0 : h,
        items: m instanceof ai.Name ? void 0 : m,
        dynamicProps: h instanceof ai.Name,
        dynamicItems: m instanceof ai.Name,
      }),
        p.source && (p.source.evaluated = (0, ai.stringify)(p.evaluated));
    }
    return (e.validate = p), e;
  } catch (u) {
    throw (
      (delete e.validate,
      delete e.validateName,
      f && this.logger.error("Error compiling schema, function code:", f),
      u)
    );
  } finally {
    this._compilations.delete(e);
  }
}
Lr.compileSchema = ib;
function nV(e, t, n) {
  var r;
  n = (0, mi.resolveUrl)(this.opts.uriResolver, t, n);
  const i = e.refs[n];
  if (i) return i;
  let a = aV.call(this, e, n);
  if (a === void 0) {
    const s = (r = e.localRefs) === null || r === void 0 ? void 0 : r[n],
      { schemaId: o } = this.opts;
    s && (a = new Np({ schema: s, schemaId: o, root: e, baseId: t }));
  }
  if (a !== void 0) return (e.refs[n] = rV.call(this, a));
}
Lr.resolveRef = nV;
function rV(e) {
  return (0, mi.inlineRef)(e.schema, this.opts.inlineRefs)
    ? e.schema
    : e.validate
    ? e
    : ib.call(this, e);
}
function AR(e) {
  for (const t of this._compilations) if (iV(t, e)) return t;
}
Lr.getCompilingSchema = AR;
function iV(e, t) {
  return e.schema === t.schema && e.root === t.root && e.baseId === t.baseId;
}
function aV(e, t) {
  let n;
  for (; typeof (n = this.refs[t]) == "string"; ) t = n;
  return n || this.schemas[t] || Op.call(this, e, t);
}
function Op(e, t) {
  const n = this.opts.uriResolver.parse(t),
    r = (0, mi._getFullPath)(this.opts.uriResolver, n);
  let i = (0, mi.getFullPath)(this.opts.uriResolver, e.baseId, void 0);
  if (Object.keys(e.schema).length > 0 && r === i) return Pm.call(this, n, e);
  const a = (0, mi.normalizeId)(r),
    s = this.refs[a] || this.schemas[a];
  if (typeof s == "string") {
    const o = Op.call(this, e, s);
    return typeof (o == null ? void 0 : o.schema) != "object"
      ? void 0
      : Pm.call(this, n, o);
  }
  if (typeof (s == null ? void 0 : s.schema) == "object") {
    if ((s.validate || ib.call(this, s), a === (0, mi.normalizeId)(t))) {
      const { schema: o } = s,
        { schemaId: c } = this.opts,
        l = o[c];
      return (
        l && (i = (0, mi.resolveUrl)(this.opts.uriResolver, i, l)),
        new Np({ schema: o, schemaId: c, root: e, baseId: i })
      );
    }
    return Pm.call(this, n, s);
  }
}
Lr.resolveSchema = Op;
const sV = new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions",
]);
function Pm(e, { baseId: t, schema: n, root: r }) {
  var i;
  if (((i = e.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
    return;
  for (const o of e.fragment.slice(1).split("/")) {
    if (typeof n == "boolean") return;
    const c = n[(0, Gx.unescapeFragment)(o)];
    if (c === void 0) return;
    n = c;
    const l = typeof n == "object" && n[this.opts.schemaId];
    !sV.has(o) && l && (t = (0, mi.resolveUrl)(this.opts.uriResolver, t, l));
  }
  let a;
  if (
    typeof n != "boolean" &&
    n.$ref &&
    !(0, Gx.schemaHasRulesButRef)(n, this.RULES)
  ) {
    const o = (0, mi.resolveUrl)(this.opts.uriResolver, t, n.$ref);
    a = Op.call(this, r, o);
  }
  const { schemaId: s } = this.opts;
  if (
    ((a = a || new Np({ schema: n, schemaId: s, root: r, baseId: t })),
    a.schema !== a.root.schema)
  )
    return a;
}
const oV =
    "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
  cV = "Meta-schema for $data reference (JSON AnySchema extension proposal)",
  lV = "object",
  uV = ["$data"],
  fV = {
    $data: {
      type: "string",
      anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }],
    },
  },
  dV = !1,
  pV = {
    $id: oV,
    description: cV,
    type: lV,
    required: uV,
    properties: fV,
    additionalProperties: dV,
  };
var ab = {};
Object.defineProperty(ab, "__esModule", { value: !0 });
const SR = H4;
SR.code = 'require("ajv/dist/runtime/uri").default';
ab.default = SR;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.CodeGen =
      e.Name =
      e.nil =
      e.stringify =
      e.str =
      e._ =
      e.KeywordCxt =
        void 0);
  var t = bi;
  Object.defineProperty(e, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return t.KeywordCxt;
    },
  });
  var n = xt;
  Object.defineProperty(e, "_", {
    enumerable: !0,
    get: function () {
      return n._;
    },
  }),
    Object.defineProperty(e, "str", {
      enumerable: !0,
      get: function () {
        return n.str;
      },
    }),
    Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function () {
        return n.stringify;
      },
    }),
    Object.defineProperty(e, "nil", {
      enumerable: !0,
      get: function () {
        return n.nil;
      },
    }),
    Object.defineProperty(e, "Name", {
      enumerable: !0,
      get: function () {
        return n.Name;
      },
    }),
    Object.defineProperty(e, "CodeGen", {
      enumerable: !0,
      get: function () {
        return n.CodeGen;
      },
    });
  const r = mu,
    i = gu,
    a = Ms,
    s = Lr,
    o = xt,
    c = rr,
    l = hu,
    f = Ft,
    u = pV,
    d = ab,
    p = (L, k) => new RegExp(L, k);
  p.code = "new RegExp";
  const h = ["removeAdditional", "useDefaults", "coerceTypes"],
    m = new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error",
    ]),
    g = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs:
        "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode:
        "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats:
        "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now.",
    },
    v = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode:
        '"minLength"/"maxLength" account for unicode characters by default.',
    },
    y = 200;
  function _(L) {
    var k,
      W,
      F,
      x,
      T,
      V,
      B,
      N,
      ce,
      re,
      ne,
      Y,
      M,
      oe,
      Ee,
      le,
      te,
      ie,
      X,
      he,
      be,
      ye,
      Qe,
      lt,
      Lt;
    const We = L.strict,
      bt = (k = L.code) === null || k === void 0 ? void 0 : k.optimize,
      wt = bt === !0 || bt === void 0 ? 1 : bt || 0,
      ct =
        (F = (W = L.code) === null || W === void 0 ? void 0 : W.regExp) !==
          null && F !== void 0
          ? F
          : p,
      ze = (x = L.uriResolver) !== null && x !== void 0 ? x : d.default;
    return {
      strictSchema:
        (V = (T = L.strictSchema) !== null && T !== void 0 ? T : We) !== null &&
        V !== void 0
          ? V
          : !0,
      strictNumbers:
        (N = (B = L.strictNumbers) !== null && B !== void 0 ? B : We) !==
          null && N !== void 0
          ? N
          : !0,
      strictTypes:
        (re = (ce = L.strictTypes) !== null && ce !== void 0 ? ce : We) !==
          null && re !== void 0
          ? re
          : "log",
      strictTuples:
        (Y = (ne = L.strictTuples) !== null && ne !== void 0 ? ne : We) !==
          null && Y !== void 0
          ? Y
          : "log",
      strictRequired:
        (oe = (M = L.strictRequired) !== null && M !== void 0 ? M : We) !==
          null && oe !== void 0
          ? oe
          : !1,
      code: L.code
        ? { ...L.code, optimize: wt, regExp: ct }
        : { optimize: wt, regExp: ct },
      loopRequired: (Ee = L.loopRequired) !== null && Ee !== void 0 ? Ee : y,
      loopEnum: (le = L.loopEnum) !== null && le !== void 0 ? le : y,
      meta: (te = L.meta) !== null && te !== void 0 ? te : !0,
      messages: (ie = L.messages) !== null && ie !== void 0 ? ie : !0,
      inlineRefs: (X = L.inlineRefs) !== null && X !== void 0 ? X : !0,
      schemaId: (he = L.schemaId) !== null && he !== void 0 ? he : "$id",
      addUsedSchema: (be = L.addUsedSchema) !== null && be !== void 0 ? be : !0,
      validateSchema:
        (ye = L.validateSchema) !== null && ye !== void 0 ? ye : !0,
      validateFormats:
        (Qe = L.validateFormats) !== null && Qe !== void 0 ? Qe : !0,
      unicodeRegExp: (lt = L.unicodeRegExp) !== null && lt !== void 0 ? lt : !0,
      int32range: (Lt = L.int32range) !== null && Lt !== void 0 ? Lt : !0,
      uriResolver: ze,
    };
  }
  class E {
    constructor(k = {}) {
      (this.schemas = {}),
        (this.refs = {}),
        (this.formats = {}),
        (this._compilations = new Set()),
        (this._loading = {}),
        (this._cache = new Map()),
        (k = this.opts = { ...k, ..._(k) });
      const { es5: W, lines: F } = this.opts.code;
      (this.scope = new o.ValueScope({
        scope: {},
        prefixes: m,
        es5: W,
        lines: F,
      })),
        (this.logger = j(k.logger));
      const x = k.validateFormats;
      (k.validateFormats = !1),
        (this.RULES = (0, a.getRules)()),
        R.call(this, g, k, "NOT SUPPORTED"),
        R.call(this, v, k, "DEPRECATED", "warn"),
        (this._metaOpts = O.call(this)),
        k.formats && S.call(this),
        this._addVocabularies(),
        this._addDefaultMetaSchema(),
        k.keywords && w.call(this, k.keywords),
        typeof k.meta == "object" && this.addMetaSchema(k.meta),
        I.call(this),
        (k.validateFormats = x);
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: k, meta: W, schemaId: F } = this.opts;
      let x = u;
      F === "id" && ((x = { ...u }), (x.id = x.$id), delete x.$id),
        W && k && this.addMetaSchema(x, x[F], !1);
    }
    defaultMeta() {
      const { meta: k, schemaId: W } = this.opts;
      return (this.opts.defaultMeta =
        typeof k == "object" ? k[W] || k : void 0);
    }
    validate(k, W) {
      let F;
      if (typeof k == "string") {
        if (((F = this.getSchema(k)), !F))
          throw new Error(`no schema with key or ref "${k}"`);
      } else F = this.compile(k);
      const x = F(W);
      return "$async" in F || (this.errors = F.errors), x;
    }
    compile(k, W) {
      const F = this._addSchema(k, W);
      return F.validate || this._compileSchemaEnv(F);
    }
    compileAsync(k, W) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: F } = this.opts;
      return x.call(this, k, W);
      async function x(re, ne) {
        await T.call(this, re.$schema);
        const Y = this._addSchema(re, ne);
        return Y.validate || V.call(this, Y);
      }
      async function T(re) {
        re && !this.getSchema(re) && (await x.call(this, { $ref: re }, !0));
      }
      async function V(re) {
        try {
          return this._compileSchemaEnv(re);
        } catch (ne) {
          if (!(ne instanceof i.default)) throw ne;
          return (
            B.call(this, ne),
            await N.call(this, ne.missingSchema),
            V.call(this, re)
          );
        }
      }
      function B({ missingSchema: re, missingRef: ne }) {
        if (this.refs[re])
          throw new Error(
            `AnySchema ${re} is loaded but ${ne} cannot be resolved`,
          );
      }
      async function N(re) {
        const ne = await ce.call(this, re);
        this.refs[re] || (await T.call(this, ne.$schema)),
          this.refs[re] || this.addSchema(ne, re, W);
      }
      async function ce(re) {
        const ne = this._loading[re];
        if (ne) return ne;
        try {
          return await (this._loading[re] = F(re));
        } finally {
          delete this._loading[re];
        }
      }
    }
    addSchema(k, W, F, x = this.opts.validateSchema) {
      if (Array.isArray(k)) {
        for (const V of k) this.addSchema(V, void 0, F, x);
        return this;
      }
      let T;
      if (typeof k == "object") {
        const { schemaId: V } = this.opts;
        if (((T = k[V]), T !== void 0 && typeof T != "string"))
          throw new Error(`schema ${V} must be string`);
      }
      return (
        (W = (0, c.normalizeId)(W || T)),
        this._checkUnique(W),
        (this.schemas[W] = this._addSchema(k, F, W, x, !0)),
        this
      );
    }
    addMetaSchema(k, W, F = this.opts.validateSchema) {
      return this.addSchema(k, W, !0, F), this;
    }
    validateSchema(k, W) {
      if (typeof k == "boolean") return !0;
      let F;
      if (((F = k.$schema), F !== void 0 && typeof F != "string"))
        throw new Error("$schema must be a string");
      if (((F = F || this.opts.defaultMeta || this.defaultMeta()), !F))
        return (
          this.logger.warn("meta-schema not available"),
          (this.errors = null),
          !0
        );
      const x = this.validate(F, k);
      if (!x && W) {
        const T = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log") this.logger.error(T);
        else throw new Error(T);
      }
      return x;
    }
    getSchema(k) {
      let W;
      for (; typeof (W = A.call(this, k)) == "string"; ) k = W;
      if (W === void 0) {
        const { schemaId: F } = this.opts,
          x = new s.SchemaEnv({ schema: {}, schemaId: F });
        if (((W = s.resolveSchema.call(this, x, k)), !W)) return;
        this.refs[k] = W;
      }
      return W.validate || this._compileSchemaEnv(W);
    }
    removeSchema(k) {
      if (k instanceof RegExp)
        return (
          this._removeAllSchemas(this.schemas, k),
          this._removeAllSchemas(this.refs, k),
          this
        );
      switch (typeof k) {
        case "undefined":
          return (
            this._removeAllSchemas(this.schemas),
            this._removeAllSchemas(this.refs),
            this._cache.clear(),
            this
          );
        case "string": {
          const W = A.call(this, k);
          return (
            typeof W == "object" && this._cache.delete(W.schema),
            delete this.schemas[k],
            delete this.refs[k],
            this
          );
        }
        case "object": {
          const W = k;
          this._cache.delete(W);
          let F = k[this.opts.schemaId];
          return (
            F &&
              ((F = (0, c.normalizeId)(F)),
              delete this.schemas[F],
              delete this.refs[F]),
            this
          );
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(k) {
      for (const W of k) this.addKeyword(W);
      return this;
    }
    addKeyword(k, W) {
      let F;
      if (typeof k == "string")
        (F = k),
          typeof W == "object" &&
            (this.logger.warn(
              "these parameters are deprecated, see docs for addKeyword",
            ),
            (W.keyword = F));
      else if (typeof k == "object" && W === void 0) {
        if (((W = k), (F = W.keyword), Array.isArray(F) && !F.length))
          throw new Error(
            "addKeywords: keyword must be string or non-empty array",
          );
      } else throw new Error("invalid addKeywords parameters");
      if ((q.call(this, F, W), !W))
        return (0, f.eachItem)(F, (T) => J.call(this, T)), this;
      z.call(this, W);
      const x = {
        ...W,
        type: (0, l.getJSONTypes)(W.type),
        schemaType: (0, l.getJSONTypes)(W.schemaType),
      };
      return (
        (0, f.eachItem)(
          F,
          x.type.length === 0
            ? (T) => J.call(this, T, x)
            : (T) => x.type.forEach((V) => J.call(this, T, x, V)),
        ),
        this
      );
    }
    getKeyword(k) {
      const W = this.RULES.all[k];
      return typeof W == "object" ? W.definition : !!W;
    }
    removeKeyword(k) {
      const { RULES: W } = this;
      delete W.keywords[k], delete W.all[k];
      for (const F of W.rules) {
        const x = F.rules.findIndex((T) => T.keyword === k);
        x >= 0 && F.rules.splice(x, 1);
      }
      return this;
    }
    addFormat(k, W) {
      return (
        typeof W == "string" && (W = new RegExp(W)), (this.formats[k] = W), this
      );
    }
    errorsText(
      k = this.errors,
      { separator: W = ", ", dataVar: F = "data" } = {},
    ) {
      return !k || k.length === 0
        ? "No errors"
        : k
            .map((x) => `${F}${x.instancePath} ${x.message}`)
            .reduce((x, T) => x + W + T);
    }
    $dataMetaSchema(k, W) {
      const F = this.RULES.all;
      k = JSON.parse(JSON.stringify(k));
      for (const x of W) {
        const T = x.split("/").slice(1);
        let V = k;
        for (const B of T) V = V[B];
        for (const B in F) {
          const N = F[B];
          if (typeof N != "object") continue;
          const { $data: ce } = N.definition,
            re = V[B];
          ce && re && (V[B] = G(re));
        }
      }
      return k;
    }
    _removeAllSchemas(k, W) {
      for (const F in k) {
        const x = k[F];
        (!W || W.test(F)) &&
          (typeof x == "string"
            ? delete k[F]
            : x && !x.meta && (this._cache.delete(x.schema), delete k[F]));
      }
    }
    _addSchema(
      k,
      W,
      F,
      x = this.opts.validateSchema,
      T = this.opts.addUsedSchema,
    ) {
      let V;
      const { schemaId: B } = this.opts;
      if (typeof k == "object") V = k[B];
      else {
        if (this.opts.jtd) throw new Error("schema must be object");
        if (typeof k != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let N = this._cache.get(k);
      if (N !== void 0) return N;
      F = (0, c.normalizeId)(V || F);
      const ce = c.getSchemaRefs.call(this, k, F);
      return (
        (N = new s.SchemaEnv({
          schema: k,
          schemaId: B,
          meta: W,
          baseId: F,
          localRefs: ce,
        })),
        this._cache.set(N.schema, N),
        T &&
          !F.startsWith("#") &&
          (F && this._checkUnique(F), (this.refs[F] = N)),
        x && this.validateSchema(k, !0),
        N
      );
    }
    _checkUnique(k) {
      if (this.schemas[k] || this.refs[k])
        throw new Error(`schema with key or id "${k}" already exists`);
    }
    _compileSchemaEnv(k) {
      if (
        (k.meta ? this._compileMetaSchema(k) : s.compileSchema.call(this, k),
        !k.validate)
      )
        throw new Error("ajv implementation error");
      return k.validate;
    }
    _compileMetaSchema(k) {
      const W = this.opts;
      this.opts = this._metaOpts;
      try {
        s.compileSchema.call(this, k);
      } finally {
        this.opts = W;
      }
    }
  }
  (e.default = E),
    (E.ValidationError = r.default),
    (E.MissingRefError = i.default);
  function R(L, k, W, F = "error") {
    for (const x in L) {
      const T = x;
      T in k && this.logger[F](`${W}: option ${x}. ${L[T]}`);
    }
  }
  function A(L) {
    return (L = (0, c.normalizeId)(L)), this.schemas[L] || this.refs[L];
  }
  function I() {
    const L = this.opts.schemas;
    if (L)
      if (Array.isArray(L)) this.addSchema(L);
      else for (const k in L) this.addSchema(L[k], k);
  }
  function S() {
    for (const L in this.opts.formats) {
      const k = this.opts.formats[L];
      k && this.addFormat(L, k);
    }
  }
  function w(L) {
    if (Array.isArray(L)) {
      this.addVocabulary(L);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const k in L) {
      const W = L[k];
      W.keyword || (W.keyword = k), this.addKeyword(W);
    }
  }
  function O() {
    const L = { ...this.opts };
    for (const k of h) delete L[k];
    return L;
  }
  const Q = { log() {}, warn() {}, error() {} };
  function j(L) {
    if (L === !1) return Q;
    if (L === void 0) return console;
    if (L.log && L.warn && L.error) return L;
    throw new Error("logger must implement log, warn and error methods");
  }
  const H = /^[a-z_$][a-z0-9_$:-]*$/i;
  function q(L, k) {
    const { RULES: W } = this;
    if (
      ((0, f.eachItem)(L, (F) => {
        if (W.keywords[F]) throw new Error(`Keyword ${F} is already defined`);
        if (!H.test(F)) throw new Error(`Keyword ${F} has invalid name`);
      }),
      !!k && k.$data && !("code" in k || "validate" in k))
    )
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function J(L, k, W) {
    var F;
    const x = k == null ? void 0 : k.post;
    if (W && x) throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: T } = this;
    let V = x ? T.post : T.rules.find(({ type: N }) => N === W);
    if (
      (V || ((V = { type: W, rules: [] }), T.rules.push(V)),
      (T.keywords[L] = !0),
      !k)
    )
      return;
    const B = {
      keyword: L,
      definition: {
        ...k,
        type: (0, l.getJSONTypes)(k.type),
        schemaType: (0, l.getJSONTypes)(k.schemaType),
      },
    };
    k.before ? Z.call(this, V, B, k.before) : V.rules.push(B),
      (T.all[L] = B),
      (F = k.implements) === null ||
        F === void 0 ||
        F.forEach((N) => this.addKeyword(N));
  }
  function Z(L, k, W) {
    const F = L.rules.findIndex((x) => x.keyword === W);
    F >= 0
      ? L.rules.splice(F, 0, k)
      : (L.rules.push(k), this.logger.warn(`rule ${W} is not defined`));
  }
  function z(L) {
    let { metaSchema: k } = L;
    k !== void 0 &&
      (L.$data && this.opts.$data && (k = G(k)),
      (L.validateSchema = this.compile(k, !0)));
  }
  const U = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
  };
  function G(L) {
    return { anyOf: [L, U] };
  }
})(tR);
var sb = {},
  ob = {},
  cb = {};
Object.defineProperty(cb, "__esModule", { value: !0 });
const hV = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  },
};
cb.default = hV;
var Hs = {};
Object.defineProperty(Hs, "__esModule", { value: !0 });
Hs.callRef = Hs.getValidate = void 0;
const mV = gu,
  Qx = It,
  Or = xt,
  ho = zi,
  Wx = Lr,
  Ef = Ft,
  gV = {
    keyword: "$ref",
    schemaType: "string",
    code(e) {
      const { gen: t, schema: n, it: r } = e,
        { baseId: i, schemaEnv: a, validateName: s, opts: o, self: c } = r,
        { root: l } = a;
      if ((n === "#" || n === "#/") && i === l.baseId) return u();
      const f = Wx.resolveRef.call(c, l, i, n);
      if (f === void 0) throw new mV.default(r.opts.uriResolver, i, n);
      if (f instanceof Wx.SchemaEnv) return d(f);
      return p(f);
      function u() {
        if (a === l) return Wf(e, s, a, a.$async);
        const h = t.scopeValue("root", { ref: l });
        return Wf(e, (0, Or._)`${h}.validate`, l, l.$async);
      }
      function d(h) {
        const m = IR(e, h);
        Wf(e, m, h, h.$async);
      }
      function p(h) {
        const m = t.scopeValue(
            "schema",
            o.code.source === !0
              ? { ref: h, code: (0, Or.stringify)(h) }
              : { ref: h },
          ),
          g = t.name("valid"),
          v = e.subschema(
            {
              schema: h,
              dataTypes: [],
              schemaPath: Or.nil,
              topSchemaRef: m,
              errSchemaPath: n,
            },
            g,
          );
        e.mergeEvaluated(v), e.ok(g);
      }
    },
  };
function IR(e, t) {
  const { gen: n } = e;
  return t.validate
    ? n.scopeValue("validate", { ref: t.validate })
    : (0, Or._)`${n.scopeValue("wrapper", { ref: t })}.validate`;
}
Hs.getValidate = IR;
function Wf(e, t, n, r) {
  const { gen: i, it: a } = e,
    { allErrors: s, schemaEnv: o, opts: c } = a,
    l = c.passContext ? ho.default.this : Or.nil;
  r ? f() : u();
  function f() {
    if (!o.$async) throw new Error("async schema referenced by sync schema");
    const h = i.let("valid");
    i.try(
      () => {
        i.code((0, Or._)`await ${(0, Qx.callValidateCode)(e, t, l)}`),
          p(t),
          s || i.assign(h, !0);
      },
      (m) => {
        i.if((0, Or._)`!(${m} instanceof ${a.ValidationError})`, () =>
          i.throw(m),
        ),
          d(m),
          s || i.assign(h, !1);
      },
    ),
      e.ok(h);
  }
  function u() {
    e.result(
      (0, Qx.callValidateCode)(e, t, l),
      () => p(t),
      () => d(t),
    );
  }
  function d(h) {
    const m = (0, Or._)`${h}.errors`;
    i.assign(
      ho.default.vErrors,
      (0,
      Or._)`${ho.default.vErrors} === null ? ${m} : ${ho.default.vErrors}.concat(${m})`,
    ),
      i.assign(ho.default.errors, (0, Or._)`${ho.default.vErrors}.length`);
  }
  function p(h) {
    var m;
    if (!a.opts.unevaluated) return;
    const g =
      (m = n == null ? void 0 : n.validate) === null || m === void 0
        ? void 0
        : m.evaluated;
    if (a.props !== !0)
      if (g && !g.dynamicProps)
        g.props !== void 0 &&
          (a.props = Ef.mergeEvaluated.props(i, g.props, a.props));
      else {
        const v = i.var("props", (0, Or._)`${h}.evaluated.props`);
        a.props = Ef.mergeEvaluated.props(i, v, a.props, Or.Name);
      }
    if (a.items !== !0)
      if (g && !g.dynamicItems)
        g.items !== void 0 &&
          (a.items = Ef.mergeEvaluated.items(i, g.items, a.items));
      else {
        const v = i.var("items", (0, Or._)`${h}.evaluated.items`);
        a.items = Ef.mergeEvaluated.items(i, v, a.items, Or.Name);
      }
  }
}
Hs.callRef = Wf;
Hs.default = gV;
Object.defineProperty(ob, "__esModule", { value: !0 });
const vV = cb,
  yV = Hs,
  bV = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    vV.default,
    yV.default,
  ];
ob.default = bV;
var lb = {},
  ub = {};
Object.defineProperty(ub, "__esModule", { value: !0 });
const Sd = xt,
  xa = Sd.operators,
  Id = {
    maximum: { okStr: "<=", ok: xa.LTE, fail: xa.GT },
    minimum: { okStr: ">=", ok: xa.GTE, fail: xa.LT },
    exclusiveMaximum: { okStr: "<", ok: xa.LT, fail: xa.GTE },
    exclusiveMinimum: { okStr: ">", ok: xa.GT, fail: xa.LTE },
  },
  _V = {
    message: ({ keyword: e, schemaCode: t }) =>
      (0, Sd.str)`must be ${Id[e].okStr} ${t}`,
    params: ({ keyword: e, schemaCode: t }) =>
      (0, Sd._)`{comparison: ${Id[e].okStr}, limit: ${t}}`,
  },
  EV = {
    keyword: Object.keys(Id),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: _V,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e;
      e.fail$data((0, Sd._)`${n} ${Id[t].fail} ${r} || isNaN(${n})`);
    },
  };
ub.default = EV;
var fb = {};
Object.defineProperty(fb, "__esModule", { value: !0 });
const xl = xt,
  wV = {
    message: ({ schemaCode: e }) => (0, xl.str)`must be multiple of ${e}`,
    params: ({ schemaCode: e }) => (0, xl._)`{multipleOf: ${e}}`,
  },
  xV = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: wV,
    code(e) {
      const { gen: t, data: n, schemaCode: r, it: i } = e,
        a = i.opts.multipleOfPrecision,
        s = t.let("res"),
        o = a
          ? (0, xl._)`Math.abs(Math.round(${s}) - ${s}) > 1e-${a}`
          : (0, xl._)`${s} !== parseInt(${s})`;
      e.fail$data((0, xl._)`(${r} === 0 || (${s} = ${n}/${r}, ${o}))`);
    },
  };
fb.default = xV;
var db = {},
  pb = {};
Object.defineProperty(pb, "__esModule", { value: !0 });
function $R(e) {
  const t = e.length;
  let n = 0,
    r = 0,
    i;
  for (; r < t; )
    n++,
      (i = e.charCodeAt(r++)),
      i >= 55296 &&
        i <= 56319 &&
        r < t &&
        ((i = e.charCodeAt(r)), (i & 64512) === 56320 && r++);
  return n;
}
pb.default = $R;
$R.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(db, "__esModule", { value: !0 });
const ws = xt,
  AV = Ft,
  SV = pb,
  IV = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxLength" ? "more" : "fewer";
      return (0, ws.str)`must NOT have ${n} than ${t} characters`;
    },
    params: ({ schemaCode: e }) => (0, ws._)`{limit: ${e}}`,
  },
  $V = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: IV,
    code(e) {
      const { keyword: t, data: n, schemaCode: r, it: i } = e,
        a = t === "maxLength" ? ws.operators.GT : ws.operators.LT,
        s =
          i.opts.unicode === !1
            ? (0, ws._)`${n}.length`
            : (0, ws._)`${(0, AV.useFunc)(e.gen, SV.default)}(${n})`;
      e.fail$data((0, ws._)`${s} ${a} ${r}`);
    },
  };
db.default = $V;
var hb = {};
Object.defineProperty(hb, "__esModule", { value: !0 });
const CV = It,
  $d = xt,
  RV = {
    message: ({ schemaCode: e }) => (0, $d.str)`must match pattern "${e}"`,
    params: ({ schemaCode: e }) => (0, $d._)`{pattern: ${e}}`,
  },
  kV = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: RV,
    code(e) {
      const { data: t, $data: n, schema: r, schemaCode: i, it: a } = e,
        s = a.opts.unicodeRegExp ? "u" : "",
        o = n ? (0, $d._)`(new RegExp(${i}, ${s}))` : (0, CV.usePattern)(e, r);
      e.fail$data((0, $d._)`!${o}.test(${t})`);
    },
  };
hb.default = kV;
var mb = {};
Object.defineProperty(mb, "__esModule", { value: !0 });
const Al = xt,
  TV = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxProperties" ? "more" : "fewer";
      return (0, Al.str)`must NOT have ${n} than ${t} properties`;
    },
    params: ({ schemaCode: e }) => (0, Al._)`{limit: ${e}}`,
  },
  NV = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: TV,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e,
        i = t === "maxProperties" ? Al.operators.GT : Al.operators.LT;
      e.fail$data((0, Al._)`Object.keys(${n}).length ${i} ${r}`);
    },
  };
mb.default = NV;
var gb = {};
Object.defineProperty(gb, "__esModule", { value: !0 });
const Kc = It,
  Sl = xt,
  OV = Ft,
  PV = {
    message: ({ params: { missingProperty: e } }) =>
      (0, Sl.str)`must have required property '${e}'`,
    params: ({ params: { missingProperty: e } }) =>
      (0, Sl._)`{missingProperty: ${e}}`,
  },
  DV = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: PV,
    code(e) {
      const { gen: t, schema: n, schemaCode: r, data: i, $data: a, it: s } = e,
        { opts: o } = s;
      if (!a && n.length === 0) return;
      const c = n.length >= o.loopRequired;
      if ((s.allErrors ? l() : f(), o.strictRequired)) {
        const p = e.parentSchema.properties,
          { definedProperties: h } = e.it;
        for (const m of n)
          if ((p == null ? void 0 : p[m]) === void 0 && !h.has(m)) {
            const g = s.schemaEnv.baseId + s.errSchemaPath,
              v = `required property "${m}" is not defined at "${g}" (strictRequired)`;
            (0, OV.checkStrictMode)(s, v, s.opts.strictRequired);
          }
      }
      function l() {
        if (c || a) e.block$data(Sl.nil, u);
        else for (const p of n) (0, Kc.checkReportMissingProp)(e, p);
      }
      function f() {
        const p = t.let("missing");
        if (c || a) {
          const h = t.let("valid", !0);
          e.block$data(h, () => d(p, h)), e.ok(h);
        } else
          t.if((0, Kc.checkMissingProp)(e, n, p)),
            (0, Kc.reportMissingProp)(e, p),
            t.else();
      }
      function u() {
        t.forOf("prop", r, (p) => {
          e.setParams({ missingProperty: p }),
            t.if((0, Kc.noPropertyInData)(t, i, p, o.ownProperties), () =>
              e.error(),
            );
        });
      }
      function d(p, h) {
        e.setParams({ missingProperty: p }),
          t.forOf(
            p,
            r,
            () => {
              t.assign(h, (0, Kc.propertyInData)(t, i, p, o.ownProperties)),
                t.if((0, Sl.not)(h), () => {
                  e.error(), t.break();
                });
            },
            Sl.nil,
          );
      }
    },
  };
gb.default = DV;
var vb = {};
Object.defineProperty(vb, "__esModule", { value: !0 });
const Il = xt,
  LV = {
    message({ keyword: e, schemaCode: t }) {
      const n = e === "maxItems" ? "more" : "fewer";
      return (0, Il.str)`must NOT have ${n} than ${t} items`;
    },
    params: ({ schemaCode: e }) => (0, Il._)`{limit: ${e}}`,
  },
  BV = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: LV,
    code(e) {
      const { keyword: t, data: n, schemaCode: r } = e,
        i = t === "maxItems" ? Il.operators.GT : Il.operators.LT;
      e.fail$data((0, Il._)`${n}.length ${i} ${r}`);
    },
  };
vb.default = BV;
var yb = {},
  vu = {};
Object.defineProperty(vu, "__esModule", { value: !0 });
const CR = $p;
CR.code = 'require("ajv/dist/runtime/equal").default';
vu.default = CR;
Object.defineProperty(yb, "__esModule", { value: !0 });
const Dm = hu,
  Jn = xt,
  UV = Ft,
  FV = vu,
  jV = {
    message: ({ params: { i: e, j: t } }) =>
      (0,
      Jn.str)`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,
    params: ({ params: { i: e, j: t } }) => (0, Jn._)`{i: ${e}, j: ${t}}`,
  },
  MV = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: jV,
    code(e) {
      const {
        gen: t,
        data: n,
        $data: r,
        schema: i,
        parentSchema: a,
        schemaCode: s,
        it: o,
      } = e;
      if (!r && !i) return;
      const c = t.let("valid"),
        l = a.items ? (0, Dm.getSchemaTypes)(a.items) : [];
      e.block$data(c, f, (0, Jn._)`${s} === false`), e.ok(c);
      function f() {
        const h = t.let("i", (0, Jn._)`${n}.length`),
          m = t.let("j");
        e.setParams({ i: h, j: m }),
          t.assign(c, !0),
          t.if((0, Jn._)`${h} > 1`, () => (u() ? d : p)(h, m));
      }
      function u() {
        return l.length > 0 && !l.some((h) => h === "object" || h === "array");
      }
      function d(h, m) {
        const g = t.name("item"),
          v = (0, Dm.checkDataTypes)(
            l,
            g,
            o.opts.strictNumbers,
            Dm.DataType.Wrong,
          ),
          y = t.const("indices", (0, Jn._)`{}`);
        t.for((0, Jn._)`;${h}--;`, () => {
          t.let(g, (0, Jn._)`${n}[${h}]`),
            t.if(v, (0, Jn._)`continue`),
            l.length > 1 &&
              t.if((0, Jn._)`typeof ${g} == "string"`, (0, Jn._)`${g} += "_"`),
            t
              .if((0, Jn._)`typeof ${y}[${g}] == "number"`, () => {
                t.assign(m, (0, Jn._)`${y}[${g}]`),
                  e.error(),
                  t.assign(c, !1).break();
              })
              .code((0, Jn._)`${y}[${g}] = ${h}`);
        });
      }
      function p(h, m) {
        const g = (0, UV.useFunc)(t, FV.default),
          v = t.name("outer");
        t.label(v).for((0, Jn._)`;${h}--;`, () =>
          t.for((0, Jn._)`${m} = ${h}; ${m}--;`, () =>
            t.if((0, Jn._)`${g}(${n}[${h}], ${n}[${m}])`, () => {
              e.error(), t.assign(c, !1).break(v);
            }),
          ),
        );
      }
    },
  };
yb.default = MV;
var bb = {};
Object.defineProperty(bb, "__esModule", { value: !0 });
const R0 = xt,
  HV = Ft,
  qV = vu,
  GV = {
    message: "must be equal to constant",
    params: ({ schemaCode: e }) => (0, R0._)`{allowedValue: ${e}}`,
  },
  QV = {
    keyword: "const",
    $data: !0,
    error: GV,
    code(e) {
      const { gen: t, data: n, $data: r, schemaCode: i, schema: a } = e;
      r || (a && typeof a == "object")
        ? e.fail$data((0, R0._)`!${(0, HV.useFunc)(t, qV.default)}(${n}, ${i})`)
        : e.fail((0, R0._)`${a} !== ${n}`);
    },
  };
bb.default = QV;
var _b = {};
Object.defineProperty(_b, "__esModule", { value: !0 });
const al = xt,
  WV = Ft,
  zV = vu,
  KV = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode: e }) => (0, al._)`{allowedValues: ${e}}`,
  },
  VV = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: KV,
    code(e) {
      const { gen: t, data: n, $data: r, schema: i, schemaCode: a, it: s } = e;
      if (!r && i.length === 0)
        throw new Error("enum must have non-empty array");
      const o = i.length >= s.opts.loopEnum;
      let c;
      const l = () => c ?? (c = (0, WV.useFunc)(t, zV.default));
      let f;
      if (o || r) (f = t.let("valid")), e.block$data(f, u);
      else {
        if (!Array.isArray(i)) throw new Error("ajv implementation error");
        const p = t.const("vSchema", a);
        f = (0, al.or)(...i.map((h, m) => d(p, m)));
      }
      e.pass(f);
      function u() {
        t.assign(f, !1),
          t.forOf("v", a, (p) =>
            t.if((0, al._)`${l()}(${n}, ${p})`, () => t.assign(f, !0).break()),
          );
      }
      function d(p, h) {
        const m = i[h];
        return typeof m == "object" && m !== null
          ? (0, al._)`${l()}(${n}, ${p}[${h}])`
          : (0, al._)`${n} === ${m}`;
      }
    },
  };
_b.default = VV;
Object.defineProperty(lb, "__esModule", { value: !0 });
const YV = ub,
  XV = fb,
  JV = db,
  ZV = hb,
  eY = mb,
  tY = gb,
  nY = vb,
  rY = yb,
  iY = bb,
  aY = _b,
  sY = [
    YV.default,
    XV.default,
    JV.default,
    ZV.default,
    eY.default,
    tY.default,
    nY.default,
    rY.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    iY.default,
    aY.default,
  ];
lb.default = sY;
var Eb = {},
  Ic = {};
Object.defineProperty(Ic, "__esModule", { value: !0 });
Ic.validateAdditionalItems = void 0;
const xs = xt,
  k0 = Ft,
  oY = {
    message: ({ params: { len: e } }) =>
      (0, xs.str)`must NOT have more than ${e} items`,
    params: ({ params: { len: e } }) => (0, xs._)`{limit: ${e}}`,
  },
  cY = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: oY,
    code(e) {
      const { parentSchema: t, it: n } = e,
        { items: r } = t;
      if (!Array.isArray(r)) {
        (0, k0.checkStrictMode)(
          n,
          '"additionalItems" is ignored when "items" is not an array of schemas',
        );
        return;
      }
      RR(e, r);
    },
  };
function RR(e, t) {
  const { gen: n, schema: r, data: i, keyword: a, it: s } = e;
  s.items = !0;
  const o = n.const("len", (0, xs._)`${i}.length`);
  if (r === !1)
    e.setParams({ len: t.length }), e.pass((0, xs._)`${o} <= ${t.length}`);
  else if (typeof r == "object" && !(0, k0.alwaysValidSchema)(s, r)) {
    const l = n.var("valid", (0, xs._)`${o} <= ${t.length}`);
    n.if((0, xs.not)(l), () => c(l)), e.ok(l);
  }
  function c(l) {
    n.forRange("i", t.length, o, (f) => {
      e.subschema({ keyword: a, dataProp: f, dataPropType: k0.Type.Num }, l),
        s.allErrors || n.if((0, xs.not)(l), () => n.break());
    });
  }
}
Ic.validateAdditionalItems = RR;
Ic.default = cY;
var wb = {},
  $c = {};
Object.defineProperty($c, "__esModule", { value: !0 });
$c.validateTuple = void 0;
const zx = xt,
  zf = Ft,
  lY = It,
  uY = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(e) {
      const { schema: t, it: n } = e;
      if (Array.isArray(t)) return kR(e, "additionalItems", t);
      (n.items = !0),
        !(0, zf.alwaysValidSchema)(n, t) && e.ok((0, lY.validateArray)(e));
    },
  };
function kR(e, t, n = e.schema) {
  const { gen: r, parentSchema: i, data: a, keyword: s, it: o } = e;
  f(i),
    o.opts.unevaluated &&
      n.length &&
      o.items !== !0 &&
      (o.items = zf.mergeEvaluated.items(r, n.length, o.items));
  const c = r.name("valid"),
    l = r.const("len", (0, zx._)`${a}.length`);
  n.forEach((u, d) => {
    (0, zf.alwaysValidSchema)(o, u) ||
      (r.if((0, zx._)`${l} > ${d}`, () =>
        e.subschema({ keyword: s, schemaProp: d, dataProp: d }, c),
      ),
      e.ok(c));
  });
  function f(u) {
    const { opts: d, errSchemaPath: p } = o,
      h = n.length,
      m = h === u.minItems && (h === u.maxItems || u[t] === !1);
    if (d.strictTuples && !m) {
      const g = `"${s}" is ${h}-tuple, but minItems or maxItems/${t} are not specified or different at path "${p}"`;
      (0, zf.checkStrictMode)(o, g, d.strictTuples);
    }
  }
}
$c.validateTuple = kR;
$c.default = uY;
Object.defineProperty(wb, "__esModule", { value: !0 });
const fY = $c,
  dY = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (e) => (0, fY.validateTuple)(e, "items"),
  };
wb.default = dY;
var xb = {};
Object.defineProperty(xb, "__esModule", { value: !0 });
const Kx = xt,
  pY = Ft,
  hY = It,
  mY = Ic,
  gY = {
    message: ({ params: { len: e } }) =>
      (0, Kx.str)`must NOT have more than ${e} items`,
    params: ({ params: { len: e } }) => (0, Kx._)`{limit: ${e}}`,
  },
  vY = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: gY,
    code(e) {
      const { schema: t, parentSchema: n, it: r } = e,
        { prefixItems: i } = n;
      (r.items = !0),
        !(0, pY.alwaysValidSchema)(r, t) &&
          (i
            ? (0, mY.validateAdditionalItems)(e, i)
            : e.ok((0, hY.validateArray)(e)));
    },
  };
xb.default = vY;
var Ab = {};
Object.defineProperty(Ab, "__esModule", { value: !0 });
const Zr = xt,
  wf = Ft,
  yY = {
    message: ({ params: { min: e, max: t } }) =>
      t === void 0
        ? (0, Zr.str)`must contain at least ${e} valid item(s)`
        : (0,
          Zr.str)`must contain at least ${e} and no more than ${t} valid item(s)`,
    params: ({ params: { min: e, max: t } }) =>
      t === void 0
        ? (0, Zr._)`{minContains: ${e}}`
        : (0, Zr._)`{minContains: ${e}, maxContains: ${t}}`,
  },
  bY = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: yY,
    code(e) {
      const { gen: t, schema: n, parentSchema: r, data: i, it: a } = e;
      let s, o;
      const { minContains: c, maxContains: l } = r;
      a.opts.next ? ((s = c === void 0 ? 1 : c), (o = l)) : (s = 1);
      const f = t.const("len", (0, Zr._)`${i}.length`);
      if ((e.setParams({ min: s, max: o }), o === void 0 && s === 0)) {
        (0, wf.checkStrictMode)(
          a,
          '"minContains" == 0 without "maxContains": "contains" keyword ignored',
        );
        return;
      }
      if (o !== void 0 && s > o) {
        (0, wf.checkStrictMode)(
          a,
          '"minContains" > "maxContains" is always invalid',
        ),
          e.fail();
        return;
      }
      if ((0, wf.alwaysValidSchema)(a, n)) {
        let m = (0, Zr._)`${f} >= ${s}`;
        o !== void 0 && (m = (0, Zr._)`${m} && ${f} <= ${o}`), e.pass(m);
        return;
      }
      a.items = !0;
      const u = t.name("valid");
      o === void 0 && s === 1
        ? p(u, () => t.if(u, () => t.break()))
        : s === 0
        ? (t.let(u, !0), o !== void 0 && t.if((0, Zr._)`${i}.length > 0`, d))
        : (t.let(u, !1), d()),
        e.result(u, () => e.reset());
      function d() {
        const m = t.name("_valid"),
          g = t.let("count", 0);
        p(m, () => t.if(m, () => h(g)));
      }
      function p(m, g) {
        t.forRange("i", 0, f, (v) => {
          e.subschema(
            {
              keyword: "contains",
              dataProp: v,
              dataPropType: wf.Type.Num,
              compositeRule: !0,
            },
            m,
          ),
            g();
        });
      }
      function h(m) {
        t.code((0, Zr._)`${m}++`),
          o === void 0
            ? t.if((0, Zr._)`${m} >= ${s}`, () => t.assign(u, !0).break())
            : (t.if((0, Zr._)`${m} > ${o}`, () => t.assign(u, !1).break()),
              s === 1
                ? t.assign(u, !0)
                : t.if((0, Zr._)`${m} >= ${s}`, () => t.assign(u, !0)));
      }
    },
  };
Ab.default = bY;
var TR = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0);
  const t = xt,
    n = Ft,
    r = It;
  e.error = {
    message: ({ params: { property: c, depsCount: l, deps: f } }) => {
      const u = l === 1 ? "property" : "properties";
      return (0, t.str)`must have ${u} ${f} when property ${c} is present`;
    },
    params: ({
      params: { property: c, depsCount: l, deps: f, missingProperty: u },
    }) => (0, t._)`{property: ${c},
    missingProperty: ${u},
    depsCount: ${l},
    deps: ${f}}`,
  };
  const i = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: e.error,
    code(c) {
      const [l, f] = a(c);
      s(c, l), o(c, f);
    },
  };
  function a({ schema: c }) {
    const l = {},
      f = {};
    for (const u in c) {
      if (u === "__proto__") continue;
      const d = Array.isArray(c[u]) ? l : f;
      d[u] = c[u];
    }
    return [l, f];
  }
  function s(c, l = c.schema) {
    const { gen: f, data: u, it: d } = c;
    if (Object.keys(l).length === 0) return;
    const p = f.let("missing");
    for (const h in l) {
      const m = l[h];
      if (m.length === 0) continue;
      const g = (0, r.propertyInData)(f, u, h, d.opts.ownProperties);
      c.setParams({ property: h, depsCount: m.length, deps: m.join(", ") }),
        d.allErrors
          ? f.if(g, () => {
              for (const v of m) (0, r.checkReportMissingProp)(c, v);
            })
          : (f.if((0, t._)`${g} && (${(0, r.checkMissingProp)(c, m, p)})`),
            (0, r.reportMissingProp)(c, p),
            f.else());
    }
  }
  e.validatePropertyDeps = s;
  function o(c, l = c.schema) {
    const { gen: f, data: u, keyword: d, it: p } = c,
      h = f.name("valid");
    for (const m in l)
      (0, n.alwaysValidSchema)(p, l[m]) ||
        (f.if(
          (0, r.propertyInData)(f, u, m, p.opts.ownProperties),
          () => {
            const g = c.subschema({ keyword: d, schemaProp: m }, h);
            c.mergeValidEvaluated(g, h);
          },
          () => f.var(h, !0),
        ),
        c.ok(h));
  }
  (e.validateSchemaDeps = o), (e.default = i);
})(TR);
var Sb = {};
Object.defineProperty(Sb, "__esModule", { value: !0 });
const NR = xt,
  _Y = Ft,
  EY = {
    message: "property name must be valid",
    params: ({ params: e }) => (0, NR._)`{propertyName: ${e.propertyName}}`,
  },
  wY = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: EY,
    code(e) {
      const { gen: t, schema: n, data: r, it: i } = e;
      if ((0, _Y.alwaysValidSchema)(i, n)) return;
      const a = t.name("valid");
      t.forIn("key", r, (s) => {
        e.setParams({ propertyName: s }),
          e.subschema(
            {
              keyword: "propertyNames",
              data: s,
              dataTypes: ["string"],
              propertyName: s,
              compositeRule: !0,
            },
            a,
          ),
          t.if((0, NR.not)(a), () => {
            e.error(!0), i.allErrors || t.break();
          });
      }),
        e.ok(a);
    },
  };
Sb.default = wY;
var Pp = {};
Object.defineProperty(Pp, "__esModule", { value: !0 });
const xf = It,
  ci = xt,
  xY = zi,
  Af = Ft,
  AY = {
    message: "must NOT have additional properties",
    params: ({ params: e }) =>
      (0, ci._)`{additionalProperty: ${e.additionalProperty}}`,
  },
  SY = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: AY,
    code(e) {
      const {
        gen: t,
        schema: n,
        parentSchema: r,
        data: i,
        errsCount: a,
        it: s,
      } = e;
      if (!a) throw new Error("ajv implementation error");
      const { allErrors: o, opts: c } = s;
      if (
        ((s.props = !0),
        c.removeAdditional !== "all" && (0, Af.alwaysValidSchema)(s, n))
      )
        return;
      const l = (0, xf.allSchemaProperties)(r.properties),
        f = (0, xf.allSchemaProperties)(r.patternProperties);
      u(), e.ok((0, ci._)`${a} === ${xY.default.errors}`);
      function u() {
        t.forIn("key", i, (g) => {
          !l.length && !f.length ? h(g) : t.if(d(g), () => h(g));
        });
      }
      function d(g) {
        let v;
        if (l.length > 8) {
          const y = (0, Af.schemaRefOrVal)(s, r.properties, "properties");
          v = (0, xf.isOwnProperty)(t, y, g);
        } else
          l.length
            ? (v = (0, ci.or)(...l.map((y) => (0, ci._)`${g} === ${y}`)))
            : (v = ci.nil);
        return (
          f.length &&
            (v = (0, ci.or)(
              v,
              ...f.map(
                (y) => (0, ci._)`${(0, xf.usePattern)(e, y)}.test(${g})`,
              ),
            )),
          (0, ci.not)(v)
        );
      }
      function p(g) {
        t.code((0, ci._)`delete ${i}[${g}]`);
      }
      function h(g) {
        if (c.removeAdditional === "all" || (c.removeAdditional && n === !1)) {
          p(g);
          return;
        }
        if (n === !1) {
          e.setParams({ additionalProperty: g }), e.error(), o || t.break();
          return;
        }
        if (typeof n == "object" && !(0, Af.alwaysValidSchema)(s, n)) {
          const v = t.name("valid");
          c.removeAdditional === "failing"
            ? (m(g, v, !1),
              t.if((0, ci.not)(v), () => {
                e.reset(), p(g);
              }))
            : (m(g, v), o || t.if((0, ci.not)(v), () => t.break()));
        }
      }
      function m(g, v, y) {
        const _ = {
          keyword: "additionalProperties",
          dataProp: g,
          dataPropType: Af.Type.Str,
        };
        y === !1 &&
          Object.assign(_, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1,
          }),
          e.subschema(_, v);
      }
    },
  };
Pp.default = SY;
var Ib = {};
Object.defineProperty(Ib, "__esModule", { value: !0 });
const IY = bi,
  Vx = It,
  Lm = Ft,
  Yx = Pp,
  $Y = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(e) {
      const { gen: t, schema: n, parentSchema: r, data: i, it: a } = e;
      a.opts.removeAdditional === "all" &&
        r.additionalProperties === void 0 &&
        Yx.default.code(
          new IY.KeywordCxt(a, Yx.default, "additionalProperties"),
        );
      const s = (0, Vx.allSchemaProperties)(n);
      for (const u of s) a.definedProperties.add(u);
      a.opts.unevaluated &&
        s.length &&
        a.props !== !0 &&
        (a.props = Lm.mergeEvaluated.props(t, (0, Lm.toHash)(s), a.props));
      const o = s.filter((u) => !(0, Lm.alwaysValidSchema)(a, n[u]));
      if (o.length === 0) return;
      const c = t.name("valid");
      for (const u of o)
        l(u)
          ? f(u)
          : (t.if((0, Vx.propertyInData)(t, i, u, a.opts.ownProperties)),
            f(u),
            a.allErrors || t.else().var(c, !0),
            t.endIf()),
          e.it.definedProperties.add(u),
          e.ok(c);
      function l(u) {
        return (
          a.opts.useDefaults && !a.compositeRule && n[u].default !== void 0
        );
      }
      function f(u) {
        e.subschema({ keyword: "properties", schemaProp: u, dataProp: u }, c);
      }
    },
  };
Ib.default = $Y;
var $b = {};
Object.defineProperty($b, "__esModule", { value: !0 });
const Xx = It,
  Sf = xt,
  Jx = Ft,
  Zx = Ft,
  CY = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(e) {
      const { gen: t, schema: n, data: r, parentSchema: i, it: a } = e,
        { opts: s } = a,
        o = (0, Xx.allSchemaProperties)(n),
        c = o.filter((m) => (0, Jx.alwaysValidSchema)(a, n[m]));
      if (
        o.length === 0 ||
        (c.length === o.length && (!a.opts.unevaluated || a.props === !0))
      )
        return;
      const l = s.strictSchema && !s.allowMatchingProperties && i.properties,
        f = t.name("valid");
      a.props !== !0 &&
        !(a.props instanceof Sf.Name) &&
        (a.props = (0, Zx.evaluatedPropsToName)(t, a.props));
      const { props: u } = a;
      d();
      function d() {
        for (const m of o)
          l && p(m), a.allErrors ? h(m) : (t.var(f, !0), h(m), t.if(f));
      }
      function p(m) {
        for (const g in l)
          new RegExp(m).test(g) &&
            (0, Jx.checkStrictMode)(
              a,
              `property ${g} matches pattern ${m} (use allowMatchingProperties)`,
            );
      }
      function h(m) {
        t.forIn("key", r, (g) => {
          t.if((0, Sf._)`${(0, Xx.usePattern)(e, m)}.test(${g})`, () => {
            const v = c.includes(m);
            v ||
              e.subschema(
                {
                  keyword: "patternProperties",
                  schemaProp: m,
                  dataProp: g,
                  dataPropType: Zx.Type.Str,
                },
                f,
              ),
              a.opts.unevaluated && u !== !0
                ? t.assign((0, Sf._)`${u}[${g}]`, !0)
                : !v && !a.allErrors && t.if((0, Sf.not)(f), () => t.break());
          });
        });
      }
    },
  };
$b.default = CY;
var Cb = {};
Object.defineProperty(Cb, "__esModule", { value: !0 });
const RY = Ft,
  kY = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(e) {
      const { gen: t, schema: n, it: r } = e;
      if ((0, RY.alwaysValidSchema)(r, n)) {
        e.fail();
        return;
      }
      const i = t.name("valid");
      e.subschema(
        { keyword: "not", compositeRule: !0, createErrors: !1, allErrors: !1 },
        i,
      ),
        e.failResult(
          i,
          () => e.reset(),
          () => e.error(),
        );
    },
    error: { message: "must NOT be valid" },
  };
Cb.default = kY;
var Rb = {};
Object.defineProperty(Rb, "__esModule", { value: !0 });
const TY = It,
  NY = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: TY.validateUnion,
    error: { message: "must match a schema in anyOf" },
  };
Rb.default = NY;
var kb = {};
Object.defineProperty(kb, "__esModule", { value: !0 });
const Kf = xt,
  OY = Ft,
  PY = {
    message: "must match exactly one schema in oneOf",
    params: ({ params: e }) => (0, Kf._)`{passingSchemas: ${e.passing}}`,
  },
  DY = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: PY,
    code(e) {
      const { gen: t, schema: n, parentSchema: r, it: i } = e;
      if (!Array.isArray(n)) throw new Error("ajv implementation error");
      if (i.opts.discriminator && r.discriminator) return;
      const a = n,
        s = t.let("valid", !1),
        o = t.let("passing", null),
        c = t.name("_valid");
      e.setParams({ passing: o }),
        t.block(l),
        e.result(
          s,
          () => e.reset(),
          () => e.error(!0),
        );
      function l() {
        a.forEach((f, u) => {
          let d;
          (0, OY.alwaysValidSchema)(i, f)
            ? t.var(c, !0)
            : (d = e.subschema(
                { keyword: "oneOf", schemaProp: u, compositeRule: !0 },
                c,
              )),
            u > 0 &&
              t
                .if((0, Kf._)`${c} && ${s}`)
                .assign(s, !1)
                .assign(o, (0, Kf._)`[${o}, ${u}]`)
                .else(),
            t.if(c, () => {
              t.assign(s, !0),
                t.assign(o, u),
                d && e.mergeEvaluated(d, Kf.Name);
            });
        });
      }
    },
  };
kb.default = DY;
var Tb = {};
Object.defineProperty(Tb, "__esModule", { value: !0 });
const LY = Ft,
  BY = {
    keyword: "allOf",
    schemaType: "array",
    code(e) {
      const { gen: t, schema: n, it: r } = e;
      if (!Array.isArray(n)) throw new Error("ajv implementation error");
      const i = t.name("valid");
      n.forEach((a, s) => {
        if ((0, LY.alwaysValidSchema)(r, a)) return;
        const o = e.subschema({ keyword: "allOf", schemaProp: s }, i);
        e.ok(i), e.mergeEvaluated(o);
      });
    },
  };
Tb.default = BY;
var Nb = {};
Object.defineProperty(Nb, "__esModule", { value: !0 });
const Cd = xt,
  OR = Ft,
  UY = {
    message: ({ params: e }) => (0, Cd.str)`must match "${e.ifClause}" schema`,
    params: ({ params: e }) => (0, Cd._)`{failingKeyword: ${e.ifClause}}`,
  },
  FY = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: UY,
    code(e) {
      const { gen: t, parentSchema: n, it: r } = e;
      n.then === void 0 &&
        n.else === void 0 &&
        (0, OR.checkStrictMode)(r, '"if" without "then" and "else" is ignored');
      const i = eA(r, "then"),
        a = eA(r, "else");
      if (!i && !a) return;
      const s = t.let("valid", !0),
        o = t.name("_valid");
      if ((c(), e.reset(), i && a)) {
        const f = t.let("ifClause");
        e.setParams({ ifClause: f }), t.if(o, l("then", f), l("else", f));
      } else i ? t.if(o, l("then")) : t.if((0, Cd.not)(o), l("else"));
      e.pass(s, () => e.error(!0));
      function c() {
        const f = e.subschema(
          { keyword: "if", compositeRule: !0, createErrors: !1, allErrors: !1 },
          o,
        );
        e.mergeEvaluated(f);
      }
      function l(f, u) {
        return () => {
          const d = e.subschema({ keyword: f }, o);
          t.assign(s, o),
            e.mergeValidEvaluated(d, s),
            u ? t.assign(u, (0, Cd._)`${f}`) : e.setParams({ ifClause: f });
        };
      }
    },
  };
function eA(e, t) {
  const n = e.schema[t];
  return n !== void 0 && !(0, OR.alwaysValidSchema)(e, n);
}
Nb.default = FY;
var Ob = {};
Object.defineProperty(Ob, "__esModule", { value: !0 });
const jY = Ft,
  MY = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: e, parentSchema: t, it: n }) {
      t.if === void 0 &&
        (0, jY.checkStrictMode)(n, `"${e}" without "if" is ignored`);
    },
  };
Ob.default = MY;
Object.defineProperty(Eb, "__esModule", { value: !0 });
const HY = Ic,
  qY = wb,
  GY = $c,
  QY = xb,
  WY = Ab,
  zY = TR,
  KY = Sb,
  VY = Pp,
  YY = Ib,
  XY = $b,
  JY = Cb,
  ZY = Rb,
  eX = kb,
  tX = Tb,
  nX = Nb,
  rX = Ob;
function iX(e = !1) {
  const t = [
    JY.default,
    ZY.default,
    eX.default,
    tX.default,
    nX.default,
    rX.default,
    KY.default,
    VY.default,
    zY.default,
    YY.default,
    XY.default,
  ];
  return (
    e ? t.push(qY.default, QY.default) : t.push(HY.default, GY.default),
    t.push(WY.default),
    t
  );
}
Eb.default = iX;
var Pb = {},
  Db = {};
Object.defineProperty(Db, "__esModule", { value: !0 });
const Rn = xt,
  aX = {
    message: ({ schemaCode: e }) => (0, Rn.str)`must match format "${e}"`,
    params: ({ schemaCode: e }) => (0, Rn._)`{format: ${e}}`,
  },
  sX = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: aX,
    code(e, t) {
      const { gen: n, data: r, $data: i, schema: a, schemaCode: s, it: o } = e,
        { opts: c, errSchemaPath: l, schemaEnv: f, self: u } = o;
      if (!c.validateFormats) return;
      i ? d() : p();
      function d() {
        const h = n.scopeValue("formats", {
            ref: u.formats,
            code: c.code.formats,
          }),
          m = n.const("fDef", (0, Rn._)`${h}[${s}]`),
          g = n.let("fType"),
          v = n.let("format");
        n.if(
          (0, Rn._)`typeof ${m} == "object" && !(${m} instanceof RegExp)`,
          () =>
            n
              .assign(g, (0, Rn._)`${m}.type || "string"`)
              .assign(v, (0, Rn._)`${m}.validate`),
          () => n.assign(g, (0, Rn._)`"string"`).assign(v, m),
        ),
          e.fail$data((0, Rn.or)(y(), _()));
        function y() {
          return c.strictSchema === !1 ? Rn.nil : (0, Rn._)`${s} && !${v}`;
        }
        function _() {
          const E = f.$async
              ? (0, Rn._)`(${m}.async ? await ${v}(${r}) : ${v}(${r}))`
              : (0, Rn._)`${v}(${r})`,
            R = (0, Rn._)`(typeof ${v} == "function" ? ${E} : ${v}.test(${r}))`;
          return (0, Rn._)`${v} && ${v} !== true && ${g} === ${t} && !${R}`;
        }
      }
      function p() {
        const h = u.formats[a];
        if (!h) {
          y();
          return;
        }
        if (h === !0) return;
        const [m, g, v] = _(h);
        m === t && e.pass(E());
        function y() {
          if (c.strictSchema === !1) {
            u.logger.warn(R());
            return;
          }
          throw new Error(R());
          function R() {
            return `unknown format "${a}" ignored in schema at path "${l}"`;
          }
        }
        function _(R) {
          const A =
              R instanceof RegExp
                ? (0, Rn.regexpCode)(R)
                : c.code.formats
                ? (0, Rn._)`${c.code.formats}${(0, Rn.getProperty)(a)}`
                : void 0,
            I = n.scopeValue("formats", { key: a, ref: R, code: A });
          return typeof R == "object" && !(R instanceof RegExp)
            ? [R.type || "string", R.validate, (0, Rn._)`${I}.validate`]
            : ["string", R, I];
        }
        function E() {
          if (typeof h == "object" && !(h instanceof RegExp) && h.async) {
            if (!f.$async) throw new Error("async format in sync schema");
            return (0, Rn._)`await ${v}(${r})`;
          }
          return typeof g == "function"
            ? (0, Rn._)`${v}(${r})`
            : (0, Rn._)`${v}.test(${r})`;
        }
      }
    },
  };
Db.default = sX;
Object.defineProperty(Pb, "__esModule", { value: !0 });
const oX = Db,
  cX = [oX.default];
Pb.default = cX;
var cc = {};
Object.defineProperty(cc, "__esModule", { value: !0 });
cc.contentVocabulary = cc.metadataVocabulary = void 0;
cc.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples",
];
cc.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
Object.defineProperty(sb, "__esModule", { value: !0 });
const lX = ob,
  uX = lb,
  fX = Eb,
  dX = Pb,
  tA = cc,
  pX = [
    lX.default,
    uX.default,
    (0, fX.default)(),
    dX.default,
    tA.metadataVocabulary,
    tA.contentVocabulary,
  ];
sb.default = pX;
var Lb = {},
  PR = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.DiscrError = void 0),
    (function (t) {
      (t.Tag = "tag"), (t.Mapping = "mapping");
    })(e.DiscrError || (e.DiscrError = {}));
})(PR);
Object.defineProperty(Lb, "__esModule", { value: !0 });
const So = xt,
  T0 = PR,
  nA = Lr,
  hX = Ft,
  mX = {
    message: ({ params: { discrError: e, tagName: t } }) =>
      e === T0.DiscrError.Tag
        ? `tag "${t}" must be string`
        : `value of tag "${t}" must be in oneOf`,
    params: ({ params: { discrError: e, tag: t, tagName: n } }) =>
      (0, So._)`{error: ${e}, tag: ${n}, tagValue: ${t}}`,
  },
  gX = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: mX,
    code(e) {
      const { gen: t, data: n, schema: r, parentSchema: i, it: a } = e,
        { oneOf: s } = i;
      if (!a.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const o = r.propertyName;
      if (typeof o != "string")
        throw new Error("discriminator: requires propertyName");
      if (r.mapping) throw new Error("discriminator: mapping is not supported");
      if (!s) throw new Error("discriminator: requires oneOf keyword");
      const c = t.let("valid", !1),
        l = t.const("tag", (0, So._)`${n}${(0, So.getProperty)(o)}`);
      t.if(
        (0, So._)`typeof ${l} == "string"`,
        () => f(),
        () =>
          e.error(!1, { discrError: T0.DiscrError.Tag, tag: l, tagName: o }),
      ),
        e.ok(c);
      function f() {
        const p = d();
        t.if(!1);
        for (const h in p)
          t.elseIf((0, So._)`${l} === ${h}`), t.assign(c, u(p[h]));
        t.else(),
          e.error(!1, {
            discrError: T0.DiscrError.Mapping,
            tag: l,
            tagName: o,
          }),
          t.endIf();
      }
      function u(p) {
        const h = t.name("valid"),
          m = e.subschema({ keyword: "oneOf", schemaProp: p }, h);
        return e.mergeEvaluated(m, So.Name), h;
      }
      function d() {
        var p;
        const h = {},
          m = v(i);
        let g = !0;
        for (let E = 0; E < s.length; E++) {
          let R = s[E];
          R != null &&
            R.$ref &&
            !(0, hX.schemaHasRulesButRef)(R, a.self.RULES) &&
            ((R = nA.resolveRef.call(
              a.self,
              a.schemaEnv.root,
              a.baseId,
              R == null ? void 0 : R.$ref,
            )),
            R instanceof nA.SchemaEnv && (R = R.schema));
          const A =
            (p = R == null ? void 0 : R.properties) === null || p === void 0
              ? void 0
              : p[o];
          if (typeof A != "object")
            throw new Error(
              `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${o}"`,
            );
          (g = g && (m || v(R))), y(A, E);
        }
        if (!g) throw new Error(`discriminator: "${o}" must be required`);
        return h;
        function v({ required: E }) {
          return Array.isArray(E) && E.includes(o);
        }
        function y(E, R) {
          if (E.const) _(E.const, R);
          else if (E.enum) for (const A of E.enum) _(A, R);
          else
            throw new Error(
              `discriminator: "properties/${o}" must have "const" or "enum"`,
            );
        }
        function _(E, R) {
          if (typeof E != "string" || E in h)
            throw new Error(
              `discriminator: "${o}" values must be unique strings`,
            );
          h[E] = R;
        }
      }
    },
  };
Lb.default = gX;
const vX = "http://json-schema.org/draft-07/schema#",
  yX = "http://json-schema.org/draft-07/schema#",
  bX = "Core schema meta-schema",
  _X = {
    schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } },
    nonNegativeInteger: { type: "integer", minimum: 0 },
    nonNegativeIntegerDefault0: {
      allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }],
    },
    simpleTypes: {
      enum: [
        "array",
        "boolean",
        "integer",
        "null",
        "number",
        "object",
        "string",
      ],
    },
    stringArray: {
      type: "array",
      items: { type: "string" },
      uniqueItems: !0,
      default: [],
    },
  },
  EX = ["object", "boolean"],
  wX = {
    $id: { type: "string", format: "uri-reference" },
    $schema: { type: "string", format: "uri" },
    $ref: { type: "string", format: "uri-reference" },
    $comment: { type: "string" },
    title: { type: "string" },
    description: { type: "string" },
    default: !0,
    readOnly: { type: "boolean", default: !1 },
    examples: { type: "array", items: !0 },
    multipleOf: { type: "number", exclusiveMinimum: 0 },
    maximum: { type: "number" },
    exclusiveMaximum: { type: "number" },
    minimum: { type: "number" },
    exclusiveMinimum: { type: "number" },
    maxLength: { $ref: "#/definitions/nonNegativeInteger" },
    minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    pattern: { type: "string", format: "regex" },
    additionalItems: { $ref: "#" },
    items: {
      anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
      default: !0,
    },
    maxItems: { $ref: "#/definitions/nonNegativeInteger" },
    minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    uniqueItems: { type: "boolean", default: !1 },
    contains: { $ref: "#" },
    maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
    minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
    required: { $ref: "#/definitions/stringArray" },
    additionalProperties: { $ref: "#" },
    definitions: {
      type: "object",
      additionalProperties: { $ref: "#" },
      default: {},
    },
    properties: {
      type: "object",
      additionalProperties: { $ref: "#" },
      default: {},
    },
    patternProperties: {
      type: "object",
      additionalProperties: { $ref: "#" },
      propertyNames: { format: "regex" },
      default: {},
    },
    dependencies: {
      type: "object",
      additionalProperties: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }],
      },
    },
    propertyNames: { $ref: "#" },
    const: !0,
    enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 },
    type: {
      anyOf: [
        { $ref: "#/definitions/simpleTypes" },
        {
          type: "array",
          items: { $ref: "#/definitions/simpleTypes" },
          minItems: 1,
          uniqueItems: !0,
        },
      ],
    },
    format: { type: "string" },
    contentMediaType: { type: "string" },
    contentEncoding: { type: "string" },
    if: { $ref: "#" },
    then: { $ref: "#" },
    else: { $ref: "#" },
    allOf: { $ref: "#/definitions/schemaArray" },
    anyOf: { $ref: "#/definitions/schemaArray" },
    oneOf: { $ref: "#/definitions/schemaArray" },
    not: { $ref: "#" },
  },
  xX = {
    $schema: vX,
    $id: yX,
    title: bX,
    definitions: _X,
    type: EX,
    properties: wX,
    default: !0,
  };
(function (e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.MissingRefError =
      t.ValidationError =
      t.CodeGen =
      t.Name =
      t.nil =
      t.stringify =
      t.str =
      t._ =
      t.KeywordCxt =
        void 0);
  const n = tR,
    r = sb,
    i = Lb,
    a = xX,
    s = ["/properties"],
    o = "http://json-schema.org/draft-07/schema";
  class c extends n.default {
    _addVocabularies() {
      super._addVocabularies(),
        r.default.forEach((h) => this.addVocabulary(h)),
        this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      if ((super._addDefaultMetaSchema(), !this.opts.meta)) return;
      const h = this.opts.$data ? this.$dataMetaSchema(a, s) : a;
      this.addMetaSchema(h, o, !1),
        (this.refs["http://json-schema.org/schema"] = o);
    }
    defaultMeta() {
      return (this.opts.defaultMeta =
        super.defaultMeta() || (this.getSchema(o) ? o : void 0));
    }
  }
  (e.exports = t = c),
    Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.default = c);
  var l = bi;
  Object.defineProperty(t, "KeywordCxt", {
    enumerable: !0,
    get: function () {
      return l.KeywordCxt;
    },
  });
  var f = xt;
  Object.defineProperty(t, "_", {
    enumerable: !0,
    get: function () {
      return f._;
    },
  }),
    Object.defineProperty(t, "str", {
      enumerable: !0,
      get: function () {
        return f.str;
      },
    }),
    Object.defineProperty(t, "stringify", {
      enumerable: !0,
      get: function () {
        return f.stringify;
      },
    }),
    Object.defineProperty(t, "nil", {
      enumerable: !0,
      get: function () {
        return f.nil;
      },
    }),
    Object.defineProperty(t, "Name", {
      enumerable: !0,
      get: function () {
        return f.Name;
      },
    }),
    Object.defineProperty(t, "CodeGen", {
      enumerable: !0,
      get: function () {
        return f.CodeGen;
      },
    });
  var u = mu;
  Object.defineProperty(t, "ValidationError", {
    enumerable: !0,
    get: function () {
      return u.default;
    },
  });
  var d = gu;
  Object.defineProperty(t, "MissingRefError", {
    enumerable: !0,
    get: function () {
      return d.default;
    },
  });
})(I0, I0.exports);
var AX = I0.exports;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.formatLimitDefinition = void 0);
  const t = AX,
    n = xt,
    r = n.operators,
    i = {
      formatMaximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
      formatMinimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
      formatExclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE },
    },
    a = {
      message: ({ keyword: o, schemaCode: c }) =>
        n.str`should be ${i[o].okStr} ${c}`,
      params: ({ keyword: o, schemaCode: c }) =>
        n._`{comparison: ${i[o].okStr}, limit: ${c}}`,
    };
  e.formatLimitDefinition = {
    keyword: Object.keys(i),
    type: "string",
    schemaType: "string",
    $data: !0,
    error: a,
    code(o) {
      const { gen: c, data: l, schemaCode: f, keyword: u, it: d } = o,
        { opts: p, self: h } = d;
      if (!p.validateFormats) return;
      const m = new t.KeywordCxt(d, h.RULES.all.format.definition, "format");
      m.$data ? g() : v();
      function g() {
        const _ = c.scopeValue("formats", {
            ref: h.formats,
            code: p.code.formats,
          }),
          E = c.const("fmt", n._`${_}[${m.schemaCode}]`);
        o.fail$data(
          n.or(
            n._`typeof ${E} != "object"`,
            n._`${E} instanceof RegExp`,
            n._`typeof ${E}.compare != "function"`,
            y(E),
          ),
        );
      }
      function v() {
        const _ = m.schema,
          E = h.formats[_];
        if (!E || E === !0) return;
        if (
          typeof E != "object" ||
          E instanceof RegExp ||
          typeof E.compare != "function"
        )
          throw new Error(
            `"${u}": format "${_}" does not define "compare" function`,
          );
        const R = c.scopeValue("formats", {
          key: _,
          ref: E,
          code: p.code.formats
            ? n._`${p.code.formats}${n.getProperty(_)}`
            : void 0,
        });
        o.fail$data(y(R));
      }
      function y(_) {
        return n._`${_}.compare(${l}, ${f}) ${i[u].fail} 0`;
      }
    },
    dependencies: ["format"],
  };
  const s = (o) => (o.addKeyword(e.formatLimitDefinition), o);
  e.default = s;
})(eR);
(function (e, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const n = Z4,
    r = eR,
    i = xt,
    a = new i.Name("fullFormats"),
    s = new i.Name("fastFormats"),
    o = (l, f = { keywords: !0 }) => {
      if (Array.isArray(f)) return c(l, f, n.fullFormats, a), l;
      const [u, d] =
          f.mode === "fast" ? [n.fastFormats, s] : [n.fullFormats, a],
        p = f.formats || n.formatNames;
      return c(l, p, u, d), f.keywords && r.default(l), l;
    };
  o.get = (l, f = "full") => {
    const d = (f === "fast" ? n.fastFormats : n.fullFormats)[l];
    if (!d) throw new Error(`Unknown format "${l}"`);
    return d;
  };
  function c(l, f, u, d) {
    var p, h;
    ((p = (h = l.opts.code).formats) !== null && p !== void 0) ||
      (h.formats = i._`require("ajv-formats/dist/formats").${d}`);
    for (const m of f) l.addFormat(m, u[m]);
  }
  (e.exports = t = o),
    Object.defineProperty(t, "__esModule", { value: !0 }),
    (t.default = o);
})(S0, S0.exports);
var SX = S0.exports;
const IX = (e, t, n, r) => {
    if (
      n === "length" ||
      n === "prototype" ||
      n === "arguments" ||
      n === "caller"
    )
      return;
    const i = Object.getOwnPropertyDescriptor(e, n),
      a = Object.getOwnPropertyDescriptor(t, n);
    (!$X(i, a) && r) || Object.defineProperty(e, n, a);
  },
  $X = function (e, t) {
    return (
      e === void 0 ||
      e.configurable ||
      (e.writable === t.writable &&
        e.enumerable === t.enumerable &&
        e.configurable === t.configurable &&
        (e.writable || e.value === t.value))
    );
  },
  CX = (e, t) => {
    const n = Object.getPrototypeOf(t);
    n !== Object.getPrototypeOf(e) && Object.setPrototypeOf(e, n);
  },
  RX = (e, t) => `/* Wrapped ${e}*/
${t}`,
  kX = Object.getOwnPropertyDescriptor(Function.prototype, "toString"),
  TX = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name"),
  NX = (e, t, n) => {
    const r = n === "" ? "" : `with ${n.trim()}() `,
      i = RX.bind(null, r, t.toString());
    Object.defineProperty(i, "name", TX),
      Object.defineProperty(e, "toString", { ...kX, value: i });
  },
  OX = (e, t, { ignoreNonConfigurable: n = !1 } = {}) => {
    const { name: r } = e;
    for (const i of Reflect.ownKeys(t)) IX(e, t, i, n);
    return CX(e, t), NX(e, t, r), e;
  };
var PX = OX;
const DX = PX;
var LX = (e, t = {}) => {
    if (typeof e != "function")
      throw new TypeError(
        `Expected the first argument to be a function, got \`${typeof e}\``,
      );
    const { wait: n = 0, before: r = !1, after: i = !0 } = t;
    if (!r && !i)
      throw new Error(
        "Both `before` and `after` are false, function wouldn't be called.",
      );
    let a, s;
    const o = function (...c) {
      const l = this,
        f = () => {
          (a = void 0), i && (s = e.apply(l, c));
        },
        u = r && !a;
      return (
        clearTimeout(a), (a = setTimeout(f, n)), u && (s = e.apply(l, c)), s
      );
    };
    return (
      DX(o, e),
      (o.cancel = () => {
        a && (clearTimeout(a), (a = void 0));
      }),
      o
    );
  },
  N0 = { exports: {} };
const BX = "2.0.0",
  DR = 256,
  UX = Number.MAX_SAFE_INTEGER || 9007199254740991,
  FX = 16,
  jX = DR - 6,
  MX = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease",
  ];
var Dp = {
  MAX_LENGTH: DR,
  MAX_SAFE_COMPONENT_LENGTH: FX,
  MAX_SAFE_BUILD_LENGTH: jX,
  MAX_SAFE_INTEGER: UX,
  RELEASE_TYPES: MX,
  SEMVER_SPEC_VERSION: BX,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2,
};
const HX =
  typeof process == "object" &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
    ? (...e) => console.error("SEMVER", ...e)
    : () => {};
var Lp = HX;
(function (e, t) {
  const {
      MAX_SAFE_COMPONENT_LENGTH: n,
      MAX_SAFE_BUILD_LENGTH: r,
      MAX_LENGTH: i,
    } = Dp,
    a = Lp;
  t = e.exports = {};
  const s = (t.re = []),
    o = (t.safeRe = []),
    c = (t.src = []),
    l = (t.t = {});
  let f = 0;
  const u = "[a-zA-Z0-9-]",
    d = [
      ["\\s", 1],
      ["\\d", i],
      [u, r],
    ],
    p = (m) => {
      for (const [g, v] of d)
        m = m
          .split(`${g}*`)
          .join(`${g}{0,${v}}`)
          .split(`${g}+`)
          .join(`${g}{1,${v}}`);
      return m;
    },
    h = (m, g, v) => {
      const y = p(g),
        _ = f++;
      a(m, _, g),
        (l[m] = _),
        (c[_] = g),
        (s[_] = new RegExp(g, v ? "g" : void 0)),
        (o[_] = new RegExp(y, v ? "g" : void 0));
    };
  h("NUMERICIDENTIFIER", "0|[1-9]\\d*"),
    h("NUMERICIDENTIFIERLOOSE", "\\d+"),
    h("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${u}*`),
    h(
      "MAINVERSION",
      `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${
        c[l.NUMERICIDENTIFIER]
      })`,
    ),
    h(
      "MAINVERSIONLOOSE",
      `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${
        c[l.NUMERICIDENTIFIERLOOSE]
      })`,
    ),
    h(
      "PRERELEASEIDENTIFIER",
      `(?:${c[l.NUMERICIDENTIFIER]}|${c[l.NONNUMERICIDENTIFIER]})`,
    ),
    h(
      "PRERELEASEIDENTIFIERLOOSE",
      `(?:${c[l.NUMERICIDENTIFIERLOOSE]}|${c[l.NONNUMERICIDENTIFIER]})`,
    ),
    h(
      "PRERELEASE",
      `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`,
    ),
    h(
      "PRERELEASELOOSE",
      `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${
        c[l.PRERELEASEIDENTIFIERLOOSE]
      })*))`,
    ),
    h("BUILDIDENTIFIER", `${u}+`),
    h(
      "BUILD",
      `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`,
    ),
    h("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`),
    h("FULL", `^${c[l.FULLPLAIN]}$`),
    h(
      "LOOSEPLAIN",
      `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`,
    ),
    h("LOOSE", `^${c[l.LOOSEPLAIN]}$`),
    h("GTLT", "((?:<|>)?=?)"),
    h("XRANGEIDENTIFIERLOOSE", `${c[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
    h("XRANGEIDENTIFIER", `${c[l.NUMERICIDENTIFIER]}|x|X|\\*`),
    h(
      "XRANGEPLAIN",
      `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${
        c[l.XRANGEIDENTIFIER]
      })(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${
        c[l.BUILD]
      }?)?)?`,
    ),
    h(
      "XRANGEPLAINLOOSE",
      `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${
        c[l.XRANGEIDENTIFIERLOOSE]
      })(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${
        c[l.BUILD]
      }?)?)?`,
    ),
    h("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`),
    h("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`),
    h(
      "COERCE",
      `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`,
    ),
    h("COERCERTL", c[l.COERCE], !0),
    h("LONETILDE", "(?:~>?)"),
    h("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0),
    (t.tildeTrimReplace = "$1~"),
    h("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`),
    h("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`),
    h("LONECARET", "(?:\\^)"),
    h("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0),
    (t.caretTrimReplace = "$1^"),
    h("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`),
    h("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`),
    h("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`),
    h("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`),
    h(
      "COMPARATORTRIM",
      `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`,
      !0,
    ),
    (t.comparatorTrimReplace = "$1$2$3"),
    h(
      "HYPHENRANGE",
      `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`,
    ),
    h(
      "HYPHENRANGELOOSE",
      `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`,
    ),
    h("STAR", "(<|>)?=?\\s*\\*"),
    h("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"),
    h("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(N0, N0.exports);
var yu = N0.exports;
const qX = Object.freeze({ loose: !0 }),
  GX = Object.freeze({}),
  QX = (e) => (e ? (typeof e != "object" ? qX : e) : GX);
var Bb = QX;
const rA = /^[0-9]+$/,
  LR = (e, t) => {
    const n = rA.test(e),
      r = rA.test(t);
    return (
      n && r && ((e = +e), (t = +t)),
      e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1
    );
  },
  WX = (e, t) => LR(t, e);
var BR = { compareIdentifiers: LR, rcompareIdentifiers: WX };
const If = Lp,
  { MAX_LENGTH: iA, MAX_SAFE_INTEGER: $f } = Dp,
  { safeRe: aA, t: sA } = yu,
  zX = Bb,
  { compareIdentifiers: mo } = BR;
let KX = class Ti {
  constructor(t, n) {
    if (((n = zX(n)), t instanceof Ti)) {
      if (
        t.loose === !!n.loose &&
        t.includePrerelease === !!n.includePrerelease
      )
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(
        `Invalid version. Must be a string. Got type "${typeof t}".`,
      );
    if (t.length > iA)
      throw new TypeError(`version is longer than ${iA} characters`);
    If("SemVer", t, n),
      (this.options = n),
      (this.loose = !!n.loose),
      (this.includePrerelease = !!n.includePrerelease);
    const r = t.trim().match(n.loose ? aA[sA.LOOSE] : aA[sA.FULL]);
    if (!r) throw new TypeError(`Invalid Version: ${t}`);
    if (
      ((this.raw = t),
      (this.major = +r[1]),
      (this.minor = +r[2]),
      (this.patch = +r[3]),
      this.major > $f || this.major < 0)
    )
      throw new TypeError("Invalid major version");
    if (this.minor > $f || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > $f || this.patch < 0)
      throw new TypeError("Invalid patch version");
    r[4]
      ? (this.prerelease = r[4].split(".").map((i) => {
          if (/^[0-9]+$/.test(i)) {
            const a = +i;
            if (a >= 0 && a < $f) return a;
          }
          return i;
        }))
      : (this.prerelease = []),
      (this.build = r[5] ? r[5].split(".") : []),
      this.format();
  }
  format() {
    return (
      (this.version = `${this.major}.${this.minor}.${this.patch}`),
      this.prerelease.length &&
        (this.version += `-${this.prerelease.join(".")}`),
      this.version
    );
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (
      (If("SemVer.compare", this.version, this.options, t), !(t instanceof Ti))
    ) {
      if (typeof t == "string" && t === this.version) return 0;
      t = new Ti(t, this.options);
    }
    return t.version === this.version
      ? 0
      : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return (
      t instanceof Ti || (t = new Ti(t, this.options)),
      mo(this.major, t.major) ||
        mo(this.minor, t.minor) ||
        mo(this.patch, t.patch)
    );
  }
  comparePre(t) {
    if (
      (t instanceof Ti || (t = new Ti(t, this.options)),
      this.prerelease.length && !t.prerelease.length)
    )
      return -1;
    if (!this.prerelease.length && t.prerelease.length) return 1;
    if (!this.prerelease.length && !t.prerelease.length) return 0;
    let n = 0;
    do {
      const r = this.prerelease[n],
        i = t.prerelease[n];
      if ((If("prerelease compare", n, r, i), r === void 0 && i === void 0))
        return 0;
      if (i === void 0) return 1;
      if (r === void 0) return -1;
      if (r === i) continue;
      return mo(r, i);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof Ti || (t = new Ti(t, this.options));
    let n = 0;
    do {
      const r = this.build[n],
        i = t.build[n];
      if ((If("prerelease compare", n, r, i), r === void 0 && i === void 0))
        return 0;
      if (i === void 0) return 1;
      if (r === void 0) return -1;
      if (r === i) continue;
      return mo(r, i);
    } while (++n);
  }
  inc(t, n, r) {
    switch (t) {
      case "premajor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          (this.minor = 0),
          this.major++,
          this.inc("pre", n, r);
        break;
      case "preminor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          this.minor++,
          this.inc("pre", n, r);
        break;
      case "prepatch":
        (this.prerelease.length = 0),
          this.inc("patch", n, r),
          this.inc("pre", n, r);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n, r),
          this.inc("pre", n, r);
        break;
      case "major":
        (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) &&
          this.major++,
          (this.minor = 0),
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++,
          (this.patch = 0),
          (this.prerelease = []);
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, (this.prerelease = []);
        break;
      case "pre": {
        const i = Number(r) ? 1 : 0;
        if (!n && r === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0) this.prerelease = [i];
        else {
          let a = this.prerelease.length;
          for (; --a >= 0; )
            typeof this.prerelease[a] == "number" &&
              (this.prerelease[a]++, (a = -2));
          if (a === -1) {
            if (n === this.prerelease.join(".") && r === !1)
              throw new Error(
                "invalid increment argument: identifier already exists",
              );
            this.prerelease.push(i);
          }
        }
        if (n) {
          let a = [n, i];
          r === !1 && (a = [n]),
            mo(this.prerelease[0], n) === 0
              ? isNaN(this.prerelease[1]) && (this.prerelease = a)
              : (this.prerelease = a);
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return (
      (this.raw = this.format()),
      this.build.length && (this.raw += `+${this.build.join(".")}`),
      this
    );
  }
};
var $r = KX;
const oA = $r,
  VX = (e, t, n = !1) => {
    if (e instanceof oA) return e;
    try {
      return new oA(e, t);
    } catch (r) {
      if (!n) return null;
      throw r;
    }
  };
var Cc = VX;
const YX = Cc,
  XX = (e, t) => {
    const n = YX(e, t);
    return n ? n.version : null;
  };
var JX = XX;
const ZX = Cc,
  eJ = (e, t) => {
    const n = ZX(e.trim().replace(/^[=v]+/, ""), t);
    return n ? n.version : null;
  };
var tJ = eJ;
const cA = $r,
  nJ = (e, t, n, r, i) => {
    typeof n == "string" && ((i = r), (r = n), (n = void 0));
    try {
      return new cA(e instanceof cA ? e.version : e, n).inc(t, r, i).version;
    } catch {
      return null;
    }
  };
var rJ = nJ;
const lA = Cc,
  iJ = (e, t) => {
    const n = lA(e, null, !0),
      r = lA(t, null, !0),
      i = n.compare(r);
    if (i === 0) return null;
    const a = i > 0,
      s = a ? n : r,
      o = a ? r : n,
      c = !!s.prerelease.length;
    if (!!o.prerelease.length && !c)
      return !o.patch && !o.minor
        ? "major"
        : s.patch
        ? "patch"
        : s.minor
        ? "minor"
        : "major";
    const f = c ? "pre" : "";
    return n.major !== r.major
      ? f + "major"
      : n.minor !== r.minor
      ? f + "minor"
      : n.patch !== r.patch
      ? f + "patch"
      : "prerelease";
  };
var aJ = iJ;
const sJ = $r,
  oJ = (e, t) => new sJ(e, t).major;
var cJ = oJ;
const lJ = $r,
  uJ = (e, t) => new lJ(e, t).minor;
var fJ = uJ;
const dJ = $r,
  pJ = (e, t) => new dJ(e, t).patch;
var hJ = pJ;
const mJ = Cc,
  gJ = (e, t) => {
    const n = mJ(e, t);
    return n && n.prerelease.length ? n.prerelease : null;
  };
var vJ = gJ;
const uA = $r,
  yJ = (e, t, n) => new uA(e, n).compare(new uA(t, n));
var $i = yJ;
const bJ = $i,
  _J = (e, t, n) => bJ(t, e, n);
var EJ = _J;
const wJ = $i,
  xJ = (e, t) => wJ(e, t, !0);
var AJ = xJ;
const fA = $r,
  SJ = (e, t, n) => {
    const r = new fA(e, n),
      i = new fA(t, n);
    return r.compare(i) || r.compareBuild(i);
  };
var Ub = SJ;
const IJ = Ub,
  $J = (e, t) => e.sort((n, r) => IJ(n, r, t));
var CJ = $J;
const RJ = Ub,
  kJ = (e, t) => e.sort((n, r) => RJ(r, n, t));
var TJ = kJ;
const NJ = $i,
  OJ = (e, t, n) => NJ(e, t, n) > 0;
var Bp = OJ;
const PJ = $i,
  DJ = (e, t, n) => PJ(e, t, n) < 0;
var Fb = DJ;
const LJ = $i,
  BJ = (e, t, n) => LJ(e, t, n) === 0;
var UR = BJ;
const UJ = $i,
  FJ = (e, t, n) => UJ(e, t, n) !== 0;
var FR = FJ;
const jJ = $i,
  MJ = (e, t, n) => jJ(e, t, n) >= 0;
var jb = MJ;
const HJ = $i,
  qJ = (e, t, n) => HJ(e, t, n) <= 0;
var Mb = qJ;
const GJ = UR,
  QJ = FR,
  WJ = Bp,
  zJ = jb,
  KJ = Fb,
  VJ = Mb,
  YJ = (e, t, n, r) => {
    switch (t) {
      case "===":
        return (
          typeof e == "object" && (e = e.version),
          typeof n == "object" && (n = n.version),
          e === n
        );
      case "!==":
        return (
          typeof e == "object" && (e = e.version),
          typeof n == "object" && (n = n.version),
          e !== n
        );
      case "":
      case "=":
      case "==":
        return GJ(e, n, r);
      case "!=":
        return QJ(e, n, r);
      case ">":
        return WJ(e, n, r);
      case ">=":
        return zJ(e, n, r);
      case "<":
        return KJ(e, n, r);
      case "<=":
        return VJ(e, n, r);
      default:
        throw new TypeError(`Invalid operator: ${t}`);
    }
  };
var jR = YJ;
const XJ = $r,
  JJ = Cc,
  { safeRe: Cf, t: Rf } = yu,
  ZJ = (e, t) => {
    if (e instanceof XJ) return e;
    if ((typeof e == "number" && (e = String(e)), typeof e != "string"))
      return null;
    t = t || {};
    let n = null;
    if (!t.rtl) n = e.match(Cf[Rf.COERCE]);
    else {
      let r;
      for (
        ;
        (r = Cf[Rf.COERCERTL].exec(e)) &&
        (!n || n.index + n[0].length !== e.length);

      )
        (!n || r.index + r[0].length !== n.index + n[0].length) && (n = r),
          (Cf[Rf.COERCERTL].lastIndex = r.index + r[1].length + r[2].length);
      Cf[Rf.COERCERTL].lastIndex = -1;
    }
    return n === null ? null : JJ(`${n[2]}.${n[3] || "0"}.${n[4] || "0"}`, t);
  };
var eZ = ZJ,
  Bm,
  dA;
function tZ() {
  return (
    dA ||
      ((dA = 1),
      (Bm = function (e) {
        e.prototype[Symbol.iterator] = function* () {
          for (let t = this.head; t; t = t.next) yield t.value;
        };
      })),
    Bm
  );
}
var nZ = Ht;
Ht.Node = qs;
Ht.create = Ht;
function Ht(e) {
  var t = this;
  if (
    (t instanceof Ht || (t = new Ht()),
    (t.tail = null),
    (t.head = null),
    (t.length = 0),
    e && typeof e.forEach == "function")
  )
    e.forEach(function (i) {
      t.push(i);
    });
  else if (arguments.length > 0)
    for (var n = 0, r = arguments.length; n < r; n++) t.push(arguments[n]);
  return t;
}
Ht.prototype.removeNode = function (e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next,
    n = e.prev;
  return (
    t && (t.prev = n),
    n && (n.next = t),
    e === this.head && (this.head = t),
    e === this.tail && (this.tail = n),
    e.list.length--,
    (e.next = null),
    (e.prev = null),
    (e.list = null),
    t
  );
};
Ht.prototype.unshiftNode = function (e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    (e.list = this),
      (e.next = t),
      t && (t.prev = e),
      (this.head = e),
      this.tail || (this.tail = e),
      this.length++;
  }
};
Ht.prototype.pushNode = function (e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    (e.list = this),
      (e.prev = t),
      t && (t.next = e),
      (this.tail = e),
      this.head || (this.head = e),
      this.length++;
  }
};
Ht.prototype.push = function () {
  for (var e = 0, t = arguments.length; e < t; e++) iZ(this, arguments[e]);
  return this.length;
};
Ht.prototype.unshift = function () {
  for (var e = 0, t = arguments.length; e < t; e++) aZ(this, arguments[e]);
  return this.length;
};
Ht.prototype.pop = function () {
  if (this.tail) {
    var e = this.tail.value;
    return (
      (this.tail = this.tail.prev),
      this.tail ? (this.tail.next = null) : (this.head = null),
      this.length--,
      e
    );
  }
};
Ht.prototype.shift = function () {
  if (this.head) {
    var e = this.head.value;
    return (
      (this.head = this.head.next),
      this.head ? (this.head.prev = null) : (this.tail = null),
      this.length--,
      e
    );
  }
};
Ht.prototype.forEach = function (e, t) {
  t = t || this;
  for (var n = this.head, r = 0; n !== null; r++)
    e.call(t, n.value, r, this), (n = n.next);
};
Ht.prototype.forEachReverse = function (e, t) {
  t = t || this;
  for (var n = this.tail, r = this.length - 1; n !== null; r--)
    e.call(t, n.value, r, this), (n = n.prev);
};
Ht.prototype.get = function (e) {
  for (var t = 0, n = this.head; n !== null && t < e; t++) n = n.next;
  if (t === e && n !== null) return n.value;
};
Ht.prototype.getReverse = function (e) {
  for (var t = 0, n = this.tail; n !== null && t < e; t++) n = n.prev;
  if (t === e && n !== null) return n.value;
};
Ht.prototype.map = function (e, t) {
  t = t || this;
  for (var n = new Ht(), r = this.head; r !== null; )
    n.push(e.call(t, r.value, this)), (r = r.next);
  return n;
};
Ht.prototype.mapReverse = function (e, t) {
  t = t || this;
  for (var n = new Ht(), r = this.tail; r !== null; )
    n.push(e.call(t, r.value, this)), (r = r.prev);
  return n;
};
Ht.prototype.reduce = function (e, t) {
  var n,
    r = this.head;
  if (arguments.length > 1) n = t;
  else if (this.head) (r = this.head.next), (n = this.head.value);
  else throw new TypeError("Reduce of empty list with no initial value");
  for (var i = 0; r !== null; i++) (n = e(n, r.value, i)), (r = r.next);
  return n;
};
Ht.prototype.reduceReverse = function (e, t) {
  var n,
    r = this.tail;
  if (arguments.length > 1) n = t;
  else if (this.tail) (r = this.tail.prev), (n = this.tail.value);
  else throw new TypeError("Reduce of empty list with no initial value");
  for (var i = this.length - 1; r !== null; i--)
    (n = e(n, r.value, i)), (r = r.prev);
  return n;
};
Ht.prototype.toArray = function () {
  for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++)
    (e[t] = n.value), (n = n.next);
  return e;
};
Ht.prototype.toArrayReverse = function () {
  for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++)
    (e[t] = n.value), (n = n.prev);
  return e;
};
Ht.prototype.slice = function (e, t) {
  (t = t || this.length),
    t < 0 && (t += this.length),
    (e = e || 0),
    e < 0 && (e += this.length);
  var n = new Ht();
  if (t < e || t < 0) return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = 0, i = this.head; i !== null && r < e; r++) i = i.next;
  for (; i !== null && r < t; r++, i = i.next) n.push(i.value);
  return n;
};
Ht.prototype.sliceReverse = function (e, t) {
  (t = t || this.length),
    t < 0 && (t += this.length),
    (e = e || 0),
    e < 0 && (e += this.length);
  var n = new Ht();
  if (t < e || t < 0) return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var r = this.length, i = this.tail; i !== null && r > t; r--) i = i.prev;
  for (; i !== null && r > e; r--, i = i.prev) n.push(i.value);
  return n;
};
Ht.prototype.splice = function (e, t, ...n) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var r = 0, i = this.head; i !== null && r < e; r++) i = i.next;
  for (var a = [], r = 0; i && r < t; r++)
    a.push(i.value), (i = this.removeNode(i));
  i === null && (i = this.tail),
    i !== this.head && i !== this.tail && (i = i.prev);
  for (var r = 0; r < n.length; r++) i = rZ(this, i, n[r]);
  return a;
};
Ht.prototype.reverse = function () {
  for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
    var r = n.prev;
    (n.prev = n.next), (n.next = r);
  }
  return (this.head = t), (this.tail = e), this;
};
function rZ(e, t, n) {
  var r = t === e.head ? new qs(n, null, t, e) : new qs(n, t, t.next, e);
  return (
    r.next === null && (e.tail = r),
    r.prev === null && (e.head = r),
    e.length++,
    r
  );
}
function iZ(e, t) {
  (e.tail = new qs(t, e.tail, null, e)),
    e.head || (e.head = e.tail),
    e.length++;
}
function aZ(e, t) {
  (e.head = new qs(t, null, e.head, e)),
    e.tail || (e.tail = e.head),
    e.length++;
}
function qs(e, t, n, r) {
  if (!(this instanceof qs)) return new qs(e, t, n, r);
  (this.list = r),
    (this.value = e),
    t ? ((t.next = this), (this.prev = t)) : (this.prev = null),
    n ? ((n.prev = this), (this.next = n)) : (this.next = null);
}
try {
  tZ()(Ht);
} catch {}
const sZ = nZ,
  As = Symbol("max"),
  ia = Symbol("length"),
  go = Symbol("lengthCalculator"),
  $l = Symbol("allowStale"),
  $s = Symbol("maxAge"),
  ta = Symbol("dispose"),
  pA = Symbol("noDisposeOnSet"),
  Qn = Symbol("lruList"),
  ui = Symbol("cache"),
  MR = Symbol("updateAgeOnGet"),
  Um = () => 1;
class oZ {
  constructor(t) {
    if (
      (typeof t == "number" && (t = { max: t }),
      t || (t = {}),
      t.max && (typeof t.max != "number" || t.max < 0))
    )
      throw new TypeError("max must be a non-negative number");
    this[As] = t.max || 1 / 0;
    const n = t.length || Um;
    if (
      ((this[go] = typeof n != "function" ? Um : n),
      (this[$l] = t.stale || !1),
      t.maxAge && typeof t.maxAge != "number")
    )
      throw new TypeError("maxAge must be a number");
    (this[$s] = t.maxAge || 0),
      (this[ta] = t.dispose),
      (this[pA] = t.noDisposeOnSet || !1),
      (this[MR] = t.updateAgeOnGet || !1),
      this.reset();
  }
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    (this[As] = t || 1 / 0), Vc(this);
  }
  get max() {
    return this[As];
  }
  set allowStale(t) {
    this[$l] = !!t;
  }
  get allowStale() {
    return this[$l];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    (this[$s] = t), Vc(this);
  }
  get maxAge() {
    return this[$s];
  }
  set lengthCalculator(t) {
    typeof t != "function" && (t = Um),
      t !== this[go] &&
        ((this[go] = t),
        (this[ia] = 0),
        this[Qn].forEach((n) => {
          (n.length = this[go](n.value, n.key)), (this[ia] += n.length);
        })),
      Vc(this);
  }
  get lengthCalculator() {
    return this[go];
  }
  get length() {
    return this[ia];
  }
  get itemCount() {
    return this[Qn].length;
  }
  rforEach(t, n) {
    n = n || this;
    for (let r = this[Qn].tail; r !== null; ) {
      const i = r.prev;
      hA(this, t, r, n), (r = i);
    }
  }
  forEach(t, n) {
    n = n || this;
    for (let r = this[Qn].head; r !== null; ) {
      const i = r.next;
      hA(this, t, r, n), (r = i);
    }
  }
  keys() {
    return this[Qn].toArray().map((t) => t.key);
  }
  values() {
    return this[Qn].toArray().map((t) => t.value);
  }
  reset() {
    this[ta] &&
      this[Qn] &&
      this[Qn].length &&
      this[Qn].forEach((t) => this[ta](t.key, t.value)),
      (this[ui] = new Map()),
      (this[Qn] = new sZ()),
      (this[ia] = 0);
  }
  dump() {
    return this[Qn].map((t) =>
      Rd(this, t) ? !1 : { k: t.key, v: t.value, e: t.now + (t.maxAge || 0) },
    )
      .toArray()
      .filter((t) => t);
  }
  dumpLru() {
    return this[Qn];
  }
  set(t, n, r) {
    if (((r = r || this[$s]), r && typeof r != "number"))
      throw new TypeError("maxAge must be a number");
    const i = r ? Date.now() : 0,
      a = this[go](n, t);
    if (this[ui].has(t)) {
      if (a > this[As]) return Fo(this, this[ui].get(t)), !1;
      const c = this[ui].get(t).value;
      return (
        this[ta] && (this[pA] || this[ta](t, c.value)),
        (c.now = i),
        (c.maxAge = r),
        (c.value = n),
        (this[ia] += a - c.length),
        (c.length = a),
        this.get(t),
        Vc(this),
        !0
      );
    }
    const s = new cZ(t, n, a, i, r);
    return s.length > this[As]
      ? (this[ta] && this[ta](t, n), !1)
      : ((this[ia] += s.length),
        this[Qn].unshift(s),
        this[ui].set(t, this[Qn].head),
        Vc(this),
        !0);
  }
  has(t) {
    if (!this[ui].has(t)) return !1;
    const n = this[ui].get(t).value;
    return !Rd(this, n);
  }
  get(t) {
    return Fm(this, t, !0);
  }
  peek(t) {
    return Fm(this, t, !1);
  }
  pop() {
    const t = this[Qn].tail;
    return t ? (Fo(this, t), t.value) : null;
  }
  del(t) {
    Fo(this, this[ui].get(t));
  }
  load(t) {
    this.reset();
    const n = Date.now();
    for (let r = t.length - 1; r >= 0; r--) {
      const i = t[r],
        a = i.e || 0;
      if (a === 0) this.set(i.k, i.v);
      else {
        const s = a - n;
        s > 0 && this.set(i.k, i.v, s);
      }
    }
  }
  prune() {
    this[ui].forEach((t, n) => Fm(this, n, !1));
  }
}
const Fm = (e, t, n) => {
    const r = e[ui].get(t);
    if (r) {
      const i = r.value;
      if (Rd(e, i)) {
        if ((Fo(e, r), !e[$l])) return;
      } else n && (e[MR] && (r.value.now = Date.now()), e[Qn].unshiftNode(r));
      return i.value;
    }
  },
  Rd = (e, t) => {
    if (!t || (!t.maxAge && !e[$s])) return !1;
    const n = Date.now() - t.now;
    return t.maxAge ? n > t.maxAge : e[$s] && n > e[$s];
  },
  Vc = (e) => {
    if (e[ia] > e[As])
      for (let t = e[Qn].tail; e[ia] > e[As] && t !== null; ) {
        const n = t.prev;
        Fo(e, t), (t = n);
      }
  },
  Fo = (e, t) => {
    if (t) {
      const n = t.value;
      e[ta] && e[ta](n.key, n.value),
        (e[ia] -= n.length),
        e[ui].delete(n.key),
        e[Qn].removeNode(t);
    }
  };
class cZ {
  constructor(t, n, r, i, a) {
    (this.key = t),
      (this.value = n),
      (this.length = r),
      (this.now = i),
      (this.maxAge = a || 0);
  }
}
const hA = (e, t, n, r) => {
  let i = n.value;
  Rd(e, i) && (Fo(e, n), e[$l] || (i = void 0)),
    i && t.call(r, i.value, i.key, e);
};
var lZ = oZ,
  jm,
  mA;
function Ci() {
  if (mA) return jm;
  mA = 1;
  class e {
    constructor(q, J) {
      if (((J = r(J)), q instanceof e))
        return q.loose === !!J.loose &&
          q.includePrerelease === !!J.includePrerelease
          ? q
          : new e(q.raw, J);
      if (q instanceof i)
        return (this.raw = q.value), (this.set = [[q]]), this.format(), this;
      if (
        ((this.options = J),
        (this.loose = !!J.loose),
        (this.includePrerelease = !!J.includePrerelease),
        (this.raw = q.trim().split(/\s+/).join(" ")),
        (this.set = this.raw
          .split("||")
          .map((Z) => this.parseRange(Z.trim()))
          .filter((Z) => Z.length)),
        !this.set.length)
      )
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const Z = this.set[0];
        if (
          ((this.set = this.set.filter((z) => !h(z[0]))), this.set.length === 0)
        )
          this.set = [Z];
        else if (this.set.length > 1) {
          for (const z of this.set)
            if (z.length === 1 && m(z[0])) {
              this.set = [z];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return (
        (this.range = this.set
          .map((q) => q.join(" ").trim())
          .join("||")
          .trim()),
        this.range
      );
    }
    toString() {
      return this.range;
    }
    parseRange(q) {
      const Z =
          ((this.options.includePrerelease && d) | (this.options.loose && p)) +
          ":" +
          q,
        z = n.get(Z);
      if (z) return z;
      const U = this.options.loose,
        G = U ? o[c.HYPHENRANGELOOSE] : o[c.HYPHENRANGE];
      (q = q.replace(G, Q(this.options.includePrerelease))),
        a("hyphen replace", q),
        (q = q.replace(o[c.COMPARATORTRIM], l)),
        a("comparator trim", q),
        (q = q.replace(o[c.TILDETRIM], f)),
        a("tilde trim", q),
        (q = q.replace(o[c.CARETTRIM], u)),
        a("caret trim", q);
      let L = q
        .split(" ")
        .map((x) => v(x, this.options))
        .join(" ")
        .split(/\s+/)
        .map((x) => O(x, this.options));
      U &&
        (L = L.filter(
          (x) => (
            a("loose invalid filter", x, this.options),
            !!x.match(o[c.COMPARATORLOOSE])
          ),
        )),
        a("range list", L);
      const k = new Map(),
        W = L.map((x) => new i(x, this.options));
      for (const x of W) {
        if (h(x)) return [x];
        k.set(x.value, x);
      }
      k.size > 1 && k.has("") && k.delete("");
      const F = [...k.values()];
      return n.set(Z, F), F;
    }
    intersects(q, J) {
      if (!(q instanceof e)) throw new TypeError("a Range is required");
      return this.set.some(
        (Z) =>
          g(Z, J) &&
          q.set.some(
            (z) =>
              g(z, J) && Z.every((U) => z.every((G) => U.intersects(G, J))),
          ),
      );
    }
    test(q) {
      if (!q) return !1;
      if (typeof q == "string")
        try {
          q = new s(q, this.options);
        } catch {
          return !1;
        }
      for (let J = 0; J < this.set.length; J++)
        if (j(this.set[J], q, this.options)) return !0;
      return !1;
    }
  }
  jm = e;
  const t = lZ,
    n = new t({ max: 1e3 }),
    r = Bb,
    i = Up(),
    a = Lp,
    s = $r,
    {
      safeRe: o,
      t: c,
      comparatorTrimReplace: l,
      tildeTrimReplace: f,
      caretTrimReplace: u,
    } = yu,
    { FLAG_INCLUDE_PRERELEASE: d, FLAG_LOOSE: p } = Dp,
    h = (H) => H.value === "<0.0.0-0",
    m = (H) => H.value === "",
    g = (H, q) => {
      let J = !0;
      const Z = H.slice();
      let z = Z.pop();
      for (; J && Z.length; )
        (J = Z.every((U) => z.intersects(U, q))), (z = Z.pop());
      return J;
    },
    v = (H, q) => (
      a("comp", H, q),
      (H = R(H, q)),
      a("caret", H),
      (H = _(H, q)),
      a("tildes", H),
      (H = I(H, q)),
      a("xrange", H),
      (H = w(H, q)),
      a("stars", H),
      H
    ),
    y = (H) => !H || H.toLowerCase() === "x" || H === "*",
    _ = (H, q) =>
      H.trim()
        .split(/\s+/)
        .map((J) => E(J, q))
        .join(" "),
    E = (H, q) => {
      const J = q.loose ? o[c.TILDELOOSE] : o[c.TILDE];
      return H.replace(J, (Z, z, U, G, L) => {
        a("tilde", H, Z, z, U, G, L);
        let k;
        return (
          y(z)
            ? (k = "")
            : y(U)
            ? (k = `>=${z}.0.0 <${+z + 1}.0.0-0`)
            : y(G)
            ? (k = `>=${z}.${U}.0 <${z}.${+U + 1}.0-0`)
            : L
            ? (a("replaceTilde pr", L),
              (k = `>=${z}.${U}.${G}-${L} <${z}.${+U + 1}.0-0`))
            : (k = `>=${z}.${U}.${G} <${z}.${+U + 1}.0-0`),
          a("tilde return", k),
          k
        );
      });
    },
    R = (H, q) =>
      H.trim()
        .split(/\s+/)
        .map((J) => A(J, q))
        .join(" "),
    A = (H, q) => {
      a("caret", H, q);
      const J = q.loose ? o[c.CARETLOOSE] : o[c.CARET],
        Z = q.includePrerelease ? "-0" : "";
      return H.replace(J, (z, U, G, L, k) => {
        a("caret", H, z, U, G, L, k);
        let W;
        return (
          y(U)
            ? (W = "")
            : y(G)
            ? (W = `>=${U}.0.0${Z} <${+U + 1}.0.0-0`)
            : y(L)
            ? U === "0"
              ? (W = `>=${U}.${G}.0${Z} <${U}.${+G + 1}.0-0`)
              : (W = `>=${U}.${G}.0${Z} <${+U + 1}.0.0-0`)
            : k
            ? (a("replaceCaret pr", k),
              U === "0"
                ? G === "0"
                  ? (W = `>=${U}.${G}.${L}-${k} <${U}.${G}.${+L + 1}-0`)
                  : (W = `>=${U}.${G}.${L}-${k} <${U}.${+G + 1}.0-0`)
                : (W = `>=${U}.${G}.${L}-${k} <${+U + 1}.0.0-0`))
            : (a("no pr"),
              U === "0"
                ? G === "0"
                  ? (W = `>=${U}.${G}.${L}${Z} <${U}.${G}.${+L + 1}-0`)
                  : (W = `>=${U}.${G}.${L}${Z} <${U}.${+G + 1}.0-0`)
                : (W = `>=${U}.${G}.${L} <${+U + 1}.0.0-0`)),
          a("caret return", W),
          W
        );
      });
    },
    I = (H, q) => (
      a("replaceXRanges", H, q),
      H.split(/\s+/)
        .map((J) => S(J, q))
        .join(" ")
    ),
    S = (H, q) => {
      H = H.trim();
      const J = q.loose ? o[c.XRANGELOOSE] : o[c.XRANGE];
      return H.replace(J, (Z, z, U, G, L, k) => {
        a("xRange", H, Z, z, U, G, L, k);
        const W = y(U),
          F = W || y(G),
          x = F || y(L),
          T = x;
        return (
          z === "=" && T && (z = ""),
          (k = q.includePrerelease ? "-0" : ""),
          W
            ? z === ">" || z === "<"
              ? (Z = "<0.0.0-0")
              : (Z = "*")
            : z && T
            ? (F && (G = 0),
              (L = 0),
              z === ">"
                ? ((z = ">="),
                  F
                    ? ((U = +U + 1), (G = 0), (L = 0))
                    : ((G = +G + 1), (L = 0)))
                : z === "<=" && ((z = "<"), F ? (U = +U + 1) : (G = +G + 1)),
              z === "<" && (k = "-0"),
              (Z = `${z + U}.${G}.${L}${k}`))
            : F
            ? (Z = `>=${U}.0.0${k} <${+U + 1}.0.0-0`)
            : x && (Z = `>=${U}.${G}.0${k} <${U}.${+G + 1}.0-0`),
          a("xRange return", Z),
          Z
        );
      });
    },
    w = (H, q) => (a("replaceStars", H, q), H.trim().replace(o[c.STAR], "")),
    O = (H, q) => (
      a("replaceGTE0", H, q),
      H.trim().replace(o[q.includePrerelease ? c.GTE0PRE : c.GTE0], "")
    ),
    Q = (H) => (q, J, Z, z, U, G, L, k, W, F, x, T, V) => (
      y(Z)
        ? (J = "")
        : y(z)
        ? (J = `>=${Z}.0.0${H ? "-0" : ""}`)
        : y(U)
        ? (J = `>=${Z}.${z}.0${H ? "-0" : ""}`)
        : G
        ? (J = `>=${J}`)
        : (J = `>=${J}${H ? "-0" : ""}`),
      y(W)
        ? (k = "")
        : y(F)
        ? (k = `<${+W + 1}.0.0-0`)
        : y(x)
        ? (k = `<${W}.${+F + 1}.0-0`)
        : T
        ? (k = `<=${W}.${F}.${x}-${T}`)
        : H
        ? (k = `<${W}.${F}.${+x + 1}-0`)
        : (k = `<=${k}`),
      `${J} ${k}`.trim()
    ),
    j = (H, q, J) => {
      for (let Z = 0; Z < H.length; Z++) if (!H[Z].test(q)) return !1;
      if (q.prerelease.length && !J.includePrerelease) {
        for (let Z = 0; Z < H.length; Z++)
          if (
            (a(H[Z].semver),
            H[Z].semver !== i.ANY && H[Z].semver.prerelease.length > 0)
          ) {
            const z = H[Z].semver;
            if (
              z.major === q.major &&
              z.minor === q.minor &&
              z.patch === q.patch
            )
              return !0;
          }
        return !1;
      }
      return !0;
    };
  return jm;
}
var Mm, gA;
function Up() {
  if (gA) return Mm;
  gA = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(f, u) {
      if (((u = n(u)), f instanceof t)) {
        if (f.loose === !!u.loose) return f;
        f = f.value;
      }
      (f = f.trim().split(/\s+/).join(" ")),
        s("comparator", f, u),
        (this.options = u),
        (this.loose = !!u.loose),
        this.parse(f),
        this.semver === e
          ? (this.value = "")
          : (this.value = this.operator + this.semver.version),
        s("comp", this);
    }
    parse(f) {
      const u = this.options.loose ? r[i.COMPARATORLOOSE] : r[i.COMPARATOR],
        d = f.match(u);
      if (!d) throw new TypeError(`Invalid comparator: ${f}`);
      (this.operator = d[1] !== void 0 ? d[1] : ""),
        this.operator === "=" && (this.operator = ""),
        d[2]
          ? (this.semver = new o(d[2], this.options.loose))
          : (this.semver = e);
    }
    toString() {
      return this.value;
    }
    test(f) {
      if (
        (s("Comparator.test", f, this.options.loose),
        this.semver === e || f === e)
      )
        return !0;
      if (typeof f == "string")
        try {
          f = new o(f, this.options);
        } catch {
          return !1;
        }
      return a(f, this.operator, this.semver, this.options);
    }
    intersects(f, u) {
      if (!(f instanceof t)) throw new TypeError("a Comparator is required");
      return this.operator === ""
        ? this.value === ""
          ? !0
          : new c(f.value, u).test(this.value)
        : f.operator === ""
        ? f.value === ""
          ? !0
          : new c(this.value, u).test(f.semver)
        : ((u = n(u)),
          (u.includePrerelease &&
            (this.value === "<0.0.0-0" || f.value === "<0.0.0-0")) ||
          (!u.includePrerelease &&
            (this.value.startsWith("<0.0.0") || f.value.startsWith("<0.0.0")))
            ? !1
            : !!(
                (this.operator.startsWith(">") && f.operator.startsWith(">")) ||
                (this.operator.startsWith("<") && f.operator.startsWith("<")) ||
                (this.semver.version === f.semver.version &&
                  this.operator.includes("=") &&
                  f.operator.includes("=")) ||
                (a(this.semver, "<", f.semver, u) &&
                  this.operator.startsWith(">") &&
                  f.operator.startsWith("<")) ||
                (a(this.semver, ">", f.semver, u) &&
                  this.operator.startsWith("<") &&
                  f.operator.startsWith(">"))
              ));
    }
  }
  Mm = t;
  const n = Bb,
    { safeRe: r, t: i } = yu,
    a = jR,
    s = Lp,
    o = $r,
    c = Ci();
  return Mm;
}
const uZ = Ci(),
  fZ = (e, t, n) => {
    try {
      t = new uZ(t, n);
    } catch {
      return !1;
    }
    return t.test(e);
  };
var Fp = fZ;
const dZ = Ci(),
  pZ = (e, t) =>
    new dZ(e, t).set.map((n) =>
      n
        .map((r) => r.value)
        .join(" ")
        .trim()
        .split(" "),
    );
var hZ = pZ;
const mZ = $r,
  gZ = Ci(),
  vZ = (e, t, n) => {
    let r = null,
      i = null,
      a = null;
    try {
      a = new gZ(t, n);
    } catch {
      return null;
    }
    return (
      e.forEach((s) => {
        a.test(s) &&
          (!r || i.compare(s) === -1) &&
          ((r = s), (i = new mZ(r, n)));
      }),
      r
    );
  };
var yZ = vZ;
const bZ = $r,
  _Z = Ci(),
  EZ = (e, t, n) => {
    let r = null,
      i = null,
      a = null;
    try {
      a = new _Z(t, n);
    } catch {
      return null;
    }
    return (
      e.forEach((s) => {
        a.test(s) &&
          (!r || i.compare(s) === 1) &&
          ((r = s), (i = new bZ(r, n)));
      }),
      r
    );
  };
var wZ = EZ;
const Hm = $r,
  xZ = Ci(),
  vA = Bp,
  AZ = (e, t) => {
    e = new xZ(e, t);
    let n = new Hm("0.0.0");
    if (e.test(n) || ((n = new Hm("0.0.0-0")), e.test(n))) return n;
    n = null;
    for (let r = 0; r < e.set.length; ++r) {
      const i = e.set[r];
      let a = null;
      i.forEach((s) => {
        const o = new Hm(s.semver.version);
        switch (s.operator) {
          case ">":
            o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0),
              (o.raw = o.format());
          case "":
          case ">=":
            (!a || vA(o, a)) && (a = o);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${s.operator}`);
        }
      }),
        a && (!n || vA(n, a)) && (n = a);
    }
    return n && e.test(n) ? n : null;
  };
var SZ = AZ;
const IZ = Ci(),
  $Z = (e, t) => {
    try {
      return new IZ(e, t).range || "*";
    } catch {
      return null;
    }
  };
var CZ = $Z;
const RZ = $r,
  HR = Up(),
  { ANY: kZ } = HR,
  TZ = Ci(),
  NZ = Fp,
  yA = Bp,
  bA = Fb,
  OZ = Mb,
  PZ = jb,
  DZ = (e, t, n, r) => {
    (e = new RZ(e, r)), (t = new TZ(t, r));
    let i, a, s, o, c;
    switch (n) {
      case ">":
        (i = yA), (a = OZ), (s = bA), (o = ">"), (c = ">=");
        break;
      case "<":
        (i = bA), (a = PZ), (s = yA), (o = "<"), (c = "<=");
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (NZ(e, t, r)) return !1;
    for (let l = 0; l < t.set.length; ++l) {
      const f = t.set[l];
      let u = null,
        d = null;
      if (
        (f.forEach((p) => {
          p.semver === kZ && (p = new HR(">=0.0.0")),
            (u = u || p),
            (d = d || p),
            i(p.semver, u.semver, r)
              ? (u = p)
              : s(p.semver, d.semver, r) && (d = p);
        }),
        u.operator === o ||
          u.operator === c ||
          ((!d.operator || d.operator === o) && a(e, d.semver)))
      )
        return !1;
      if (d.operator === c && s(e, d.semver)) return !1;
    }
    return !0;
  };
var Hb = DZ;
const LZ = Hb,
  BZ = (e, t, n) => LZ(e, t, ">", n);
var UZ = BZ;
const FZ = Hb,
  jZ = (e, t, n) => FZ(e, t, "<", n);
var MZ = jZ;
const _A = Ci(),
  HZ = (e, t, n) => (
    (e = new _A(e, n)), (t = new _A(t, n)), e.intersects(t, n)
  );
var qZ = HZ;
const GZ = Fp,
  QZ = $i;
var WZ = (e, t, n) => {
  const r = [];
  let i = null,
    a = null;
  const s = e.sort((f, u) => QZ(f, u, n));
  for (const f of s)
    GZ(f, t, n)
      ? ((a = f), i || (i = f))
      : (a && r.push([i, a]), (a = null), (i = null));
  i && r.push([i, null]);
  const o = [];
  for (const [f, u] of r)
    f === u
      ? o.push(f)
      : !u && f === s[0]
      ? o.push("*")
      : u
      ? f === s[0]
        ? o.push(`<=${u}`)
        : o.push(`${f} - ${u}`)
      : o.push(`>=${f}`);
  const c = o.join(" || "),
    l = typeof t.raw == "string" ? t.raw : String(t);
  return c.length < l.length ? c : t;
};
const EA = Ci(),
  qb = Up(),
  { ANY: qm } = qb,
  Yc = Fp,
  Gb = $i,
  zZ = (e, t, n = {}) => {
    if (e === t) return !0;
    (e = new EA(e, n)), (t = new EA(t, n));
    let r = !1;
    e: for (const i of e.set) {
      for (const a of t.set) {
        const s = VZ(i, a, n);
        if (((r = r || s !== null), s)) continue e;
      }
      if (r) return !1;
    }
    return !0;
  },
  KZ = [new qb(">=0.0.0-0")],
  wA = [new qb(">=0.0.0")],
  VZ = (e, t, n) => {
    if (e === t) return !0;
    if (e.length === 1 && e[0].semver === qm) {
      if (t.length === 1 && t[0].semver === qm) return !0;
      n.includePrerelease ? (e = KZ) : (e = wA);
    }
    if (t.length === 1 && t[0].semver === qm) {
      if (n.includePrerelease) return !0;
      t = wA;
    }
    const r = new Set();
    let i, a;
    for (const p of e)
      p.operator === ">" || p.operator === ">="
        ? (i = xA(i, p, n))
        : p.operator === "<" || p.operator === "<="
        ? (a = AA(a, p, n))
        : r.add(p.semver);
    if (r.size > 1) return null;
    let s;
    if (i && a) {
      if (((s = Gb(i.semver, a.semver, n)), s > 0)) return null;
      if (s === 0 && (i.operator !== ">=" || a.operator !== "<=")) return null;
    }
    for (const p of r) {
      if ((i && !Yc(p, String(i), n)) || (a && !Yc(p, String(a), n)))
        return null;
      for (const h of t) if (!Yc(p, String(h), n)) return !1;
      return !0;
    }
    let o,
      c,
      l,
      f,
      u =
        a && !n.includePrerelease && a.semver.prerelease.length ? a.semver : !1,
      d =
        i && !n.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
    u &&
      u.prerelease.length === 1 &&
      a.operator === "<" &&
      u.prerelease[0] === 0 &&
      (u = !1);
    for (const p of t) {
      if (
        ((f = f || p.operator === ">" || p.operator === ">="),
        (l = l || p.operator === "<" || p.operator === "<="),
        i)
      ) {
        if (
          (d &&
            p.semver.prerelease &&
            p.semver.prerelease.length &&
            p.semver.major === d.major &&
            p.semver.minor === d.minor &&
            p.semver.patch === d.patch &&
            (d = !1),
          p.operator === ">" || p.operator === ">=")
        ) {
          if (((o = xA(i, p, n)), o === p && o !== i)) return !1;
        } else if (i.operator === ">=" && !Yc(i.semver, String(p), n))
          return !1;
      }
      if (a) {
        if (
          (u &&
            p.semver.prerelease &&
            p.semver.prerelease.length &&
            p.semver.major === u.major &&
            p.semver.minor === u.minor &&
            p.semver.patch === u.patch &&
            (u = !1),
          p.operator === "<" || p.operator === "<=")
        ) {
          if (((c = AA(a, p, n)), c === p && c !== a)) return !1;
        } else if (a.operator === "<=" && !Yc(a.semver, String(p), n))
          return !1;
      }
      if (!p.operator && (a || i) && s !== 0) return !1;
    }
    return !((i && l && !a && s !== 0) || (a && f && !i && s !== 0) || d || u);
  },
  xA = (e, t, n) => {
    if (!e) return t;
    const r = Gb(e.semver, t.semver, n);
    return r > 0
      ? e
      : r < 0 || (t.operator === ">" && e.operator === ">=")
      ? t
      : e;
  },
  AA = (e, t, n) => {
    if (!e) return t;
    const r = Gb(e.semver, t.semver, n);
    return r < 0
      ? e
      : r > 0 || (t.operator === "<" && e.operator === "<=")
      ? t
      : e;
  };
var YZ = zZ;
const Gm = yu,
  SA = Dp,
  XZ = $r,
  IA = BR,
  JZ = Cc,
  ZZ = JX,
  eee = tJ,
  tee = rJ,
  nee = aJ,
  ree = cJ,
  iee = fJ,
  aee = hJ,
  see = vJ,
  oee = $i,
  cee = EJ,
  lee = AJ,
  uee = Ub,
  fee = CJ,
  dee = TJ,
  pee = Bp,
  hee = Fb,
  mee = UR,
  gee = FR,
  vee = jb,
  yee = Mb,
  bee = jR,
  _ee = eZ,
  Eee = Up(),
  wee = Ci(),
  xee = Fp,
  Aee = hZ,
  See = yZ,
  Iee = wZ,
  $ee = SZ,
  Cee = CZ,
  Ree = Hb,
  kee = UZ,
  Tee = MZ,
  Nee = qZ,
  Oee = WZ,
  Pee = YZ;
var Dee = {
    parse: JZ,
    valid: ZZ,
    clean: eee,
    inc: tee,
    diff: nee,
    major: ree,
    minor: iee,
    patch: aee,
    prerelease: see,
    compare: oee,
    rcompare: cee,
    compareLoose: lee,
    compareBuild: uee,
    sort: fee,
    rsort: dee,
    gt: pee,
    lt: hee,
    eq: mee,
    neq: gee,
    gte: vee,
    lte: yee,
    cmp: bee,
    coerce: _ee,
    Comparator: Eee,
    Range: wee,
    satisfies: xee,
    toComparators: Aee,
    maxSatisfying: See,
    minSatisfying: Iee,
    minVersion: $ee,
    validRange: Cee,
    outside: Ree,
    gtr: kee,
    ltr: Tee,
    intersects: Nee,
    simplifyRange: Oee,
    subset: Pee,
    SemVer: XZ,
    re: Gm.re,
    src: Gm.src,
    tokens: Gm.t,
    SEMVER_SPEC_VERSION: SA.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: SA.RELEASE_TYPES,
    compareIdentifiers: IA.compareIdentifiers,
    rcompareIdentifiers: IA.rcompareIdentifiers,
  },
  jp = { exports: {} },
  Qb = { exports: {} };
const qR = (e, t) => {
  for (const n of Reflect.ownKeys(t))
    Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n));
  return e;
};
Qb.exports = qR;
Qb.exports.default = qR;
var Lee = Qb.exports;
const Bee = Lee,
  kd = new WeakMap(),
  GR = (e, t = {}) => {
    if (typeof e != "function") throw new TypeError("Expected a function");
    let n,
      r = 0;
    const i = e.displayName || e.name || "<anonymous>",
      a = function (...s) {
        if ((kd.set(a, ++r), r === 1)) (n = e.apply(this, s)), (e = null);
        else if (t.throw === !0)
          throw new Error(`Function \`${i}\` can only be called once`);
        return n;
      };
    return Bee(a, e), kd.set(a, r), a;
  };
jp.exports = GR;
jp.exports.default = GR;
jp.exports.callCount = (e) => {
  if (!kd.has(e))
    throw new Error(
      `The given function \`${e.name}\` is not wrapped by the \`onetime\` package`,
    );
  return kd.get(e);
};
var Uee = jp.exports;
(function (e, t) {
  var n =
      (Tn && Tn.__classPrivateFieldSet) ||
      function (z, U, G, L, k) {
        if (L === "m") throw new TypeError("Private method is not writable");
        if (L === "a" && !k)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof U == "function" ? z !== U || !k : !U.has(z))
          throw new TypeError(
            "Cannot write private member to an object whose class did not declare it",
          );
        return L === "a" ? k.call(z, G) : k ? (k.value = G) : U.set(z, G), G;
      },
    r =
      (Tn && Tn.__classPrivateFieldGet) ||
      function (z, U, G, L) {
        if (G === "a" && !L)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof U == "function" ? z !== U || !L : !U.has(z))
          throw new TypeError(
            "Cannot read private member from an object whose class did not declare it",
          );
        return G === "m" ? L : G === "a" ? L.call(z) : L ? L.value : U.get(z);
      },
    i,
    a,
    s,
    o,
    c,
    l;
  Object.defineProperty(t, "__esModule", { value: !0 });
  const f = wr,
    u = Xt,
    d = pt,
    p = pr,
    h = gc,
    m = Hi,
    g = sq,
    v = vq,
    y = Eq,
    _ = Ui,
    E = Pz,
    R = SX,
    A = LX,
    I = Dee,
    S = Uee,
    w = "aes-256-cbc",
    O = () => Object.create(null),
    Q = (z) => z != null;
  let j = "";
  try {
    delete require.cache[__filename],
      (j = d.dirname(
        (a = (i = e.parent) === null || i === void 0 ? void 0 : i.filename) !==
          null && a !== void 0
          ? a
          : ".",
      ));
  } catch {}
  const H = (z, U) => {
      const G = new Set(["undefined", "symbol", "function"]),
        L = typeof U;
      if (G.has(L))
        throw new TypeError(
          `Setting a value of type \`${L}\` for key \`${z}\` is not allowed as it's not supported by JSON`,
        );
    },
    q = "__internal__",
    J = `${q}.migrations.version`;
  class Z {
    constructor(U = {}) {
      var G;
      s.set(this, void 0),
        o.set(this, void 0),
        c.set(this, void 0),
        l.set(this, {}),
        (this._deserialize = (T) => JSON.parse(T)),
        (this._serialize = (T) => JSON.stringify(T, void 0, "	"));
      const L = {
          configName: "config",
          fileExtension: "json",
          projectSuffix: "nodejs",
          clearInvalidConfig: !1,
          accessPropertiesByDotNotation: !0,
          configFileMode: 438,
          ...U,
        },
        k = S(() => {
          const T = v.sync({ cwd: j }),
            V = T && JSON.parse(u.readFileSync(T, "utf8"));
          return V ?? {};
        });
      if (!L.cwd) {
        if ((L.projectName || (L.projectName = k().name), !L.projectName))
          throw new Error(
            "Project name could not be inferred. Please specify the `projectName` option.",
          );
        L.cwd = y(L.projectName, { suffix: L.projectSuffix }).config;
      }
      if ((n(this, c, L, "f"), L.schema)) {
        if (typeof L.schema != "object")
          throw new TypeError("The `schema` option must be an object.");
        const T = new E.default({ allErrors: !0, useDefaults: !0 });
        (0, R.default)(T);
        const V = { type: "object", properties: L.schema };
        n(this, s, T.compile(V), "f");
        for (const [B, N] of Object.entries(L.schema))
          N != null && N.default && (r(this, l, "f")[B] = N.default);
      }
      L.defaults && n(this, l, { ...r(this, l, "f"), ...L.defaults }, "f"),
        L.serialize && (this._serialize = L.serialize),
        L.deserialize && (this._deserialize = L.deserialize),
        (this.events = new m.EventEmitter()),
        n(this, o, L.encryptionKey, "f");
      const W = L.fileExtension ? `.${L.fileExtension}` : "";
      this.path = d.resolve(
        L.cwd,
        `${(G = L.configName) !== null && G !== void 0 ? G : "config"}${W}`,
      );
      const F = this.store,
        x = Object.assign(O(), L.defaults, F);
      this._validate(x);
      try {
        h.deepEqual(F, x);
      } catch {
        this.store = x;
      }
      if ((L.watch && this._watch(), L.migrations)) {
        if (
          (L.projectVersion || (L.projectVersion = k().version),
          !L.projectVersion)
        )
          throw new Error(
            "Project version could not be inferred. Please specify the `projectVersion` option.",
          );
        this._migrate(L.migrations, L.projectVersion, L.beforeEachMigration);
      }
    }
    get(U, G) {
      if (r(this, c, "f").accessPropertiesByDotNotation) return this._get(U, G);
      const { store: L } = this;
      return U in L ? L[U] : G;
    }
    set(U, G) {
      if (typeof U != "string" && typeof U != "object")
        throw new TypeError(
          `Expected \`key\` to be of type \`string\` or \`object\`, got ${typeof U}`,
        );
      if (typeof U != "object" && G === void 0)
        throw new TypeError("Use `delete()` to clear values");
      if (this._containsReservedKey(U))
        throw new TypeError(
          `Please don't use the ${q} key, as it's used to manage this module internal operations.`,
        );
      const { store: L } = this,
        k = (W, F) => {
          H(W, F),
            r(this, c, "f").accessPropertiesByDotNotation
              ? g.set(L, W, F)
              : (L[W] = F);
        };
      if (typeof U == "object") {
        const W = U;
        for (const [F, x] of Object.entries(W)) k(F, x);
      } else k(U, G);
      this.store = L;
    }
    has(U) {
      return r(this, c, "f").accessPropertiesByDotNotation
        ? g.has(this.store, U)
        : U in this.store;
    }
    reset(...U) {
      for (const G of U)
        Q(r(this, l, "f")[G]) && this.set(G, r(this, l, "f")[G]);
    }
    delete(U) {
      const { store: G } = this;
      r(this, c, "f").accessPropertiesByDotNotation
        ? g.delete(G, U)
        : delete G[U],
        (this.store = G);
    }
    clear() {
      this.store = O();
      for (const U of Object.keys(r(this, l, "f"))) this.reset(U);
    }
    onDidChange(U, G) {
      if (typeof U != "string")
        throw new TypeError(
          `Expected \`key\` to be of type \`string\`, got ${typeof U}`,
        );
      if (typeof G != "function")
        throw new TypeError(
          `Expected \`callback\` to be of type \`function\`, got ${typeof G}`,
        );
      return this._handleChange(() => this.get(U), G);
    }
    onDidAnyChange(U) {
      if (typeof U != "function")
        throw new TypeError(
          `Expected \`callback\` to be of type \`function\`, got ${typeof U}`,
        );
      return this._handleChange(() => this.store, U);
    }
    get size() {
      return Object.keys(this.store).length;
    }
    get store() {
      try {
        const U = u.readFileSync(this.path, r(this, o, "f") ? null : "utf8"),
          G = this._encryptData(U),
          L = this._deserialize(G);
        return this._validate(L), Object.assign(O(), L);
      } catch (U) {
        if ((U == null ? void 0 : U.code) === "ENOENT")
          return this._ensureDirectory(), O();
        if (r(this, c, "f").clearInvalidConfig && U.name === "SyntaxError")
          return O();
        throw U;
      }
    }
    set store(U) {
      this._ensureDirectory(),
        this._validate(U),
        this._write(U),
        this.events.emit("change");
    }
    *[((s = new WeakMap()),
    (o = new WeakMap()),
    (c = new WeakMap()),
    (l = new WeakMap()),
    Symbol.iterator)]() {
      for (const [U, G] of Object.entries(this.store)) yield [U, G];
    }
    _encryptData(U) {
      if (!r(this, o, "f")) return U.toString();
      try {
        if (r(this, o, "f"))
          try {
            if (U.slice(16, 17).toString() === ":") {
              const G = U.slice(0, 16),
                L = p.pbkdf2Sync(
                  r(this, o, "f"),
                  G.toString(),
                  1e4,
                  32,
                  "sha512",
                ),
                k = p.createDecipheriv(w, L, G);
              U = Buffer.concat([
                k.update(Buffer.from(U.slice(17))),
                k.final(),
              ]).toString("utf8");
            } else {
              const G = p.createDecipher(w, r(this, o, "f"));
              U = Buffer.concat([G.update(Buffer.from(U)), G.final()]).toString(
                "utf8",
              );
            }
          } catch {}
      } catch {}
      return U.toString();
    }
    _handleChange(U, G) {
      let L = U();
      const k = () => {
        const W = L,
          F = U();
        (0, f.isDeepStrictEqual)(F, W) || ((L = F), G.call(this, F, W));
      };
      return (
        this.events.on("change", k),
        () => this.events.removeListener("change", k)
      );
    }
    _validate(U) {
      if (
        !r(this, s, "f") ||
        r(this, s, "f").call(this, U) ||
        !r(this, s, "f").errors
      )
        return;
      const L = r(this, s, "f").errors.map(
        ({ instancePath: k, message: W = "" }) => `\`${k.slice(1)}\` ${W}`,
      );
      throw new Error("Config schema violation: " + L.join("; "));
    }
    _ensureDirectory() {
      u.mkdirSync(d.dirname(this.path), { recursive: !0 });
    }
    _write(U) {
      let G = this._serialize(U);
      if (r(this, o, "f")) {
        const L = p.randomBytes(16),
          k = p.pbkdf2Sync(r(this, o, "f"), L.toString(), 1e4, 32, "sha512"),
          W = p.createCipheriv(w, k, L);
        G = Buffer.concat([
          L,
          Buffer.from(":"),
          W.update(Buffer.from(G)),
          W.final(),
        ]);
      }
      if (process.env.SNAP)
        u.writeFileSync(this.path, G, { mode: r(this, c, "f").configFileMode });
      else
        try {
          _.writeFileSync(this.path, G, {
            mode: r(this, c, "f").configFileMode,
          });
        } catch (L) {
          if ((L == null ? void 0 : L.code) === "EXDEV") {
            u.writeFileSync(this.path, G, {
              mode: r(this, c, "f").configFileMode,
            });
            return;
          }
          throw L;
        }
    }
    _watch() {
      this._ensureDirectory(),
        u.existsSync(this.path) || this._write(O()),
        process.platform === "win32"
          ? u.watch(
              this.path,
              { persistent: !1 },
              A(
                () => {
                  this.events.emit("change");
                },
                { wait: 100 },
              ),
            )
          : u.watchFile(
              this.path,
              { persistent: !1 },
              A(
                () => {
                  this.events.emit("change");
                },
                { wait: 5e3 },
              ),
            );
    }
    _migrate(U, G, L) {
      let k = this._get(J, "0.0.0");
      const W = Object.keys(U).filter((x) =>
        this._shouldPerformMigration(x, k, G),
      );
      let F = { ...this.store };
      for (const x of W)
        try {
          L &&
            L(this, {
              fromVersion: k,
              toVersion: x,
              finalVersion: G,
              versions: W,
            });
          const T = U[x];
          T(this), this._set(J, x), (k = x), (F = { ...this.store });
        } catch (T) {
          throw (
            ((this.store = F),
            new Error(
              `Something went wrong during the migration! Changes applied to the store until this failed migration will be restored. ${T}`,
            ))
          );
        }
      (this._isVersionInRangeFormat(k) || !I.eq(k, G)) && this._set(J, G);
    }
    _containsReservedKey(U) {
      return typeof U == "object" && Object.keys(U)[0] === q
        ? !0
        : typeof U != "string"
        ? !1
        : r(this, c, "f").accessPropertiesByDotNotation
        ? !!U.startsWith(`${q}.`)
        : !1;
    }
    _isVersionInRangeFormat(U) {
      return I.clean(U) === null;
    }
    _shouldPerformMigration(U, G, L) {
      return this._isVersionInRangeFormat(U)
        ? G !== "0.0.0" && I.satisfies(G, U)
          ? !1
          : I.satisfies(L, U)
        : !(I.lte(U, G) || I.gt(U, L));
    }
    _get(U, G) {
      return g.get(this.store, U, G);
    }
    _set(U, G) {
      const { store: L } = this;
      g.set(L, U, G), (this.store = L);
    }
  }
  (t.default = Z), (e.exports = Z), (e.exports.default = Z);
})(g0, g0.exports);
var Fee = g0.exports;
const $A = pt,
  { app: Vf, ipcMain: O0, ipcRenderer: CA, shell: jee } = xe,
  Mee = Fee;
let RA = !1;
const kA = () => {
  if (!O0 || !Vf)
    throw new Error(
      "Electron Store: You need to call `.initRenderer()` from the main process.",
    );
  const e = { defaultCwd: Vf.getPath("userData"), appVersion: Vf.getVersion() };
  return (
    RA ||
      (O0.on("electron-store-get-data", (t) => {
        t.returnValue = e;
      }),
      (RA = !0)),
    e
  );
};
class Hee extends Mee {
  constructor(t) {
    let n, r;
    if (CA) {
      const i = CA.sendSync("electron-store-get-data");
      if (!i)
        throw new Error(
          "Electron Store: You need to call `.initRenderer()` from the main process.",
        );
      ({ defaultCwd: n, appVersion: r } = i);
    } else O0 && Vf && ({ defaultCwd: n, appVersion: r } = kA());
    (t = { name: "config", ...t }),
      t.projectVersion || (t.projectVersion = r),
      t.cwd
        ? (t.cwd = $A.isAbsolute(t.cwd) ? t.cwd : $A.join(n, t.cwd))
        : (t.cwd = n),
      (t.configName = t.name),
      delete t.name,
      super(t);
  }
  static initRenderer() {
    kA();
  }
  openInEditor() {
    jee.openPath(this.path);
  }
}
var qee = Hee;
const Mp = Wl(qee),
  Hp = process.env.NODE_ENV === "development";
function Gee(e) {
  return e.length > 0;
}
const Qee = (function () {
    return typeof window > "u" ? process.platform : window.Ray.platform;
  })(),
  Wee = {
    Atom: "atom://core/open/file?filename=%path&line=%line",
    Emacs: "emacs://open?url=file://%path&line=%line",
    Idea: "idea://open?file=%path&line=%line",
    MacVim: "mvim://open/?url=file://%path&line=%line",
    PhpStorm: "phpstorm://open?file=%path&line=%line",
    Sublime:
      Qee === "linux"
        ? "subl://%path:%line"
        : "subl://open?url=file://%path&line=%line",
    TextMate: "txmt://open?url=file://%path&line=%line",
    VSCode: "vscode://file/%path:%line",
    "VSCode-insiders": "vscode-insiders://file/%path:%line",
    "Custom URL": "",
  };
let ei = null;
function QR() {
  if (ei) return ei.show();
  (ei = new xe.BrowserWindow(Qp())),
    ei.on("closed", () => (ei = null)),
    Wp(ei, { page: "preferences" }),
    zp(ei);
}
function zee() {
  ei == null || ei.close(), (ei = null);
}
function WR() {
  ei ? zee() : QR();
}
xe.ipcMain.on("open-preferences", QR);
const Kee = Fr.platform() === "win32";
let P0;
function Vee() {
  (P0 = [
    {
      role: "appMenu",
      label: "Menu",
      submenu: [
        {
          label: "About Ray",
          role: process.platform === "linux" ? void 0 : "about",
          click: () => {
            process.platform === "linux" &&
              xe.dialog.showMessageBox({
                title: "Ray",
                message: "Version " + xe.app.getVersion(),
              });
          },
        },
        {
          label: "Check for updatesâ€¦",
          click: () =>
            vs.autoUpdater.checkForUpdatesAndNotify().then((e) => {
              const t =
                (e == null ? void 0 : e.updateInfo.version) !==
                xe.app.getVersion();
              t &&
                xe.dialog.showMessageBox({
                  message:
                    "A new version is available, it will be downloaded in the background.",
                }),
                t ||
                  xe.dialog.showMessageBox({
                    message: "You are running the latest version.",
                  });
            }),
        },
        { type: "separator" },
        { label: "Services", role: "services", submenu: [] },
        { type: "separator" },
        { label: "Preferences...", accelerator: "CmdOrCtrl+,", click: WR },
        ...(Kee
          ? []
          : [
              { type: "separator" },
              { label: "Hide Ray", accelerator: "CmdOrCtrl+H", role: "hide" },
              {
                label: "Hide Others",
                accelerator: "CmdOrCtrl+Alt+H",
                role: "hideOthers",
              },
              { label: "Show All", role: "unhide" },
            ]),
        { type: "separator" },
        {
          label: "Quit Ray",
          accelerator: process.platform === "darwin" ? "Cmd+Q" : "Alt+F4",
          click: xe.app.quit,
        },
      ],
    },
    {
      label: "File",
      submenu: [
        {
          label: "Find",
          accelerator: "CmdOrCtrl+F",
          click: () => {
            var e;
            return (e = xe.BrowserWindow.getFocusedWindow()) == null
              ? void 0
              : e.webContents.send("toggle-search");
          },
        },
        {
          label: "Close",
          accelerator: "CmdOrCtrl+W",
          click: () => {
            var e;
            return (e = xe.BrowserWindow.getFocusedWindow()) == null
              ? void 0
              : e.close();
          },
        },
      ],
    },
    { role: "editMenu" },
    {
      label: "View",
      submenu: [
        {
          label: "New Blank Screen",
          accelerator: "CmdOrCtrl+K",
          click: () => {
            const e = xe.BrowserWindow.getFocusedWindow();
            if (!e) return;
            const t = Yt.find((n) => n.window.id === e.id);
            t && th(t);
          },
        },
        {
          label: "New Blank Screen and Clear History",
          accelerator: "CmdOrCtrl+L",
          click: () => {
            const e = xe.BrowserWindow.getFocusedWindow();
            if (!e) return;
            const t = Yt.find((n) => n.window.id === e.id);
            t && aT(t);
          },
        },
        { type: "separator" },
        ...(Hp ? [{ role: "toggleDevTools" }] : []),
        { type: "separator" },
        { role: "resetZoom" },
        { role: "zoomIn" },
        { role: "zoomOut" },
        { type: "separator" },
        { role: "togglefullscreen" },
      ],
    },
    {
      role: "windowMenu",
      submenu: [
        {
          label: "Reset to center of screen",
          accelerator: "CmdOrCtrl+Shift+R",
          click: () => {
            var e;
            return (e = xe.BrowserWindow.getFocusedWindow()) == null
              ? void 0
              : e.center();
          },
        },
        {
          label: "Float on top",
          type: "radio",
          checked: rt.floating(),
          accelerator: rt.toggleAlwaysOnTopHotkey(),
          click: () => {
            const e = !rt.floating();
            Wb(e);
          },
        },
      ],
    },
    {
      label: "Help",
      submenu: [
        {
          label: "Documentationâ€¦",
          click: () => xe.shell.openExternal("https://spatie.be/docs/ray"),
        },
        {
          label: "Referenceâ€¦",
          click: () =>
            xe.shell.openExternal(
              "https://spatie.be/docs/ray/v1/usage/reference",
            ),
        },
        {
          label: "Release Notesâ€¦",
          click: () =>
            xe.shell.openExternal(
              `https://spatie.be/products/ray/release-notes#${xe.app.getVersion()}`,
            ),
        },
        {
          label: "Manage Licenseâ€¦",
          click: () =>
            xe.shell.openExternal("https://spatie.be/profile/purchases"),
        },
        {
          label: "Report a Bugâ€¦",
          click: () =>
            xe.shell.openExternal(
              "https://github.com/spatie/ray/issues/new?assignees=&labels=&template=bug_report.md&title=",
            ),
        },
      ],
    },
  ]),
    xe.Menu.setApplicationMenu(xe.Menu.buildFromTemplate(P0));
}
function Yee(e) {
  const t = e(P0);
  xe.Menu.setApplicationMenu(xe.Menu.buildFromTemplate(t));
}
function zR({ floating: e, accelerator: t }) {
  Yee((n) =>
    n.map(
      (i) => (
        i.role !== "windowMenu" ||
          !Array.isArray(i.submenu) ||
          (i.submenu = i.submenu.map(
            (a) => (
              a.label !== "Float on top" ||
                ((a.checked = e ?? a.checked),
                (a.accelerator = t ?? a.accelerator)),
              a
            ),
          )),
        i
      ),
    ),
  );
}
function qp() {
  xe.globalShortcut.unregisterAll(),
    rt.toggleVisibilityGlobalHotkey() &&
      xe.globalShortcut.register(rt.toggleVisibilityGlobalHotkey(), () =>
        xe.BrowserWindow.getAllWindows().forEach((e) =>
          e != null && e.isVisible()
            ? e == null
              ? void 0
              : e.hide()
            : e.show(),
        ),
      ),
    rt.newScreenGlobalHotkey() &&
      xe.globalShortcut.register(rt.newScreenGlobalHotkey(), () =>
        Yt.forEach((e) => th(e)),
      ),
    rt.toggleAlwaysOnTopHotkey() &&
      xe.globalShortcut.register(rt.toggleAlwaysOnTopHotkey(), () => {
        const e = !rt.floating();
        Wb(e);
      });
}
const jt = new Mp({
    name: "preferences",
    watch: !0,
    defaults: {
      port: "23517",
      floating: !1,
      displayTimes: !0,
      scrollOnLog: !0,
      editor: "PhpStorm",
      customEditor: "",
      colorblindMode: "Disabled",
      toggleVisibilityGlobalHotkey: "CmdOrCtrl+Shift+L",
      newScreenGlobalHotkey: "CmdOrCtrl+Shift+K",
      toggleAlwaysOnTopHotkey: "",
      newWindow: "server",
      appVisibility: "both",
      theme: "automatic",
      servers: [],
      historyLimit: 1e5,
    },
    migrations: {
      ">=1.14.0": (e) => {
        const t = e.get("appVisibility");
        ["both", "menubar"].includes(t) || e.set("appVisibility", "both");
      },
      ">=1.18.0": (e) => {
        const t = e
          .get("servers")
          .map((n) => ({
            ...n,
            uuid: n.uuid.replace(".", ""),
            needsCredentialsUpdate: !0,
          }));
        e.set("servers", t);
      },
    },
  }),
  Xee = { light: "light", dark: "dark", automatic: "system" };
function Jee() {
  KR(rt.theme());
}
function KR(e) {
  xe.nativeTheme.themeSource = Xee[e];
}
const rt = {
  instance: jt,
  port() {
    return jt.get("port");
  },
  storePort(e) {
    jt.set("port", e), Yn();
  },
  floating() {
    return jt.get("floating");
  },
  storeFloating(e) {
    jt.set("floating", e), Yn();
  },
  historyLimit() {
    return jt.get("historyLimit");
  },
  storeHistoryLimit(e) {
    jt.set("historyLimit", e), Yn();
  },
  editor() {
    return jt.get("editor");
  },
  storeEditor(e) {
    jt.set("editor", e), Yn();
  },
  customEditor() {
    return jt.get("customEditor");
  },
  storeCustomEditor(e) {
    jt.set("customEditor", e), Yn();
  },
  editorString() {
    const e = this.editor(),
      t = this.customEditor();
    return e ? (e === "Custom URL" ? t : Wee[e]) : "";
  },
  displayTimes() {
    return jt.get("displayTimes");
  },
  storeDisplayTimes(e) {
    jt.set("displayTimes", e), Yn();
  },
  scrollOnLog() {
    return jt.get("scrollOnLog");
  },
  storeScrollOnLog(e) {
    jt.set("scrollOnLog", e), Yn();
  },
  colorblindMode() {
    return jt.get("colorblindMode");
  },
  storeColorblindMode(e) {
    jt.set("colorblindMode", e), Yn();
  },
  toggleVisibilityGlobalHotkey() {
    return jt.get("toggleVisibilityGlobalHotkey");
  },
  storeToggleVisibilityGlobalHotkey(e) {
    jt.set("toggleVisibilityGlobalHotkey", e), Yn();
  },
  newScreenGlobalHotkey() {
    return jt.get("newScreenGlobalHotkey");
  },
  storeNewScreenGlobalHotkey(e) {
    jt.set("newScreenGlobalHotkey", e), Yn();
  },
  toggleAlwaysOnTopHotkey() {
    return jt.get("toggleAlwaysOnTopHotkey");
  },
  storeToggleAlwaysOnTopHotkey(e) {
    jt.set("toggleAlwaysOnTopHotkey", e), Yn();
  },
  appVisibility() {
    return jt.get("appVisibility");
  },
  storeAppVisibility(e) {
    jt.set("appVisibility", e), Yn();
  },
  shouldShowDockIcon() {
    return this.appVisibility() === "both";
  },
  newWindow() {
    return jt.get("newWindow");
  },
  storeNewWindow(e) {
    jt.set("newWindow", e), Yn();
  },
  theme() {
    return jt.get("theme");
  },
  storeTheme(e) {
    jt.set("theme", e), KR(e), Yn();
  },
  servers() {
    return jt.get("servers");
  },
  updateServer(e) {
    jt.set("servers", [...this.servers().filter((t) => t.uuid !== e.uuid), e]),
      Yn();
  },
  removeServer(e) {
    jt.set(
      "servers",
      this.servers().filter((t) => t.uuid !== e),
    ),
      Yn();
  },
  sync: Yn,
};
function VR() {
  return {
    port: rt.port(),
    floating: rt.floating(),
    displayTimes: rt.displayTimes(),
    scrollOnLog: rt.scrollOnLog(),
    editor: rt.editor(),
    customEditor: rt.customEditor(),
    colorblindMode: rt.colorblindMode(),
    toggleVisibilityGlobalHotkey: rt.toggleVisibilityGlobalHotkey(),
    newScreenGlobalHotkey: rt.newScreenGlobalHotkey(),
    toggleAlwaysOnTopHotkey: rt.toggleAlwaysOnTopHotkey(),
    newWindow: rt.newWindow(),
    appVisibility: rt.appVisibility(),
    theme: rt.theme(),
    servers: rt.servers(),
    historyLimit: rt.historyLimit(),
  };
}
function Yn() {
  const e = VR();
  xe.BrowserWindow.getAllWindows().forEach((t) =>
    t.webContents.send("preferences-changed", e),
  );
}
xe.ipcMain.handle("get-preferences", () => VR());
xe.ipcMain.on("set-port", (e, t) => {
  rt.storePort(t), nse();
});
function Wb(e) {
  xe.BrowserWindow.getAllWindows().forEach((t) => t.setAlwaysOnTop(e)),
    rt.storeFloating(e),
    zR({ floating: e });
}
xe.ipcMain.on("set-floating", (e, t) => {
  Wb(t);
});
xe.ipcMain.on("set-display-times", (e, t) => {
  rt.storeDisplayTimes(t);
});
xe.ipcMain.on("set-scroll-on-log", (e, t) => {
  rt.storeScrollOnLog(t);
});
xe.ipcMain.on("set-editor", (e, t) => {
  rt.storeEditor(t);
});
xe.ipcMain.on("set-custom-editor", (e, t) => {
  rt.storeCustomEditor(t);
});
xe.ipcMain.on("set-colorblind-mode", (e, t) => {
  rt.storeColorblindMode(t);
});
xe.ipcMain.on("set-toggle-visibility-global-hotkey", (e, t) => {
  rt.storeToggleVisibilityGlobalHotkey(t), qp();
});
xe.ipcMain.on("set-new-screen-global-hotkey", (e, t) => {
  rt.storeNewScreenGlobalHotkey(t), qp();
});
xe.ipcMain.on("set-toggle-always-on-top-hotkey", (e, t) => {
  rt.storeToggleAlwaysOnTopHotkey(t), qp(), zR({ accelerator: t });
});
xe.ipcMain.on("set-new-window", (e, t) => {
  rt.storeNewWindow(t);
});
xe.ipcMain.on("set-app-visibility", (e, t) => {
  const n = t === "both";
  rt.storeAppVisibility(t),
    Yt.forEach(({ window: r }) => {
      var i, a;
      n
        ? ((i = xe.app.dock) == null || i.show(),
          r.setSkipTaskbar(!1),
          r.setFullScreenable(!0))
        : ((a = xe.app.dock) == null || a.hide(),
          r.setSkipTaskbar(!0),
          r.setFullScreenable(!1)),
        r.show();
    });
});
xe.ipcMain.on("set-theme", (e, t) => {
  rt.storeTheme(t);
});
xe.ipcMain.on("set-history-limit", (e, t) => {
  rt.storeHistoryLimit(t);
});
const Zee = `-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAtxFglxsbAwOGzWrJrVc6
RRIE/eDTo2Wmu/sNt93tvwpNlKAvpZ/n2rEbRYrbuZkGRUP5gCJGi5jkhOB5fgEF
9MvTiZa59aOLDaC9Jk98vrGI4igZJAyKQhLJ2JqNH7Ck5IlMVt+cHkEjmjBM/eru
MWrga4uUPUBZAWqwQtHrELdYQd1wdJmlBNbnkAMceBA1tFyQpcZ5GDDJg+Bi7pS8
ef6aInWNBcyT5GIS8yA6kOolGBcSezzobq/oq/RGMouXJEm1xKLeuYfezrl7+HPS
xZgeBk24kTJnXNV9X4y7axZnOHG2CdpvTapl8QhFFbg23dtnFH2qw+u4QlDksBdy
74zJd7ZsAKzOCtsRNJoOm7BPy2TMWzWIlUvYXHcNe3AMdprTUyCGoYO+lqOImqW/
Vns2b19PepehZfoykKB6nsuDcmaSFCsTquY2MzPL331OhFH6bU6ddEx+IT4+7bYG
bpb4dO3Ef6UJwtXrXFPNJHkKyiesbHHsXnbY2z/oQ3rs1XvjVikZXBL4tG/+E0hf
uunAUrVEgZuQQat83V8nYMeVVGka523styIp2pLPaES9qZoynpj5ZrlLRFrBccBc
wu25DlxMVwm+zYSK2FTEUHdow0zxNuH6GHBP/+5vtn10loN9VxNDvFE4ZSI8TA/3
1hch+DWFkDEt6CP68r9FdKcCAwEAAQ==
-----END PUBLIC KEY-----`;
class YR {
  constructor({
    activation_code: t,
    expires_at: n,
    license_key: r,
    licensed_to: i,
    signature: a,
  }) {
    At(this, "license_key");
    At(this, "licensed_to");
    At(this, "activation_code");
    At(this, "expires_at");
    At(this, "signature");
    (this.license_key = r),
      (this.licensed_to = i),
      (this.activation_code = t),
      (this.expires_at = n),
      (this.signature = a);
  }
  get licenseProperties() {
    return {
      activation_code: this.activation_code,
      expires_at: this.expires_at,
      license_key: this.license_key,
      licensed_to: this.licensed_to,
      signature: this.signature,
    };
  }
  isValid() {
    return pr.verify(
      "sha256",
      Buffer.from(
        JSON.stringify({
          activation_code: this.activation_code,
          expires_at: this.expires_at,
          license_key: this.license_key,
          licensed_to: this.licensed_to,
        }),
      ),
      Zee,
      Buffer.from(this.signature, "base64"),
    );
  }
  isExpired() {
    return Date.now() > this.expires_at * 1e3;
  }
  isActive() {
    return this.isValid() && !this.isExpired();
  }
  humanReadableExpiresAt() {
    return new Date(this.expires_at * 1e3).toLocaleDateString();
  }
}
function TA(e) {
  return new URL(`/api${e}`, "https://spatie.be");
}
const Gp = {
    delete: async (e) =>
      fetch(TA(e), {
        method: "DELETE",
        headers: { Accept: "application/json" },
      }),
    post: async (e, t) => {
      var r;
      const n = await fetch(TA(e), {
        method: "POST",
        body: JSON.stringify(t),
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json",
        },
      });
      if (
        !n.ok ||
        ((r = n.headers.get("content-type")) != null && r.includes("text/html"))
      )
        throw n;
      return n.json();
    },
  },
  kn = new Mp({
    name: "licensestorage",
    watch: !0,
    defaults: {
      licenseProperties: "",
      endOfGracePeriod: null,
      amountOfRequests: 0,
      hasActiveLicense: !1,
      isLicenseOverlayLocked: !1,
      errorMessage: null,
    },
  }),
  fn = {
    instance: kn,
    getAmountOfRequests() {
      return kn.get("amountOfRequests");
    },
    setAmountOfRequests(e) {
      kn.set("amountOfRequests", e), Ni();
    },
    getHasActiveLicense() {
      return kn.get("hasActiveLicense");
    },
    setHasActiveLicense(e) {
      kn.set("hasActiveLicense", e), Ni(), e && ate();
    },
    getIsLicenseOverlayLocked() {
      return kn.get("isLicenseOverlayLocked");
    },
    setIsLicenseOverlayLocked(e) {
      kn.set("isLicenseOverlayLocked", e), Ni();
    },
    getErrorMessage() {
      return kn.get("errorMessage");
    },
    setErrorMessage(e) {
      kn.set("errorMessage", e), Ni();
    },
    getSignedLicense() {
      const e = kn.get("licenseProperties");
      if (e) return new YR(JSON.parse(e));
    },
    store(e) {
      kn.set({ licenseProperties: JSON.stringify(e.licenseProperties) }), Ni();
    },
    async delete() {
      const e = this.getSignedLicense();
      e && (await Gp.delete(`/activations/${e.activation_code}`)),
        kn.delete("licenseProperties"),
        kn.delete("endOfGracePeriod"),
        Ni();
    },
    startGracePeriod() {
      const e = new Date(),
        t = e.setDate(e.getDate() + 7);
      kn.set("endOfGracePeriod", t), Ni();
    },
    endGracePeriod() {
      kn.delete("endOfGracePeriod"), Ni();
    },
    getGracePeriod() {
      const e = kn.get("endOfGracePeriod"),
        t = e ? e < new Date().getTime() : !1;
      return {
        isInGracePeriod: !!e,
        endOfGracePeriod: e,
        hasGracePeriodExpired: t,
      };
    },
    setEndOfGracePeriod(e) {
      kn.set("endOfGracePeriod", e), Ni();
    },
  };
function ete() {
  kn.set("amountOfRequests", -9999999999999),
    kn.set("hasActiveLicense", !1),
    kn.set("isLicenseOverlayLocked", !1),
    kn.set("errorMessage", null),
    Ni();
}
ete();
function XR() {
  const e = fn.getSignedLicense();
  return {
    ...(!e
      ? {
          licensed_to: "à¦…à¦­à¦¿à¦•à¦°à§à¦·",
          expiry_date: "à¦†à¦œà§€à¦¬à¦¨ à¦®à§‡à§Ÿà¦¾à¦¦",
          license_key: "à¦•à§‹à¦¨ à¦²à¦¾à¦‡à¦¸à§‡à¦¨à§à¦¸ à¦¨à§‡à¦‡",
          is_expired: false,
        }
      : {}),
    is_overlay_locked: false,
    error_message: fn.getErrorMessage() ?? void 0,
    has_grace_period_expired: fn.getGracePeriod().hasGracePeriodExpired,
    end_of_grace_period: 0,
    has_active_license: !fn.getHasActiveLicense(),
    amount_of_requests: fn.getAmountOfRequests(),
  };
}
function Ni() {
  const e = XR();
  xe.BrowserWindow.getAllWindows().forEach((t) =>
    t.webContents.send("license-changed", e),
  );
}
xe.ipcMain.handle("get-license", () => XR());
const Js = new Mp({
  name: "usage",
  defaults: {
    hasReceivedRayRequest: !1,
    mainWindowBounds: {},
    reportedVersion: "0.0.0",
  },
});
let NA = Js.get("hasReceivedRayRequest");
function tte() {
  NA || (Js.set("hasReceivedRayRequest", !0), (NA = !0));
}
function JR() {
  return Js.get("mainWindowBounds");
}
function nte(e) {
  Js.set("mainWindowBounds", e);
}
function rte() {
  return Js.get("reportedVersion");
}
function ite(e) {
  Js.set("reportedVersion", e);
}
xe.ipcMain.handle(
  "get-is-first-time-user",
  () => !Js.get("hasReceivedRayRequest"),
);
async function ate() {
  var n;
  const e = xe.app.getVersion();
  if (e === rte()) return;
  const t = (n = fn.getSignedLicense()) == null ? void 0 : n.activation_code;
  if (t) {
    try {
      await Gp.post(`/activations/${t}/version`, {
        current_version: e,
        arch: process.arch,
        platform: process.platform,
        os_version: Fr.version(),
      });
    } catch {}
    ite(e);
  }
}
const ste = Gl.join(__dirname, "../preload/index.js");
function Qp() {
  return {
    ...ZR(),
    width: 700,
    height: 600,
    minWidth: 400,
    minHeight: 140,
    titleBarStyle: "hiddenInset",
    skipTaskbar: !0,
    show: !1,
    webPreferences: { preload: ste },
  };
}
function ZR() {
  var t;
  const e =
    ((t =
      xe.BrowserWindow.getFocusedWindow() ||
      xe.BrowserWindow.getAllWindows()[0]) == null
      ? void 0
      : t.getBounds()) || JR();
  return (e.x = e.x + 20), (e.y = e.y + 20), e;
}
function Wp(e, t) {
  if (process.env.VITE_DEV_SERVER_URL) {
    const n = new URLSearchParams(JSON.parse(JSON.stringify(t))),
      r = new URL(process.env.VITE_DEV_SERVER_URL);
    (r.search = n.toString()), e.loadURL(r.toString());
  } else e.loadFile(Gl.join(process.env.DIST, "index.html"), { query: t });
}
function zp(e, t = !0) {
  D0(e),
    cte(e),
    rt.floating() && e.setAlwaysOnTop(!0),
    e.once("ready-to-show", () => {
      if (!Hp && t) return e.show();
      e.showInactive();
    });
}
function D0(e, t = !0) {
  t &&
    (xe.screen.on("display-removed", () => D0(e, !1)),
    xe.screen.on("display-metrics-changed", () => D0(e, !1))),
    !e.isDestroyed() && (ote(e.getBounds()) || e.center());
}
function ote(e) {
  const t = xe.screen.getDisplayMatching(e),
    n = t.bounds.x <= e.x,
    r = t.bounds.x + t.bounds.width >= e.x + e.width,
    i = t.bounds.y <= e.y,
    a = t.bounds.y + t.bounds.height >= e.y + e.height;
  return n && r && i && a;
}
function cte(e) {
  e.webContents.setWindowOpenHandler(
    ({ url: t }) => (L0(t), { action: "deny" }),
  ),
    e.webContents.on("will-navigate", async (t, n) => {
      (Hp && n.includes("localhost")) || (t.preventDefault(), await L0(n));
    });
}
async function L0(e) {
  e.startsWith("https:") && (await xe.shell.openExternal(e));
}
var ek = { exports: {} },
  zb = {
    newInvalidAsn1Error: function (e) {
      var t = new Error();
      return (t.name = "InvalidAsn1Error"), (t.message = e || ""), t;
    },
  },
  Kb = {
    EOC: 0,
    Boolean: 1,
    Integer: 2,
    BitString: 3,
    OctetString: 4,
    Null: 5,
    OID: 6,
    ObjectDescriptor: 7,
    External: 8,
    Real: 9,
    Enumeration: 10,
    PDV: 11,
    Utf8String: 12,
    RelativeOID: 13,
    Sequence: 16,
    Set: 17,
    NumericString: 18,
    PrintableString: 19,
    T61String: 20,
    VideotexString: 21,
    IA5String: 22,
    UTCTime: 23,
    GeneralizedTime: 24,
    GraphicString: 25,
    VisibleString: 26,
    GeneralString: 28,
    UniversalString: 29,
    CharacterString: 30,
    BMPString: 31,
    Constructor: 32,
    Context: 128,
  },
  lte = gc,
  tk = Xa().Buffer,
  bu = Kb,
  ute = zb,
  lc = ute.newInvalidAsn1Error;
function Cr(e) {
  if (!e || !tk.isBuffer(e)) throw new TypeError("data must be a node Buffer");
  (this._buf = e), (this._size = e.length), (this._len = 0), (this._offset = 0);
}
Object.defineProperty(Cr.prototype, "length", {
  enumerable: !0,
  get: function () {
    return this._len;
  },
});
Object.defineProperty(Cr.prototype, "offset", {
  enumerable: !0,
  get: function () {
    return this._offset;
  },
});
Object.defineProperty(Cr.prototype, "remain", {
  get: function () {
    return this._size - this._offset;
  },
});
Object.defineProperty(Cr.prototype, "buffer", {
  get: function () {
    return this._buf.slice(this._offset);
  },
});
Cr.prototype.readByte = function (e) {
  if (this._size - this._offset < 1) return null;
  var t = this._buf[this._offset] & 255;
  return e || (this._offset += 1), t;
};
Cr.prototype.peek = function () {
  return this.readByte(!0);
};
Cr.prototype.readLength = function (e) {
  if ((e === void 0 && (e = this._offset), e >= this._size)) return null;
  var t = this._buf[e++] & 255;
  if (t === null) return null;
  if ((t & 128) === 128) {
    if (((t &= 127), t === 0)) throw lc("Indefinite length not supported");
    if (t > 4) throw lc("encoding too long");
    if (this._size - e < t) return null;
    this._len = 0;
    for (var n = 0; n < t; n++)
      this._len = (this._len << 8) + (this._buf[e++] & 255);
  } else this._len = t;
  return e;
};
Cr.prototype.readSequence = function (e) {
  var t = this.peek();
  if (t === null) return null;
  if (e !== void 0 && e !== t)
    throw lc("Expected 0x" + e.toString(16) + ": got 0x" + t.toString(16));
  var n = this.readLength(this._offset + 1);
  return n === null ? null : ((this._offset = n), t);
};
Cr.prototype.readInt = function () {
  return this._readTag(bu.Integer);
};
Cr.prototype.readBoolean = function () {
  return this._readTag(bu.Boolean) !== 0;
};
Cr.prototype.readEnumeration = function () {
  return this._readTag(bu.Enumeration);
};
Cr.prototype.readString = function (e, t) {
  e || (e = bu.OctetString);
  var n = this.peek();
  if (n === null) return null;
  if (n !== e)
    throw lc("Expected 0x" + e.toString(16) + ": got 0x" + n.toString(16));
  var r = this.readLength(this._offset + 1);
  if (r === null || this.length > this._size - r) return null;
  if (((this._offset = r), this.length === 0)) return t ? tk.alloc(0) : "";
  var i = this._buf.slice(this._offset, this._offset + this.length);
  return (this._offset += this.length), t ? i : i.toString("utf8");
};
Cr.prototype.readOID = function (e) {
  e || (e = bu.OID);
  var t = this.readString(e, !0);
  if (t === null) return null;
  for (var n = [], r = 0, i = 0; i < t.length; i++) {
    var a = t[i] & 255;
    (r <<= 7), (r += a & 127), a & 128 || (n.push(r), (r = 0));
  }
  return (
    (r = n.shift()), n.unshift(r % 40), n.unshift((r / 40) >> 0), n.join(".")
  );
};
Cr.prototype._readTag = function (e) {
  lte.ok(e !== void 0);
  var t = this.peek();
  if (t === null) return null;
  if (t !== e)
    throw lc("Expected 0x" + e.toString(16) + ": got 0x" + t.toString(16));
  var n = this.readLength(this._offset + 1);
  if (n === null) return null;
  if (this.length > 4) throw lc("Integer too long: " + this.length);
  if (this.length > this._size - n) return null;
  this._offset = n;
  for (var r = this._buf[this._offset], i = 0, a = 0; a < this.length; a++)
    (i <<= 8), (i |= this._buf[this._offset++] & 255);
  return (r & 128) === 128 && a !== 4 && (i -= 1 << (a * 8)), i >> 0;
};
var fte = Cr,
  Ma = gc,
  Kp = Xa().Buffer,
  Va = Kb,
  dte = zb,
  Vp = dte.newInvalidAsn1Error,
  pte = { size: 1024, growthFactor: 8 };
function hte(e, t) {
  Ma.ok(e),
    Ma.equal(typeof e, "object"),
    Ma.ok(t),
    Ma.equal(typeof t, "object");
  var n = Object.getOwnPropertyNames(e);
  return (
    n.forEach(function (r) {
      if (!t[r]) {
        var i = Object.getOwnPropertyDescriptor(e, r);
        Object.defineProperty(t, r, i);
      }
    }),
    t
  );
}
function mr(e) {
  (e = hte(pte, e || {})),
    (this._buf = Kp.alloc(e.size || 1024)),
    (this._size = this._buf.length),
    (this._offset = 0),
    (this._options = e),
    (this._seq = []);
}
Object.defineProperty(mr.prototype, "buffer", {
  get: function () {
    if (this._seq.length) throw Vp(this._seq.length + " unended sequence(s)");
    return this._buf.slice(0, this._offset);
  },
});
mr.prototype.writeByte = function (e) {
  if (typeof e != "number") throw new TypeError("argument must be a Number");
  this._ensure(1), (this._buf[this._offset++] = e);
};
mr.prototype.writeInt = function (e, t) {
  if (typeof e != "number") throw new TypeError("argument must be a Number");
  typeof t != "number" && (t = Va.Integer);
  for (
    var n = 4;
    (!(e & 4286578688) || (e & 4286578688) === -8388608) && n > 1;

  )
    n--, (e <<= 8);
  if (n > 4) throw Vp("BER ints cannot be > 0xffffffff");
  for (
    this._ensure(2 + n),
      this._buf[this._offset++] = t,
      this._buf[this._offset++] = n;
    n-- > 0;

  )
    (this._buf[this._offset++] = (e & 4278190080) >>> 24), (e <<= 8);
};
mr.prototype.writeNull = function () {
  this.writeByte(Va.Null), this.writeByte(0);
};
mr.prototype.writeEnumeration = function (e, t) {
  if (typeof e != "number") throw new TypeError("argument must be a Number");
  return typeof t != "number" && (t = Va.Enumeration), this.writeInt(e, t);
};
mr.prototype.writeBoolean = function (e, t) {
  if (typeof e != "boolean") throw new TypeError("argument must be a Boolean");
  typeof t != "number" && (t = Va.Boolean),
    this._ensure(3),
    (this._buf[this._offset++] = t),
    (this._buf[this._offset++] = 1),
    (this._buf[this._offset++] = e ? 255 : 0);
};
mr.prototype.writeString = function (e, t) {
  if (typeof e != "string")
    throw new TypeError("argument must be a string (was: " + typeof e + ")");
  typeof t != "number" && (t = Va.OctetString);
  var n = Kp.byteLength(e);
  this.writeByte(t),
    this.writeLength(n),
    n &&
      (this._ensure(n), this._buf.write(e, this._offset), (this._offset += n));
};
mr.prototype.writeBuffer = function (e, t) {
  if (typeof t != "number") throw new TypeError("tag must be a number");
  if (!Kp.isBuffer(e)) throw new TypeError("argument must be a buffer");
  this.writeByte(t),
    this.writeLength(e.length),
    this._ensure(e.length),
    e.copy(this._buf, this._offset, 0, e.length),
    (this._offset += e.length);
};
mr.prototype.writeStringArray = function (e) {
  if (!e instanceof Array)
    throw new TypeError("argument must be an Array[String]");
  var t = this;
  e.forEach(function (n) {
    t.writeString(n);
  });
};
mr.prototype.writeOID = function (e, t) {
  if (typeof e != "string") throw new TypeError("argument must be a string");
  if ((typeof t != "number" && (t = Va.OID), !/^([0-9]+\.){3,}[0-9]+$/.test(e)))
    throw new Error("argument is not a valid OID string");
  function n(s, o) {
    o < 128
      ? s.push(o)
      : o < 16384
      ? (s.push((o >>> 7) | 128), s.push(o & 127))
      : o < 2097152
      ? (s.push((o >>> 14) | 128),
        s.push(((o >>> 7) | 128) & 255),
        s.push(o & 127))
      : o < 268435456
      ? (s.push((o >>> 21) | 128),
        s.push(((o >>> 14) | 128) & 255),
        s.push(((o >>> 7) | 128) & 255),
        s.push(o & 127))
      : (s.push(((o >>> 28) | 128) & 255),
        s.push(((o >>> 21) | 128) & 255),
        s.push(((o >>> 14) | 128) & 255),
        s.push(((o >>> 7) | 128) & 255),
        s.push(o & 127));
  }
  var r = e.split("."),
    i = [];
  i.push(parseInt(r[0], 10) * 40 + parseInt(r[1], 10)),
    r.slice(2).forEach(function (s) {
      n(i, parseInt(s, 10));
    });
  var a = this;
  this._ensure(2 + i.length),
    this.writeByte(t),
    this.writeLength(i.length),
    i.forEach(function (s) {
      a.writeByte(s);
    });
};
mr.prototype.writeLength = function (e) {
  if (typeof e != "number") throw new TypeError("argument must be a Number");
  if ((this._ensure(4), e <= 127)) this._buf[this._offset++] = e;
  else if (e <= 255)
    (this._buf[this._offset++] = 129), (this._buf[this._offset++] = e);
  else if (e <= 65535)
    (this._buf[this._offset++] = 130),
      (this._buf[this._offset++] = e >> 8),
      (this._buf[this._offset++] = e);
  else if (e <= 16777215)
    (this._buf[this._offset++] = 131),
      (this._buf[this._offset++] = e >> 16),
      (this._buf[this._offset++] = e >> 8),
      (this._buf[this._offset++] = e);
  else throw Vp("Length too long (> 4 bytes)");
};
mr.prototype.startSequence = function (e) {
  typeof e != "number" && (e = Va.Sequence | Va.Constructor),
    this.writeByte(e),
    this._seq.push(this._offset),
    this._ensure(3),
    (this._offset += 3);
};
mr.prototype.endSequence = function () {
  var e = this._seq.pop(),
    t = e + 3,
    n = this._offset - t;
  if (n <= 127) this._shift(t, n, -2), (this._buf[e] = n);
  else if (n <= 255)
    this._shift(t, n, -1), (this._buf[e] = 129), (this._buf[e + 1] = n);
  else if (n <= 65535)
    (this._buf[e] = 130), (this._buf[e + 1] = n >> 8), (this._buf[e + 2] = n);
  else if (n <= 16777215)
    this._shift(t, n, 1),
      (this._buf[e] = 131),
      (this._buf[e + 1] = n >> 16),
      (this._buf[e + 2] = n >> 8),
      (this._buf[e + 3] = n);
  else throw Vp("Sequence too long");
};
mr.prototype._shift = function (e, t, n) {
  Ma.ok(e !== void 0),
    Ma.ok(t !== void 0),
    Ma.ok(n),
    this._buf.copy(this._buf, e + n, e, e + t),
    (this._offset += n);
};
mr.prototype._ensure = function (e) {
  if ((Ma.ok(e), this._size - this._offset < e)) {
    var t = this._size * this._options.growthFactor;
    t - this._offset < e && (t += e);
    var n = Kp.alloc(t);
    this._buf.copy(n, 0, 0, this._offset), (this._buf = n), (this._size = t);
  }
};
var mte = mr;
(function (e) {
  var t = zb,
    n = Kb,
    r = fte,
    i = mte;
  e.exports = { Reader: r, Writer: i };
  for (var a in n) n.hasOwnProperty(a) && (e.exports[a] = n[a]);
  for (var s in t) t.hasOwnProperty(s) && (e.exports[s] = t[s]);
})(ek);
var gte = ek.exports,
  Qm = gte,
  Yp = { Ber: Qm, BerReader: Qm.Reader, BerWriter: Qm.Writer },
  nk = { exports: {} };
(function (e) {
  (function (t) {
    var n = function (P) {
        var C,
          $ = new Float64Array(16);
        if (P) for (C = 0; C < P.length; C++) $[C] = P[C];
        return $;
      },
      r = function () {
        throw new Error("no PRNG");
      },
      i = new Uint8Array(16),
      a = new Uint8Array(32);
    a[0] = 9;
    var s = n(),
      o = n([1]),
      c = n([56129, 1]),
      l = n([
        30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505,
        36039, 65139, 11119, 27886, 20995,
      ]),
      f = n([
        61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010,
        6542, 64743, 22239, 55772, 9222,
      ]),
      u = n([
        54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982,
        57905, 49316, 21502, 52590, 14035, 8553,
      ]),
      d = n([
        26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214,
        26214, 26214, 26214, 26214, 26214, 26214,
      ]),
      p = n([
        41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153,
        11085, 57099, 20417, 9344, 11139,
      ]);
    function h(P, C, $, b) {
      (P[C] = ($ >> 24) & 255),
        (P[C + 1] = ($ >> 16) & 255),
        (P[C + 2] = ($ >> 8) & 255),
        (P[C + 3] = $ & 255),
        (P[C + 4] = (b >> 24) & 255),
        (P[C + 5] = (b >> 16) & 255),
        (P[C + 6] = (b >> 8) & 255),
        (P[C + 7] = b & 255);
    }
    function m(P, C, $, b, D) {
      var K,
        se = 0;
      for (K = 0; K < D; K++) se |= P[C + K] ^ $[b + K];
      return (1 & ((se - 1) >>> 8)) - 1;
    }
    function g(P, C, $, b) {
      return m(P, C, $, b, 16);
    }
    function v(P, C, $, b) {
      return m(P, C, $, b, 32);
    }
    function y(P, C, $, b) {
      for (
        var D =
            (b[0] & 255) |
            ((b[1] & 255) << 8) |
            ((b[2] & 255) << 16) |
            ((b[3] & 255) << 24),
          K =
            ($[0] & 255) |
            (($[1] & 255) << 8) |
            (($[2] & 255) << 16) |
            (($[3] & 255) << 24),
          se =
            ($[4] & 255) |
            (($[5] & 255) << 8) |
            (($[6] & 255) << 16) |
            (($[7] & 255) << 24),
          pe =
            ($[8] & 255) |
            (($[9] & 255) << 8) |
            (($[10] & 255) << 16) |
            (($[11] & 255) << 24),
          we =
            ($[12] & 255) |
            (($[13] & 255) << 8) |
            (($[14] & 255) << 16) |
            (($[15] & 255) << 24),
          Re =
            (b[4] & 255) |
            ((b[5] & 255) << 8) |
            ((b[6] & 255) << 16) |
            ((b[7] & 255) << 24),
          ke =
            (C[0] & 255) |
            ((C[1] & 255) << 8) |
            ((C[2] & 255) << 16) |
            ((C[3] & 255) << 24),
          je =
            (C[4] & 255) |
            ((C[5] & 255) << 8) |
            ((C[6] & 255) << 16) |
            ((C[7] & 255) << 24),
          Te =
            (C[8] & 255) |
            ((C[9] & 255) << 8) |
            ((C[10] & 255) << 16) |
            ((C[11] & 255) << 24),
          Me =
            (C[12] & 255) |
            ((C[13] & 255) << 8) |
            ((C[14] & 255) << 16) |
            ((C[15] & 255) << 24),
          Ne =
            (b[8] & 255) |
            ((b[9] & 255) << 8) |
            ((b[10] & 255) << 16) |
            ((b[11] & 255) << 24),
          Ue =
            ($[16] & 255) |
            (($[17] & 255) << 8) |
            (($[18] & 255) << 16) |
            (($[19] & 255) << 24),
          qe =
            ($[20] & 255) |
            (($[21] & 255) << 8) |
            (($[22] & 255) << 16) |
            (($[23] & 255) << 24),
          Fe =
            ($[24] & 255) |
            (($[25] & 255) << 8) |
            (($[26] & 255) << 16) |
            (($[27] & 255) << 24),
          Je =
            ($[28] & 255) |
            (($[29] & 255) << 8) |
            (($[30] & 255) << 16) |
            (($[31] & 255) << 24),
          Ke =
            (b[12] & 255) |
            ((b[13] & 255) << 8) |
            ((b[14] & 255) << 16) |
            ((b[15] & 255) << 24),
          Be = D,
          He = K,
          De = se,
          Le = pe,
          Pe = we,
          Oe = Re,
          ge = ke,
          ve = je,
          Ie = Te,
          Se = Me,
          Ae = Ne,
          Ce = Ue,
          Ve = qe,
          it = Fe,
          mt = Je,
          at = Ke,
          ae,
          _t = 0;
        _t < 20;
        _t += 2
      )
        (ae = (Be + Ve) | 0),
          (Pe ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Pe + Be) | 0),
          (Ie ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (Ie + Pe) | 0),
          (Ve ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Ve + Ie) | 0),
          (Be ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Oe + He) | 0),
          (Se ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Se + Oe) | 0),
          (it ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (it + Se) | 0),
          (He ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (He + it) | 0),
          (Oe ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Ae + ge) | 0),
          (mt ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (mt + Ae) | 0),
          (De ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (De + mt) | 0),
          (ge ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (ge + De) | 0),
          (Ae ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (at + Ce) | 0),
          (Le ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Le + at) | 0),
          (ve ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (ve + Le) | 0),
          (Ce ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Ce + ve) | 0),
          (at ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Be + Le) | 0),
          (He ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (He + Be) | 0),
          (De ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (De + He) | 0),
          (Le ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Le + De) | 0),
          (Be ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Oe + Pe) | 0),
          (ge ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (ge + Oe) | 0),
          (ve ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (ve + ge) | 0),
          (Pe ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Pe + ve) | 0),
          (Oe ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Ae + Se) | 0),
          (Ce ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Ce + Ae) | 0),
          (Ie ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (Ie + Ce) | 0),
          (Se ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Se + Ie) | 0),
          (Ae ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (at + mt) | 0),
          (Ve ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Ve + at) | 0),
          (it ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (it + Ve) | 0),
          (mt ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (mt + it) | 0),
          (at ^= (ae << 18) | (ae >>> (32 - 18)));
      (Be = (Be + D) | 0),
        (He = (He + K) | 0),
        (De = (De + se) | 0),
        (Le = (Le + pe) | 0),
        (Pe = (Pe + we) | 0),
        (Oe = (Oe + Re) | 0),
        (ge = (ge + ke) | 0),
        (ve = (ve + je) | 0),
        (Ie = (Ie + Te) | 0),
        (Se = (Se + Me) | 0),
        (Ae = (Ae + Ne) | 0),
        (Ce = (Ce + Ue) | 0),
        (Ve = (Ve + qe) | 0),
        (it = (it + Fe) | 0),
        (mt = (mt + Je) | 0),
        (at = (at + Ke) | 0),
        (P[0] = (Be >>> 0) & 255),
        (P[1] = (Be >>> 8) & 255),
        (P[2] = (Be >>> 16) & 255),
        (P[3] = (Be >>> 24) & 255),
        (P[4] = (He >>> 0) & 255),
        (P[5] = (He >>> 8) & 255),
        (P[6] = (He >>> 16) & 255),
        (P[7] = (He >>> 24) & 255),
        (P[8] = (De >>> 0) & 255),
        (P[9] = (De >>> 8) & 255),
        (P[10] = (De >>> 16) & 255),
        (P[11] = (De >>> 24) & 255),
        (P[12] = (Le >>> 0) & 255),
        (P[13] = (Le >>> 8) & 255),
        (P[14] = (Le >>> 16) & 255),
        (P[15] = (Le >>> 24) & 255),
        (P[16] = (Pe >>> 0) & 255),
        (P[17] = (Pe >>> 8) & 255),
        (P[18] = (Pe >>> 16) & 255),
        (P[19] = (Pe >>> 24) & 255),
        (P[20] = (Oe >>> 0) & 255),
        (P[21] = (Oe >>> 8) & 255),
        (P[22] = (Oe >>> 16) & 255),
        (P[23] = (Oe >>> 24) & 255),
        (P[24] = (ge >>> 0) & 255),
        (P[25] = (ge >>> 8) & 255),
        (P[26] = (ge >>> 16) & 255),
        (P[27] = (ge >>> 24) & 255),
        (P[28] = (ve >>> 0) & 255),
        (P[29] = (ve >>> 8) & 255),
        (P[30] = (ve >>> 16) & 255),
        (P[31] = (ve >>> 24) & 255),
        (P[32] = (Ie >>> 0) & 255),
        (P[33] = (Ie >>> 8) & 255),
        (P[34] = (Ie >>> 16) & 255),
        (P[35] = (Ie >>> 24) & 255),
        (P[36] = (Se >>> 0) & 255),
        (P[37] = (Se >>> 8) & 255),
        (P[38] = (Se >>> 16) & 255),
        (P[39] = (Se >>> 24) & 255),
        (P[40] = (Ae >>> 0) & 255),
        (P[41] = (Ae >>> 8) & 255),
        (P[42] = (Ae >>> 16) & 255),
        (P[43] = (Ae >>> 24) & 255),
        (P[44] = (Ce >>> 0) & 255),
        (P[45] = (Ce >>> 8) & 255),
        (P[46] = (Ce >>> 16) & 255),
        (P[47] = (Ce >>> 24) & 255),
        (P[48] = (Ve >>> 0) & 255),
        (P[49] = (Ve >>> 8) & 255),
        (P[50] = (Ve >>> 16) & 255),
        (P[51] = (Ve >>> 24) & 255),
        (P[52] = (it >>> 0) & 255),
        (P[53] = (it >>> 8) & 255),
        (P[54] = (it >>> 16) & 255),
        (P[55] = (it >>> 24) & 255),
        (P[56] = (mt >>> 0) & 255),
        (P[57] = (mt >>> 8) & 255),
        (P[58] = (mt >>> 16) & 255),
        (P[59] = (mt >>> 24) & 255),
        (P[60] = (at >>> 0) & 255),
        (P[61] = (at >>> 8) & 255),
        (P[62] = (at >>> 16) & 255),
        (P[63] = (at >>> 24) & 255);
    }
    function _(P, C, $, b) {
      for (
        var D =
            (b[0] & 255) |
            ((b[1] & 255) << 8) |
            ((b[2] & 255) << 16) |
            ((b[3] & 255) << 24),
          K =
            ($[0] & 255) |
            (($[1] & 255) << 8) |
            (($[2] & 255) << 16) |
            (($[3] & 255) << 24),
          se =
            ($[4] & 255) |
            (($[5] & 255) << 8) |
            (($[6] & 255) << 16) |
            (($[7] & 255) << 24),
          pe =
            ($[8] & 255) |
            (($[9] & 255) << 8) |
            (($[10] & 255) << 16) |
            (($[11] & 255) << 24),
          we =
            ($[12] & 255) |
            (($[13] & 255) << 8) |
            (($[14] & 255) << 16) |
            (($[15] & 255) << 24),
          Re =
            (b[4] & 255) |
            ((b[5] & 255) << 8) |
            ((b[6] & 255) << 16) |
            ((b[7] & 255) << 24),
          ke =
            (C[0] & 255) |
            ((C[1] & 255) << 8) |
            ((C[2] & 255) << 16) |
            ((C[3] & 255) << 24),
          je =
            (C[4] & 255) |
            ((C[5] & 255) << 8) |
            ((C[6] & 255) << 16) |
            ((C[7] & 255) << 24),
          Te =
            (C[8] & 255) |
            ((C[9] & 255) << 8) |
            ((C[10] & 255) << 16) |
            ((C[11] & 255) << 24),
          Me =
            (C[12] & 255) |
            ((C[13] & 255) << 8) |
            ((C[14] & 255) << 16) |
            ((C[15] & 255) << 24),
          Ne =
            (b[8] & 255) |
            ((b[9] & 255) << 8) |
            ((b[10] & 255) << 16) |
            ((b[11] & 255) << 24),
          Ue =
            ($[16] & 255) |
            (($[17] & 255) << 8) |
            (($[18] & 255) << 16) |
            (($[19] & 255) << 24),
          qe =
            ($[20] & 255) |
            (($[21] & 255) << 8) |
            (($[22] & 255) << 16) |
            (($[23] & 255) << 24),
          Fe =
            ($[24] & 255) |
            (($[25] & 255) << 8) |
            (($[26] & 255) << 16) |
            (($[27] & 255) << 24),
          Je =
            ($[28] & 255) |
            (($[29] & 255) << 8) |
            (($[30] & 255) << 16) |
            (($[31] & 255) << 24),
          Ke =
            (b[12] & 255) |
            ((b[13] & 255) << 8) |
            ((b[14] & 255) << 16) |
            ((b[15] & 255) << 24),
          Be = D,
          He = K,
          De = se,
          Le = pe,
          Pe = we,
          Oe = Re,
          ge = ke,
          ve = je,
          Ie = Te,
          Se = Me,
          Ae = Ne,
          Ce = Ue,
          Ve = qe,
          it = Fe,
          mt = Je,
          at = Ke,
          ae,
          _t = 0;
        _t < 20;
        _t += 2
      )
        (ae = (Be + Ve) | 0),
          (Pe ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Pe + Be) | 0),
          (Ie ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (Ie + Pe) | 0),
          (Ve ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Ve + Ie) | 0),
          (Be ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Oe + He) | 0),
          (Se ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Se + Oe) | 0),
          (it ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (it + Se) | 0),
          (He ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (He + it) | 0),
          (Oe ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Ae + ge) | 0),
          (mt ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (mt + Ae) | 0),
          (De ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (De + mt) | 0),
          (ge ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (ge + De) | 0),
          (Ae ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (at + Ce) | 0),
          (Le ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Le + at) | 0),
          (ve ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (ve + Le) | 0),
          (Ce ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Ce + ve) | 0),
          (at ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Be + Le) | 0),
          (He ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (He + Be) | 0),
          (De ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (De + He) | 0),
          (Le ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Le + De) | 0),
          (Be ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Oe + Pe) | 0),
          (ge ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (ge + Oe) | 0),
          (ve ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (ve + ge) | 0),
          (Pe ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Pe + ve) | 0),
          (Oe ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (Ae + Se) | 0),
          (Ce ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Ce + Ae) | 0),
          (Ie ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (Ie + Ce) | 0),
          (Se ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (Se + Ie) | 0),
          (Ae ^= (ae << 18) | (ae >>> (32 - 18))),
          (ae = (at + mt) | 0),
          (Ve ^= (ae << 7) | (ae >>> (32 - 7))),
          (ae = (Ve + at) | 0),
          (it ^= (ae << 9) | (ae >>> (32 - 9))),
          (ae = (it + Ve) | 0),
          (mt ^= (ae << 13) | (ae >>> (32 - 13))),
          (ae = (mt + it) | 0),
          (at ^= (ae << 18) | (ae >>> (32 - 18)));
      (P[0] = (Be >>> 0) & 255),
        (P[1] = (Be >>> 8) & 255),
        (P[2] = (Be >>> 16) & 255),
        (P[3] = (Be >>> 24) & 255),
        (P[4] = (Oe >>> 0) & 255),
        (P[5] = (Oe >>> 8) & 255),
        (P[6] = (Oe >>> 16) & 255),
        (P[7] = (Oe >>> 24) & 255),
        (P[8] = (Ae >>> 0) & 255),
        (P[9] = (Ae >>> 8) & 255),
        (P[10] = (Ae >>> 16) & 255),
        (P[11] = (Ae >>> 24) & 255),
        (P[12] = (at >>> 0) & 255),
        (P[13] = (at >>> 8) & 255),
        (P[14] = (at >>> 16) & 255),
        (P[15] = (at >>> 24) & 255),
        (P[16] = (ge >>> 0) & 255),
        (P[17] = (ge >>> 8) & 255),
        (P[18] = (ge >>> 16) & 255),
        (P[19] = (ge >>> 24) & 255),
        (P[20] = (ve >>> 0) & 255),
        (P[21] = (ve >>> 8) & 255),
        (P[22] = (ve >>> 16) & 255),
        (P[23] = (ve >>> 24) & 255),
        (P[24] = (Ie >>> 0) & 255),
        (P[25] = (Ie >>> 8) & 255),
        (P[26] = (Ie >>> 16) & 255),
        (P[27] = (Ie >>> 24) & 255),
        (P[28] = (Se >>> 0) & 255),
        (P[29] = (Se >>> 8) & 255),
        (P[30] = (Se >>> 16) & 255),
        (P[31] = (Se >>> 24) & 255);
    }
    function E(P, C, $, b) {
      y(P, C, $, b);
    }
    function R(P, C, $, b) {
      _(P, C, $, b);
    }
    var A = new Uint8Array([
      101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107,
    ]);
    function I(P, C, $, b, D, K, se) {
      var pe = new Uint8Array(16),
        we = new Uint8Array(64),
        Re,
        ke;
      for (ke = 0; ke < 16; ke++) pe[ke] = 0;
      for (ke = 0; ke < 8; ke++) pe[ke] = K[ke];
      for (; D >= 64; ) {
        for (E(we, pe, se, A), ke = 0; ke < 64; ke++)
          P[C + ke] = $[b + ke] ^ we[ke];
        for (Re = 1, ke = 8; ke < 16; ke++)
          (Re = (Re + (pe[ke] & 255)) | 0), (pe[ke] = Re & 255), (Re >>>= 8);
        (D -= 64), (C += 64), (b += 64);
      }
      if (D > 0)
        for (E(we, pe, se, A), ke = 0; ke < D; ke++)
          P[C + ke] = $[b + ke] ^ we[ke];
      return 0;
    }
    function S(P, C, $, b, D) {
      var K = new Uint8Array(16),
        se = new Uint8Array(64),
        pe,
        we;
      for (we = 0; we < 16; we++) K[we] = 0;
      for (we = 0; we < 8; we++) K[we] = b[we];
      for (; $ >= 64; ) {
        for (E(se, K, D, A), we = 0; we < 64; we++) P[C + we] = se[we];
        for (pe = 1, we = 8; we < 16; we++)
          (pe = (pe + (K[we] & 255)) | 0), (K[we] = pe & 255), (pe >>>= 8);
        ($ -= 64), (C += 64);
      }
      if ($ > 0) for (E(se, K, D, A), we = 0; we < $; we++) P[C + we] = se[we];
      return 0;
    }
    function w(P, C, $, b, D) {
      var K = new Uint8Array(32);
      R(K, b, D, A);
      for (var se = new Uint8Array(8), pe = 0; pe < 8; pe++)
        se[pe] = b[pe + 16];
      return S(P, C, $, se, K);
    }
    function O(P, C, $, b, D, K, se) {
      var pe = new Uint8Array(32);
      R(pe, K, se, A);
      for (var we = new Uint8Array(8), Re = 0; Re < 8; Re++)
        we[Re] = K[Re + 16];
      return I(P, C, $, b, D, we, pe);
    }
    var Q = function (P) {
      (this.buffer = new Uint8Array(16)),
        (this.r = new Uint16Array(10)),
        (this.h = new Uint16Array(10)),
        (this.pad = new Uint16Array(8)),
        (this.leftover = 0),
        (this.fin = 0);
      var C, $, b, D, K, se, pe, we;
      (C = (P[0] & 255) | ((P[1] & 255) << 8)),
        (this.r[0] = C & 8191),
        ($ = (P[2] & 255) | ((P[3] & 255) << 8)),
        (this.r[1] = ((C >>> 13) | ($ << 3)) & 8191),
        (b = (P[4] & 255) | ((P[5] & 255) << 8)),
        (this.r[2] = (($ >>> 10) | (b << 6)) & 7939),
        (D = (P[6] & 255) | ((P[7] & 255) << 8)),
        (this.r[3] = ((b >>> 7) | (D << 9)) & 8191),
        (K = (P[8] & 255) | ((P[9] & 255) << 8)),
        (this.r[4] = ((D >>> 4) | (K << 12)) & 255),
        (this.r[5] = (K >>> 1) & 8190),
        (se = (P[10] & 255) | ((P[11] & 255) << 8)),
        (this.r[6] = ((K >>> 14) | (se << 2)) & 8191),
        (pe = (P[12] & 255) | ((P[13] & 255) << 8)),
        (this.r[7] = ((se >>> 11) | (pe << 5)) & 8065),
        (we = (P[14] & 255) | ((P[15] & 255) << 8)),
        (this.r[8] = ((pe >>> 8) | (we << 8)) & 8191),
        (this.r[9] = (we >>> 5) & 127),
        (this.pad[0] = (P[16] & 255) | ((P[17] & 255) << 8)),
        (this.pad[1] = (P[18] & 255) | ((P[19] & 255) << 8)),
        (this.pad[2] = (P[20] & 255) | ((P[21] & 255) << 8)),
        (this.pad[3] = (P[22] & 255) | ((P[23] & 255) << 8)),
        (this.pad[4] = (P[24] & 255) | ((P[25] & 255) << 8)),
        (this.pad[5] = (P[26] & 255) | ((P[27] & 255) << 8)),
        (this.pad[6] = (P[28] & 255) | ((P[29] & 255) << 8)),
        (this.pad[7] = (P[30] & 255) | ((P[31] & 255) << 8));
    };
    (Q.prototype.blocks = function (P, C, $) {
      for (
        var b = this.fin ? 0 : 2048,
          D,
          K,
          se,
          pe,
          we,
          Re,
          ke,
          je,
          Te,
          Me,
          Ne,
          Ue,
          qe,
          Fe,
          Je,
          Ke,
          Be,
          He,
          De,
          Le = this.h[0],
          Pe = this.h[1],
          Oe = this.h[2],
          ge = this.h[3],
          ve = this.h[4],
          Ie = this.h[5],
          Se = this.h[6],
          Ae = this.h[7],
          Ce = this.h[8],
          Ve = this.h[9],
          it = this.r[0],
          mt = this.r[1],
          at = this.r[2],
          ae = this.r[3],
          _t = this.r[4],
          Nt = this.r[5],
          Ot = this.r[6],
          yt = this.r[7],
          Ct = this.r[8],
          Rt = this.r[9];
        $ >= 16;

      )
        (D = (P[C + 0] & 255) | ((P[C + 1] & 255) << 8)),
          (Le += D & 8191),
          (K = (P[C + 2] & 255) | ((P[C + 3] & 255) << 8)),
          (Pe += ((D >>> 13) | (K << 3)) & 8191),
          (se = (P[C + 4] & 255) | ((P[C + 5] & 255) << 8)),
          (Oe += ((K >>> 10) | (se << 6)) & 8191),
          (pe = (P[C + 6] & 255) | ((P[C + 7] & 255) << 8)),
          (ge += ((se >>> 7) | (pe << 9)) & 8191),
          (we = (P[C + 8] & 255) | ((P[C + 9] & 255) << 8)),
          (ve += ((pe >>> 4) | (we << 12)) & 8191),
          (Ie += (we >>> 1) & 8191),
          (Re = (P[C + 10] & 255) | ((P[C + 11] & 255) << 8)),
          (Se += ((we >>> 14) | (Re << 2)) & 8191),
          (ke = (P[C + 12] & 255) | ((P[C + 13] & 255) << 8)),
          (Ae += ((Re >>> 11) | (ke << 5)) & 8191),
          (je = (P[C + 14] & 255) | ((P[C + 15] & 255) << 8)),
          (Ce += ((ke >>> 8) | (je << 8)) & 8191),
          (Ve += (je >>> 5) | b),
          (Te = 0),
          (Me = Te),
          (Me += Le * it),
          (Me += Pe * (5 * Rt)),
          (Me += Oe * (5 * Ct)),
          (Me += ge * (5 * yt)),
          (Me += ve * (5 * Ot)),
          (Te = Me >>> 13),
          (Me &= 8191),
          (Me += Ie * (5 * Nt)),
          (Me += Se * (5 * _t)),
          (Me += Ae * (5 * ae)),
          (Me += Ce * (5 * at)),
          (Me += Ve * (5 * mt)),
          (Te += Me >>> 13),
          (Me &= 8191),
          (Ne = Te),
          (Ne += Le * mt),
          (Ne += Pe * it),
          (Ne += Oe * (5 * Rt)),
          (Ne += ge * (5 * Ct)),
          (Ne += ve * (5 * yt)),
          (Te = Ne >>> 13),
          (Ne &= 8191),
          (Ne += Ie * (5 * Ot)),
          (Ne += Se * (5 * Nt)),
          (Ne += Ae * (5 * _t)),
          (Ne += Ce * (5 * ae)),
          (Ne += Ve * (5 * at)),
          (Te += Ne >>> 13),
          (Ne &= 8191),
          (Ue = Te),
          (Ue += Le * at),
          (Ue += Pe * mt),
          (Ue += Oe * it),
          (Ue += ge * (5 * Rt)),
          (Ue += ve * (5 * Ct)),
          (Te = Ue >>> 13),
          (Ue &= 8191),
          (Ue += Ie * (5 * yt)),
          (Ue += Se * (5 * Ot)),
          (Ue += Ae * (5 * Nt)),
          (Ue += Ce * (5 * _t)),
          (Ue += Ve * (5 * ae)),
          (Te += Ue >>> 13),
          (Ue &= 8191),
          (qe = Te),
          (qe += Le * ae),
          (qe += Pe * at),
          (qe += Oe * mt),
          (qe += ge * it),
          (qe += ve * (5 * Rt)),
          (Te = qe >>> 13),
          (qe &= 8191),
          (qe += Ie * (5 * Ct)),
          (qe += Se * (5 * yt)),
          (qe += Ae * (5 * Ot)),
          (qe += Ce * (5 * Nt)),
          (qe += Ve * (5 * _t)),
          (Te += qe >>> 13),
          (qe &= 8191),
          (Fe = Te),
          (Fe += Le * _t),
          (Fe += Pe * ae),
          (Fe += Oe * at),
          (Fe += ge * mt),
          (Fe += ve * it),
          (Te = Fe >>> 13),
          (Fe &= 8191),
          (Fe += Ie * (5 * Rt)),
          (Fe += Se * (5 * Ct)),
          (Fe += Ae * (5 * yt)),
          (Fe += Ce * (5 * Ot)),
          (Fe += Ve * (5 * Nt)),
          (Te += Fe >>> 13),
          (Fe &= 8191),
          (Je = Te),
          (Je += Le * Nt),
          (Je += Pe * _t),
          (Je += Oe * ae),
          (Je += ge * at),
          (Je += ve * mt),
          (Te = Je >>> 13),
          (Je &= 8191),
          (Je += Ie * it),
          (Je += Se * (5 * Rt)),
          (Je += Ae * (5 * Ct)),
          (Je += Ce * (5 * yt)),
          (Je += Ve * (5 * Ot)),
          (Te += Je >>> 13),
          (Je &= 8191),
          (Ke = Te),
          (Ke += Le * Ot),
          (Ke += Pe * Nt),
          (Ke += Oe * _t),
          (Ke += ge * ae),
          (Ke += ve * at),
          (Te = Ke >>> 13),
          (Ke &= 8191),
          (Ke += Ie * mt),
          (Ke += Se * it),
          (Ke += Ae * (5 * Rt)),
          (Ke += Ce * (5 * Ct)),
          (Ke += Ve * (5 * yt)),
          (Te += Ke >>> 13),
          (Ke &= 8191),
          (Be = Te),
          (Be += Le * yt),
          (Be += Pe * Ot),
          (Be += Oe * Nt),
          (Be += ge * _t),
          (Be += ve * ae),
          (Te = Be >>> 13),
          (Be &= 8191),
          (Be += Ie * at),
          (Be += Se * mt),
          (Be += Ae * it),
          (Be += Ce * (5 * Rt)),
          (Be += Ve * (5 * Ct)),
          (Te += Be >>> 13),
          (Be &= 8191),
          (He = Te),
          (He += Le * Ct),
          (He += Pe * yt),
          (He += Oe * Ot),
          (He += ge * Nt),
          (He += ve * _t),
          (Te = He >>> 13),
          (He &= 8191),
          (He += Ie * ae),
          (He += Se * at),
          (He += Ae * mt),
          (He += Ce * it),
          (He += Ve * (5 * Rt)),
          (Te += He >>> 13),
          (He &= 8191),
          (De = Te),
          (De += Le * Rt),
          (De += Pe * Ct),
          (De += Oe * yt),
          (De += ge * Ot),
          (De += ve * Nt),
          (Te = De >>> 13),
          (De &= 8191),
          (De += Ie * _t),
          (De += Se * ae),
          (De += Ae * at),
          (De += Ce * mt),
          (De += Ve * it),
          (Te += De >>> 13),
          (De &= 8191),
          (Te = ((Te << 2) + Te) | 0),
          (Te = (Te + Me) | 0),
          (Me = Te & 8191),
          (Te = Te >>> 13),
          (Ne += Te),
          (Le = Me),
          (Pe = Ne),
          (Oe = Ue),
          (ge = qe),
          (ve = Fe),
          (Ie = Je),
          (Se = Ke),
          (Ae = Be),
          (Ce = He),
          (Ve = De),
          (C += 16),
          ($ -= 16);
      (this.h[0] = Le),
        (this.h[1] = Pe),
        (this.h[2] = Oe),
        (this.h[3] = ge),
        (this.h[4] = ve),
        (this.h[5] = Ie),
        (this.h[6] = Se),
        (this.h[7] = Ae),
        (this.h[8] = Ce),
        (this.h[9] = Ve);
    }),
      (Q.prototype.finish = function (P, C) {
        var $ = new Uint16Array(10),
          b,
          D,
          K,
          se;
        if (this.leftover) {
          for (se = this.leftover, this.buffer[se++] = 1; se < 16; se++)
            this.buffer[se] = 0;
          (this.fin = 1), this.blocks(this.buffer, 0, 16);
        }
        for (b = this.h[1] >>> 13, this.h[1] &= 8191, se = 2; se < 10; se++)
          (this.h[se] += b), (b = this.h[se] >>> 13), (this.h[se] &= 8191);
        for (
          this.h[0] += b * 5,
            b = this.h[0] >>> 13,
            this.h[0] &= 8191,
            this.h[1] += b,
            b = this.h[1] >>> 13,
            this.h[1] &= 8191,
            this.h[2] += b,
            $[0] = this.h[0] + 5,
            b = $[0] >>> 13,
            $[0] &= 8191,
            se = 1;
          se < 10;
          se++
        )
          ($[se] = this.h[se] + b), (b = $[se] >>> 13), ($[se] &= 8191);
        for ($[9] -= 8192, D = (b ^ 1) - 1, se = 0; se < 10; se++) $[se] &= D;
        for (D = ~D, se = 0; se < 10; se++)
          this.h[se] = (this.h[se] & D) | $[se];
        for (
          this.h[0] = (this.h[0] | (this.h[1] << 13)) & 65535,
            this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 65535,
            this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 65535,
            this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 65535,
            this.h[4] =
              ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) &
              65535,
            this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 65535,
            this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 65535,
            this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 65535,
            K = this.h[0] + this.pad[0],
            this.h[0] = K & 65535,
            se = 1;
          se < 8;
          se++
        )
          (K = (((this.h[se] + this.pad[se]) | 0) + (K >>> 16)) | 0),
            (this.h[se] = K & 65535);
        (P[C + 0] = (this.h[0] >>> 0) & 255),
          (P[C + 1] = (this.h[0] >>> 8) & 255),
          (P[C + 2] = (this.h[1] >>> 0) & 255),
          (P[C + 3] = (this.h[1] >>> 8) & 255),
          (P[C + 4] = (this.h[2] >>> 0) & 255),
          (P[C + 5] = (this.h[2] >>> 8) & 255),
          (P[C + 6] = (this.h[3] >>> 0) & 255),
          (P[C + 7] = (this.h[3] >>> 8) & 255),
          (P[C + 8] = (this.h[4] >>> 0) & 255),
          (P[C + 9] = (this.h[4] >>> 8) & 255),
          (P[C + 10] = (this.h[5] >>> 0) & 255),
          (P[C + 11] = (this.h[5] >>> 8) & 255),
          (P[C + 12] = (this.h[6] >>> 0) & 255),
          (P[C + 13] = (this.h[6] >>> 8) & 255),
          (P[C + 14] = (this.h[7] >>> 0) & 255),
          (P[C + 15] = (this.h[7] >>> 8) & 255);
      }),
      (Q.prototype.update = function (P, C, $) {
        var b, D;
        if (this.leftover) {
          for (D = 16 - this.leftover, D > $ && (D = $), b = 0; b < D; b++)
            this.buffer[this.leftover + b] = P[C + b];
          if ((($ -= D), (C += D), (this.leftover += D), this.leftover < 16))
            return;
          this.blocks(this.buffer, 0, 16), (this.leftover = 0);
        }
        if (
          ($ >= 16 &&
            ((D = $ - ($ % 16)), this.blocks(P, C, D), (C += D), ($ -= D)),
          $)
        ) {
          for (b = 0; b < $; b++) this.buffer[this.leftover + b] = P[C + b];
          this.leftover += $;
        }
      });
    function j(P, C, $, b, D, K) {
      var se = new Q(K);
      return se.update($, b, D), se.finish(P, C), 0;
    }
    function H(P, C, $, b, D, K) {
      var se = new Uint8Array(16);
      return j(se, 0, $, b, D, K), g(P, C, se, 0);
    }
    function q(P, C, $, b, D) {
      var K;
      if ($ < 32) return -1;
      for (
        O(P, 0, C, 0, $, b, D), j(P, 16, P, 32, $ - 32, P), K = 0;
        K < 16;
        K++
      )
        P[K] = 0;
      return 0;
    }
    function J(P, C, $, b, D) {
      var K,
        se = new Uint8Array(32);
      if ($ < 32 || (w(se, 0, 32, b, D), H(C, 16, C, 32, $ - 32, se) !== 0))
        return -1;
      for (O(P, 0, C, 0, $, b, D), K = 0; K < 32; K++) P[K] = 0;
      return 0;
    }
    function Z(P, C) {
      var $;
      for ($ = 0; $ < 16; $++) P[$] = C[$] | 0;
    }
    function z(P) {
      var C,
        $,
        b = 1;
      for (C = 0; C < 16; C++)
        ($ = P[C] + b + 65535),
          (b = Math.floor($ / 65536)),
          (P[C] = $ - b * 65536);
      P[0] += b - 1 + 37 * (b - 1);
    }
    function U(P, C, $) {
      for (var b, D = ~($ - 1), K = 0; K < 16; K++)
        (b = D & (P[K] ^ C[K])), (P[K] ^= b), (C[K] ^= b);
    }
    function G(P, C) {
      var $,
        b,
        D,
        K = n(),
        se = n();
      for ($ = 0; $ < 16; $++) se[$] = C[$];
      for (z(se), z(se), z(se), b = 0; b < 2; b++) {
        for (K[0] = se[0] - 65517, $ = 1; $ < 15; $++)
          (K[$] = se[$] - 65535 - ((K[$ - 1] >> 16) & 1)), (K[$ - 1] &= 65535);
        (K[15] = se[15] - 32767 - ((K[14] >> 16) & 1)),
          (D = (K[15] >> 16) & 1),
          (K[14] &= 65535),
          U(se, K, 1 - D);
      }
      for ($ = 0; $ < 16; $++)
        (P[2 * $] = se[$] & 255), (P[2 * $ + 1] = se[$] >> 8);
    }
    function L(P, C) {
      var $ = new Uint8Array(32),
        b = new Uint8Array(32);
      return G($, P), G(b, C), v($, 0, b, 0);
    }
    function k(P) {
      var C = new Uint8Array(32);
      return G(C, P), C[0] & 1;
    }
    function W(P, C) {
      var $;
      for ($ = 0; $ < 16; $++) P[$] = C[2 * $] + (C[2 * $ + 1] << 8);
      P[15] &= 32767;
    }
    function F(P, C, $) {
      for (var b = 0; b < 16; b++) P[b] = C[b] + $[b];
    }
    function x(P, C, $) {
      for (var b = 0; b < 16; b++) P[b] = C[b] - $[b];
    }
    function T(P, C, $) {
      var b,
        D,
        K = 0,
        se = 0,
        pe = 0,
        we = 0,
        Re = 0,
        ke = 0,
        je = 0,
        Te = 0,
        Me = 0,
        Ne = 0,
        Ue = 0,
        qe = 0,
        Fe = 0,
        Je = 0,
        Ke = 0,
        Be = 0,
        He = 0,
        De = 0,
        Le = 0,
        Pe = 0,
        Oe = 0,
        ge = 0,
        ve = 0,
        Ie = 0,
        Se = 0,
        Ae = 0,
        Ce = 0,
        Ve = 0,
        it = 0,
        mt = 0,
        at = 0,
        ae = $[0],
        _t = $[1],
        Nt = $[2],
        Ot = $[3],
        yt = $[4],
        Ct = $[5],
        Rt = $[6],
        hn = $[7],
        Pt = $[8],
        zt = $[9],
        mn = $[10],
        gn = $[11],
        en = $[12],
        Un = $[13],
        Fn = $[14],
        jn = $[15];
      (b = C[0]),
        (K += b * ae),
        (se += b * _t),
        (pe += b * Nt),
        (we += b * Ot),
        (Re += b * yt),
        (ke += b * Ct),
        (je += b * Rt),
        (Te += b * hn),
        (Me += b * Pt),
        (Ne += b * zt),
        (Ue += b * mn),
        (qe += b * gn),
        (Fe += b * en),
        (Je += b * Un),
        (Ke += b * Fn),
        (Be += b * jn),
        (b = C[1]),
        (se += b * ae),
        (pe += b * _t),
        (we += b * Nt),
        (Re += b * Ot),
        (ke += b * yt),
        (je += b * Ct),
        (Te += b * Rt),
        (Me += b * hn),
        (Ne += b * Pt),
        (Ue += b * zt),
        (qe += b * mn),
        (Fe += b * gn),
        (Je += b * en),
        (Ke += b * Un),
        (Be += b * Fn),
        (He += b * jn),
        (b = C[2]),
        (pe += b * ae),
        (we += b * _t),
        (Re += b * Nt),
        (ke += b * Ot),
        (je += b * yt),
        (Te += b * Ct),
        (Me += b * Rt),
        (Ne += b * hn),
        (Ue += b * Pt),
        (qe += b * zt),
        (Fe += b * mn),
        (Je += b * gn),
        (Ke += b * en),
        (Be += b * Un),
        (He += b * Fn),
        (De += b * jn),
        (b = C[3]),
        (we += b * ae),
        (Re += b * _t),
        (ke += b * Nt),
        (je += b * Ot),
        (Te += b * yt),
        (Me += b * Ct),
        (Ne += b * Rt),
        (Ue += b * hn),
        (qe += b * Pt),
        (Fe += b * zt),
        (Je += b * mn),
        (Ke += b * gn),
        (Be += b * en),
        (He += b * Un),
        (De += b * Fn),
        (Le += b * jn),
        (b = C[4]),
        (Re += b * ae),
        (ke += b * _t),
        (je += b * Nt),
        (Te += b * Ot),
        (Me += b * yt),
        (Ne += b * Ct),
        (Ue += b * Rt),
        (qe += b * hn),
        (Fe += b * Pt),
        (Je += b * zt),
        (Ke += b * mn),
        (Be += b * gn),
        (He += b * en),
        (De += b * Un),
        (Le += b * Fn),
        (Pe += b * jn),
        (b = C[5]),
        (ke += b * ae),
        (je += b * _t),
        (Te += b * Nt),
        (Me += b * Ot),
        (Ne += b * yt),
        (Ue += b * Ct),
        (qe += b * Rt),
        (Fe += b * hn),
        (Je += b * Pt),
        (Ke += b * zt),
        (Be += b * mn),
        (He += b * gn),
        (De += b * en),
        (Le += b * Un),
        (Pe += b * Fn),
        (Oe += b * jn),
        (b = C[6]),
        (je += b * ae),
        (Te += b * _t),
        (Me += b * Nt),
        (Ne += b * Ot),
        (Ue += b * yt),
        (qe += b * Ct),
        (Fe += b * Rt),
        (Je += b * hn),
        (Ke += b * Pt),
        (Be += b * zt),
        (He += b * mn),
        (De += b * gn),
        (Le += b * en),
        (Pe += b * Un),
        (Oe += b * Fn),
        (ge += b * jn),
        (b = C[7]),
        (Te += b * ae),
        (Me += b * _t),
        (Ne += b * Nt),
        (Ue += b * Ot),
        (qe += b * yt),
        (Fe += b * Ct),
        (Je += b * Rt),
        (Ke += b * hn),
        (Be += b * Pt),
        (He += b * zt),
        (De += b * mn),
        (Le += b * gn),
        (Pe += b * en),
        (Oe += b * Un),
        (ge += b * Fn),
        (ve += b * jn),
        (b = C[8]),
        (Me += b * ae),
        (Ne += b * _t),
        (Ue += b * Nt),
        (qe += b * Ot),
        (Fe += b * yt),
        (Je += b * Ct),
        (Ke += b * Rt),
        (Be += b * hn),
        (He += b * Pt),
        (De += b * zt),
        (Le += b * mn),
        (Pe += b * gn),
        (Oe += b * en),
        (ge += b * Un),
        (ve += b * Fn),
        (Ie += b * jn),
        (b = C[9]),
        (Ne += b * ae),
        (Ue += b * _t),
        (qe += b * Nt),
        (Fe += b * Ot),
        (Je += b * yt),
        (Ke += b * Ct),
        (Be += b * Rt),
        (He += b * hn),
        (De += b * Pt),
        (Le += b * zt),
        (Pe += b * mn),
        (Oe += b * gn),
        (ge += b * en),
        (ve += b * Un),
        (Ie += b * Fn),
        (Se += b * jn),
        (b = C[10]),
        (Ue += b * ae),
        (qe += b * _t),
        (Fe += b * Nt),
        (Je += b * Ot),
        (Ke += b * yt),
        (Be += b * Ct),
        (He += b * Rt),
        (De += b * hn),
        (Le += b * Pt),
        (Pe += b * zt),
        (Oe += b * mn),
        (ge += b * gn),
        (ve += b * en),
        (Ie += b * Un),
        (Se += b * Fn),
        (Ae += b * jn),
        (b = C[11]),
        (qe += b * ae),
        (Fe += b * _t),
        (Je += b * Nt),
        (Ke += b * Ot),
        (Be += b * yt),
        (He += b * Ct),
        (De += b * Rt),
        (Le += b * hn),
        (Pe += b * Pt),
        (Oe += b * zt),
        (ge += b * mn),
        (ve += b * gn),
        (Ie += b * en),
        (Se += b * Un),
        (Ae += b * Fn),
        (Ce += b * jn),
        (b = C[12]),
        (Fe += b * ae),
        (Je += b * _t),
        (Ke += b * Nt),
        (Be += b * Ot),
        (He += b * yt),
        (De += b * Ct),
        (Le += b * Rt),
        (Pe += b * hn),
        (Oe += b * Pt),
        (ge += b * zt),
        (ve += b * mn),
        (Ie += b * gn),
        (Se += b * en),
        (Ae += b * Un),
        (Ce += b * Fn),
        (Ve += b * jn),
        (b = C[13]),
        (Je += b * ae),
        (Ke += b * _t),
        (Be += b * Nt),
        (He += b * Ot),
        (De += b * yt),
        (Le += b * Ct),
        (Pe += b * Rt),
        (Oe += b * hn),
        (ge += b * Pt),
        (ve += b * zt),
        (Ie += b * mn),
        (Se += b * gn),
        (Ae += b * en),
        (Ce += b * Un),
        (Ve += b * Fn),
        (it += b * jn),
        (b = C[14]),
        (Ke += b * ae),
        (Be += b * _t),
        (He += b * Nt),
        (De += b * Ot),
        (Le += b * yt),
        (Pe += b * Ct),
        (Oe += b * Rt),
        (ge += b * hn),
        (ve += b * Pt),
        (Ie += b * zt),
        (Se += b * mn),
        (Ae += b * gn),
        (Ce += b * en),
        (Ve += b * Un),
        (it += b * Fn),
        (mt += b * jn),
        (b = C[15]),
        (Be += b * ae),
        (He += b * _t),
        (De += b * Nt),
        (Le += b * Ot),
        (Pe += b * yt),
        (Oe += b * Ct),
        (ge += b * Rt),
        (ve += b * hn),
        (Ie += b * Pt),
        (Se += b * zt),
        (Ae += b * mn),
        (Ce += b * gn),
        (Ve += b * en),
        (it += b * Un),
        (mt += b * Fn),
        (at += b * jn),
        (K += 38 * He),
        (se += 38 * De),
        (pe += 38 * Le),
        (we += 38 * Pe),
        (Re += 38 * Oe),
        (ke += 38 * ge),
        (je += 38 * ve),
        (Te += 38 * Ie),
        (Me += 38 * Se),
        (Ne += 38 * Ae),
        (Ue += 38 * Ce),
        (qe += 38 * Ve),
        (Fe += 38 * it),
        (Je += 38 * mt),
        (Ke += 38 * at),
        (D = 1),
        (b = K + D + 65535),
        (D = Math.floor(b / 65536)),
        (K = b - D * 65536),
        (b = se + D + 65535),
        (D = Math.floor(b / 65536)),
        (se = b - D * 65536),
        (b = pe + D + 65535),
        (D = Math.floor(b / 65536)),
        (pe = b - D * 65536),
        (b = we + D + 65535),
        (D = Math.floor(b / 65536)),
        (we = b - D * 65536),
        (b = Re + D + 65535),
        (D = Math.floor(b / 65536)),
        (Re = b - D * 65536),
        (b = ke + D + 65535),
        (D = Math.floor(b / 65536)),
        (ke = b - D * 65536),
        (b = je + D + 65535),
        (D = Math.floor(b / 65536)),
        (je = b - D * 65536),
        (b = Te + D + 65535),
        (D = Math.floor(b / 65536)),
        (Te = b - D * 65536),
        (b = Me + D + 65535),
        (D = Math.floor(b / 65536)),
        (Me = b - D * 65536),
        (b = Ne + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ne = b - D * 65536),
        (b = Ue + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ue = b - D * 65536),
        (b = qe + D + 65535),
        (D = Math.floor(b / 65536)),
        (qe = b - D * 65536),
        (b = Fe + D + 65535),
        (D = Math.floor(b / 65536)),
        (Fe = b - D * 65536),
        (b = Je + D + 65535),
        (D = Math.floor(b / 65536)),
        (Je = b - D * 65536),
        (b = Ke + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ke = b - D * 65536),
        (b = Be + D + 65535),
        (D = Math.floor(b / 65536)),
        (Be = b - D * 65536),
        (K += D - 1 + 37 * (D - 1)),
        (D = 1),
        (b = K + D + 65535),
        (D = Math.floor(b / 65536)),
        (K = b - D * 65536),
        (b = se + D + 65535),
        (D = Math.floor(b / 65536)),
        (se = b - D * 65536),
        (b = pe + D + 65535),
        (D = Math.floor(b / 65536)),
        (pe = b - D * 65536),
        (b = we + D + 65535),
        (D = Math.floor(b / 65536)),
        (we = b - D * 65536),
        (b = Re + D + 65535),
        (D = Math.floor(b / 65536)),
        (Re = b - D * 65536),
        (b = ke + D + 65535),
        (D = Math.floor(b / 65536)),
        (ke = b - D * 65536),
        (b = je + D + 65535),
        (D = Math.floor(b / 65536)),
        (je = b - D * 65536),
        (b = Te + D + 65535),
        (D = Math.floor(b / 65536)),
        (Te = b - D * 65536),
        (b = Me + D + 65535),
        (D = Math.floor(b / 65536)),
        (Me = b - D * 65536),
        (b = Ne + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ne = b - D * 65536),
        (b = Ue + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ue = b - D * 65536),
        (b = qe + D + 65535),
        (D = Math.floor(b / 65536)),
        (qe = b - D * 65536),
        (b = Fe + D + 65535),
        (D = Math.floor(b / 65536)),
        (Fe = b - D * 65536),
        (b = Je + D + 65535),
        (D = Math.floor(b / 65536)),
        (Je = b - D * 65536),
        (b = Ke + D + 65535),
        (D = Math.floor(b / 65536)),
        (Ke = b - D * 65536),
        (b = Be + D + 65535),
        (D = Math.floor(b / 65536)),
        (Be = b - D * 65536),
        (K += D - 1 + 37 * (D - 1)),
        (P[0] = K),
        (P[1] = se),
        (P[2] = pe),
        (P[3] = we),
        (P[4] = Re),
        (P[5] = ke),
        (P[6] = je),
        (P[7] = Te),
        (P[8] = Me),
        (P[9] = Ne),
        (P[10] = Ue),
        (P[11] = qe),
        (P[12] = Fe),
        (P[13] = Je),
        (P[14] = Ke),
        (P[15] = Be);
    }
    function V(P, C) {
      T(P, C, C);
    }
    function B(P, C) {
      var $ = n(),
        b;
      for (b = 0; b < 16; b++) $[b] = C[b];
      for (b = 253; b >= 0; b--) V($, $), b !== 2 && b !== 4 && T($, $, C);
      for (b = 0; b < 16; b++) P[b] = $[b];
    }
    function N(P, C) {
      var $ = n(),
        b;
      for (b = 0; b < 16; b++) $[b] = C[b];
      for (b = 250; b >= 0; b--) V($, $), b !== 1 && T($, $, C);
      for (b = 0; b < 16; b++) P[b] = $[b];
    }
    function ce(P, C, $) {
      var b = new Uint8Array(32),
        D = new Float64Array(80),
        K,
        se,
        pe = n(),
        we = n(),
        Re = n(),
        ke = n(),
        je = n(),
        Te = n();
      for (se = 0; se < 31; se++) b[se] = C[se];
      for (
        b[31] = (C[31] & 127) | 64, b[0] &= 248, W(D, $), se = 0;
        se < 16;
        se++
      )
        (we[se] = D[se]), (ke[se] = pe[se] = Re[se] = 0);
      for (pe[0] = ke[0] = 1, se = 254; se >= 0; --se)
        (K = (b[se >>> 3] >>> (se & 7)) & 1),
          U(pe, we, K),
          U(Re, ke, K),
          F(je, pe, Re),
          x(pe, pe, Re),
          F(Re, we, ke),
          x(we, we, ke),
          V(ke, je),
          V(Te, pe),
          T(pe, Re, pe),
          T(Re, we, je),
          F(je, pe, Re),
          x(pe, pe, Re),
          V(we, pe),
          x(Re, ke, Te),
          T(pe, Re, c),
          F(pe, pe, ke),
          T(Re, Re, pe),
          T(pe, ke, Te),
          T(ke, we, D),
          V(we, je),
          U(pe, we, K),
          U(Re, ke, K);
      for (se = 0; se < 16; se++)
        (D[se + 16] = pe[se]),
          (D[se + 32] = Re[se]),
          (D[se + 48] = we[se]),
          (D[se + 64] = ke[se]);
      var Me = D.subarray(32),
        Ne = D.subarray(16);
      return B(Me, Me), T(Ne, Ne, Me), G(P, Ne), 0;
    }
    function re(P, C) {
      return ce(P, C, a);
    }
    function ne(P, C) {
      return r(C, 32), re(P, C);
    }
    function Y(P, C, $) {
      var b = new Uint8Array(32);
      return ce(b, $, C), R(P, i, b, A);
    }
    var M = q,
      oe = J;
    function Ee(P, C, $, b, D, K) {
      var se = new Uint8Array(32);
      return Y(se, D, K), M(P, C, $, b, se);
    }
    function le(P, C, $, b, D, K) {
      var se = new Uint8Array(32);
      return Y(se, D, K), oe(P, C, $, b, se);
    }
    var te = [
      1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399,
      3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265,
      2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394,
      310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994,
      1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317,
      3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139,
      264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901,
      1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
      2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879,
      3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901,
      113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964,
      773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
      1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142,
      2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273,
      3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344,
      3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
      430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593,
      883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
      1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012,
      2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044,
      2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
      3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711,
      3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554,
      174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
      685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100,
      1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866,
      1607167915, 987167468, 1816402316, 1246189591,
    ];
    function ie(P, C, $, b) {
      for (
        var D = new Int32Array(16),
          K = new Int32Array(16),
          se,
          pe,
          we,
          Re,
          ke,
          je,
          Te,
          Me,
          Ne,
          Ue,
          qe,
          Fe,
          Je,
          Ke,
          Be,
          He,
          De,
          Le,
          Pe,
          Oe,
          ge,
          ve,
          Ie,
          Se,
          Ae,
          Ce,
          Ve = P[0],
          it = P[1],
          mt = P[2],
          at = P[3],
          ae = P[4],
          _t = P[5],
          Nt = P[6],
          Ot = P[7],
          yt = C[0],
          Ct = C[1],
          Rt = C[2],
          hn = C[3],
          Pt = C[4],
          zt = C[5],
          mn = C[6],
          gn = C[7],
          en = 0;
        b >= 128;

      ) {
        for (Pe = 0; Pe < 16; Pe++)
          (Oe = 8 * Pe + en),
            (D[Pe] =
              ($[Oe + 0] << 24) |
              ($[Oe + 1] << 16) |
              ($[Oe + 2] << 8) |
              $[Oe + 3]),
            (K[Pe] =
              ($[Oe + 4] << 24) |
              ($[Oe + 5] << 16) |
              ($[Oe + 6] << 8) |
              $[Oe + 7]);
        for (Pe = 0; Pe < 80; Pe++)
          if (
            ((se = Ve),
            (pe = it),
            (we = mt),
            (Re = at),
            (ke = ae),
            (je = _t),
            (Te = Nt),
            (Me = Ot),
            (Ne = yt),
            (Ue = Ct),
            (qe = Rt),
            (Fe = hn),
            (Je = Pt),
            (Ke = zt),
            (Be = mn),
            (He = gn),
            (ge = Ot),
            (ve = gn),
            (Ie = ve & 65535),
            (Se = ve >>> 16),
            (Ae = ge & 65535),
            (Ce = ge >>> 16),
            (ge =
              ((ae >>> 14) | (Pt << (32 - 14))) ^
              ((ae >>> 18) | (Pt << (32 - 18))) ^
              ((Pt >>> (41 - 32)) | (ae << (32 - (41 - 32))))),
            (ve =
              ((Pt >>> 14) | (ae << (32 - 14))) ^
              ((Pt >>> 18) | (ae << (32 - 18))) ^
              ((ae >>> (41 - 32)) | (Pt << (32 - (41 - 32))))),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (ge = (ae & _t) ^ (~ae & Nt)),
            (ve = (Pt & zt) ^ (~Pt & mn)),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (ge = te[Pe * 2]),
            (ve = te[Pe * 2 + 1]),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (ge = D[Pe % 16]),
            (ve = K[Pe % 16]),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (Se += Ie >>> 16),
            (Ae += Se >>> 16),
            (Ce += Ae >>> 16),
            (De = (Ae & 65535) | (Ce << 16)),
            (Le = (Ie & 65535) | (Se << 16)),
            (ge = De),
            (ve = Le),
            (Ie = ve & 65535),
            (Se = ve >>> 16),
            (Ae = ge & 65535),
            (Ce = ge >>> 16),
            (ge =
              ((Ve >>> 28) | (yt << (32 - 28))) ^
              ((yt >>> (34 - 32)) | (Ve << (32 - (34 - 32)))) ^
              ((yt >>> (39 - 32)) | (Ve << (32 - (39 - 32))))),
            (ve =
              ((yt >>> 28) | (Ve << (32 - 28))) ^
              ((Ve >>> (34 - 32)) | (yt << (32 - (34 - 32)))) ^
              ((Ve >>> (39 - 32)) | (yt << (32 - (39 - 32))))),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (ge = (Ve & it) ^ (Ve & mt) ^ (it & mt)),
            (ve = (yt & Ct) ^ (yt & Rt) ^ (Ct & Rt)),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (Se += Ie >>> 16),
            (Ae += Se >>> 16),
            (Ce += Ae >>> 16),
            (Me = (Ae & 65535) | (Ce << 16)),
            (He = (Ie & 65535) | (Se << 16)),
            (ge = Re),
            (ve = Fe),
            (Ie = ve & 65535),
            (Se = ve >>> 16),
            (Ae = ge & 65535),
            (Ce = ge >>> 16),
            (ge = De),
            (ve = Le),
            (Ie += ve & 65535),
            (Se += ve >>> 16),
            (Ae += ge & 65535),
            (Ce += ge >>> 16),
            (Se += Ie >>> 16),
            (Ae += Se >>> 16),
            (Ce += Ae >>> 16),
            (Re = (Ae & 65535) | (Ce << 16)),
            (Fe = (Ie & 65535) | (Se << 16)),
            (it = se),
            (mt = pe),
            (at = we),
            (ae = Re),
            (_t = ke),
            (Nt = je),
            (Ot = Te),
            (Ve = Me),
            (Ct = Ne),
            (Rt = Ue),
            (hn = qe),
            (Pt = Fe),
            (zt = Je),
            (mn = Ke),
            (gn = Be),
            (yt = He),
            Pe % 16 === 15)
          )
            for (Oe = 0; Oe < 16; Oe++)
              (ge = D[Oe]),
                (ve = K[Oe]),
                (Ie = ve & 65535),
                (Se = ve >>> 16),
                (Ae = ge & 65535),
                (Ce = ge >>> 16),
                (ge = D[(Oe + 9) % 16]),
                (ve = K[(Oe + 9) % 16]),
                (Ie += ve & 65535),
                (Se += ve >>> 16),
                (Ae += ge & 65535),
                (Ce += ge >>> 16),
                (De = D[(Oe + 1) % 16]),
                (Le = K[(Oe + 1) % 16]),
                (ge =
                  ((De >>> 1) | (Le << (32 - 1))) ^
                  ((De >>> 8) | (Le << (32 - 8))) ^
                  (De >>> 7)),
                (ve =
                  ((Le >>> 1) | (De << (32 - 1))) ^
                  ((Le >>> 8) | (De << (32 - 8))) ^
                  ((Le >>> 7) | (De << (32 - 7)))),
                (Ie += ve & 65535),
                (Se += ve >>> 16),
                (Ae += ge & 65535),
                (Ce += ge >>> 16),
                (De = D[(Oe + 14) % 16]),
                (Le = K[(Oe + 14) % 16]),
                (ge =
                  ((De >>> 19) | (Le << (32 - 19))) ^
                  ((Le >>> (61 - 32)) | (De << (32 - (61 - 32)))) ^
                  (De >>> 6)),
                (ve =
                  ((Le >>> 19) | (De << (32 - 19))) ^
                  ((De >>> (61 - 32)) | (Le << (32 - (61 - 32)))) ^
                  ((Le >>> 6) | (De << (32 - 6)))),
                (Ie += ve & 65535),
                (Se += ve >>> 16),
                (Ae += ge & 65535),
                (Ce += ge >>> 16),
                (Se += Ie >>> 16),
                (Ae += Se >>> 16),
                (Ce += Ae >>> 16),
                (D[Oe] = (Ae & 65535) | (Ce << 16)),
                (K[Oe] = (Ie & 65535) | (Se << 16));
        (ge = Ve),
          (ve = yt),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[0]),
          (ve = C[0]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[0] = Ve = (Ae & 65535) | (Ce << 16)),
          (C[0] = yt = (Ie & 65535) | (Se << 16)),
          (ge = it),
          (ve = Ct),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[1]),
          (ve = C[1]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[1] = it = (Ae & 65535) | (Ce << 16)),
          (C[1] = Ct = (Ie & 65535) | (Se << 16)),
          (ge = mt),
          (ve = Rt),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[2]),
          (ve = C[2]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[2] = mt = (Ae & 65535) | (Ce << 16)),
          (C[2] = Rt = (Ie & 65535) | (Se << 16)),
          (ge = at),
          (ve = hn),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[3]),
          (ve = C[3]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[3] = at = (Ae & 65535) | (Ce << 16)),
          (C[3] = hn = (Ie & 65535) | (Se << 16)),
          (ge = ae),
          (ve = Pt),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[4]),
          (ve = C[4]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[4] = ae = (Ae & 65535) | (Ce << 16)),
          (C[4] = Pt = (Ie & 65535) | (Se << 16)),
          (ge = _t),
          (ve = zt),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[5]),
          (ve = C[5]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[5] = _t = (Ae & 65535) | (Ce << 16)),
          (C[5] = zt = (Ie & 65535) | (Se << 16)),
          (ge = Nt),
          (ve = mn),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[6]),
          (ve = C[6]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[6] = Nt = (Ae & 65535) | (Ce << 16)),
          (C[6] = mn = (Ie & 65535) | (Se << 16)),
          (ge = Ot),
          (ve = gn),
          (Ie = ve & 65535),
          (Se = ve >>> 16),
          (Ae = ge & 65535),
          (Ce = ge >>> 16),
          (ge = P[7]),
          (ve = C[7]),
          (Ie += ve & 65535),
          (Se += ve >>> 16),
          (Ae += ge & 65535),
          (Ce += ge >>> 16),
          (Se += Ie >>> 16),
          (Ae += Se >>> 16),
          (Ce += Ae >>> 16),
          (P[7] = Ot = (Ae & 65535) | (Ce << 16)),
          (C[7] = gn = (Ie & 65535) | (Se << 16)),
          (en += 128),
          (b -= 128);
      }
      return b;
    }
    function X(P, C, $) {
      var b = new Int32Array(8),
        D = new Int32Array(8),
        K = new Uint8Array(256),
        se,
        pe = $;
      for (
        b[0] = 1779033703,
          b[1] = 3144134277,
          b[2] = 1013904242,
          b[3] = 2773480762,
          b[4] = 1359893119,
          b[5] = 2600822924,
          b[6] = 528734635,
          b[7] = 1541459225,
          D[0] = 4089235720,
          D[1] = 2227873595,
          D[2] = 4271175723,
          D[3] = 1595750129,
          D[4] = 2917565137,
          D[5] = 725511199,
          D[6] = 4215389547,
          D[7] = 327033209,
          ie(b, D, C, $),
          $ %= 128,
          se = 0;
        se < $;
        se++
      )
        K[se] = C[pe - $ + se];
      for (
        K[$] = 128,
          $ = 256 - 128 * ($ < 112 ? 1 : 0),
          K[$ - 9] = 0,
          h(K, $ - 8, (pe / 536870912) | 0, pe << 3),
          ie(b, D, K, $),
          se = 0;
        se < 8;
        se++
      )
        h(P, 8 * se, b[se], D[se]);
      return 0;
    }
    function he(P, C) {
      var $ = n(),
        b = n(),
        D = n(),
        K = n(),
        se = n(),
        pe = n(),
        we = n(),
        Re = n(),
        ke = n();
      x($, P[1], P[0]),
        x(ke, C[1], C[0]),
        T($, $, ke),
        F(b, P[0], P[1]),
        F(ke, C[0], C[1]),
        T(b, b, ke),
        T(D, P[3], C[3]),
        T(D, D, f),
        T(K, P[2], C[2]),
        F(K, K, K),
        x(se, b, $),
        x(pe, K, D),
        F(we, K, D),
        F(Re, b, $),
        T(P[0], se, pe),
        T(P[1], Re, we),
        T(P[2], we, pe),
        T(P[3], se, Re);
    }
    function be(P, C, $) {
      var b;
      for (b = 0; b < 4; b++) U(P[b], C[b], $);
    }
    function ye(P, C) {
      var $ = n(),
        b = n(),
        D = n();
      B(D, C[2]), T($, C[0], D), T(b, C[1], D), G(P, b), (P[31] ^= k($) << 7);
    }
    function Qe(P, C, $) {
      var b, D;
      for (Z(P[0], s), Z(P[1], o), Z(P[2], o), Z(P[3], s), D = 255; D >= 0; --D)
        (b = ($[(D / 8) | 0] >> (D & 7)) & 1),
          be(P, C, b),
          he(C, P),
          he(P, P),
          be(P, C, b);
    }
    function lt(P, C) {
      var $ = [n(), n(), n(), n()];
      Z($[0], u), Z($[1], d), Z($[2], o), T($[3], u, d), Qe(P, $, C);
    }
    function Lt(P, C, $) {
      var b = new Uint8Array(64),
        D = [n(), n(), n(), n()],
        K;
      for (
        $ || r(C, 32),
          X(b, C, 32),
          b[0] &= 248,
          b[31] &= 127,
          b[31] |= 64,
          lt(D, b),
          ye(P, D),
          K = 0;
        K < 32;
        K++
      )
        C[K + 32] = P[K];
      return 0;
    }
    var We = new Float64Array([
      237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16,
    ]);
    function bt(P, C) {
      var $, b, D, K;
      for (b = 63; b >= 32; --b) {
        for ($ = 0, D = b - 32, K = b - 12; D < K; ++D)
          (C[D] += $ - 16 * C[b] * We[D - (b - 32)]),
            ($ = (C[D] + 128) >> 8),
            (C[D] -= $ * 256);
        (C[D] += $), (C[b] = 0);
      }
      for ($ = 0, D = 0; D < 32; D++)
        (C[D] += $ - (C[31] >> 4) * We[D]), ($ = C[D] >> 8), (C[D] &= 255);
      for (D = 0; D < 32; D++) C[D] -= $ * We[D];
      for (b = 0; b < 32; b++) (C[b + 1] += C[b] >> 8), (P[b] = C[b] & 255);
    }
    function wt(P) {
      var C = new Float64Array(64),
        $;
      for ($ = 0; $ < 64; $++) C[$] = P[$];
      for ($ = 0; $ < 64; $++) P[$] = 0;
      bt(P, C);
    }
    function ct(P, C, $, b) {
      var D = new Uint8Array(64),
        K = new Uint8Array(64),
        se = new Uint8Array(64),
        pe,
        we,
        Re = new Float64Array(64),
        ke = [n(), n(), n(), n()];
      X(D, b, 32), (D[0] &= 248), (D[31] &= 127), (D[31] |= 64);
      var je = $ + 64;
      for (pe = 0; pe < $; pe++) P[64 + pe] = C[pe];
      for (pe = 0; pe < 32; pe++) P[32 + pe] = D[32 + pe];
      for (
        X(se, P.subarray(32), $ + 32), wt(se), lt(ke, se), ye(P, ke), pe = 32;
        pe < 64;
        pe++
      )
        P[pe] = b[pe];
      for (X(K, P, $ + 64), wt(K), pe = 0; pe < 64; pe++) Re[pe] = 0;
      for (pe = 0; pe < 32; pe++) Re[pe] = se[pe];
      for (pe = 0; pe < 32; pe++)
        for (we = 0; we < 32; we++) Re[pe + we] += K[pe] * D[we];
      return bt(P.subarray(32), Re), je;
    }
    function ze(P, C) {
      var $ = n(),
        b = n(),
        D = n(),
        K = n(),
        se = n(),
        pe = n(),
        we = n();
      return (
        Z(P[2], o),
        W(P[1], C),
        V(D, P[1]),
        T(K, D, l),
        x(D, D, P[2]),
        F(K, P[2], K),
        V(se, K),
        V(pe, se),
        T(we, pe, se),
        T($, we, D),
        T($, $, K),
        N($, $),
        T($, $, D),
        T($, $, K),
        T($, $, K),
        T(P[0], $, K),
        V(b, P[0]),
        T(b, b, K),
        L(b, D) && T(P[0], P[0], p),
        V(b, P[0]),
        T(b, b, K),
        L(b, D)
          ? -1
          : (k(P[0]) === C[31] >> 7 && x(P[0], s, P[0]), T(P[3], P[0], P[1]), 0)
      );
    }
    function dt(P, C, $, b) {
      var D,
        K,
        se = new Uint8Array(32),
        pe = new Uint8Array(64),
        we = [n(), n(), n(), n()],
        Re = [n(), n(), n(), n()];
      if (((K = -1), $ < 64 || ze(Re, b))) return -1;
      for (D = 0; D < $; D++) P[D] = C[D];
      for (D = 0; D < 32; D++) P[D + 32] = b[D];
      if (
        (X(pe, P, $),
        wt(pe),
        Qe(we, Re, pe),
        lt(Re, C.subarray(32)),
        he(we, Re),
        ye(se, we),
        ($ -= 64),
        v(C, 0, se, 0))
      ) {
        for (D = 0; D < $; D++) P[D] = 0;
        return -1;
      }
      for (D = 0; D < $; D++) P[D] = C[D + 64];
      return (K = $), K;
    }
    var ht = 32,
      an = 24,
      $n = 32,
      Wt = 16,
      Jt = 32,
      Zt = 32,
      jr = 32,
      Nn = 32,
      Vr = 32,
      Vi = an,
      On = $n,
      ni = Wt,
      An = 64,
      Mr = 32,
      Hr = 64,
      Yi = 32,
      qr = 64;
    t.lowlevel = {
      crypto_core_hsalsa20: R,
      crypto_stream_xor: O,
      crypto_stream: w,
      crypto_stream_salsa20_xor: I,
      crypto_stream_salsa20: S,
      crypto_onetimeauth: j,
      crypto_onetimeauth_verify: H,
      crypto_verify_16: g,
      crypto_verify_32: v,
      crypto_secretbox: q,
      crypto_secretbox_open: J,
      crypto_scalarmult: ce,
      crypto_scalarmult_base: re,
      crypto_box_beforenm: Y,
      crypto_box_afternm: M,
      crypto_box: Ee,
      crypto_box_open: le,
      crypto_box_keypair: ne,
      crypto_hash: X,
      crypto_sign: ct,
      crypto_sign_keypair: Lt,
      crypto_sign_open: dt,
      crypto_secretbox_KEYBYTES: ht,
      crypto_secretbox_NONCEBYTES: an,
      crypto_secretbox_ZEROBYTES: $n,
      crypto_secretbox_BOXZEROBYTES: Wt,
      crypto_scalarmult_BYTES: Jt,
      crypto_scalarmult_SCALARBYTES: Zt,
      crypto_box_PUBLICKEYBYTES: jr,
      crypto_box_SECRETKEYBYTES: Nn,
      crypto_box_BEFORENMBYTES: Vr,
      crypto_box_NONCEBYTES: Vi,
      crypto_box_ZEROBYTES: On,
      crypto_box_BOXZEROBYTES: ni,
      crypto_sign_BYTES: An,
      crypto_sign_PUBLICKEYBYTES: Mr,
      crypto_sign_SECRETKEYBYTES: Hr,
      crypto_sign_SEEDBYTES: Yi,
      crypto_hash_BYTES: qr,
    };
    function ns(P, C) {
      if (P.length !== ht) throw new Error("bad key size");
      if (C.length !== an) throw new Error("bad nonce size");
    }
    function kc(P, C) {
      if (P.length !== jr) throw new Error("bad public key size");
      if (C.length !== Nn) throw new Error("bad secret key size");
    }
    function Bn() {
      var P, C;
      for (C = 0; C < arguments.length; C++)
        if (
          (P = Object.prototype.toString.call(arguments[C])) !==
          "[object Uint8Array]"
        )
          throw new TypeError("unexpected type " + P + ", use Uint8Array");
    }
    function no(P) {
      for (var C = 0; C < P.length; C++) P[C] = 0;
    }
    t.util ||
      ((t.util = {}),
      (t.util.decodeUTF8 =
        t.util.encodeUTF8 =
        t.util.encodeBase64 =
        t.util.decodeBase64 =
          function () {
            throw new Error(
              "nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js",
            );
          })),
      (t.randomBytes = function (P) {
        var C = new Uint8Array(P);
        return r(C, P), C;
      }),
      (t.secretbox = function (P, C, $) {
        Bn(P, C, $), ns($, C);
        for (
          var b = new Uint8Array($n + P.length),
            D = new Uint8Array(b.length),
            K = 0;
          K < P.length;
          K++
        )
          b[K + $n] = P[K];
        return q(D, b, b.length, C, $), D.subarray(Wt);
      }),
      (t.secretbox.open = function (P, C, $) {
        Bn(P, C, $), ns($, C);
        for (
          var b = new Uint8Array(Wt + P.length),
            D = new Uint8Array(b.length),
            K = 0;
          K < P.length;
          K++
        )
          b[K + Wt] = P[K];
        return b.length < 32 || J(D, b, b.length, C, $) !== 0
          ? !1
          : D.subarray($n);
      }),
      (t.secretbox.keyLength = ht),
      (t.secretbox.nonceLength = an),
      (t.secretbox.overheadLength = Wt),
      (t.scalarMult = function (P, C) {
        if ((Bn(P, C), P.length !== Zt)) throw new Error("bad n size");
        if (C.length !== Jt) throw new Error("bad p size");
        var $ = new Uint8Array(Jt);
        return ce($, P, C), $;
      }),
      (t.scalarMult.base = function (P) {
        if ((Bn(P), P.length !== Zt)) throw new Error("bad n size");
        var C = new Uint8Array(Jt);
        return re(C, P), C;
      }),
      (t.scalarMult.scalarLength = Zt),
      (t.scalarMult.groupElementLength = Jt),
      (t.box = function (P, C, $, b) {
        var D = t.box.before($, b);
        return t.secretbox(P, C, D);
      }),
      (t.box.before = function (P, C) {
        Bn(P, C), kc(P, C);
        var $ = new Uint8Array(Vr);
        return Y($, P, C), $;
      }),
      (t.box.after = t.secretbox),
      (t.box.open = function (P, C, $, b) {
        var D = t.box.before($, b);
        return t.secretbox.open(P, C, D);
      }),
      (t.box.open.after = t.secretbox.open),
      (t.box.keyPair = function () {
        var P = new Uint8Array(jr),
          C = new Uint8Array(Nn);
        return ne(P, C), { publicKey: P, secretKey: C };
      }),
      (t.box.keyPair.fromSecretKey = function (P) {
        if ((Bn(P), P.length !== Nn)) throw new Error("bad secret key size");
        var C = new Uint8Array(jr);
        return re(C, P), { publicKey: C, secretKey: new Uint8Array(P) };
      }),
      (t.box.publicKeyLength = jr),
      (t.box.secretKeyLength = Nn),
      (t.box.sharedKeyLength = Vr),
      (t.box.nonceLength = Vi),
      (t.box.overheadLength = t.secretbox.overheadLength),
      (t.sign = function (P, C) {
        if ((Bn(P, C), C.length !== Hr)) throw new Error("bad secret key size");
        var $ = new Uint8Array(An + P.length);
        return ct($, P, P.length, C), $;
      }),
      (t.sign.open = function (P, C) {
        if (arguments.length !== 2)
          throw new Error(
            "nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?",
          );
        if ((Bn(P, C), C.length !== Mr)) throw new Error("bad public key size");
        var $ = new Uint8Array(P.length),
          b = dt($, P, P.length, C);
        if (b < 0) return null;
        for (var D = new Uint8Array(b), K = 0; K < D.length; K++) D[K] = $[K];
        return D;
      }),
      (t.sign.detached = function (P, C) {
        for (
          var $ = t.sign(P, C), b = new Uint8Array(An), D = 0;
          D < b.length;
          D++
        )
          b[D] = $[D];
        return b;
      }),
      (t.sign.detached.verify = function (P, C, $) {
        if ((Bn(P, C, $), C.length !== An))
          throw new Error("bad signature size");
        if ($.length !== Mr) throw new Error("bad public key size");
        var b = new Uint8Array(An + P.length),
          D = new Uint8Array(An + P.length),
          K;
        for (K = 0; K < An; K++) b[K] = C[K];
        for (K = 0; K < P.length; K++) b[K + An] = P[K];
        return dt(D, b, b.length, $) >= 0;
      }),
      (t.sign.keyPair = function () {
        var P = new Uint8Array(Mr),
          C = new Uint8Array(Hr);
        return Lt(P, C), { publicKey: P, secretKey: C };
      }),
      (t.sign.keyPair.fromSecretKey = function (P) {
        if ((Bn(P), P.length !== Hr)) throw new Error("bad secret key size");
        for (var C = new Uint8Array(Mr), $ = 0; $ < C.length; $++)
          C[$] = P[32 + $];
        return { publicKey: C, secretKey: new Uint8Array(P) };
      }),
      (t.sign.keyPair.fromSeed = function (P) {
        if ((Bn(P), P.length !== Yi)) throw new Error("bad seed size");
        for (
          var C = new Uint8Array(Mr), $ = new Uint8Array(Hr), b = 0;
          b < 32;
          b++
        )
          $[b] = P[b];
        return Lt(C, $, !0), { publicKey: C, secretKey: $ };
      }),
      (t.sign.publicKeyLength = Mr),
      (t.sign.secretKeyLength = Hr),
      (t.sign.seedLength = Yi),
      (t.sign.signatureLength = An),
      (t.hash = function (P) {
        Bn(P);
        var C = new Uint8Array(qr);
        return X(C, P, P.length), C;
      }),
      (t.hash.hashLength = qr),
      (t.verify = function (P, C) {
        return (
          Bn(P, C),
          P.length === 0 || C.length === 0 || P.length !== C.length
            ? !1
            : m(P, 0, C, 0, P.length) === 0
        );
      }),
      (t.setPRNG = function (P) {
        r = P;
      }),
      (function () {
        var P = typeof self < "u" ? self.crypto || self.msCrypto : null;
        if (P && P.getRandomValues) {
          var C = 65536;
          t.setPRNG(function ($, b) {
            var D,
              K = new Uint8Array(b);
            for (D = 0; D < b; D += C)
              P.getRandomValues(K.subarray(D, D + Math.min(b - D, C)));
            for (D = 0; D < b; D++) $[D] = K[D];
            no(K);
          });
        } else
          typeof d$ < "u" &&
            ((P = pr),
            P &&
              P.randomBytes &&
              t.setPRNG(function ($, b) {
                var D,
                  K = P.randomBytes(b);
                for (D = 0; D < b; D++) $[D] = K[D];
                no(K);
              }));
      })();
  })(e.exports ? e.exports : (self.nacl = self.nacl || {}));
})(nk);
var vte = nk.exports,
  Wm = vte.lowlevel.crypto_hash,
  sa = 0,
  Zs = function () {
    (this.S = [
      new Uint32Array([
        3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670,
        3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374,
        1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416,
        1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379,
        3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982,
        1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464,
        3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006,
        3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050,
        732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708,
        2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067,
        1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745,
        3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033,
        772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826,
        1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571,
        1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486,
        1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502,
        3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902,
        469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251,
        122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683,
        2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531,
        1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396,
        3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435,
        3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882,
        3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056,
        1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064,
        1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595,
        3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392,
        3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851,
        2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539,
        1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580,
        2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160,
        2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540,
        1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551,
        3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937,
        3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981,
        2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143,
        3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398,
        577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418,
        2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193,
        298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269,
        3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943,
        4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956,
        1404054877, 2845806497, 146425753, 1854211946,
      ]),
      new Uint32Array([
        1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493,
        2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449,
        422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325,
        1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673,
        1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473,
        1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447,
        1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805,
        4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981,
        3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892,
        3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881,
        3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856,
        1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655,
        3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252,
        1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668,
        3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616,
        3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781,
        1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859,
        1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206,
        2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330,
        694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202,
        3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277,
        423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102,
        3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133,
        1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780,
        354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286,
        53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820,
        4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346,
        2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511,
        2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927,
        300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857,
        1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956,
        2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347,
        1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338,
        3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373,
        3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030,
        4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533,
        157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106,
        497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875,
        2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966,
        3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476,
        2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037,
        1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792,
        356393447, 2410691914, 3873677099, 3682840055,
      ]),
      new Uint32Array([
        3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079,
        3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287,
        507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711,
        1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444,
        2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812,
        170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054,
        1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612,
        3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499,
        499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714,
        1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951,
        1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544,
        3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748,
        4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314,
        1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167,
        845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280,
        3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701,
        1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857,
        3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200,
        1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100,
        980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669,
        3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507,
        3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355,
        3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081,
        2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300,
        1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866,
        1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610,
        1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518,
        1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100,
        2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756,
        1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170,
        1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788,
        2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396,
        3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297,
        1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264,
        448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134,
        2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375,
        2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320,
        6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572,
        3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056,
        963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620,
        3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352,
        2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119,
        3617206836, 2455994898, 1729034894, 1080033504,
      ]),
      new Uint32Array([
        976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578,
        3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283,
        3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217,
        3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814,
        691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906,
        1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820,
        2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233,
        1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353,
        2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191,
        753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344,
        530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254,
        1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136,
        2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250,
        60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426,
        457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805,
        55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263,
        1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142,
        1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792,
        2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957,
        1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891,
        3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579,
        2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400,
        1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388,
        886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488,
        1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036,
        3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993,
        3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674,
        3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343,
        4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370,
        261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801,
        3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347,
        1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142,
        453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566,
        3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879,
        370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899,
        2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580,
        3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322,
        1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758,
        1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379,
        950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296,
        2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436,
        29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231,
        3075367218, 3463963227, 1469046755, 985887462,
      ]),
    ]),
      (this.P = new Uint32Array([
        608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832,
        137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300,
        3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731,
      ]));
  };
function Td(e, t, n) {
  return ((e[0][t[n + 3]] + e[1][t[n + 2]]) ^ e[2][t[n + 1]]) + e[3][t[n]];
}
Zs.prototype.encipher = function (e, t) {
  t === void 0 &&
    ((t = new Uint8Array(e.buffer)),
    e.byteOffset !== 0 && (t = t.subarray(e.byteOffset))),
    (e[0] ^= this.P[0]);
  for (var n = 1; n < 16; n += 2)
    (e[1] ^= Td(this.S, t, 0) ^ this.P[n]),
      (e[0] ^= Td(this.S, t, 4) ^ this.P[n + 1]);
  var r = e[0];
  (e[0] = e[1] ^ this.P[17]), (e[1] = r);
};
Zs.prototype.decipher = function (e) {
  var t = new Uint8Array(e.buffer);
  e.byteOffset !== 0 && (t = t.subarray(e.byteOffset)), (e[0] ^= this.P[17]);
  for (var n = 16; n > 0; n -= 2)
    (e[1] ^= Td(this.S, t, 0) ^ this.P[n]),
      (e[0] ^= Td(this.S, t, 4) ^ this.P[n - 1]);
  var r = e[0];
  (e[0] = e[1] ^ this.P[0]), (e[1] = r);
};
function Ss(e, t) {
  var n,
    r = 0;
  for (n = 0; n < 4; n++, sa++) sa >= t && (sa = 0), (r = (r << 8) | e[sa]);
  return r;
}
Zs.prototype.expand0state = function (e, t) {
  var n = new Uint32Array(2),
    r,
    i,
    a = new Uint8Array(n.buffer);
  for (r = 0, sa = 0; r < 18; r++) this.P[r] ^= Ss(e, t);
  for (sa = 0, r = 0; r < 18; r += 2)
    this.encipher(n, a), (this.P[r] = n[0]), (this.P[r + 1] = n[1]);
  for (r = 0; r < 4; r++)
    for (i = 0; i < 256; i += 2)
      this.encipher(n, a), (this.S[r][i] = n[0]), (this.S[r][i + 1] = n[1]);
};
Zs.prototype.expandstate = function (e, t, n, r) {
  var i = new Uint32Array(2),
    a,
    s;
  for (a = 0, sa = 0; a < 18; a++) this.P[a] ^= Ss(n, r);
  for (a = 0, sa = 0; a < 18; a += 2)
    (i[0] ^= Ss(e, t)),
      (i[1] ^= Ss(e, t)),
      this.encipher(i),
      (this.P[a] = i[0]),
      (this.P[a + 1] = i[1]);
  for (a = 0; a < 4; a++)
    for (s = 0; s < 256; s += 2)
      (i[0] ^= Ss(e, t)),
        (i[1] ^= Ss(e, t)),
        this.encipher(i),
        (this.S[a][s] = i[0]),
        (this.S[a][s + 1] = i[1]);
  sa = 0;
};
Zs.prototype.enc = function (e, t) {
  for (var n = 0; n < t; n++) this.encipher(e.subarray(n * 2));
};
Zs.prototype.dec = function (e, t) {
  for (var n = 0; n < t; n++) this.decipher(e.subarray(n * 2));
};
var Yf = 8,
  B0 = 32;
function U0(e, t, n) {
  var r = new Zs(),
    i = new Uint32Array(Yf),
    a,
    s = new Uint8Array([
      79, 120, 121, 99, 104, 114, 111, 109, 97, 116, 105, 99, 66, 108, 111, 119,
      102, 105, 115, 104, 83, 119, 97, 116, 68, 121, 110, 97, 109, 105, 116,
      101,
    ]);
  for (r.expandstate(t, 64, e, 64), a = 0; a < 64; a++)
    r.expand0state(t, 64), r.expand0state(e, 64);
  for (a = 0; a < Yf; a++) i[a] = Ss(s, s.byteLength);
  for (a = 0; a < 64; a++) r.enc(i, i.byteLength / 8);
  for (a = 0; a < Yf; a++)
    (n[4 * a + 3] = i[a] >>> 24),
      (n[4 * a + 2] = i[a] >>> 16),
      (n[4 * a + 1] = i[a] >>> 8),
      (n[4 * a + 0] = i[a]);
}
function yte(e, t, n, r, i, a, s) {
  var o = new Uint8Array(64),
    c = new Uint8Array(64),
    l = new Uint8Array(B0),
    f = new Uint8Array(B0),
    u = new Uint8Array(r + 4),
    d,
    p,
    h,
    m,
    g,
    v,
    y = a;
  if (
    s < 1 ||
    t === 0 ||
    r === 0 ||
    a === 0 ||
    a > l.byteLength * l.byteLength ||
    r > 1 << 20
  )
    return -1;
  for (
    m = Math.floor((a + l.byteLength - 1) / l.byteLength),
      h = Math.floor((a + m - 1) / m),
      d = 0;
    d < r;
    d++
  )
    u[d] = n[d];
  for (Wm(o, e, t), v = 1; a > 0; v++) {
    for (
      u[r + 0] = v >>> 24,
        u[r + 1] = v >>> 16,
        u[r + 2] = v >>> 8,
        u[r + 3] = v,
        Wm(c, u, r + 4),
        U0(o, c, f),
        d = l.byteLength;
      d--;

    )
      l[d] = f[d];
    for (d = 1; d < s; d++)
      for (Wm(c, f, f.byteLength), U0(o, c, f), p = 0; p < l.byteLength; p++)
        l[p] ^= f[p];
    for (
      h = Math.min(h, a), d = 0;
      d < h && ((g = d * m + (v - 1)), !(g >= y));
      d++
    )
      i[g] = l[d];
    a -= d;
  }
  return 0;
}
var rk = { BLOCKS: Yf, HASHSIZE: B0, hash: U0, pbkdf: yte },
  zm = { exports: {} },
  OA;
function es() {
  return (
    OA ||
      ((OA = 1),
      (function (e) {
        const t = pr;
        let n;
        try {
          n = require("cpu-features")();
        } catch {}
        const { bindingAvailable: r, CIPHER_INFO: i, MAC_INFO: a } = eo(),
          s = (() => {
            if (typeof t.sign == "function" && typeof t.verify == "function") {
              const R = `-----BEGIN PRIVATE KEY-----\r
MC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\r
-----END PRIVATE KEY-----`,
                A = Buffer.from("a");
              let I, S;
              try {
                (I = t.sign(null, A, R)), (S = t.verify(null, A, R, I));
              } catch {}
              return Buffer.isBuffer(I) && I.length === 64 && S === !0;
            }
            return !1;
          })(),
          o =
            typeof t.diffieHellman == "function" &&
            typeof t.generateKeyPairSync == "function" &&
            typeof t.createPublicKey == "function",
          c = [
            "ecdh-sha2-nistp256",
            "ecdh-sha2-nistp384",
            "ecdh-sha2-nistp521",
            "diffie-hellman-group-exchange-sha256",
            "diffie-hellman-group14-sha256",
            "diffie-hellman-group15-sha512",
            "diffie-hellman-group16-sha512",
            "diffie-hellman-group17-sha512",
            "diffie-hellman-group18-sha512",
          ];
        o &&
          (c.unshift("curve25519-sha256"),
          c.unshift("curve25519-sha256@libssh.org"));
        const l = c.concat([
            "diffie-hellman-group-exchange-sha1",
            "diffie-hellman-group14-sha1",
            "diffie-hellman-group1-sha1",
          ]),
          f = [
            "ecdsa-sha2-nistp256",
            "ecdsa-sha2-nistp384",
            "ecdsa-sha2-nistp521",
            "rsa-sha2-512",
            "rsa-sha2-256",
            "ssh-rsa",
          ];
        s && f.unshift("ssh-ed25519");
        const u = f.concat(["ssh-dss"]),
          d = (() => {
            const R = t.getCiphers();
            return (A) => R.includes(i[A].sslName);
          })();
        let p = [
          "aes128-gcm@openssh.com",
          "aes256-gcm@openssh.com",
          "aes128-ctr",
          "aes192-ctr",
          "aes256-ctr",
        ];
        n && n.flags && !n.flags.aes
          ? r
            ? p.unshift("chacha20-poly1305@openssh.com")
            : p.push("chacha20-poly1305@openssh.com")
          : r && n && n.arch === "x86"
          ? p.splice(4, 0, "chacha20-poly1305@openssh.com")
          : p.push("chacha20-poly1305@openssh.com"),
          (p = p.filter(d));
        const h = p.concat(
            [
              "aes256-cbc",
              "aes192-cbc",
              "aes128-cbc",
              "blowfish-cbc",
              "3des-cbc",
              "aes128-gcm",
              "aes256-gcm",
              "arcfour256",
              "arcfour128",
              "cast128-cbc",
              "arcfour",
            ].filter(d),
          ),
          m = (() => {
            const R = t.getHashes();
            return (A) => R.includes(a[A].sslName);
          })(),
          g = [
            "hmac-sha2-256-etm@openssh.com",
            "hmac-sha2-512-etm@openssh.com",
            "hmac-sha1-etm@openssh.com",
            "hmac-sha2-256",
            "hmac-sha2-512",
            "hmac-sha1",
          ].filter(m),
          v = g.concat(
            [
              "hmac-md5",
              "hmac-sha2-256-96",
              "hmac-sha2-512-96",
              "hmac-ripemd160",
              "hmac-sha1-96",
              "hmac-md5-96",
            ].filter(m),
          ),
          y = ["none", "zlib@openssh.com", "zlib"],
          _ = y.concat([]),
          E = {
            BAD_DHGEX: 1,
            OLD_EXIT: 2,
            DYN_RPORT_BUG: 4,
            BUG_DHGEX_LARGE: 8,
            IMPLY_RSA_SHA2_SIGALGS: 16,
          };
        (e.exports = {
          MESSAGE: {
            DISCONNECT: 1,
            IGNORE: 2,
            UNIMPLEMENTED: 3,
            DEBUG: 4,
            SERVICE_REQUEST: 5,
            SERVICE_ACCEPT: 6,
            EXT_INFO: 7,
            KEXINIT: 20,
            NEWKEYS: 21,
            KEXDH_INIT: 30,
            KEXDH_REPLY: 31,
            KEXDH_GEX_GROUP: 31,
            KEXDH_GEX_INIT: 32,
            KEXDH_GEX_REPLY: 33,
            KEXDH_GEX_REQUEST: 34,
            KEXECDH_INIT: 30,
            KEXECDH_REPLY: 31,
            USERAUTH_REQUEST: 50,
            USERAUTH_FAILURE: 51,
            USERAUTH_SUCCESS: 52,
            USERAUTH_BANNER: 53,
            USERAUTH_PASSWD_CHANGEREQ: 60,
            USERAUTH_PK_OK: 60,
            USERAUTH_INFO_REQUEST: 60,
            USERAUTH_INFO_RESPONSE: 61,
            GLOBAL_REQUEST: 80,
            REQUEST_SUCCESS: 81,
            REQUEST_FAILURE: 82,
            CHANNEL_OPEN: 90,
            CHANNEL_OPEN_CONFIRMATION: 91,
            CHANNEL_OPEN_FAILURE: 92,
            CHANNEL_WINDOW_ADJUST: 93,
            CHANNEL_DATA: 94,
            CHANNEL_EXTENDED_DATA: 95,
            CHANNEL_EOF: 96,
            CHANNEL_CLOSE: 97,
            CHANNEL_REQUEST: 98,
            CHANNEL_SUCCESS: 99,
            CHANNEL_FAILURE: 100,
          },
          DISCONNECT_REASON: {
            HOST_NOT_ALLOWED_TO_CONNECT: 1,
            PROTOCOL_ERROR: 2,
            KEY_EXCHANGE_FAILED: 3,
            RESERVED: 4,
            MAC_ERROR: 5,
            COMPRESSION_ERROR: 6,
            SERVICE_NOT_AVAILABLE: 7,
            PROTOCOL_VERSION_NOT_SUPPORTED: 8,
            HOST_KEY_NOT_VERIFIABLE: 9,
            CONNECTION_LOST: 10,
            BY_APPLICATION: 11,
            TOO_MANY_CONNECTIONS: 12,
            AUTH_CANCELED_BY_USER: 13,
            NO_MORE_AUTH_METHODS_AVAILABLE: 14,
            ILLEGAL_USER_NAME: 15,
          },
          DISCONNECT_REASON_STR: void 0,
          CHANNEL_OPEN_FAILURE: {
            ADMINISTRATIVELY_PROHIBITED: 1,
            CONNECT_FAILED: 2,
            UNKNOWN_CHANNEL_TYPE: 3,
            RESOURCE_SHORTAGE: 4,
          },
          TERMINAL_MODE: {
            TTY_OP_END: 0,
            VINTR: 1,
            VQUIT: 2,
            VERASE: 3,
            VKILL: 4,
            VEOF: 5,
            VEOL: 6,
            VEOL2: 7,
            VSTART: 8,
            VSTOP: 9,
            VSUSP: 10,
            VDSUSP: 11,
            VREPRINT: 12,
            VWERASE: 13,
            VLNEXT: 14,
            VFLUSH: 15,
            VSWTCH: 16,
            VSTATUS: 17,
            VDISCARD: 18,
            IGNPAR: 30,
            PARMRK: 31,
            INPCK: 32,
            ISTRIP: 33,
            INLCR: 34,
            IGNCR: 35,
            ICRNL: 36,
            IUCLC: 37,
            IXON: 38,
            IXANY: 39,
            IXOFF: 40,
            IMAXBEL: 41,
            ISIG: 50,
            ICANON: 51,
            XCASE: 52,
            ECHO: 53,
            ECHOE: 54,
            ECHOK: 55,
            ECHONL: 56,
            NOFLSH: 57,
            TOSTOP: 58,
            IEXTEN: 59,
            ECHOCTL: 60,
            ECHOKE: 61,
            PENDIN: 62,
            OPOST: 70,
            OLCUC: 71,
            ONLCR: 72,
            OCRNL: 73,
            ONOCR: 74,
            ONLRET: 75,
            CS7: 90,
            CS8: 91,
            PARENB: 92,
            PARODD: 93,
            TTY_OP_ISPEED: 128,
            TTY_OP_OSPEED: 129,
          },
          CHANNEL_EXTENDED_DATATYPE: { STDERR: 1 },
          SIGNALS: [
            "ABRT",
            "ALRM",
            "FPE",
            "HUP",
            "ILL",
            "INT",
            "QUIT",
            "SEGV",
            "TERM",
            "USR1",
            "USR2",
            "KILL",
            "PIPE",
          ].reduce((R, A) => ({ ...R, [A]: 1 }), {}),
          COMPAT: E,
          COMPAT_CHECKS: [
            ["Cisco-1.25", E.BAD_DHGEX],
            [/^Cisco-1[.]/, E.BUG_DHGEX_LARGE],
            [/^[0-9.]+$/, E.OLD_EXIT],
            [/^OpenSSH_5[.][0-9]+/, E.DYN_RPORT_BUG],
            [/^OpenSSH_7[.]4/, E.IMPLY_RSA_SHA2_SIGALGS],
          ],
          DEFAULT_KEX: c,
          SUPPORTED_KEX: l,
          DEFAULT_SERVER_HOST_KEY: f,
          SUPPORTED_SERVER_HOST_KEY: u,
          DEFAULT_CIPHER: p,
          SUPPORTED_CIPHER: h,
          DEFAULT_MAC: g,
          SUPPORTED_MAC: v,
          DEFAULT_COMPRESSION: y,
          SUPPORTED_COMPRESSION: _,
          curve25519Supported: o,
          eddsaSupported: s,
        }),
          (e.exports.DISCONNECT_REASON_BY_VALUE = Array.from(
            Object.entries(e.exports.DISCONNECT_REASON),
          ).reduce((R, [A, I]) => ({ ...R, [I]: A }), {}));
      })(zm)),
    zm.exports
  );
}
var Km, PA;
function Ki() {
  if (PA) return Km;
  PA = 1;
  const e = Yp.Ber;
  let t;
  const n = Buffer[Symbol.species],
    r = Object.getPrototypeOf(Uint8Array.prototype).fill;
  function i(u, d) {
    return u[d++] * 16777216 + u[d++] * 65536 + u[d++] * 256 + u[d];
  }
  function a(u, d, p, h, m) {
    m || (m = 0), h > u.length && (h = u.length);
    let g = h - p;
    const v = d.length - m;
    return (
      g > v && (g = v),
      d.set(new Uint8Array(u.buffer, u.byteOffset + p, g), m),
      g
    );
  }
  function s(u, d, p) {
    return (
      p === void 0 && (p = u.length), new n(u.buffer, u.byteOffset + d, p - d)
    );
  }
  function o() {
    let u = 0,
      d;
    const p = {
      init: (h, m) => {
        (d = h), (u = typeof m == "number" ? m : 0);
      },
      pos: () => u,
      length: () => (d ? d.length : 0),
      avail: () => (d && u < d.length ? d.length - u : 0),
      clear: () => {
        d = void 0;
      },
      readUInt32BE: () => {
        if (!(!d || u + 3 >= d.length))
          return d[u++] * 16777216 + d[u++] * 65536 + d[u++] * 256 + d[u++];
      },
      readUInt64BE: (h) => {
        if (!(!d || u + 7 >= d.length))
          switch (h) {
            case "always":
              return BigInt(`0x${d.hexSlice(u, (u += 8))}`);
            case "maybe":
              if (d[u] > 31) return BigInt(`0x${d.hexSlice(u, (u += 8))}`);
            default:
              return (
                d[u++] * 72057594037927940 +
                d[u++] * 281474976710656 +
                d[u++] * 1099511627776 +
                d[u++] * 4294967296 +
                d[u++] * 16777216 +
                d[u++] * 65536 +
                d[u++] * 256 +
                d[u++]
              );
          }
      },
      skip: (h) => {
        d && h > 0 && (u += h);
      },
      skipString: () => {
        const h = p.readUInt32BE();
        if (h !== void 0) return (u += h), u <= d.length ? h : void 0;
      },
      readByte: () => {
        if (d && u < d.length) return d[u++];
      },
      readBool: () => {
        if (d && u < d.length) return !!d[u++];
      },
      readList: () => {
        const h = p.readString(!0);
        if (h !== void 0) return h ? h.split(",") : [];
      },
      readString: (h, m) => {
        typeof h == "number" && ((m = h), (h = void 0));
        const g = p.readUInt32BE();
        if (
          g !== void 0 &&
          !(d.length - u < g || (typeof m == "number" && g > m))
        )
          return h
            ? Buffer.isBuffer(h)
              ? a(d, h, u, (u += g))
              : d.utf8Slice(u, (u += g))
            : s(d, u, (u += g));
      },
      readRaw: (h) => {
        if (d) {
          if (typeof h != "number") return s(d, u, (u += d.length - u));
          if (d.length - u >= h) return s(d, u, (u += h));
        }
      },
    };
    return p;
  }
  function c(u, d, p) {
    const h = new Error(u);
    return (
      typeof d == "boolean"
        ? ((p = d), (h.level = "protocol"))
        : (h.level = d || "protocol"),
      (h.fatal = !!p),
      h
    );
  }
  function l(u, d, p) {
    return (
      (u[p++] = d >>> 24),
      (u[p++] = d >>> 16),
      (u[p++] = d >>> 8),
      (u[p++] = d),
      p
    );
  }
  const f = o();
  return (
    (Km = {
      bufferCopy: a,
      bufferSlice: s,
      FastBuffer: n,
      bufferFill: (u, d, p, h) => r.call(u, d, p, h),
      makeError: c,
      doFatalError: (u, d, p, h) => {
        let m;
        return (
          t === void 0 && ({ DISCONNECT_REASON: t } = es()),
          d instanceof Error
            ? ((m = d), typeof p != "number" ? (h = t.PROTOCOL_ERROR) : (h = p))
            : (m = c(d, p, !0)),
          typeof h != "number" && (h = t.PROTOCOL_ERROR),
          u.disconnect(h),
          u._destruct(),
          u._onError(m),
          1 / 0
        );
      },
      readUInt32BE: i,
      writeUInt32BE: l,
      writeUInt32LE: (u, d, p) => (
        (u[p++] = d),
        (u[p++] = d >>> 8),
        (u[p++] = d >>> 16),
        (u[p++] = d >>> 24),
        p
      ),
      makeBufferParser: o,
      bufferParser: o(),
      readString: (u, d, p, h) => {
        typeof p == "number" && ((h = p), (p = void 0)),
          d === void 0 && (d = 0);
        const m = u.length - d;
        if (d < 0 || d >= u.length || m < 4) return;
        const g = i(u, d);
        if (m < 4 + g || (typeof h == "number" && g > h)) return;
        d += 4;
        const v = d + g;
        return (
          (u._pos = v),
          p
            ? Buffer.isBuffer(p)
              ? a(u, p, d, v)
              : u.utf8Slice(d, v)
            : s(u, d, v)
        );
      },
      sigSSHToASN1: (u, d) => {
        switch (d) {
          case "ssh-dss": {
            if (u.length > 40) return u;
            const p = new e.Writer();
            p.startSequence();
            let h = u.slice(0, 20),
              m = u.slice(20);
            if (h[0] & 128) {
              const g = Buffer.allocUnsafe(21);
              (g[0] = 0), h.copy(g, 1), (h = g);
            } else h[0] === 0 && !(h[1] & 128) && (h = h.slice(1));
            if (m[0] & 128) {
              const g = Buffer.allocUnsafe(21);
              (g[0] = 0), m.copy(g, 1), (m = g);
            } else m[0] === 0 && !(m[1] & 128) && (m = m.slice(1));
            return (
              p.writeBuffer(h, e.Integer),
              p.writeBuffer(m, e.Integer),
              p.endSequence(),
              p.buffer
            );
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            f.init(u, 0);
            const p = f.readString(),
              h = f.readString();
            if ((f.clear(), p === void 0 || h === void 0)) return;
            const m = new e.Writer();
            return (
              m.startSequence(),
              m.writeBuffer(p, e.Integer),
              m.writeBuffer(h, e.Integer),
              m.endSequence(),
              m.buffer
            );
          }
          default:
            return u;
        }
      },
      convertSignature: (u, d) => {
        switch (d) {
          case "ssh-dss": {
            if (u.length <= 40) return u;
            const p = new e.Reader(u);
            p.readSequence();
            let h = p.readString(e.Integer, !0),
              m = p.readString(e.Integer, !0),
              g = 0,
              v = 0;
            if (h.length < 20) {
              const _ = Buffer.allocUnsafe(20);
              _.set(h, 1), (h = _), (h[0] = 0);
            }
            if (m.length < 20) {
              const _ = Buffer.allocUnsafe(20);
              _.set(m, 1), (m = _), (m[0] = 0);
            }
            h.length > 20 && h[0] === 0 && (g = 1),
              m.length > 20 && m[0] === 0 && (v = 1);
            const y = Buffer.allocUnsafe(h.length - g + (m.length - v));
            return (
              a(h, y, g, h.length, 0), a(m, y, v, m.length, h.length - g), y
            );
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            if (u[0] === 0) return u;
            const p = new e.Reader(u);
            p.readSequence();
            const h = p.readString(e.Integer, !0),
              m = p.readString(e.Integer, !0);
            if (h === null || m === null) return;
            const g = Buffer.allocUnsafe(4 + h.length + 4 + m.length);
            return (
              l(g, h.length, 0),
              g.set(h, 4),
              l(g, m.length, 4 + h.length),
              g.set(m, 4 + 4 + h.length),
              g
            );
          }
        }
        return u;
      },
      sendPacket: (u, d, p) =>
        !p && u._kexinit !== void 0
          ? (u._queue === void 0 && (u._queue = []),
            u._queue.push(d),
            u._debug && u._debug("Outbound: ... packet queued"),
            !1)
          : (u._cipher.encrypt(d), !0),
    }),
    Km
  );
}
var Vm = { exports: {} },
  DA;
function bte() {
  return (
    DA ||
      ((DA = 1),
      (function (e, t) {
        var n = (function () {
          var r =
            typeof document < "u" && document.currentScript
              ? document.currentScript.src
              : void 0;
          return (
            typeof __filename < "u" && (r = r || __filename),
            function (i) {
              i = i || {};
              var a;
              a || (a = typeof i < "u" ? i : {});
              var s, o;
              a.ready = new Promise(function (te, ie) {
                (s = te), (o = ie);
              });
              var c = {},
                l;
              for (l in a) a.hasOwnProperty(l) && (c[l] = a[l]);
              var f = typeof window == "object",
                u = typeof importScripts == "function",
                d =
                  typeof process == "object" &&
                  typeof process.versions == "object" &&
                  typeof process.versions.node == "string",
                p = "",
                h,
                m,
                g,
                v,
                y;
              d
                ? ((p = u ? pt.dirname(p) + "/" : __dirname + "/"),
                  (h = function (te, ie) {
                    var X = re(te);
                    return X
                      ? ie
                        ? X
                        : X.toString()
                      : (v || (v = Xt),
                        y || (y = pt),
                        (te = y.normalize(te)),
                        v.readFileSync(te, ie ? null : "utf8"));
                  }),
                  (g = function (te) {
                    return (
                      (te = h(te, !0)),
                      te.buffer || (te = new Uint8Array(te)),
                      I(te.buffer),
                      te
                    );
                  }),
                  (m = function (te, ie, X) {
                    var he = re(te);
                    he && ie(he),
                      v || (v = Xt),
                      y || (y = pt),
                      (te = y.normalize(te)),
                      v.readFile(te, function (be, ye) {
                        be ? X(be) : ie(ye.buffer);
                      });
                  }),
                  1 < process.argv.length &&
                    process.argv[1].replace(/\\/g, "/"),
                  process.argv.slice(2),
                  (a.inspect = function () {
                    return "[Emscripten Module object]";
                  }))
                : (f || u) &&
                  (u
                    ? (p = self.location.href)
                    : typeof document < "u" &&
                      document.currentScript &&
                      (p = document.currentScript.src),
                  r && (p = r),
                  p.indexOf("blob:") !== 0
                    ? (p = p.substr(0, p.lastIndexOf("/") + 1))
                    : (p = ""),
                  (h = function (te) {
                    try {
                      var ie = new XMLHttpRequest();
                      return (
                        ie.open("GET", te, !1), ie.send(null), ie.responseText
                      );
                    } catch (be) {
                      if ((te = re(te))) {
                        ie = [];
                        for (var X = 0; X < te.length; X++) {
                          var he = te[X];
                          255 < he && (he &= 255),
                            ie.push(String.fromCharCode(he));
                        }
                        return ie.join("");
                      }
                      throw be;
                    }
                  }),
                  u &&
                    (g = function (te) {
                      try {
                        var ie = new XMLHttpRequest();
                        return (
                          ie.open("GET", te, !1),
                          (ie.responseType = "arraybuffer"),
                          ie.send(null),
                          new Uint8Array(ie.response)
                        );
                      } catch (X) {
                        if ((te = re(te))) return te;
                        throw X;
                      }
                    }),
                  (m = function (te, ie, X) {
                    var he = new XMLHttpRequest();
                    he.open("GET", te, !0),
                      (he.responseType = "arraybuffer"),
                      (he.onload = function () {
                        if (he.status == 200 || (he.status == 0 && he.response))
                          ie(he.response);
                        else {
                          var be = re(te);
                          be ? ie(be.buffer) : X();
                        }
                      }),
                      (he.onerror = X),
                      he.send(null);
                  })),
                a.print || console.log.bind(console);
              var _ = a.printErr || console.warn.bind(console);
              for (l in c) c.hasOwnProperty(l) && (a[l] = c[l]);
              c = null;
              var E;
              a.wasmBinary && (E = a.wasmBinary),
                a.noExitRuntime,
                typeof WebAssembly != "object" &&
                  W("no native wasm support detected");
              var R,
                A = !1;
              function I(te, ie) {
                te || W("Assertion failed: " + ie);
              }
              function S(te) {
                var ie = a["_" + te];
                return (
                  I(
                    ie,
                    "Cannot call unknown function " +
                      te +
                      ", make sure it is exported",
                  ),
                  ie
                );
              }
              function w(te, ie, X, he) {
                var be = {
                    string: function (We) {
                      var bt = 0;
                      if (We != null && We !== 0) {
                        var wt = (We.length << 2) + 1;
                        bt = oe(wt);
                        var ct = bt,
                          ze = H;
                        if (0 < wt) {
                          wt = ct + wt - 1;
                          for (var dt = 0; dt < We.length; ++dt) {
                            var ht = We.charCodeAt(dt);
                            if (55296 <= ht && 57343 >= ht) {
                              var an = We.charCodeAt(++dt);
                              ht = (65536 + ((ht & 1023) << 10)) | (an & 1023);
                            }
                            if (127 >= ht) {
                              if (ct >= wt) break;
                              ze[ct++] = ht;
                            } else {
                              if (2047 >= ht) {
                                if (ct + 1 >= wt) break;
                                ze[ct++] = 192 | (ht >> 6);
                              } else {
                                if (65535 >= ht) {
                                  if (ct + 2 >= wt) break;
                                  ze[ct++] = 224 | (ht >> 12);
                                } else {
                                  if (ct + 3 >= wt) break;
                                  (ze[ct++] = 240 | (ht >> 18)),
                                    (ze[ct++] = 128 | ((ht >> 12) & 63));
                                }
                                ze[ct++] = 128 | ((ht >> 6) & 63);
                              }
                              ze[ct++] = 128 | (ht & 63);
                            }
                          }
                          ze[ct] = 0;
                        }
                      }
                      return bt;
                    },
                    array: function (We) {
                      var bt = oe(We.length);
                      return j.set(We, bt), bt;
                    },
                  },
                  ye = S(te),
                  Qe = [];
                if (((te = 0), he))
                  for (var lt = 0; lt < he.length; lt++) {
                    var Lt = be[X[lt]];
                    Lt
                      ? (te === 0 && (te = Y()), (Qe[lt] = Lt(he[lt])))
                      : (Qe[lt] = he[lt]);
                  }
                return (
                  (X = ye.apply(null, Qe)),
                  (X = (function (We) {
                    if (ie === "string")
                      if (We) {
                        for (
                          var bt = H, wt = We + NaN, ct = We;
                          bt[ct] && !(ct >= wt);

                        )
                          ++ct;
                        if (16 < ct - We && bt.subarray && O)
                          We = O.decode(bt.subarray(We, ct));
                        else {
                          for (wt = ""; We < ct; ) {
                            var ze = bt[We++];
                            if (ze & 128) {
                              var dt = bt[We++] & 63;
                              if ((ze & 224) == 192)
                                wt += String.fromCharCode(
                                  ((ze & 31) << 6) | dt,
                                );
                              else {
                                var ht = bt[We++] & 63;
                                (ze =
                                  (ze & 240) == 224
                                    ? ((ze & 15) << 12) | (dt << 6) | ht
                                    : ((ze & 7) << 18) |
                                      (dt << 12) |
                                      (ht << 6) |
                                      (bt[We++] & 63)),
                                  65536 > ze
                                    ? (wt += String.fromCharCode(ze))
                                    : ((ze -= 65536),
                                      (wt += String.fromCharCode(
                                        55296 | (ze >> 10),
                                        56320 | (ze & 1023),
                                      )));
                              }
                            } else wt += String.fromCharCode(ze);
                          }
                          We = wt;
                        }
                      } else We = "";
                    else We = ie === "boolean" ? !!We : We;
                    return We;
                  })(X)),
                  te !== 0 && M(te),
                  X
                );
              }
              var O =
                  typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0,
                Q,
                j,
                H;
              function q() {
                var te = R.buffer;
                (Q = te),
                  (a.HEAP8 = j = new Int8Array(te)),
                  (a.HEAP16 = new Int16Array(te)),
                  (a.HEAP32 = new Int32Array(te)),
                  (a.HEAPU8 = H = new Uint8Array(te)),
                  (a.HEAPU16 = new Uint16Array(te)),
                  (a.HEAPU32 = new Uint32Array(te)),
                  (a.HEAPF32 = new Float32Array(te)),
                  (a.HEAPF64 = new Float64Array(te));
              }
              var J,
                Z = [],
                z = [],
                U = [];
              function G() {
                var te = a.preRun.shift();
                Z.unshift(te);
              }
              var L = 0,
                k = null;
              (a.preloadedImages = {}), (a.preloadedAudios = {});
              function W(te) {
                throw (
                  (a.onAbort && a.onAbort(te),
                  _(te),
                  (A = !0),
                  (te = new WebAssembly.RuntimeError(
                    "abort(" +
                      te +
                      "). Build with -s ASSERTIONS=1 for more info.",
                  )),
                  o(te),
                  te)
                );
              }
              var F = "data:application/octet-stream;base64,",
                x;
              if (
                ((x =
                  "data:application/octet-stream;base64,AGFzbQEAAAABIAZgAX8Bf2ADf39/AGABfwBgAABgAAF/YAZ/f39/f38AAgcBAWEBYQAAAwsKAAEDAQAAAgQFAgQFAXABAQEFBwEBgAKAgAIGCQF/AUGAjMACCwclCQFiAgABYwADAWQACQFlAAgBZgAHAWcABgFoAAUBaQAKAWoBAAqGTQpPAQJ/QYAIKAIAIgEgAEEDakF8cSICaiEAAkAgAkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQAEUNAQtBgAggADYCACABDwtBhAhBMDYCAEF/C4wFAg5+Cn8gACgCJCEUIAAoAiAhFSAAKAIcIREgACgCGCESIAAoAhQhEyACQRBPBEAgAC0ATEVBGHQhFyAAKAIEIhZBBWytIQ8gACgCCCIYQQVsrSENIAAoAgwiGUEFbK0hCyAAKAIQIhpBBWytIQkgADUCACEIIBqtIRAgGa0hDiAYrSEMIBatIQoDQCASIAEtAAMiEiABLQAEQQh0ciABLQAFQRB0ciABLQAGIhZBGHRyQQJ2Qf///x9xaq0iAyAOfiABLwAAIAEtAAJBEHRyIBNqIBJBGHRBgICAGHFqrSIEIBB+fCARIAEtAAdBCHQgFnIgAS0ACEEQdHIgAS0ACSIRQRh0ckEEdkH///8fcWqtIgUgDH58IAEtAApBCHQgEXIgAS0AC0EQdHIgAS0ADEEYdHJBBnYgFWqtIgYgCn58IBQgF2ogAS8ADSABLQAPQRB0cmqtIgcgCH58IAMgDH4gBCAOfnwgBSAKfnwgBiAIfnwgByAJfnwgAyAKfiAEIAx+fCAFIAh+fCAGIAl+fCAHIAt+fCADIAh+IAQgCn58IAUgCX58IAYgC358IAcgDX58IAMgCX4gBCAIfnwgBSALfnwgBiANfnwgByAPfnwiA0IaiEL/////D4N8IgRCGohC/////w+DfCIFQhqIQv////8Pg3wiBkIaiEL/////D4N8IgdCGoinQQVsIAOnQf///x9xaiITQRp2IASnQf///x9xaiESIAWnQf///x9xIREgBqdB////H3EhFSAHp0H///8fcSEUIBNB////H3EhEyABQRBqIQEgAkEQayICQQ9LDQALCyAAIBQ2AiQgACAVNgIgIAAgETYCHCAAIBI2AhggACATNgIUCwMAAQu2BAEGfwJAIAAoAjgiBARAIABBPGohBQJAIAJBECAEayIDIAIgA0kbIgZFDQAgBkEDcSEHAkAgBkEBa0EDSQRAQQAhAwwBCyAGQXxxIQhBACEDA0AgBSADIARqaiABIANqLQAAOgAAIAUgA0EBciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0ECciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0EDciIEIAAoAjhqaiABIARqLQAAOgAAIANBBGohAyAAKAI4IQQgCEEEayIIDQALCyAHRQ0AA0AgBSADIARqaiABIANqLQAAOgAAIANBAWohAyAAKAI4IQQgB0EBayIHDQALCyAAIAQgBmoiAzYCOCADQRBJDQEgACAFQRAQAiAAQQA2AjggAiAGayECIAEgBmohAQsgAkEQTwRAIAAgASACQXBxIgMQAiACQQ9xIQIgASADaiEBCyACRQ0AIAJBA3EhBCAAQTxqIQVBACEDIAJBAWtBA08EQCACQXxxIQcDQCAFIAAoAjggA2pqIAEgA2otAAA6AAAgBSADQQFyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQJyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQNyIgYgACgCOGpqIAEgBmotAAA6AAAgA0EEaiEDIAdBBGsiBw0ACwsgBARAA0AgBSAAKAI4IANqaiABIANqLQAAOgAAIANBAWohAyAEQQFrIgQNAAsLIAAgACgCOCACajYCOAsLoS0BDH8jAEEQayIMJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEH0AU0EQEGICCgCACIFQRAgAEELakF4cSAAQQtJGyIIQQN2IgJ2IgFBA3EEQCABQX9zQQFxIAJqIgNBA3QiAUG4CGooAgAiBEEIaiEAAkAgBCgCCCICIAFBsAhqIgFGBEBBiAggBUF+IAN3cTYCAAwBCyACIAE2AgwgASACNgIICyAEIANBA3QiAUEDcjYCBCABIARqIgEgASgCBEEBcjYCBAwNCyAIQZAIKAIAIgpNDQEgAQRAAkBBAiACdCIAQQAgAGtyIAEgAnRxIgBBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2aiIDQQN0IgBBuAhqKAIAIgQoAggiASAAQbAIaiIARgRAQYgIIAVBfiADd3EiBTYCAAwBCyABIAA2AgwgACABNgIICyAEQQhqIQAgBCAIQQNyNgIEIAQgCGoiAiADQQN0IgEgCGsiA0EBcjYCBCABIARqIAM2AgAgCgRAIApBA3YiAUEDdEGwCGohB0GcCCgCACEEAn8gBUEBIAF0IgFxRQRAQYgIIAEgBXI2AgAgBwwBCyAHKAIICyEBIAcgBDYCCCABIAQ2AgwgBCAHNgIMIAQgATYCCAtBnAggAjYCAEGQCCADNgIADA0LQYwIKAIAIgZFDQEgBkEAIAZrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QbgKaigCACIBKAIEQXhxIAhrIQMgASECA0ACQCACKAIQIgBFBEAgAigCFCIARQ0BCyAAKAIEQXhxIAhrIgIgAyACIANJIgIbIQMgACABIAIbIQEgACECDAELCyABIAhqIgkgAU0NAiABKAIYIQsgASABKAIMIgRHBEAgASgCCCIAQZgIKAIASRogACAENgIMIAQgADYCCAwMCyABQRRqIgIoAgAiAEUEQCABKAIQIgBFDQQgAUEQaiECCwNAIAIhByAAIgRBFGoiAigCACIADQAgBEEQaiECIAQoAhAiAA0ACyAHQQA2AgAMCwtBfyEIIABBv39LDQAgAEELaiIAQXhxIQhBjAgoAgAiCUUNAEEAIAhrIQMCQAJAAkACf0EAIAhBgAJJDQAaQR8gCEH///8HSw0AGiAAQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgCCAAQRVqdkEBcXJBHGoLIgVBAnRBuApqKAIAIgJFBEBBACEADAELQQAhACAIQQBBGSAFQQF2ayAFQR9GG3QhAQNAAkAgAigCBEF4cSAIayIHIANPDQAgAiEEIAciAw0AQQAhAyACIQAMAwsgACACKAIUIgcgByACIAFBHXZBBHFqKAIQIgJGGyAAIAcbIQAgAUEBdCEBIAINAAsLIAAgBHJFBEBBACEEQQIgBXQiAEEAIABrciAJcSIARQ0DIABBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2akECdEG4CmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAhrIgEgA0khAiABIAMgAhshAyAAIAQgAhshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANBkAgoAgAgCGtPDQAgBCAIaiIGIARNDQEgBCgCGCEFIAQgBCgCDCIBRwRAIAQoAggiAEGYCCgCAEkaIAAgATYCDCABIAA2AggMCgsgBEEUaiICKAIAIgBFBEAgBCgCECIARQ0EIARBEGohAgsDQCACIQcgACIBQRRqIgIoAgAiAA0AIAFBEGohAiABKAIQIgANAAsgB0EANgIADAkLIAhBkAgoAgAiAk0EQEGcCCgCACEDAkAgAiAIayIBQRBPBEBBkAggATYCAEGcCCADIAhqIgA2AgAgACABQQFyNgIEIAIgA2ogATYCACADIAhBA3I2AgQMAQtBnAhBADYCAEGQCEEANgIAIAMgAkEDcjYCBCACIANqIgAgACgCBEEBcjYCBAsgA0EIaiEADAsLIAhBlAgoAgAiBkkEQEGUCCAGIAhrIgE2AgBBoAhBoAgoAgAiAiAIaiIANgIAIAAgAUEBcjYCBCACIAhBA3I2AgQgAkEIaiEADAsLQQAhACAIQS9qIgkCf0HgCygCAARAQegLKAIADAELQewLQn83AgBB5AtCgKCAgICABDcCAEHgCyAMQQxqQXBxQdiq1aoFczYCAEH0C0EANgIAQcQLQQA2AgBBgCALIgFqIgVBACABayIHcSICIAhNDQpBwAsoAgAiBARAQbgLKAIAIgMgAmoiASADTQ0LIAEgBEsNCwtBxAstAABBBHENBQJAAkBBoAgoAgAiAwRAQcgLIQADQCADIAAoAgAiAU8EQCABIAAoAgRqIANLDQMLIAAoAggiAA0ACwtBABABIgFBf0YNBiACIQVB5AsoAgAiA0EBayIAIAFxBEAgAiABayAAIAFqQQAgA2txaiEFCyAFIAhNDQYgBUH+////B0sNBkHACygCACIEBEBBuAsoAgAiAyAFaiIAIANNDQcgACAESw0HCyAFEAEiACABRw0BDAgLIAUgBmsgB3EiBUH+////B0sNBSAFEAEiASAAKAIAIAAoAgRqRg0EIAEhAAsCQCAAQX9GDQAgCEEwaiAFTQ0AQegLKAIAIgEgCSAFa2pBACABa3EiAUH+////B0sEQCAAIQEMCAsgARABQX9HBEAgASAFaiEFIAAhAQwIC0EAIAVrEAEaDAULIAAiAUF/Rw0GDAQLAAtBACEEDAcLQQAhAQwFCyABQX9HDQILQcQLQcQLKAIAQQRyNgIACyACQf7///8HSw0BIAIQASEBQQAQASEAIAFBf0YNASAAQX9GDQEgACABTQ0BIAAgAWsiBSAIQShqTQ0BC0G4C0G4CygCACAFaiIANgIAQbwLKAIAIABJBEBBvAsgADYCAAsCQAJAAkBBoAgoAgAiBwRAQcgLIQADQCABIAAoAgAiAyAAKAIEIgJqRg0CIAAoAggiAA0ACwwCC0GYCCgCACIAQQAgACABTRtFBEBBmAggATYCAAtBACEAQcwLIAU2AgBByAsgATYCAEGoCEF/NgIAQawIQeALKAIANgIAQdQLQQA2AgADQCAAQQN0IgNBuAhqIANBsAhqIgI2AgAgA0G8CGogAjYCACAAQQFqIgBBIEcNAAtBlAggBUEoayIDQXggAWtBB3FBACABQQhqQQdxGyIAayICNgIAQaAIIAAgAWoiADYCACAAIAJBAXI2AgQgASADakEoNgIEQaQIQfALKAIANgIADAILIAAtAAxBCHENACADIAdLDQAgASAHTQ0AIAAgAiAFajYCBEGgCCAHQXggB2tBB3FBACAHQQhqQQdxGyIAaiICNgIAQZQIQZQIKAIAIAVqIgEgAGsiADYCACACIABBAXI2AgQgASAHakEoNgIEQaQIQfALKAIANgIADAELQZgIKAIAIAFLBEBBmAggATYCAAsgASAFaiECQcgLIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQcgLIQADQCAHIAAoAgAiAk8EQCACIAAoAgRqIgQgB0sNAwsgACgCCCEADAALAAsgACABNgIAIAAgACgCBCAFajYCBCABQXggAWtBB3FBACABQQhqQQdxG2oiCSAIQQNyNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIFIAggCWoiBmshAiAFIAdGBEBBoAggBjYCAEGUCEGUCCgCACACaiIANgIAIAYgAEEBcjYCBAwDCyAFQZwIKAIARgRAQZwIIAY2AgBBkAhBkAgoAgAgAmoiADYCACAGIABBAXI2AgQgACAGaiAANgIADAMLIAUoAgQiAEEDcUEBRgRAIABBeHEhBwJAIABB/wFNBEAgBSgCCCIDIABBA3YiAEEDdEGwCGpGGiADIAUoAgwiAUYEQEGICEGICCgCAEF+IAB3cTYCAAwCCyADIAE2AgwgASADNgIIDAELIAUoAhghCAJAIAUgBSgCDCIBRwRAIAUoAggiACABNgIMIAEgADYCCAwBCwJAIAVBFGoiACgCACIDDQAgBUEQaiIAKAIAIgMNAEEAIQEMAQsDQCAAIQQgAyIBQRRqIgAoAgAiAw0AIAFBEGohACABKAIQIgMNAAsgBEEANgIACyAIRQ0AAkAgBSAFKAIcIgNBAnRBuApqIgAoAgBGBEAgACABNgIAIAENAUGMCEGMCCgCAEF+IAN3cTYCAAwCCyAIQRBBFCAIKAIQIAVGG2ogATYCACABRQ0BCyABIAg2AhggBSgCECIABEAgASAANgIQIAAgATYCGAsgBSgCFCIARQ0AIAEgADYCFCAAIAE2AhgLIAUgB2ohBSACIAdqIQILIAUgBSgCBEF+cTYCBCAGIAJBAXI2AgQgAiAGaiACNgIAIAJB/wFNBEAgAkEDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwDC0EfIQAgAkH///8HTQRAIAJBCHYiACAAQYD+P2pBEHZBCHEiA3QiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASADciAAcmsiAEEBdCACIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQQCQEGMCCgCACIDQQEgAHQiAXFFBEBBjAggASADcjYCACAEIAY2AgAgBiAENgIYDAELIAJBAEEZIABBAXZrIABBH0YbdCEAIAQoAgAhAQNAIAEiAygCBEF4cSACRg0DIABBHXYhASAAQQF0IQAgAyABQQRxaiIEKAIQIgENAAsgBCAGNgIQIAYgAzYCGAsgBiAGNgIMIAYgBjYCCAwCC0GUCCAFQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBBoAggACABaiIANgIAIAAgAkEBcjYCBCABIANqQSg2AgRBpAhB8AsoAgA2AgAgByAEQScgBGtBB3FBACAEQSdrQQdxG2pBL2siACAAIAdBEGpJGyICQRs2AgQgAkHQCykCADcCECACQcgLKQIANwIIQdALIAJBCGo2AgBBzAsgBTYCAEHICyABNgIAQdQLQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgASAESQ0ACyACIAdGDQMgAiACKAIEQX5xNgIEIAcgAiAHayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAEEDdEGwCGohAgJ/QYgIKAIAIgFBASAAdCIAcUUEQEGICCAAIAFyNgIAIAIMAQsgAigCCAshACACIAc2AgggACAHNgIMIAcgAjYCDCAHIAA2AggMBAtBHyEAIAdCADcCECAEQf///wdNBEAgBEEIdiIAIABBgP4/akEQdkEIcSICdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIAJyIAByayIAQQF0IAQgAEEVanZBAXFyQRxqIQALIAcgADYCHCAAQQJ0QbgKaiEDAkBBjAgoAgAiAkEBIAB0IgFxRQRAQYwIIAEgAnI2AgAgAyAHNgIAIAcgAzYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBzYCECAHIAI2AhgLIAcgBzYCDCAHIAc2AggMAwsgAygCCCIAIAY2AgwgAyAGNgIIIAZBADYCGCAGIAM2AgwgBiAANgIICyAJQQhqIQAMBQsgAigCCCIAIAc2AgwgAiAHNgIIIAdBADYCGCAHIAI2AgwgByAANgIIC0GUCCgCACIAIAhNDQBBlAggACAIayIBNgIAQaAIQaAIKAIAIgIgCGoiADYCACAAIAFBAXI2AgQgAiAIQQNyNgIEIAJBCGohAAwDC0GECEEwNgIAQQAhAAwCCwJAIAVFDQACQCAEKAIcIgJBAnRBuApqIgAoAgAgBEYEQCAAIAE2AgAgAQ0BQYwIIAlBfiACd3EiCTYCAAwCCyAFQRBBFCAFKAIQIARGG2ogATYCACABRQ0BCyABIAU2AhggBCgCECIABEAgASAANgIQIAAgATYCGAsgBCgCFCIARQ0AIAEgADYCFCAAIAE2AhgLAkAgA0EPTQRAIAQgAyAIaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgCEEDcjYCBCAGIANBAXI2AgQgAyAGaiADNgIAIANB/wFNBEAgA0EDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwBC0EfIQAgA0H///8HTQRAIANBCHYiACAAQYD+P2pBEHZBCHEiAnQiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASACciAAcmsiAEEBdCADIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQICQAJAIAlBASAAdCIBcUUEQEGMCCABIAlyNgIAIAIgBjYCACAGIAI2AhgMAQsgA0EAQRkgAEEBdmsgAEEfRht0IQAgAigCACEIA0AgCCIBKAIEQXhxIANGDQIgAEEddiECIABBAXQhACABIAJBBHFqIgIoAhAiCA0ACyACIAY2AhAgBiABNgIYCyAGIAY2AgwgBiAGNgIIDAELIAEoAggiACAGNgIMIAEgBjYCCCAGQQA2AhggBiABNgIMIAYgADYCCAsgBEEIaiEADAELAkAgC0UNAAJAIAEoAhwiAkECdEG4CmoiACgCACABRgRAIAAgBDYCACAEDQFBjAggBkF+IAJ3cTYCAAwCCyALQRBBFCALKAIQIAFGG2ogBDYCACAERQ0BCyAEIAs2AhggASgCECIABEAgBCAANgIQIAAgBDYCGAsgASgCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAEgAyAIaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEDAELIAEgCEEDcjYCBCAJIANBAXI2AgQgAyAJaiADNgIAIAoEQCAKQQN2IgBBA3RBsAhqIQRBnAgoAgAhAgJ/QQEgAHQiACAFcUUEQEGICCAAIAVyNgIAIAQMAQsgBCgCCAshACAEIAI2AgggACACNgIMIAIgBDYCDCACIAA2AggLQZwIIAk2AgBBkAggAzYCAAsgAUEIaiEACyAMQRBqJAAgAAsQACMAIABrQXBxIgAkACAACwYAIAAkAAsEACMAC4AJAgh/BH4jAEGQAWsiBiQAIAYgBS0AA0EYdEGAgIAYcSAFLwAAIAUtAAJBEHRycjYCACAGIAUoAANBAnZBg/7/H3E2AgQgBiAFKAAGQQR2Qf+B/x9xNgIIIAYgBSgACUEGdkH//8AfcTYCDCAFLwANIQggBS0ADyEJIAZCADcCFCAGQgA3AhwgBkEANgIkIAYgCCAJQRB0QYCAPHFyNgIQIAYgBSgAEDYCKCAGIAUoABQ2AiwgBiAFKAAYNgIwIAUoABwhBSAGQQA6AEwgBkEANgI4IAYgBTYCNCAGIAEgAhAEIAQEQCAGIAMgBBAECyAGKAI4IgEEQCAGQTxqIgIgAWpBAToAACABQQFqQQ9NBEAgASAGakE9aiEEAkBBDyABayIDRQ0AIAMgBGoiAUEBa0EAOgAAIARBADoAACADQQNJDQAgAUECa0EAOgAAIARBADoAASABQQNrQQA6AAAgBEEAOgACIANBB0kNACABQQRrQQA6AAAgBEEAOgADIANBCUkNACAEQQAgBGtBA3EiAWoiBEEANgIAIAQgAyABa0F8cSIBaiIDQQRrQQA2AgAgAUEJSQ0AIARBADYCCCAEQQA2AgQgA0EIa0EANgIAIANBDGtBADYCACABQRlJDQAgBEEANgIYIARBADYCFCAEQQA2AhAgBEEANgIMIANBEGtBADYCACADQRRrQQA2AgAgA0EYa0EANgIAIANBHGtBADYCACABIARBBHFBGHIiAWsiA0EgSQ0AIAEgBGohAQNAIAFCADcDGCABQgA3AxAgAUIANwMIIAFCADcDACABQSBqIQEgA0EgayIDQR9LDQALCwsgBkEBOgBMIAYgAkEQEAILIAY1AjQhECAGNQIwIREgBjUCLCEOIAAgBjUCKCAGKAIkIAYoAiAgBigCHCAGKAIYIgNBGnZqIgJBGnZqIgFBGnZqIgtBgICAYHIgAUH///8fcSINIAJB////H3EiCCAGKAIUIAtBGnZBBWxqIgFB////H3EiCUEFaiIFQRp2IANB////H3EgAUEadmoiA2oiAUEadmoiAkEadmoiBEEadmoiDEEfdSIHIANxIAEgDEEfdkEBayIDQf///x9xIgpxciIBQRp0IAUgCnEgByAJcXJyrXwiDzwAACAAIA9CGIg8AAMgACAPQhCIPAACIAAgD0IIiDwAASAAIA4gByAIcSACIApxciICQRR0IAFBBnZyrXwgD0IgiHwiDjwABCAAIA5CGIg8AAcgACAOQhCIPAAGIAAgDkIIiDwABSAAIBEgByANcSAEIApxciIBQQ50IAJBDHZyrXwgDkIgiHwiDjwACCAAIA5CGIg8AAsgACAOQhCIPAAKIAAgDkIIiDwACSAAIBAgAyAMcSAHIAtxckEIdCABQRJ2cq18IA5CIIh8Ig48AAwgACAOQhiIPAAPIAAgDkIQiDwADiAAIA5CCIg8AA0gBkIANwIwIAZCADcCKCAGQgA3AiAgBkIANwIYIAZCADcCECAGQgA3AgggBkIANwIAIAZBkAFqJAALpwwBB38CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACIBayIDQZgIKAIASQ0BIAAgAWohACADQZwIKAIARwRAIAFB/wFNBEAgAygCCCICIAFBA3YiBEEDdEGwCGpGGiACIAMoAgwiAUYEQEGICEGICCgCAEF+IAR3cTYCAAwDCyACIAE2AgwgASACNgIIDAILIAMoAhghBgJAIAMgAygCDCIBRwRAIAMoAggiAiABNgIMIAEgAjYCCAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQEMAQsDQCACIQcgBCIBQRRqIgIoAgAiBA0AIAFBEGohAiABKAIQIgQNAAsgB0EANgIACyAGRQ0BAkAgAyADKAIcIgJBAnRBuApqIgQoAgBGBEAgBCABNgIAIAENAUGMCEGMCCgCAEF+IAJ3cTYCAAwDCyAGQRBBFCAGKAIQIANGG2ogATYCACABRQ0CCyABIAY2AhggAygCECICBEAgASACNgIQIAIgATYCGAsgAygCFCICRQ0BIAEgAjYCFCACIAE2AhgMAQsgBSgCBCIBQQNxQQNHDQBBkAggADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAMgBU8NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVBoAgoAgBGBEBBoAggAzYCAEGUCEGUCCgCACAAaiIANgIAIAMgAEEBcjYCBCADQZwIKAIARw0DQZAIQQA2AgBBnAhBADYCAA8LIAVBnAgoAgBGBEBBnAggAzYCAEGQCEGQCCgCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyABQXhxIABqIQACQCABQf8BTQRAIAUoAggiAiABQQN2IgRBA3RBsAhqRhogAiAFKAIMIgFGBEBBiAhBiAgoAgBBfiAEd3E2AgAMAgsgAiABNgIMIAEgAjYCCAwBCyAFKAIYIQYCQCAFIAUoAgwiAUcEQCAFKAIIIgJBmAgoAgBJGiACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEG4CmoiBCgCAEYEQCAEIAE2AgAgAQ0BQYwIQYwIKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQZwIKAIARw0BQZAIIAA2AgAPCyAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAAsgAEH/AU0EQCAAQQN2IgFBA3RBsAhqIQACf0GICCgCACICQQEgAXQiAXFFBEBBiAggASACcjYCACAADAELIAAoAggLIQIgACADNgIIIAIgAzYCDCADIAA2AgwgAyACNgIIDwtBHyECIANCADcCECAAQf///wdNBEAgAEEIdiIBIAFBgP4/akEQdkEIcSIBdCICIAJBgOAfakEQdkEEcSICdCIEIARBgIAPakEQdkECcSIEdEEPdiABIAJyIARyayIBQQF0IAAgAUEVanZBAXFyQRxqIQILIAMgAjYCHCACQQJ0QbgKaiEBAkACQAJAQYwIKAIAIgRBASACdCIHcUUEQEGMCCAEIAdyNgIAIAEgAzYCACADIAE2AhgMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgASgCACEBA0AgASIEKAIEQXhxIABGDQIgAkEddiEBIAJBAXQhAiAEIAFBBHFqIgdBEGooAgAiAQ0ACyAHIAM2AhAgAyAENgIYCyADIAM2AgwgAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtBqAhBqAgoAgBBAWsiAEF/IAAbNgIACwsLCQEAQYEICwIGUA=="),
                !x.startsWith(F))
              ) {
                var T = x;
                x = a.locateFile ? a.locateFile(T, p) : p + T;
              }
              function V() {
                var te = x;
                try {
                  if (te == x && E) return new Uint8Array(E);
                  var ie = re(te);
                  if (ie) return ie;
                  if (g) return g(te);
                  throw "both async and sync fetching of the wasm failed";
                } catch (X) {
                  W(X);
                }
              }
              function B() {
                if (!E && (f || u)) {
                  if (typeof fetch == "function" && !x.startsWith("file://"))
                    return fetch(x, { credentials: "same-origin" })
                      .then(function (te) {
                        if (!te.ok)
                          throw (
                            "failed to load wasm binary file at '" + x + "'"
                          );
                        return te.arrayBuffer();
                      })
                      .catch(function () {
                        return V();
                      });
                  if (m)
                    return new Promise(function (te, ie) {
                      m(
                        x,
                        function (X) {
                          te(new Uint8Array(X));
                        },
                        ie,
                      );
                    });
                }
                return Promise.resolve().then(function () {
                  return V();
                });
              }
              function N(te) {
                for (; 0 < te.length; ) {
                  var ie = te.shift();
                  if (typeof ie == "function") ie(a);
                  else {
                    var X = ie.m;
                    typeof X == "number"
                      ? ie.l === void 0
                        ? J.get(X)()
                        : J.get(X)(ie.l)
                      : X(ie.l === void 0 ? null : ie.l);
                  }
                }
              }
              var ce =
                typeof atob == "function"
                  ? atob
                  : function (te) {
                      var ie = "",
                        X = 0;
                      te = te.replace(/[^A-Za-z0-9\+\/=]/g, "");
                      do {
                        var he =
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(
                              te.charAt(X++),
                            ),
                          be =
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(
                              te.charAt(X++),
                            ),
                          ye =
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(
                              te.charAt(X++),
                            ),
                          Qe =
                            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(
                              te.charAt(X++),
                            );
                        (he = (he << 2) | (be >> 4)),
                          (be = ((be & 15) << 4) | (ye >> 2));
                        var lt = ((ye & 3) << 6) | Qe;
                        (ie += String.fromCharCode(he)),
                          ye !== 64 && (ie += String.fromCharCode(be)),
                          Qe !== 64 && (ie += String.fromCharCode(lt));
                      } while (X < te.length);
                      return ie;
                    };
              function re(te) {
                if (te.startsWith(F)) {
                  if (((te = te.slice(F.length)), typeof d == "boolean" && d)) {
                    var ie = Buffer.from(te, "base64");
                    ie = new Uint8Array(
                      ie.buffer,
                      ie.byteOffset,
                      ie.byteLength,
                    );
                  } else
                    try {
                      var X = ce(te),
                        he = new Uint8Array(X.length);
                      for (te = 0; te < X.length; ++te)
                        he[te] = X.charCodeAt(te);
                      ie = he;
                    } catch {
                      throw Error("Converting base64 string to bytes failed.");
                    }
                  return ie;
                }
              }
              var ne = {
                a: function (te) {
                  var ie = H.length;
                  if (((te >>>= 0), 2147483648 < te)) return !1;
                  for (var X = 1; 4 >= X; X *= 2) {
                    var he = ie * (1 + 0.2 / X);
                    (he = Math.min(he, te + 100663296)),
                      (he = Math.max(te, he)),
                      0 < he % 65536 && (he += 65536 - (he % 65536));
                    e: {
                      try {
                        R.grow(
                          (Math.min(2147483648, he) - Q.byteLength + 65535) >>>
                            16,
                        ),
                          q();
                        var be = 1;
                        break e;
                      } catch {}
                      be = void 0;
                    }
                    if (be) return !0;
                  }
                  return !1;
                },
              };
              (function () {
                function te(be) {
                  (a.asm = be.exports),
                    (R = a.asm.b),
                    q(),
                    (J = a.asm.j),
                    z.unshift(a.asm.c),
                    L--,
                    a.monitorRunDependencies && a.monitorRunDependencies(L),
                    L == 0 && k && ((be = k), (k = null), be());
                }
                function ie(be) {
                  te(be.instance);
                }
                function X(be) {
                  return B()
                    .then(function (ye) {
                      return WebAssembly.instantiate(ye, he);
                    })
                    .then(be, function (ye) {
                      _("failed to asynchronously prepare wasm: " + ye), W(ye);
                    });
                }
                var he = { a: ne };
                if (
                  (L++,
                  a.monitorRunDependencies && a.monitorRunDependencies(L),
                  a.instantiateWasm)
                )
                  try {
                    return a.instantiateWasm(he, te);
                  } catch (be) {
                    return (
                      _(
                        "Module.instantiateWasm callback failed with error: " +
                          be,
                      ),
                      !1
                    );
                  }
                return (
                  (function () {
                    return E ||
                      typeof WebAssembly.instantiateStreaming != "function" ||
                      x.startsWith(F) ||
                      x.startsWith("file://") ||
                      typeof fetch != "function"
                      ? X(ie)
                      : fetch(x, { credentials: "same-origin" }).then(
                          function (be) {
                            return WebAssembly.instantiateStreaming(
                              be,
                              he,
                            ).then(ie, function (ye) {
                              return (
                                _("wasm streaming compile failed: " + ye),
                                _("falling back to ArrayBuffer instantiation"),
                                X(ie)
                              );
                            });
                          },
                        );
                  })().catch(o),
                  {}
                );
              })(),
                (a.___wasm_call_ctors = function () {
                  return (a.___wasm_call_ctors = a.asm.c).apply(
                    null,
                    arguments,
                  );
                }),
                (a._poly1305_auth = function () {
                  return (a._poly1305_auth = a.asm.d).apply(null, arguments);
                });
              var Y = (a.stackSave = function () {
                  return (Y = a.stackSave = a.asm.e).apply(null, arguments);
                }),
                M = (a.stackRestore = function () {
                  return (M = a.stackRestore = a.asm.f).apply(null, arguments);
                }),
                oe = (a.stackAlloc = function () {
                  return (oe = a.stackAlloc = a.asm.g).apply(null, arguments);
                });
              (a._malloc = function () {
                return (a._malloc = a.asm.h).apply(null, arguments);
              }),
                (a._free = function () {
                  return (a._free = a.asm.i).apply(null, arguments);
                }),
                (a.cwrap = function (te, ie, X, he) {
                  X = X || [];
                  var be = X.every(function (ye) {
                    return ye === "number";
                  });
                  return ie !== "string" && be && !he
                    ? S(te)
                    : function () {
                        return w(te, ie, X, arguments);
                      };
                });
              var Ee;
              k = function te() {
                Ee || le(), Ee || (k = te);
              };
              function le() {
                function te() {
                  if (!Ee && ((Ee = !0), (a.calledRun = !0), !A)) {
                    if (
                      (N(z),
                      s(a),
                      a.onRuntimeInitialized && a.onRuntimeInitialized(),
                      a.postRun)
                    )
                      for (
                        typeof a.postRun == "function" &&
                        (a.postRun = [a.postRun]);
                        a.postRun.length;

                      ) {
                        var ie = a.postRun.shift();
                        U.unshift(ie);
                      }
                    N(U);
                  }
                }
                if (!(0 < L)) {
                  if (a.preRun)
                    for (
                      typeof a.preRun == "function" && (a.preRun = [a.preRun]);
                      a.preRun.length;

                    )
                      G();
                  N(Z),
                    0 < L ||
                      (a.setStatus
                        ? (a.setStatus("Running..."),
                          setTimeout(function () {
                            setTimeout(function () {
                              a.setStatus("");
                            }, 1),
                              te();
                          }, 1))
                        : te());
                }
              }
              if (((a.run = le), a.preInit))
                for (
                  typeof a.preInit == "function" && (a.preInit = [a.preInit]);
                  0 < a.preInit.length;

                )
                  a.preInit.pop()();
              return le(), i.ready;
            }
          );
        })();
        e.exports = n;
      })(Vm)),
    Vm.exports
  );
}
var Ym, LA;
function eo() {
  if (LA) return Ym;
  LA = 1;
  const {
      createCipheriv: e,
      createDecipheriv: t,
      createHmac: n,
      randomFillSync: r,
      timingSafeEqual: i,
    } = pr,
    { readUInt32BE: a, writeUInt32BE: s } = Ki(),
    o = Buffer[Symbol.species],
    c = 2 ** 32 - 1,
    l = Buffer.alloc(0),
    f = Buffer.alloc(4),
    u = new Map(),
    d = 35e3;
  let p, h, m, g, v, y, _;
  try {
    (p = require("./crypto/build/Release/sshcrypto.node")),
      ({
        AESGCMCipher: h,
        ChaChaPolyCipher: m,
        GenericCipher: g,
        AESGCMDecipher: v,
        ChaChaPolyDecipher: y,
        GenericDecipher: _,
      } = p);
  } catch {}
  const E = 1,
    R = (() => {
      function ne(Y, M, oe, Ee, le, te, ie) {
        return {
          sslName: Y,
          blockLen: M,
          keyLen: oe,
          ivLen: Ee !== 0 || ie & E ? Ee : M,
          authLen: le,
          discardLen: te,
          stream: !!(ie & E),
        };
      }
      return {
        "chacha20-poly1305@openssh.com": ne("chacha20", 8, 64, 0, 16, 0, E),
        "aes128-gcm": ne("aes-128-gcm", 16, 16, 12, 16, 0, E),
        "aes256-gcm": ne("aes-256-gcm", 16, 32, 12, 16, 0, E),
        "aes128-gcm@openssh.com": ne("aes-128-gcm", 16, 16, 12, 16, 0, E),
        "aes256-gcm@openssh.com": ne("aes-256-gcm", 16, 32, 12, 16, 0, E),
        "aes128-cbc": ne("aes-128-cbc", 16, 16, 0, 0, 0, 0),
        "aes192-cbc": ne("aes-192-cbc", 16, 24, 0, 0, 0, 0),
        "aes256-cbc": ne("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "rijndael-cbc@lysator.liu.se": ne("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "3des-cbc": ne("des-ede3-cbc", 8, 24, 0, 0, 0, 0),
        "blowfish-cbc": ne("bf-cbc", 8, 16, 0, 0, 0, 0),
        "idea-cbc": ne("idea-cbc", 8, 16, 0, 0, 0, 0),
        "cast128-cbc": ne("cast-cbc", 8, 16, 0, 0, 0, 0),
        "aes128-ctr": ne("aes-128-ctr", 16, 16, 16, 0, 0, E),
        "aes192-ctr": ne("aes-192-ctr", 16, 24, 16, 0, 0, E),
        "aes256-ctr": ne("aes-256-ctr", 16, 32, 16, 0, 0, E),
        "3des-ctr": ne("des-ede3", 8, 24, 8, 0, 0, E),
        "blowfish-ctr": ne("bf-ecb", 8, 16, 8, 0, 0, E),
        "cast128-ctr": ne("cast5-ecb", 8, 16, 8, 0, 0, E),
        arcfour: ne("rc4", 8, 16, 0, 0, 1536, E),
        arcfour128: ne("rc4", 8, 16, 0, 0, 1536, E),
        arcfour256: ne("rc4", 8, 32, 0, 0, 1536, E),
        arcfour512: ne("rc4", 8, 64, 0, 0, 1536, E),
      };
    })(),
    A = (() => {
      function ne(Y, M, oe, Ee) {
        return { sslName: Y, len: M, actualLen: oe, isETM: Ee };
      }
      return {
        "hmac-md5": ne("md5", 16, 16, !1),
        "hmac-md5-96": ne("md5", 16, 12, !1),
        "hmac-ripemd160": ne("ripemd160", 20, 20, !1),
        "hmac-sha1": ne("sha1", 20, 20, !1),
        "hmac-sha1-etm@openssh.com": ne("sha1", 20, 20, !0),
        "hmac-sha1-96": ne("sha1", 20, 12, !1),
        "hmac-sha2-256": ne("sha256", 32, 32, !1),
        "hmac-sha2-256-etm@openssh.com": ne("sha256", 32, 32, !0),
        "hmac-sha2-256-96": ne("sha256", 32, 12, !1),
        "hmac-sha2-512": ne("sha512", 64, 64, !1),
        "hmac-sha2-512-etm@openssh.com": ne("sha512", 64, 64, !0),
        "hmac-sha2-512-96": ne("sha512", 64, 12, !1),
      };
    })();
  class I {
    constructor(Y, M) {
      (this.outSeqno = Y), (this._onWrite = M), (this._dead = !1);
    }
    free() {
      this._dead = !0;
    }
    allocPacket(Y) {
      let M = 5 + Y,
        oe = 8 - (M & (8 - 1));
      oe < 4 && (oe += 8), (M += oe);
      const Ee = Buffer.allocUnsafe(M);
      return s(Ee, M - 4, 0), (Ee[4] = oe), r(Ee, 5 + Y, oe), Ee;
    }
    encrypt(Y) {
      this._dead ||
        (this._onWrite(Y), (this.outSeqno = (this.outSeqno + 1) >>> 0));
    }
  }
  const S = Buffer.alloc(32),
    w = Buffer.alloc(16);
  let O, Q, j;
  class H {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._encKeyMain = M.cipherKey.slice(0, 32)),
        (this._encKeyPktLen = M.cipherKey.slice(32)),
        (this._dead = !1);
    }
    free() {
      this._dead = !0;
    }
    allocPacket(Y) {
      let M = 5 + Y,
        oe = 8 - ((M - 4) & (8 - 1));
      oe < 4 && (oe += 8), (M += oe);
      const Ee = Buffer.allocUnsafe(M);
      return s(Ee, M - 4, 0), (Ee[4] = oe), r(Ee, 5 + Y, oe), Ee;
    }
    encrypt(Y) {
      if (this._dead) return;
      (w[0] = 0), s(w, this.outSeqno, 12);
      const M = e("chacha20", this._encKeyMain, w).update(S),
        oe = e("chacha20", this._encKeyPktLen, w).update(Y.slice(0, 4));
      this._onWrite(oe), (w[0] = 1);
      const Ee = e("chacha20", this._encKeyMain, w).update(Y.slice(4));
      this._onWrite(Ee), j(Q, oe, oe.length, Ee, Ee.length, M);
      const le = Buffer.allocUnsafe(16);
      le.set(new Uint8Array(O.HEAPU8.buffer, Q, 16), 0),
        this._onWrite(le),
        (this.outSeqno = (this.outSeqno + 1) >>> 0);
    }
  }
  class q {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._instance = new m(M.cipherKey)),
        (this._dead = !1);
    }
    free() {
      (this._dead = !0), this._instance.free();
    }
    allocPacket(Y) {
      let M = 5 + Y,
        oe = 8 - ((M - 4) & (8 - 1));
      oe < 4 && (oe += 8), (M += oe);
      const Ee = Buffer.allocUnsafe(M + 16);
      return s(Ee, M - 4, 0), (Ee[4] = oe), r(Ee, 5 + Y, oe), Ee;
    }
    encrypt(Y) {
      this._dead ||
        (this._instance.encrypt(Y, this.outSeqno),
        this._onWrite(Y),
        (this.outSeqno = (this.outSeqno + 1) >>> 0));
    }
  }
  class J {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._encSSLName = M.cipherInfo.sslName),
        (this._encKey = M.cipherKey),
        (this._encIV = M.cipherIV),
        (this._dead = !1);
    }
    free() {
      this._dead = !0;
    }
    allocPacket(Y) {
      let M = 5 + Y,
        oe = 16 - ((M - 4) & (16 - 1));
      oe < 4 && (oe += 16), (M += oe);
      const Ee = Buffer.allocUnsafe(M);
      return s(Ee, M - 4, 0), (Ee[4] = oe), r(Ee, 5 + Y, oe), Ee;
    }
    encrypt(Y) {
      if (this._dead) return;
      const M = e(this._encSSLName, this._encKey, this._encIV);
      M.setAutoPadding(!1);
      const oe = Y.slice(0, 4);
      M.setAAD(oe), this._onWrite(oe);
      const Ee = M.update(Y.slice(4));
      this._onWrite(Ee);
      const le = M.final();
      le.length && this._onWrite(le);
      const te = M.getAuthTag();
      this._onWrite(te),
        V(this._encIV),
        (this.outSeqno = (this.outSeqno + 1) >>> 0);
    }
  }
  class Z {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._instance = new h(M.cipherInfo.sslName, M.cipherKey, M.cipherIV)),
        (this._dead = !1);
    }
    free() {
      (this._dead = !0), this._instance.free();
    }
    allocPacket(Y) {
      let M = 5 + Y,
        oe = 16 - ((M - 4) & (16 - 1));
      oe < 4 && (oe += 16), (M += oe);
      const Ee = Buffer.allocUnsafe(M + 16);
      return s(Ee, M - 4, 0), (Ee[4] = oe), r(Ee, 5 + Y, oe), Ee;
    }
    encrypt(Y) {
      this._dead ||
        (this._instance.encrypt(Y),
        this._onWrite(Y),
        (this.outSeqno = (this.outSeqno + 1) >>> 0));
    }
  }
  class z {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._encBlockLen = M.cipherInfo.blockLen),
        (this._cipherInstance = e(
          M.cipherInfo.sslName,
          M.cipherKey,
          M.cipherIV,
        )),
        (this._macSSLName = M.macInfo.sslName),
        (this._macKey = M.macKey),
        (this._macActualLen = M.macInfo.actualLen),
        (this._macETM = M.macInfo.isETM),
        (this._aadLen = this._macETM ? 4 : 0),
        (this._dead = !1);
      const oe = M.cipherInfo.discardLen;
      if (oe) {
        let Ee = u.get(oe);
        Ee === void 0 && ((Ee = Buffer.alloc(oe)), u.set(oe, Ee)),
          this._cipherInstance.update(Ee);
      }
    }
    free() {
      this._dead = !0;
    }
    allocPacket(Y) {
      const M = this._encBlockLen;
      let oe = 4 + 1 + Y,
        Ee = M - ((oe - this._aadLen) & (M - 1));
      Ee < 4 && (Ee += M), (oe += Ee);
      const le = Buffer.allocUnsafe(oe);
      return s(le, oe - 4, 0), (le[4] = Ee), r(le, 5 + Y, Ee), le;
    }
    encrypt(Y) {
      if (this._dead) return;
      let M;
      if (this._macETM) {
        const Ee = new Uint8Array(Y.buffer, Y.byteOffset, 4),
          le = this._cipherInstance.update(
            new Uint8Array(Y.buffer, Y.byteOffset + 4, Y.length - 4),
          );
        this._onWrite(Ee),
          this._onWrite(le),
          (M = n(this._macSSLName, this._macKey)),
          s(f, this.outSeqno, 0),
          M.update(f),
          M.update(Ee),
          M.update(le);
      } else {
        const Ee = this._cipherInstance.update(Y);
        this._onWrite(Ee),
          (M = n(this._macSSLName, this._macKey)),
          s(f, this.outSeqno, 0),
          M.update(f),
          M.update(Y);
      }
      let oe = M.digest();
      oe.length > this._macActualLen && (oe = oe.slice(0, this._macActualLen)),
        this._onWrite(oe),
        (this.outSeqno = (this.outSeqno + 1) >>> 0);
    }
  }
  class U {
    constructor(Y) {
      const M = Y.outbound;
      (this.outSeqno = M.seqno),
        (this._onWrite = M.onWrite),
        (this._encBlockLen = M.cipherInfo.blockLen),
        (this._macLen = M.macInfo.len),
        (this._macActualLen = M.macInfo.actualLen),
        (this._aadLen = M.macInfo.isETM ? 4 : 0),
        (this._instance = new g(
          M.cipherInfo.sslName,
          M.cipherKey,
          M.cipherIV,
          M.macInfo.sslName,
          M.macKey,
          M.macInfo.isETM,
        )),
        (this._dead = !1);
    }
    free() {
      (this._dead = !0), this._instance.free();
    }
    allocPacket(Y) {
      const M = this._encBlockLen;
      let oe = 4 + 1 + Y,
        Ee = M - ((oe - this._aadLen) & (M - 1));
      Ee < 4 && (Ee += M), (oe += Ee);
      const le = Buffer.allocUnsafe(oe + this._macLen);
      return s(le, oe - 4, 0), (le[4] = Ee), r(le, 5 + Y, Ee), le;
    }
    encrypt(Y) {
      this._dead ||
        (this._instance.encrypt(Y, this.outSeqno),
        this._macActualLen < this._macLen &&
          (Y = new o(
            Y.buffer,
            Y.byteOffset,
            Y.length - (this._macLen - this._macActualLen),
          )),
        this._onWrite(Y),
        (this.outSeqno = (this.outSeqno + 1) >>> 0));
    }
  }
  class G {
    constructor(Y, M) {
      (this.inSeqno = Y),
        (this._onPayload = M),
        (this._len = 0),
        (this._lenBytes = 0),
        (this._packet = null),
        (this._packetPos = 0);
    }
    free() {}
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._lenBytes < 4) {
          let le = Math.min(4 - this._lenBytes, oe - M);
          for (this._lenBytes += le; le--; )
            this._len = (this._len << 8) + Y[M++];
          if (this._lenBytes < 4) return;
          if (this._len > d || this._len < 8 || (4 + this._len) & 7)
            throw new Error("Bad packet length");
          if (M >= oe) return;
        }
        if (this._packetPos < this._len) {
          const le = Math.min(this._len - this._packetPos, oe - M);
          let te;
          if (
            (M !== 0 || le !== oe
              ? (te = new Uint8Array(Y.buffer, Y.byteOffset + M, le))
              : (te = Y),
            le === this._len
              ? (this._packet = te)
              : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(te, this._packetPos)),
            (M += le),
            (this._packetPos += le),
            this._packetPos < this._len)
          )
            return;
        }
        const Ee = this._packet
          ? new o(
              this._packet.buffer,
              this._packet.byteOffset + 1,
              this._packet.length - this._packet[0] - 1,
            )
          : l;
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._len = 0),
          (this._lenBytes = 0),
          (this._packet = null),
          (this._packetPos = 0);
        {
          const le = this._onPayload(Ee);
          if (le !== void 0) return le === !1 ? M : le;
        }
      }
    }
  }
  class L {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._decKeyMain = M.decipherKey.slice(0, 32)),
        (this._decKeyPktLen = M.decipherKey.slice(32)),
        (this._len = 0),
        (this._lenBuf = Buffer.alloc(4)),
        (this._lenPos = 0),
        (this._packet = null),
        (this._pktLen = 0),
        (this._mac = Buffer.allocUnsafe(16)),
        (this._calcMac = Buffer.allocUnsafe(16)),
        (this._macPos = 0);
    }
    free() {}
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._lenPos < 4) {
          let ie = Math.min(4 - this._lenPos, oe - M);
          for (; ie--; ) this._lenBuf[this._lenPos++] = Y[M++];
          if (this._lenPos < 4) return;
          (w[0] = 0), s(w, this.inSeqno, 12);
          const X = t("chacha20", this._decKeyPktLen, w).update(this._lenBuf);
          if (
            ((this._len = a(X, 0)),
            this._len > d || this._len < 8 || this._len & 7)
          )
            throw new Error("Bad packet length");
        }
        if (this._pktLen < this._len) {
          if (M >= oe) return;
          const ie = Math.min(this._len - this._pktLen, oe - M);
          let X;
          if (
            (M !== 0 || ie !== oe
              ? (X = new Uint8Array(Y.buffer, Y.byteOffset + M, ie))
              : (X = Y),
            ie === this._len
              ? (this._packet = X)
              : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(X, this._pktLen)),
            (M += ie),
            (this._pktLen += ie),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const ie = Math.min(16 - this._macPos, oe - M);
          if (
            (M !== 0 || ie !== oe
              ? this._mac.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, ie),
                  this._macPos,
                )
              : this._mac.set(Y, this._macPos),
            (M += ie),
            (this._macPos += ie),
            this._macPos < 16)
          )
            return;
        }
        (w[0] = 0), s(w, this.inSeqno, 12);
        const Ee = e("chacha20", this._decKeyMain, w).update(S);
        if (
          (j(Q, this._lenBuf, 4, this._packet, this._packet.length, Ee),
          this._calcMac.set(new Uint8Array(O.HEAPU8.buffer, Q, 16), 0),
          !i(this._calcMac, this._mac))
        )
          throw new Error("Invalid MAC");
        w[0] = 1;
        const le = t("chacha20", this._decKeyMain, w).update(this._packet),
          te = new o(le.buffer, le.byteOffset + 1, le.length - le[0] - 1);
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._len = 0),
          (this._lenPos = 0),
          (this._packet = null),
          (this._pktLen = 0),
          (this._macPos = 0);
        {
          const ie = this._onPayload(te);
          if (ie !== void 0) return ie === !1 ? M : ie;
        }
      }
    }
  }
  class k {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._instance = new y(M.decipherKey)),
        (this._len = 0),
        (this._lenBuf = Buffer.alloc(4)),
        (this._lenPos = 0),
        (this._packet = null),
        (this._pktLen = 0),
        (this._mac = Buffer.allocUnsafe(16)),
        (this._macPos = 0);
    }
    free() {
      this._instance.free();
    }
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._lenPos < 4) {
          let le = Math.min(4 - this._lenPos, oe - M);
          for (; le--; ) this._lenBuf[this._lenPos++] = Y[M++];
          if (this._lenPos < 4) return;
          if (
            ((this._len = this._instance.decryptLen(
              this._lenBuf,
              this.inSeqno,
            )),
            this._len > d || this._len < 8 || this._len & 7)
          )
            throw new Error("Bad packet length");
          if (M >= oe) return;
        }
        if (this._pktLen < this._len) {
          const le = Math.min(this._len - this._pktLen, oe - M);
          let te;
          if (
            (M !== 0 || le !== oe
              ? (te = new Uint8Array(Y.buffer, Y.byteOffset + M, le))
              : (te = Y),
            le === this._len
              ? (this._packet = te)
              : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(te, this._pktLen)),
            (M += le),
            (this._pktLen += le),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const le = Math.min(16 - this._macPos, oe - M);
          if (
            (M !== 0 || le !== oe
              ? this._mac.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                  this._macPos,
                )
              : this._mac.set(Y, this._macPos),
            (M += le),
            (this._macPos += le),
            this._macPos < 16)
          )
            return;
        }
        this._instance.decrypt(this._packet, this._mac, this.inSeqno);
        const Ee = new o(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1,
        );
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._len = 0),
          (this._lenPos = 0),
          (this._packet = null),
          (this._pktLen = 0),
          (this._macPos = 0);
        {
          const le = this._onPayload(Ee);
          if (le !== void 0) return le === !1 ? M : le;
        }
      }
    }
  }
  class W {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._decipherInstance = null),
        (this._decipherSSLName = M.decipherInfo.sslName),
        (this._decipherKey = M.decipherKey),
        (this._decipherIV = M.decipherIV),
        (this._len = 0),
        (this._lenBytes = 0),
        (this._packet = null),
        (this._packetPos = 0),
        (this._pktLen = 0),
        (this._tag = Buffer.allocUnsafe(16)),
        (this._tagPos = 0);
    }
    free() {}
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._lenBytes < 4) {
          let le = Math.min(4 - this._lenBytes, oe - M);
          for (this._lenBytes += le; le--; )
            this._len = (this._len << 8) + Y[M++];
          if (this._lenBytes < 4) return;
          if (this._len + 20 > d || this._len < 16 || this._len & 15)
            throw new Error("Bad packet length");
          (this._decipherInstance = t(
            this._decipherSSLName,
            this._decipherKey,
            this._decipherIV,
          )),
            this._decipherInstance.setAutoPadding(!1),
            this._decipherInstance.setAAD(B(this._len));
        }
        if (this._pktLen < this._len) {
          if (M >= oe) return;
          const le = Math.min(this._len - this._pktLen, oe - M);
          let te;
          if (
            (M !== 0 || le !== oe
              ? (te = this._decipherInstance.update(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                ))
              : (te = this._decipherInstance.update(Y)),
            te.length &&
              (le === this._len
                ? (this._packet = te)
                : (this._packet ||
                    (this._packet = Buffer.allocUnsafe(this._len)),
                  this._packet.set(te, this._packetPos)),
              (this._packetPos += te.length)),
            (M += le),
            (this._pktLen += le),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const le = Math.min(16 - this._tagPos, oe - M);
          if (
            (M !== 0 || le !== oe
              ? this._tag.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                  this._tagPos,
                )
              : this._tag.set(Y, this._tagPos),
            (M += le),
            (this._tagPos += le),
            this._tagPos < 16)
          )
            return;
        }
        {
          this._decipherInstance.setAuthTag(this._tag);
          const le = this._decipherInstance.final();
          le.length &&
            (this._packet
              ? this._packet.set(le, this._packetPos)
              : (this._packet = le));
        }
        const Ee = this._packet
          ? new o(
              this._packet.buffer,
              this._packet.byteOffset + 1,
              this._packet.length - this._packet[0] - 1,
            )
          : l;
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          V(this._decipherIV),
          (this._len = 0),
          (this._lenBytes = 0),
          (this._packet = null),
          (this._packetPos = 0),
          (this._pktLen = 0),
          (this._tagPos = 0);
        {
          const le = this._onPayload(Ee);
          if (le !== void 0) return le === !1 ? M : le;
        }
      }
    }
  }
  class F {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._instance = new v(
          M.decipherInfo.sslName,
          M.decipherKey,
          M.decipherIV,
        )),
        (this._len = 0),
        (this._lenBytes = 0),
        (this._packet = null),
        (this._pktLen = 0),
        (this._tag = Buffer.allocUnsafe(16)),
        (this._tagPos = 0);
    }
    free() {}
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._lenBytes < 4) {
          let le = Math.min(4 - this._lenBytes, oe - M);
          for (this._lenBytes += le; le--; )
            this._len = (this._len << 8) + Y[M++];
          if (this._lenBytes < 4) return;
          if (this._len + 20 > d || this._len < 16 || this._len & 15)
            throw new Error(`Bad packet length: ${this._len}`);
        }
        if (this._pktLen < this._len) {
          if (M >= oe) return;
          const le = Math.min(this._len - this._pktLen, oe - M);
          let te;
          if (
            (M !== 0 || le !== oe
              ? (te = new Uint8Array(Y.buffer, Y.byteOffset + M, le))
              : (te = Y),
            le === this._len
              ? (this._packet = te)
              : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(te, this._pktLen)),
            (M += le),
            (this._pktLen += le),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const le = Math.min(16 - this._tagPos, oe - M);
          if (
            (M !== 0 || le !== oe
              ? this._tag.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                  this._tagPos,
                )
              : this._tag.set(Y, this._tagPos),
            (M += le),
            (this._tagPos += le),
            this._tagPos < 16)
          )
            return;
        }
        this._instance.decrypt(this._packet, this._len, this._tag);
        const Ee = new o(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1,
        );
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._len = 0),
          (this._lenBytes = 0),
          (this._packet = null),
          (this._pktLen = 0),
          (this._tagPos = 0);
        {
          const le = this._onPayload(Ee);
          if (le !== void 0) return le === !1 ? M : le;
        }
      }
    }
  }
  class x {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._decipherInstance = t(
          M.decipherInfo.sslName,
          M.decipherKey,
          M.decipherIV,
        )),
        this._decipherInstance.setAutoPadding(!1),
        (this._block = Buffer.allocUnsafe(
          M.macInfo.isETM ? 4 : M.decipherInfo.blockLen,
        )),
        (this._blockSize = M.decipherInfo.blockLen),
        (this._blockPos = 0),
        (this._len = 0),
        (this._packet = null),
        (this._packetPos = 0),
        (this._pktLen = 0),
        (this._mac = Buffer.allocUnsafe(M.macInfo.actualLen)),
        (this._macPos = 0),
        (this._macSSLName = M.macInfo.sslName),
        (this._macKey = M.macKey),
        (this._macActualLen = M.macInfo.actualLen),
        (this._macETM = M.macInfo.isETM),
        (this._macInstance = null);
      const oe = M.decipherInfo.discardLen;
      if (oe) {
        let Ee = u.get(oe);
        Ee === void 0 && ((Ee = Buffer.alloc(oe)), u.set(oe, Ee)),
          this._decipherInstance.update(Ee);
      }
    }
    free() {}
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._blockPos < this._block.length) {
          const te = Math.min(this._block.length - this._blockPos, oe - M);
          if (
            (M !== 0 || te !== oe || te < Y.length
              ? this._block.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, te),
                  this._blockPos,
                )
              : this._block.set(Y, this._blockPos),
            (M += te),
            (this._blockPos += te),
            this._blockPos < this._block.length)
          )
            return;
          let ie, X;
          if (
            (this._macETM
              ? (this._len = X = a(this._block, 0))
              : ((ie = this._decipherInstance.update(this._block)),
                (this._len = a(ie, 0)),
                (X = 4 + this._len - this._blockSize)),
            this._len > d || this._len < 5 || X & (this._blockSize - 1))
          )
            throw new Error("Bad packet length");
          if (
            ((this._macInstance = n(this._macSSLName, this._macKey)),
            s(f, this.inSeqno, 0),
            this._macInstance.update(f),
            this._macETM
              ? this._macInstance.update(this._block)
              : (this._macInstance.update(
                  new Uint8Array(ie.buffer, ie.byteOffset, 4),
                ),
                (this._pktLen = ie.length - 4),
                (this._packetPos = this._pktLen),
                (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(
                  new Uint8Array(ie.buffer, ie.byteOffset + 4, this._packetPos),
                  0,
                )),
            M >= oe)
          )
            return;
        }
        if (this._pktLen < this._len) {
          const te = Math.min(this._len - this._pktLen, oe - M);
          let ie;
          M !== 0 || te !== oe
            ? (ie = new Uint8Array(Y.buffer, Y.byteOffset + M, te))
            : (ie = Y),
            this._macETM && this._macInstance.update(ie);
          const X = this._decipherInstance.update(ie);
          if (
            (X.length &&
              (te === this._len
                ? (this._packet = X)
                : (this._packet ||
                    (this._packet = Buffer.allocUnsafe(this._len)),
                  this._packet.set(X, this._packetPos)),
              (this._packetPos += X.length)),
            (M += te),
            (this._pktLen += te),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const te = Math.min(this._macActualLen - this._macPos, oe - M);
          if (
            (M !== 0 || te !== oe
              ? this._mac.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, te),
                  this._macPos,
                )
              : this._mac.set(Y, this._macPos),
            (M += te),
            (this._macPos += te),
            this._macPos < this._macActualLen)
          )
            return;
        }
        this._macETM || this._macInstance.update(this._packet);
        let Ee = this._macInstance.digest();
        if (
          (this._macActualLen < Ee.length &&
            (Ee = new Uint8Array(Ee.buffer, Ee.byteOffset, this._macActualLen)),
          !N(Ee, this._mac))
        )
          throw new Error("Invalid MAC");
        const le = new o(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1,
        );
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._blockPos = 0),
          (this._len = 0),
          (this._packet = null),
          (this._packetPos = 0),
          (this._pktLen = 0),
          (this._macPos = 0),
          (this._macInstance = null);
        {
          const te = this._onPayload(le);
          if (te !== void 0) return te === !1 ? M : te;
        }
      }
    }
  }
  class T {
    constructor(Y) {
      const M = Y.inbound;
      (this.inSeqno = M.seqno),
        (this._onPayload = M.onPayload),
        (this._instance = new _(
          M.decipherInfo.sslName,
          M.decipherKey,
          M.decipherIV,
          M.macInfo.sslName,
          M.macKey,
          M.macInfo.isETM,
          M.macInfo.actualLen,
        )),
        (this._block = Buffer.allocUnsafe(
          M.macInfo.isETM || M.decipherInfo.stream
            ? 4
            : M.decipherInfo.blockLen,
        )),
        (this._blockPos = 0),
        (this._len = 0),
        (this._packet = null),
        (this._pktLen = 0),
        (this._mac = Buffer.allocUnsafe(M.macInfo.actualLen)),
        (this._macPos = 0),
        (this._macActualLen = M.macInfo.actualLen),
        (this._macETM = M.macInfo.isETM);
    }
    free() {
      this._instance.free();
    }
    decrypt(Y, M, oe) {
      for (; M < oe; ) {
        if (this._blockPos < this._block.length) {
          const le = Math.min(this._block.length - this._blockPos, oe - M);
          if (
            (M !== 0 || le !== oe || le < Y.length
              ? this._block.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                  this._blockPos,
                )
              : this._block.set(Y, this._blockPos),
            (M += le),
            (this._blockPos += le),
            this._blockPos < this._block.length)
          )
            return;
          let te;
          if (
            (this._macETM
              ? (this._len = te = a(this._block, 0))
              : (this._instance.decryptBlock(this._block),
                (this._len = a(this._block, 0)),
                (te = 4 + this._len - this._block.length)),
            this._len > d || this._len < 5 || te & (this._block.length - 1))
          )
            throw new Error("Bad packet length");
          if (
            (this._macETM ||
              ((this._pktLen = this._block.length - 4),
              this._pktLen &&
                ((this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(
                  new Uint8Array(
                    this._block.buffer,
                    this._block.byteOffset + 4,
                    this._pktLen,
                  ),
                  0,
                ))),
            M >= oe)
          )
            return;
        }
        if (this._pktLen < this._len) {
          const le = Math.min(this._len - this._pktLen, oe - M);
          let te;
          if (
            (M !== 0 || le !== oe
              ? (te = new Uint8Array(Y.buffer, Y.byteOffset + M, le))
              : (te = Y),
            le === this._len
              ? (this._packet = te)
              : (this._packet || (this._packet = Buffer.allocUnsafe(this._len)),
                this._packet.set(te, this._pktLen)),
            (M += le),
            (this._pktLen += le),
            this._pktLen < this._len || M >= oe)
          )
            return;
        }
        {
          const le = Math.min(this._macActualLen - this._macPos, oe - M);
          if (
            (M !== 0 || le !== oe
              ? this._mac.set(
                  new Uint8Array(Y.buffer, Y.byteOffset + M, le),
                  this._macPos,
                )
              : this._mac.set(Y, this._macPos),
            (M += le),
            (this._macPos += le),
            this._macPos < this._macActualLen)
          )
            return;
        }
        this._instance.decrypt(
          this._packet,
          this.inSeqno,
          this._block,
          this._mac,
        );
        const Ee = new o(
          this._packet.buffer,
          this._packet.byteOffset + 1,
          this._packet.length - this._packet[0] - 1,
        );
        (this.inSeqno = (this.inSeqno + 1) >>> 0),
          (this._blockPos = 0),
          (this._len = 0),
          (this._packet = null),
          (this._pktLen = 0),
          (this._macPos = 0),
          (this._macInstance = null);
        {
          const le = this._onPayload(Ee);
          if (le !== void 0) return le === !1 ? M : le;
        }
      }
    }
  }
  function V(ne) {
    ++ne[11] >>> 8 &&
      ++ne[10] >>> 8 &&
      ++ne[9] >>> 8 &&
      ++ne[8] >>> 8 &&
      ++ne[7] >>> 8 &&
      ++ne[6] >>> 8 &&
      ++ne[5] >>> 8 &&
      ++ne[4] >>> 8;
  }
  const B = (() => {
    const ne = Buffer.alloc(4);
    return (Y) => (
      (ne[0] = Y >>> 24), (ne[1] = Y >>> 16), (ne[2] = Y >>> 8), (ne[3] = Y), ne
    );
  })();
  function N(ne, Y) {
    return ne.length !== Y.length ? (i(ne, ne), !1) : i(ne, Y);
  }
  function ce(ne) {
    if (typeof ne != "object" || ne === null) throw new Error("Invalid config");
    if (typeof ne.outbound != "object" || ne.outbound === null)
      throw new Error("Invalid outbound");
    const Y = ne.outbound;
    if (typeof Y.onWrite != "function")
      throw new Error("Invalid outbound.onWrite");
    if (typeof Y.cipherInfo != "object" || Y.cipherInfo === null)
      throw new Error("Invalid outbound.cipherInfo");
    if (
      !Buffer.isBuffer(Y.cipherKey) ||
      Y.cipherKey.length !== Y.cipherInfo.keyLen
    )
      throw new Error("Invalid outbound.cipherKey");
    if (
      Y.cipherInfo.ivLen &&
      (!Buffer.isBuffer(Y.cipherIV) || Y.cipherIV.length !== Y.cipherInfo.ivLen)
    )
      throw new Error("Invalid outbound.cipherIV");
    if (typeof Y.seqno != "number" || Y.seqno < 0 || Y.seqno > c)
      throw new Error("Invalid outbound.seqno");
    const M = !!Y.forceNative;
    switch (Y.cipherInfo.sslName) {
      case "aes-128-gcm":
      case "aes-256-gcm":
        return h && !M ? new Z(ne) : new J(ne);
      case "chacha20":
        return m && !M ? new q(ne) : new H(ne);
      default: {
        if (typeof Y.macInfo != "object" || Y.macInfo === null)
          throw new Error("Invalid outbound.macInfo");
        if (!Buffer.isBuffer(Y.macKey) || Y.macKey.length !== Y.macInfo.len)
          throw new Error("Invalid outbound.macKey");
        return g && !M ? new U(ne) : new z(ne);
      }
    }
  }
  function re(ne) {
    if (typeof ne != "object" || ne === null) throw new Error("Invalid config");
    if (typeof ne.inbound != "object" || ne.inbound === null)
      throw new Error("Invalid inbound");
    const Y = ne.inbound;
    if (typeof Y.onPayload != "function")
      throw new Error("Invalid inbound.onPayload");
    if (typeof Y.decipherInfo != "object" || Y.decipherInfo === null)
      throw new Error("Invalid inbound.decipherInfo");
    if (
      !Buffer.isBuffer(Y.decipherKey) ||
      Y.decipherKey.length !== Y.decipherInfo.keyLen
    )
      throw new Error("Invalid inbound.decipherKey");
    if (
      Y.decipherInfo.ivLen &&
      (!Buffer.isBuffer(Y.decipherIV) ||
        Y.decipherIV.length !== Y.decipherInfo.ivLen)
    )
      throw new Error("Invalid inbound.decipherIV");
    if (typeof Y.seqno != "number" || Y.seqno < 0 || Y.seqno > c)
      throw new Error("Invalid inbound.seqno");
    const M = !!Y.forceNative;
    switch (Y.decipherInfo.sslName) {
      case "aes-128-gcm":
      case "aes-256-gcm":
        return v && !M ? new F(ne) : new W(ne);
      case "chacha20":
        return y && !M ? new k(ne) : new L(ne);
      default: {
        if (typeof Y.macInfo != "object" || Y.macInfo === null)
          throw new Error("Invalid inbound.macInfo");
        if (!Buffer.isBuffer(Y.macKey) || Y.macKey.length !== Y.macInfo.len)
          throw new Error("Invalid inbound.macKey");
        return _ && !M ? new T(ne) : new x(ne);
      }
    }
  }
  return (
    (Ym = {
      CIPHER_INFO: R,
      MAC_INFO: A,
      bindingAvailable: !!p,
      init: (() =>
        new Promise(async (ne, Y) => {
          try {
            (O = await bte()()),
              (Q = O._malloc(16)),
              (j = O.cwrap("poly1305_auth", null, [
                "number",
                "array",
                "number",
                "array",
                "number",
                "array",
              ]));
          } catch (M) {
            return Y(M);
          }
          ne();
        }))(),
      NullCipher: I,
      createCipher: ce,
      NullDecipher: G,
      createDecipher: re,
    }),
    Ym
  );
}
const {
    createDecipheriv: Vb,
    createECDH: _te,
    createHash: Cl,
    createHmac: Ete,
    createSign: wte,
    createVerify: xte,
    getCiphers: Ate,
    sign: BA,
    verify: UA,
  } = pr,
  Ste = Ate(),
  { Ber: ft } = Yp,
  Ite = rk.pbkdf,
  { CIPHER_INFO: Rl } = eo(),
  { eddsaSupported: Yb, SUPPORTED_CIPHER: $te } = es(),
  {
    bufferSlice: Cs,
    makeBufferParser: Cte,
    readString: ot,
    readUInt32BE: sl,
    writeUInt32BE: Kn,
  } = Ki(),
  oa = Symbol("Hash Algorithm"),
  pi = Symbol("Private key PEM"),
  Bi = Symbol("Public key PEM"),
  Wa = Symbol("Public key SSH"),
  Rc = Symbol("Decrypted Key"),
  F0 = Object.create(null);
{
  const e = Object.keys(Rl);
  for (let t = 0; t < e.length; ++t) {
    const n = Rl[e[t]].sslName;
    !n || F0[n] || (F0[n] = Rl[e[t]]);
  }
}
const kf = Cte();
function _i(e, t) {
  t = t.base64Slice(0, t.length);
  let n = t.replace(
    /.{64}/g,
    `$&
`,
  );
  return (
    t.length & 63 &&
      (n += `
`),
    `-----BEGIN ${e} KEY-----
${n}-----END ${e} KEY-----`
  );
}
function ql(e, t) {
  const n = Buffer.allocUnsafe(e.length + t.length);
  return n.set(e, 0), n.set(t, e.length), n;
}
function Xb(e, t) {
  const n = e.length;
  let r = e._pos || 0;
  for (let i = 0; i < t; ++i) {
    const a = n - r;
    if (r >= n || a < 4) return !1;
    const s = sl(e, r);
    if (a < 4 + s) return !1;
    r += 4 + s;
  }
  return (e._pos = r), !0;
}
function _u(e, t) {
  const n = new ft.Writer();
  return (
    n.startSequence(),
    n.startSequence(),
    n.writeOID("1.2.840.113549.1.1.1"),
    n.writeNull(),
    n.endSequence(),
    n.startSequence(ft.BitString),
    n.writeByte(0),
    n.startSequence(),
    n.writeBuffer(e, ft.Integer),
    n.writeBuffer(t, ft.Integer),
    n.endSequence(),
    n.endSequence(),
    n.endSequence(),
    _i("PUBLIC", n.buffer)
  );
}
function Eu(e, t) {
  const n = Buffer.allocUnsafe(15 + t.length + 4 + e.length);
  Kn(n, 7, 0), n.utf8Write("ssh-rsa", 4, 7);
  let r = 4 + 7;
  return (
    Kn(n, t.length, r),
    n.set(t, (r += 4)),
    Kn(n, e.length, (r += t.length)),
    n.set(e, r + 4),
    n
  );
}
const ik = (() => {
  function e(r, i, a, s, o, c, l, f) {
    const u = new ft.Writer();
    return (
      u.startSequence(),
      u.writeInt(0, ft.Integer),
      u.writeBuffer(r, ft.Integer),
      u.writeBuffer(i, ft.Integer),
      u.writeBuffer(a, ft.Integer),
      u.writeBuffer(s, ft.Integer),
      u.writeBuffer(o, ft.Integer),
      u.writeBuffer(c, ft.Integer),
      u.writeBuffer(l, ft.Integer),
      u.writeBuffer(f, ft.Integer),
      u.endSequence(),
      u.buffer
    );
  }
  function t(r) {
    return BigInt(`0x${r.hexSlice(0, r.length)}`);
  }
  function n(r) {
    let i = r.toString(16);
    if (i.length & 1) i = `0${i}`;
    else {
      const a = i.charCodeAt(0);
      (a === 56 || a === 57 || (a >= 97 && a <= 102)) && (i = `00${i}`);
    }
    return Buffer.from(i, "hex");
  }
  return function (i, a, s, o, c, l) {
    const f = t(s),
      u = n(f % (t(c) - 1n)),
      d = n(f % (t(l) - 1n));
    return _i("RSA PRIVATE", e(i, a, s, c, l, u, d, o));
  };
})();
function wu(e, t, n, r) {
  const i = new ft.Writer();
  return (
    i.startSequence(),
    i.startSequence(),
    i.writeOID("1.2.840.10040.4.1"),
    i.startSequence(),
    i.writeBuffer(e, ft.Integer),
    i.writeBuffer(t, ft.Integer),
    i.writeBuffer(n, ft.Integer),
    i.endSequence(),
    i.endSequence(),
    i.startSequence(ft.BitString),
    i.writeByte(0),
    i.writeBuffer(r, ft.Integer),
    i.endSequence(),
    i.endSequence(),
    _i("PUBLIC", i.buffer)
  );
}
function xu(e, t, n, r) {
  const i = Buffer.allocUnsafe(
    15 + e.length + 4 + t.length + 4 + n.length + 4 + r.length,
  );
  Kn(i, 7, 0), i.utf8Write("ssh-dss", 4, 7);
  let a = 4 + 7;
  return (
    Kn(i, e.length, a),
    i.set(e, (a += 4)),
    Kn(i, t.length, (a += e.length)),
    i.set(t, (a += 4)),
    Kn(i, n.length, (a += t.length)),
    i.set(n, (a += 4)),
    Kn(i, r.length, (a += n.length)),
    i.set(r, a + 4),
    i
  );
}
function ak(e, t, n, r, i) {
  const a = new ft.Writer();
  return (
    a.startSequence(),
    a.writeInt(0, ft.Integer),
    a.writeBuffer(e, ft.Integer),
    a.writeBuffer(t, ft.Integer),
    a.writeBuffer(n, ft.Integer),
    a.writeBuffer(r, ft.Integer),
    a.writeBuffer(i, ft.Integer),
    a.endSequence(),
    _i("DSA PRIVATE", a.buffer)
  );
}
function sk(e) {
  const t = new ft.Writer();
  return (
    t.startSequence(),
    t.startSequence(),
    t.writeOID("1.3.101.112"),
    t.endSequence(),
    t.startSequence(ft.BitString),
    t.writeByte(0),
    t._ensure(e.length),
    t._buf.set(e, t._offset),
    (t._offset += e.length),
    t.endSequence(),
    t.endSequence(),
    _i("PUBLIC", t.buffer)
  );
}
function ok(e) {
  const t = Buffer.allocUnsafe(19 + e.length);
  return (
    Kn(t, 11, 0),
    t.utf8Write("ssh-ed25519", 4, 11),
    Kn(t, e.length, 15),
    t.set(e, 19),
    t
  );
}
function Rte(e) {
  const t = new ft.Writer();
  return (
    t.startSequence(),
    t.writeInt(0, ft.Integer),
    t.startSequence(),
    t.writeOID("1.3.101.112"),
    t.endSequence(),
    t.startSequence(ft.OctetString),
    t.writeBuffer(e, ft.OctetString),
    t.endSequence(),
    t.endSequence(),
    _i("PRIVATE", t.buffer)
  );
}
function Jb(e, t) {
  const n = new ft.Writer();
  return (
    n.startSequence(),
    n.startSequence(),
    n.writeOID("1.2.840.10045.2.1"),
    n.writeOID(e),
    n.endSequence(),
    n.startSequence(ft.BitString),
    n.writeByte(0),
    n._ensure(t.length),
    n._buf.set(t, n._offset),
    (n._offset += t.length),
    n.endSequence(),
    n.endSequence(),
    _i("PUBLIC", n.buffer)
  );
}
function Zb(e, t) {
  let n;
  switch (e) {
    case "1.2.840.10045.3.1.7":
      n = "nistp256";
      break;
    case "1.3.132.0.34":
      n = "nistp384";
      break;
    case "1.3.132.0.35":
      n = "nistp521";
      break;
    default:
      return;
  }
  const r = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + t.length);
  return (
    Kn(r, 19, 0),
    r.utf8Write(`ecdsa-sha2-${n}`, 4, 19),
    Kn(r, 8, 23),
    r.utf8Write(n, 27, 8),
    Kn(r, t.length, 35),
    r.set(t, 39),
    r
  );
}
function kte(e, t, n) {
  const r = new ft.Writer();
  return (
    r.startSequence(),
    r.writeInt(1, ft.Integer),
    r.writeBuffer(n, ft.OctetString),
    r.startSequence(160),
    r.writeOID(e),
    r.endSequence(),
    r.startSequence(161),
    r.startSequence(ft.BitString),
    r.writeByte(0),
    r._ensure(t.length),
    r._buf.set(t, r._offset),
    (r._offset += t.length),
    r.endSequence(),
    r.endSequence(),
    r.endSequence(),
    _i("EC PRIVATE", r.buffer)
  );
}
function Tte(e, t) {
  const n = _te(e);
  return n.setPrivateKey(t), n.getPublicKey();
}
const Au = {
  sign: (() =>
    typeof BA == "function"
      ? function (t, n) {
          const r = this[pi];
          if (r === null) return new Error("No private key available");
          (!n || typeof n != "string") && (n = this[oa]);
          try {
            return BA(n, t, r);
          } catch (i) {
            return i;
          }
        }
      : function (t, n) {
          const r = this[pi];
          if (r === null) return new Error("No private key available");
          (!n || typeof n != "string") && (n = this[oa]);
          const i = wte(n);
          i.update(t);
          try {
            return i.sign(r);
          } catch (a) {
            return a;
          }
        })(),
  verify: (() =>
    typeof UA == "function"
      ? function (t, n, r) {
          const i = this[Bi];
          if (i === null) return new Error("No public key available");
          (!r || typeof r != "string") && (r = this[oa]);
          try {
            return UA(r, t, i, n);
          } catch (a) {
            return a;
          }
        }
      : function (t, n, r) {
          const i = this[Bi];
          if (i === null) return new Error("No public key available");
          (!r || typeof r != "string") && (r = this[oa]);
          const a = xte(r);
          a.update(t);
          try {
            return a.verify(i, n);
          } catch (s) {
            return s;
          }
        })(),
  isPrivateKey: function () {
    return this[pi] !== null;
  },
  getPrivatePEM: function () {
    return this[pi];
  },
  getPublicPEM: function () {
    return this[Bi];
  },
  getPublicSSH: function () {
    return this[Wa];
  },
  equals: function (t) {
    const n = uk(t);
    return n instanceof Error
      ? !1
      : this.type === n.type &&
          this[pi] === n[pi] &&
          this[Bi] === n[Bi] &&
          this[Wa] === n[Wa];
  },
};
function Nd(e, t, n, r, i, a, s) {
  (this.type = e),
    (this.comment = t),
    (this[pi] = n),
    (this[Bi] = r),
    (this[Wa] = i),
    (this[oa] = a),
    (this[Rc] = s);
}
Nd.prototype = Au;
{
  let t = function (n, r, i) {
    const a = [];
    if (n.length < 8) return new Error("Malformed OpenSSH private key");
    const s = sl(n, 0),
      o = sl(n, 4);
    if (s !== o)
      return i
        ? new Error("OpenSSH key integrity check failed -- bad passphrase?")
        : new Error("OpenSSH key integrity check failed");
    n._pos = 8;
    let c, l;
    for (c = 0; c < r; ++c) {
      let u, d, p, h;
      const m = ot(n, n._pos, !0);
      if (m === void 0) return new Error("Malformed OpenSSH private key");
      switch (m) {
        case "ssh-rsa": {
          const v = ot(n, n._pos);
          if (v === void 0) return new Error("Malformed OpenSSH private key");
          const y = ot(n, n._pos);
          if (y === void 0) return new Error("Malformed OpenSSH private key");
          const _ = ot(n, n._pos);
          if (_ === void 0) return new Error("Malformed OpenSSH private key");
          const E = ot(n, n._pos);
          if (E === void 0) return new Error("Malformed OpenSSH private key");
          const R = ot(n, n._pos);
          if (R === void 0) return new Error("Malformed OpenSSH private key");
          const A = ot(n, n._pos);
          if (A === void 0) return new Error("Malformed OpenSSH private key");
          (p = _u(v, y)),
            (h = Eu(v, y)),
            (d = ik(v, y, _, E, R, A)),
            (u = "sha1");
          break;
        }
        case "ssh-dss": {
          const v = ot(n, n._pos);
          if (v === void 0) return new Error("Malformed OpenSSH private key");
          const y = ot(n, n._pos);
          if (y === void 0) return new Error("Malformed OpenSSH private key");
          const _ = ot(n, n._pos);
          if (_ === void 0) return new Error("Malformed OpenSSH private key");
          const E = ot(n, n._pos);
          if (E === void 0) return new Error("Malformed OpenSSH private key");
          const R = ot(n, n._pos);
          if (R === void 0) return new Error("Malformed OpenSSH private key");
          (p = wu(v, y, _, E)),
            (h = xu(v, y, _, E)),
            (d = ak(v, y, _, E, R)),
            (u = "sha1");
          break;
        }
        case "ssh-ed25519": {
          if (!Yb)
            return new Error(`Unsupported OpenSSH private key type: ${m}`);
          const v = ot(n, n._pos);
          if (v === void 0 || v.length !== 32)
            return new Error("Malformed OpenSSH private key");
          const y = ot(n, n._pos);
          if (y === void 0 || y.length !== 64)
            return new Error("Malformed OpenSSH private key");
          (p = sk(v)), (h = ok(v)), (d = Rte(Cs(y, 0, 32))), (u = null);
          break;
        }
        case "ecdsa-sha2-nistp256":
          (u = "sha256"), (l = "1.2.840.10045.3.1.7");
        case "ecdsa-sha2-nistp384":
          u === void 0 && ((u = "sha384"), (l = "1.3.132.0.34"));
        case "ecdsa-sha2-nistp521": {
          if (
            (u === void 0 && ((u = "sha512"), (l = "1.3.132.0.35")), !Xb(n, 1))
          )
            return new Error("Malformed OpenSSH private key");
          const v = ot(n, n._pos);
          if (v === void 0) return new Error("Malformed OpenSSH private key");
          const y = ot(n, n._pos);
          if (y === void 0) return new Error("Malformed OpenSSH private key");
          (p = Jb(l, v)), (h = Zb(l, v)), (d = kte(l, v, y));
          break;
        }
        default:
          return new Error(`Unsupported OpenSSH private key type: ${m}`);
      }
      const g = ot(n, n._pos, !0);
      if (g === void 0) return new Error("Malformed OpenSSH private key");
      a.push(new Nd(m, g, d, p, h, u, i));
    }
    let f = 0;
    for (c = n._pos; c < n.length; ++c)
      if (n[c] !== ++f % 255) return new Error("Malformed OpenSSH private key");
    return a;
  };
  const e =
    /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\r\n|\n)([\s\S]+)(?:\r\n|\n)-----END OPENSSH PRIVATE KEY-----$/;
  Nd.parse = (n, r) => {
    const i = e.exec(n);
    if (i === null) return null;
    let a;
    const s = Buffer.from(i[1], "base64");
    if (s.length < 31) return new Error("Malformed OpenSSH private key");
    const o = s.utf8Slice(0, 15);
    if (o !== "openssh-key-v1\0")
      return new Error(`Unsupported OpenSSH key magic: ${o}`);
    const c = ot(s, 15, !0);
    if (c === void 0) return new Error("Malformed OpenSSH private key");
    if (c !== "none" && $te.indexOf(c) === -1)
      return new Error(`Unsupported cipher for OpenSSH key: ${c}`);
    const l = ot(s, s._pos, !0);
    if (l === void 0) return new Error("Malformed OpenSSH private key");
    if (l !== "none") {
      if (c === "none") return new Error("Malformed OpenSSH private key");
      if (l !== "bcrypt")
        return new Error(`Unsupported kdf name for OpenSSH key: ${l}`);
      if (!r)
        return new Error(
          "Encrypted private OpenSSH key detected, but no passphrase given",
        );
    } else if (c !== "none") return new Error("Malformed OpenSSH private key");
    let f, u, d;
    c !== "none" && (f = Rl[c]);
    const p = ot(s, s._pos);
    if (p === void 0) return new Error("Malformed OpenSSH private key");
    if (p.length)
      switch (l) {
        case "none":
          return new Error("Malformed OpenSSH private key");
        case "bcrypt": {
          const m = ot(p, 0);
          if (m === void 0 || p._pos + 4 > p.length)
            return new Error("Malformed OpenSSH private key");
          const g = sl(p, p._pos),
            v = Buffer.allocUnsafe(f.keyLen + f.ivLen);
          if (Ite(r, r.length, m, m.length, v, v.length, g) !== 0)
            return new Error("Failed to generate information to decrypt key");
          (u = Cs(v, 0, f.keyLen)), (d = Cs(v, f.keyLen, v.length));
          break;
        }
      }
    else if (l !== "none") return new Error("Malformed OpenSSH private key");
    if (s._pos + 3 >= s.length)
      return new Error("Malformed OpenSSH private key");
    const h = sl(s, s._pos);
    if (((s._pos += 4), h > 0)) {
      for (let g = 0; g < h; ++g) {
        const v = ot(s, s._pos);
        if (v === void 0) return new Error("Malformed OpenSSH private key");
        if (ot(v, 0, !0) === void 0)
          return new Error("Malformed OpenSSH private key");
      }
      let m = ot(s, s._pos);
      if (m === void 0) return new Error("Malformed OpenSSH private key");
      if (u !== void 0) {
        if (m.length < f.blockLen || m.length % f.blockLen !== 0)
          return new Error("Malformed OpenSSH private key");
        try {
          const g = { authTagLength: f.authLen },
            v = Vb(f.sslName, u, d, g);
          if ((v.setAutoPadding(!1), f.authLen > 0)) {
            if (s.length - s._pos < f.authLen)
              return new Error("Malformed OpenSSH private key");
            v.setAuthTag(Cs(s, s._pos, (s._pos += f.authLen)));
          }
          m = ql(v.update(m), v.final());
        } catch (g) {
          return g;
        }
      }
      if (s._pos !== s.length)
        return new Error("Malformed OpenSSH private key");
      a = t(m, h, u !== void 0);
    } else a = [];
    return a instanceof Error ? a : a[0];
  };
}
function Od(e, t, n, r, i, a, s) {
  (this.type = e),
    (this.comment = t),
    (this[pi] = n),
    (this[Bi] = r),
    (this[Wa] = i),
    (this[oa] = a),
    (this[Rc] = s);
}
Od.prototype = Au;
{
  const e =
    /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\r\n|\n)((?:[^:]+:\s*[\S].*(?:\r\n|\n))*)([\s\S]+)(?:\r\n|\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;
  Od.parse = (t, n) => {
    const r = e.exec(t);
    if (r === null) return null;
    let i = Buffer.from(r[3], "base64"),
      a = r[2],
      s = !1;
    if (a !== void 0) {
      a = a.split(/\r\n|\n/g);
      for (let h = 0; h < a.length; ++h) {
        const m = a[h];
        let g = m.indexOf(":");
        if (m.slice(0, g) === "DEK-Info") {
          const v = m.slice(g + 2);
          if (((g = v.indexOf(",")), g === -1)) continue;
          const y = v.slice(0, g).toLowerCase();
          if (Ste.indexOf(y) === -1)
            return new Error(
              `Cipher (${y}) not supported for encrypted OpenSSH private key`,
            );
          const _ = F0[y];
          if (!_)
            return new Error(
              `Cipher (${y}) not supported for encrypted OpenSSH private key`,
            );
          const E = Buffer.from(v.slice(g + 1), "hex");
          if (E.length !== _.ivLen)
            return new Error("Malformed encrypted OpenSSH private key");
          if (!n)
            return new Error(
              "Encrypted OpenSSH private key detected, but no passphrase given",
            );
          const R = Cs(E, 0, 8);
          let A = Cl("md5").update(n).update(R).digest();
          for (; A.length < _.keyLen; )
            A = ql(A, Cl("md5").update(A).update(n).update(R).digest());
          A.length > _.keyLen && (A = Cs(A, 0, _.keyLen));
          try {
            const I = Vb(y, A, E);
            I.setAutoPadding(!1), (i = ql(I.update(i), I.final())), (s = !0);
          } catch (I) {
            return I;
          }
        }
      }
    }
    let o,
      c,
      l,
      f,
      u,
      d,
      p = "Malformed OpenSSH private key";
    switch ((s && (p += ". Bad passphrase?"), r[1])) {
      case "RSA":
        (o = "ssh-rsa"), (c = _i("RSA PRIVATE", i));
        try {
          (d = new ft.Reader(i)), d.readSequence(), d.readInt();
          const h = d.readString(ft.Integer, !0);
          if (h === null) return new Error(p);
          const m = d.readString(ft.Integer, !0);
          if (m === null) return new Error(p);
          (l = _u(h, m)), (f = Eu(h, m));
        } catch {
          return new Error(p);
        }
        u = "sha1";
        break;
      case "DSA":
        (o = "ssh-dss"), (c = _i("DSA PRIVATE", i));
        try {
          (d = new ft.Reader(i)), d.readSequence(), d.readInt();
          const h = d.readString(ft.Integer, !0);
          if (h === null) return new Error(p);
          const m = d.readString(ft.Integer, !0);
          if (m === null) return new Error(p);
          const g = d.readString(ft.Integer, !0);
          if (g === null) return new Error(p);
          const v = d.readString(ft.Integer, !0);
          if (v === null) return new Error(p);
          (l = wu(h, m, g, v)), (f = xu(h, m, g, v));
        } catch {
          return new Error(p);
        }
        u = "sha1";
        break;
      case "EC": {
        let h, m, g;
        try {
          (d = new ft.Reader(i)),
            d.readSequence(),
            d.readInt(),
            (m = d.readString(ft.OctetString, !0)),
            d.readByte();
          const y = d.readLength();
          if (y !== null) {
            if (((d._offset = y), (g = d.readOID()), g === null))
              return new Error(p);
            switch (g) {
              case "1.2.840.10045.3.1.7":
                (h = "prime256v1"), (o = "ecdsa-sha2-nistp256"), (u = "sha256");
                break;
              case "1.3.132.0.34":
                (h = "secp384r1"), (o = "ecdsa-sha2-nistp384"), (u = "sha384");
                break;
              case "1.3.132.0.35":
                (h = "secp521r1"), (o = "ecdsa-sha2-nistp521"), (u = "sha512");
                break;
              default:
                return new Error(`Unsupported private key EC OID: ${g}`);
            }
          } else return new Error(p);
        } catch {
          return new Error(p);
        }
        c = _i("EC PRIVATE", i);
        const v = Tte(h, m);
        (l = Jb(g, v)), (f = Zb(g, v));
        break;
      }
    }
    return new Od(o, "", c, l, f, u, s);
  };
}
function Pd(e, t, n, r, i, a, s) {
  (this.type = e),
    (this.comment = t),
    (this[pi] = n),
    (this[Bi] = r),
    (this[Wa] = i),
    (this[oa] = a),
    (this[Rc] = s);
}
Pd.prototype = Au;
{
  const e = Buffer.alloc(0),
    t = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
    n = Buffer.from([0, 0, 0, 0]),
    r = Buffer.from([0, 0, 0, 1]),
    i =
      /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\r?\nEncryption: (aes256-cbc|none)\r?\nComment: ([^\r\n]*)\r?\nPublic-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-MAC: ([^\r\n]+)/;
  Pd.parse = (a, s) => {
    const o = i.exec(a);
    if (o === null) return null;
    const c = o[2],
      l = c !== "none";
    if (l && !s)
      return new Error(
        "Encrypted PPK private key detected, but no passphrase given",
      );
    let f = Buffer.from(o[5], "base64");
    if (l) {
      const O = Rl[c];
      let Q = ql(
        Cl("sha1").update(n).update(s).digest(),
        Cl("sha1").update(r).update(s).digest(),
      );
      Q.length > O.keyLen && (Q = Cs(Q, 0, O.keyLen));
      try {
        const j = Vb(O.sslName, Q, t);
        j.setAutoPadding(!1), (f = ql(j.update(f), j.final()));
      } catch (j) {
        return j;
      }
    }
    const u = o[1],
      d = o[3],
      p = Buffer.from(o[4], "base64"),
      h = o[6],
      m = u.length,
      g = c.length,
      v = Buffer.byteLength(d),
      y = p.length,
      _ = f.length,
      E = Buffer.allocUnsafe(4 + m + 4 + g + 4 + v + 4 + y + 4 + _);
    let R = 0;
    if (
      (Kn(E, m, R),
      E.utf8Write(u, (R += 4), m),
      Kn(E, g, (R += m)),
      E.utf8Write(c, (R += 4), g),
      Kn(E, v, (R += g)),
      E.utf8Write(d, (R += 4), v),
      Kn(E, y, (R += v)),
      E.set(p, (R += 4)),
      Kn(E, _, (R += y)),
      E.set(f, R + 4),
      s || (s = e),
      Ete(
        "sha1",
        Cl("sha1").update("putty-private-key-file-mac-key").update(s).digest(),
      )
        .update(E)
        .digest("hex") !== h)
    )
      return l
        ? new Error("PPK private key integrity check failed -- bad passphrase?")
        : new Error("PPK private key integrity check failed");
    let I, S, w;
    switch (((p._pos = 0), Xb(p, 1), u)) {
      case "ssh-rsa": {
        const O = ot(p, p._pos);
        if (O === void 0) return new Error("Malformed PPK public key");
        const Q = ot(p, p._pos);
        if (Q === void 0) return new Error("Malformed PPK public key");
        const j = ot(f, 0);
        if (j === void 0) return new Error("Malformed PPK private key");
        const H = ot(f, f._pos);
        if (H === void 0) return new Error("Malformed PPK private key");
        const q = ot(f, f._pos);
        if (q === void 0) return new Error("Malformed PPK private key");
        const J = ot(f, f._pos);
        if (J === void 0) return new Error("Malformed PPK private key");
        (I = _u(Q, O)), (S = Eu(Q, O)), (w = ik(Q, O, j, J, H, q));
        break;
      }
      case "ssh-dss": {
        const O = ot(p, p._pos);
        if (O === void 0) return new Error("Malformed PPK public key");
        const Q = ot(p, p._pos);
        if (Q === void 0) return new Error("Malformed PPK public key");
        const j = ot(p, p._pos);
        if (j === void 0) return new Error("Malformed PPK public key");
        const H = ot(p, p._pos);
        if (H === void 0) return new Error("Malformed PPK public key");
        const q = ot(f, 0);
        if (q === void 0) return new Error("Malformed PPK private key");
        (I = wu(O, Q, j, H)), (S = xu(O, Q, j, H)), (w = ak(O, Q, j, H, q));
        break;
      }
    }
    return new Pd(u, d, w, I, S, "sha1", l);
  };
}
function Xp(e, t, n, r, i) {
  (this.type = e),
    (this.comment = t),
    (this[pi] = null),
    (this[Bi] = n),
    (this[Wa] = r),
    (this[oa] = i),
    (this[Rc] = !1);
}
Xp.prototype = Au;
{
  let e;
  Yb
    ? (e =
        /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/)
    : (e =
        /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/),
    (Xp.parse = (t) => {
      const n = e.exec(t);
      if (n === null) return null;
      const r = n[1],
        i = n[2],
        a = Buffer.from(n[3], "base64"),
        s = n[4] || "",
        o = ot(a, a._pos, !0);
      return o === void 0 || o.indexOf(i) !== 0
        ? new Error("Malformed OpenSSH public key")
        : e1(a, i, s, r);
    });
}
function Dd(e, t, n, r, i) {
  (this.type = e),
    (this.comment = t),
    (this[pi] = null),
    (this[Bi] = n),
    (this[Wa] = r),
    (this[oa] = i),
    (this[Rc] = !1);
}
Dd.prototype = Au;
{
  const e =
      /^---- BEGIN SSH2 PUBLIC KEY ----(?:\r?\n)((?:.{0,72}\r?\n)+)---- END SSH2 PUBLIC KEY ----$/,
    t = /^[A-Z0-9a-z/+=\r\n]+$/,
    n = /^([\x21-\x39\x3B-\x7E]{1,64}): ((?:[^\\]*\\\r?\n)*[^\r\n]+)\r?\n/gm,
    r = /\\\r?\n/g;
  Dd.parse = (i) => {
    let a = e.exec(i);
    if (a === null) return null;
    const s = a[1];
    let o = 0,
      c = "";
    for (; (a = n.exec(s)); ) {
      const p = a[1],
        h = a[2].replace(r, "");
      if (h.length > 1024)
        return (n.lastIndex = 0), new Error("Malformed RFC4716 public key");
      (o = n.lastIndex),
        p.toLowerCase() === "comment" &&
          ((c = h),
          c.length > 1 &&
            c.charCodeAt(0) === 34 &&
            c.charCodeAt(c.length - 1) === 34 &&
            (c = c.slice(1, -1)));
    }
    let l = s.slice(o);
    if (!t.test(l)) return new Error("Malformed RFC4716 public key");
    l = Buffer.from(l, "base64");
    const f = ot(l, 0, !0);
    if (f === void 0) return new Error("Malformed RFC4716 public key");
    let u = null,
      d = null;
    switch (f) {
      case "ssh-rsa": {
        const p = ot(l, l._pos);
        if (p === void 0) return new Error("Malformed RFC4716 public key");
        const h = ot(l, l._pos);
        if (h === void 0) return new Error("Malformed RFC4716 public key");
        (u = _u(h, p)), (d = Eu(h, p));
        break;
      }
      case "ssh-dss": {
        const p = ot(l, l._pos);
        if (p === void 0) return new Error("Malformed RFC4716 public key");
        const h = ot(l, l._pos);
        if (h === void 0) return new Error("Malformed RFC4716 public key");
        const m = ot(l, l._pos);
        if (m === void 0) return new Error("Malformed RFC4716 public key");
        const g = ot(l, l._pos);
        if (g === void 0) return new Error("Malformed RFC4716 public key");
        (u = wu(p, h, m, g)), (d = xu(p, h, m, g));
        break;
      }
      default:
        return new Error("Malformed RFC4716 public key");
    }
    return new Dd(f, c, u, d, "sha1");
  };
}
function e1(e, t, n, r) {
  if (!ck(t)) return new Error(`Unsupported OpenSSH public key type: ${t}`);
  let i,
    a,
    s = null,
    o = null;
  switch (t) {
    case "ssh-rsa": {
      const c = ot(e, e._pos || 0);
      if (c === void 0) return new Error("Malformed OpenSSH public key");
      const l = ot(e, e._pos);
      if (l === void 0) return new Error("Malformed OpenSSH public key");
      (s = _u(l, c)), (o = Eu(l, c)), (i = "sha1");
      break;
    }
    case "ssh-dss": {
      const c = ot(e, e._pos || 0);
      if (c === void 0) return new Error("Malformed OpenSSH public key");
      const l = ot(e, e._pos);
      if (l === void 0) return new Error("Malformed OpenSSH public key");
      const f = ot(e, e._pos);
      if (f === void 0) return new Error("Malformed OpenSSH public key");
      const u = ot(e, e._pos);
      if (u === void 0) return new Error("Malformed OpenSSH public key");
      (s = wu(c, l, f, u)), (o = xu(c, l, f, u)), (i = "sha1");
      break;
    }
    case "ssh-ed25519": {
      const c = ot(e, e._pos || 0);
      if (c === void 0 || c.length !== 32)
        return new Error("Malformed OpenSSH public key");
      (s = sk(c)), (o = ok(c)), (i = null);
      break;
    }
    case "ecdsa-sha2-nistp256":
      (i = "sha256"), (a = "1.2.840.10045.3.1.7");
    case "ecdsa-sha2-nistp384":
      i === void 0 && ((i = "sha384"), (a = "1.3.132.0.34"));
    case "ecdsa-sha2-nistp521": {
      if ((i === void 0 && ((i = "sha512"), (a = "1.3.132.0.35")), !Xb(e, 1)))
        return new Error("Malformed OpenSSH public key");
      const c = ot(e, e._pos || 0);
      if (c === void 0) return new Error("Malformed OpenSSH public key");
      (s = Jb(a, c)), (o = Zb(a, c));
      break;
    }
    default:
      return new Error(`Unsupported OpenSSH public key type: ${t}`);
  }
  return new Xp(r, n, s, o, i);
}
function ck(e) {
  switch (e) {
    case "ssh-rsa":
    case "ssh-dss":
    case "ecdsa-sha2-nistp256":
    case "ecdsa-sha2-nistp384":
    case "ecdsa-sha2-nistp521":
      return !0;
    case "ssh-ed25519":
      if (Yb) return !0;
    default:
      return !1;
  }
}
function lk(e) {
  return e ? typeof e[Rc] == "boolean" : !1;
}
function uk(e, t) {
  if (lk(e)) return e;
  let n;
  if (Buffer.isBuffer(e)) (n = e), (e = e.utf8Slice(0, e.length).trim());
  else if (typeof e == "string") e = e.trim();
  else return new Error("Key data must be a Buffer or string");
  if (t != null) {
    if (typeof t == "string") t = Buffer.from(t);
    else if (!Buffer.isBuffer(t))
      return new Error("Passphrase must be a string or Buffer when supplied");
  }
  let r;
  if (
    (r = Nd.parse(e, t)) !== null ||
    (r = Od.parse(e, t)) !== null ||
    (r = Pd.parse(e, t)) !== null ||
    (r = Xp.parse(e)) !== null ||
    (r = Dd.parse(e)) !== null
  )
    return r;
  if (n) {
    kf.init(n, 0);
    const i = kf.readString(!0);
    i !== void 0 &&
      ((e = kf.readRaw()),
      e !== void 0 &&
        ((r = e1(e, i, "", i)), r instanceof Error && (r = null))),
      kf.clear();
  }
  return r || new Error("Unsupported key format");
}
var to = {
  isParsedKey: lk,
  isSupportedKeyType: ck,
  parseDERKey: (e, t) => e1(e, t, "", t),
  parseKey: uk,
};
const { Socket: fk } = ha,
  { Duplex: dk } = Kr,
  { resolve: Nte } = pt,
  { readFile: FA } = Xt,
  { execFile: Ote, spawn: Pte } = Ql,
  { isParsedKey: jA, parseKey: ol } = to,
  {
    makeBufferParser: Dte,
    readUInt32BE: t1,
    writeUInt32BE: kr,
    writeUInt32LE: MA,
  } = Ki();
function kl(e) {
  let t = !1;
  return (...n) => {
    t || ((t = !0), e(...n));
  };
}
function Lte(e, t) {
  const n = Buffer.allocUnsafe(e.length + t.length);
  return e.copy(n, 0), t.copy(n, e.length), n;
}
function j0() {}
const Bte = Buffer.alloc(0),
  _n = Dte();
let n1 = class {
    getIdentities(t) {
      t(new Error("Missing getIdentities() implementation"));
    }
    sign(t, n, r, i) {
      typeof r == "function" && (i = r),
        i(new Error("Missing sign() implementation"));
    }
  },
  Jp = class extends n1 {
    constructor(t) {
      super(), (this.socketPath = t);
    }
    getStream(t) {
      t = kl(t);
      const n = new fk();
      n.on("connect", () => {
        t(null, n);
      }),
        n.on("close", r).on("end", r).on("error", r),
        n.connect(this.socketPath);
      function r() {
        try {
          n.destroy();
        } catch {}
        t(new Error("Failed to connect to agent"));
      }
    }
    getIdentities(t) {
      (t = kl(t)),
        this.getStream((n, r) => {
          function i(s) {
            if (r)
              try {
                r.destroy();
              } catch {}
            s || (s = new Error("Failed to retrieve identities from agent")),
              t(s);
          }
          if (n) return i(n);
          const a = new M0(!0);
          a.on("error", i),
            a.pipe(r).pipe(a),
            r.on("close", i).on("end", i).on("error", i),
            a.getIdentities((s, o) => {
              if (s) return i(s);
              try {
                r.destroy();
              } catch {}
              t(null, o);
            });
        });
    }
    sign(t, n, r, i) {
      typeof r == "function"
        ? ((i = r), (r = void 0))
        : (typeof r != "object" || r === null) && (r = void 0),
        (i = kl(i)),
        this.getStream((a, s) => {
          function o(l) {
            if (s)
              try {
                s.destroy();
              } catch {}
            l || (l = new Error("Failed to sign data with agent")), i(l);
          }
          if (a) return o(a);
          const c = new M0(!0);
          c.on("error", o),
            c.pipe(s).pipe(c),
            s.on("close", o).on("end", o).on("error", o),
            c.sign(t, n, r, (l, f) => {
              if (l) return o(l);
              try {
                s.destroy();
              } catch {}
              i(null, f);
            });
        });
    }
  };
const pk = (() => {
    const s = Nte(__dirname, "..", "util/pagent.exe"),
      o = {
        10: new Error("Invalid pagent.exe arguments"),
        11: new Error("Pageant is not running"),
        12: new Error("pagent.exe could not create an mmap"),
        13: new Error("pagent.exe could not set mode for stdin"),
        14: new Error("pagent.exe could not set mode for stdout"),
        15: new Error("pagent.exe did not get expected input payload"),
      };
    function c(f) {
      (f.buffer = null), f.proc && (f.proc.kill(), (f.proc = void 0));
    }
    class l extends dk {
      constructor() {
        super(), (this.proc = void 0), (this.buffer = null);
      }
      _read(u) {}
      _write(u, d, p) {
        if (this.buffer === null) this.buffer = u;
        else {
          const v = Buffer.allocUnsafe(this.buffer.length + u.length);
          this.buffer.copy(v, 0),
            u.copy(v, this.buffer.length),
            (this.buffer = v);
        }
        if (this.buffer.length < 4) return p();
        const h = t1(this.buffer, 0);
        if (this.buffer.length - 4 < h) return p();
        if (((u = this.buffer.slice(0, 4 + h)), this.buffer.length > 4 + h))
          return p(new Error("Unexpected multiple agent requests"));
        this.buffer = null;
        let m;
        const g = (this.proc = Pte(s, [u.length]));
        g.stdout.on("data", (v) => {
          this.push(v);
        }),
          g.on("error", (v) => {
            (m = v), p(m);
          }),
          g.on("close", (v) => {
            if (((this.proc = void 0), !m)) {
              if ((m = o[v])) return p(m);
              p();
            }
          }),
          g.stdin.end(u);
      }
      _final(u) {
        c(this), u();
      }
      _destroy(u, d) {
        c(this), d();
      }
    }
    return class extends Jp {
      getStream(u) {
        u(null, new l());
      }
    };
  })(),
  hk = (() => {
    const e =
      /^!<socket >(\d+) s ([A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8})/;
    return class extends Jp {
      getStream(n) {
        n = kl(n);
        let r = this.socketPath,
          i = !1;
        FA(r, function a(s, o) {
          if (s) {
            if (i) return n(new Error("Invalid cygwin unix socket path"));
            Ote("cygpath", ["-w", r], (A, I, S) => {
              if (A || I.length === 0)
                return n(new Error("Invalid cygwin unix socket path"));
              (i = !0), (r = I.toString().replace(/[\r\n]/g, "")), FA(r, a);
            });
            return;
          }
          const c = e.exec(o.toString("ascii"));
          if (!c) return n(new Error("Malformed cygwin unix socket file"));
          let l,
            f = 0,
            u = !1;
          const d = [];
          let p,
            h = Buffer.alloc(12);
          const m = parseInt(c[1], 10),
            g = c[2].replace(/-/g, ""),
            v = Buffer.allocUnsafe(16);
          for (let A = 0, I = 0; I < 32; ++A, I += 2)
            v[A] = parseInt(g.substring(I, I + 2), 16);
          for (let A = 0; A < 16; A += 4) MA(v, t1(v, A), A);
          R();
          function y() {
            (f = 0), (l = "secret"), p.write(v);
          }
          function _(A) {
            if (((f += A.length), l === "secret")) {
              f === 16 && ((f = 0), (l = "creds"), p.write(h));
              return;
            }
            if (l === "creds" && (u || d.push(A), f === 12)) {
              if (
                (p.removeListener("connect", y),
                p.removeListener("data", _),
                p.removeListener("error", E),
                p.removeListener("end", E),
                p.removeListener("close", E),
                u)
              )
                return n(null, p);
              (u = !0),
                (h = Buffer.concat(d)),
                MA(h, process.pid, 0),
                p.on("error", () => {}),
                p.destroy(),
                R();
            }
          }
          function E() {
            n(new Error("Problem negotiating cygwin unix socket security"));
          }
          function R() {
            (p = new fk()),
              p.on("connect", y),
              p.on("data", _),
              p.on("error", E),
              p.on("end", E),
              p.on("close", E),
              p.connect(m);
          }
        });
      }
    };
  })(),
  Ute = /^[/\\][/\\]\.[/\\]pipe[/\\].+/;
function mk(e) {
  return process.platform === "win32" && !Ute.test(e)
    ? e === "pageant"
      ? new pk()
      : new hk(e)
    : new Jp(e);
}
const M0 = (() => {
    function l(S) {
      let w;
      for (; S[y].length; ) {
        const O = S[y][0][u];
        if (O === void 0) break;
        S[y].shift(), (w = S.push(O));
      }
      return w;
    }
    const f = Symbol("Inbound Request Type"),
      u = Symbol("Inbound Request Response"),
      d = Symbol("Inbound Request Context");
    class p {
      constructor(w, O) {
        (this[f] = w), (this[u] = void 0), (this[d] = O);
      }
      hasResponded() {
        return this[u] !== void 0;
      }
      getType() {
        return this[f];
      }
      getContext() {
        return this[d];
      }
    }
    function h(S, w, O) {
      return (w[u] = O), l(S);
    }
    function m(S) {
      if (((S[E] = null), S[_] === 0)) {
        const w = S[y];
        if (w && w.length) {
          S[y] = [];
          for (const O of w) O.cb(new Error("No reply from server"));
        }
      }
      try {
        S.end();
      } catch {}
      setImmediate(() => {
        S[I] || S.emit("end"), S[A] || S.emit("close");
      });
    }
    function g() {
      this[A] = !0;
    }
    function v() {
      this[I] = !0;
    }
    const y = Symbol("Requests"),
      _ = Symbol("Agent Protocol Role"),
      E = Symbol("Agent Protocol Buffer"),
      R = Symbol("Agent Protocol Current Message Length"),
      A = Symbol("Agent Protocol Closed"),
      I = Symbol("Agent Protocol Ended");
    return class extends dk {
      constructor(w) {
        super({ autoDestroy: !0, emitClose: !1 }),
          (this[_] = w ? 0 : 1),
          (this[y] = []),
          (this[E] = null),
          (this[R] = -1),
          this.once("end", v),
          this.once("close", g);
      }
      _read(w) {}
      _write(w, O, Q) {
        this[E] === null ? (this[E] = w) : (this[E] = Lte(this[E], w));
        let j = this[E],
          H = j.length,
          q = 0;
        for (
          ;
          q < H &&
          !(H < 5 || (this[R] === -1 && (this[R] = t1(j, q)), H < 4 + this[R]));

        ) {
          const J = j[(q += 4)];
          if ((++q, this[_] === 0)) {
            if (this[y].length === 0)
              return Q(new Error("Received unexpected message from server"));
            const Z = this[y].shift();
            switch (J) {
              case 5:
                Z.cb(new Error("Agent responded with failure"));
                break;
              case 12: {
                if (Z.type !== 11)
                  return Q(
                    new Error("Agent responded with wrong message type"),
                  );
                _n.init(j, q);
                const z = _n.readUInt32BE();
                if (z === void 0)
                  return _n.clear(), Q(new Error("Malformed agent response"));
                const U = [];
                for (let G = 0; G < z; ++G) {
                  let L = _n.readString();
                  if (L === void 0)
                    return _n.clear(), Q(new Error("Malformed agent response"));
                  const k = _n.readString(!0);
                  if (k === void 0)
                    return _n.clear(), Q(new Error("Malformed agent response"));
                  (L = ol(L)),
                    !(L instanceof Error) &&
                      ((L.comment = L.comment || k), U.push(L));
                }
                (q = _n.pos()), _n.clear(), Z.cb(null, U);
                break;
              }
              case 14: {
                if (Z.type !== 13)
                  return Q(
                    new Error("Agent responded with wrong message type"),
                  );
                _n.init(j, q);
                let z = _n.readString();
                if (((q = _n.pos()), _n.clear(), z === void 0))
                  return Q(new Error("Malformed agent response"));
                if (
                  (_n.init(z, 0),
                  _n.readString(!0),
                  (z = _n.readString()),
                  _n.clear(),
                  z === void 0)
                )
                  return Q(new Error("Malformed OpenSSH signature format"));
                Z.cb(null, z);
                break;
              }
              default:
                return Q(
                  new Error("Agent responded with unsupported message type"),
                );
            }
          } else
            switch (J) {
              case 11: {
                const Z = new p(J);
                this[y].push(Z), this.emit("identities", Z);
                break;
              }
              case 13: {
                _n.init(j, q);
                let Z = _n.readString();
                const z = _n.readString(),
                  U = _n.readUInt32BE();
                if (((q = _n.pos()), _n.clear(), U === void 0)) {
                  const W = new p(J);
                  return this[y].push(W), this.failureReply(W);
                }
                if (((Z = ol(Z)), Z instanceof Error)) {
                  const W = new p(J);
                  return this[y].push(W), this.failureReply(W);
                }
                const G = { hash: void 0 };
                let L;
                Z.type === "ssh-rsa" &&
                  (U & 2
                    ? ((L = "rsa-sha2-256"), (G.hash = "sha256"))
                    : U & 4 && ((L = "rsa-sha2-512"), (G.hash = "sha512"))),
                  L === void 0 && (L = Z.type);
                const k = new p(J, L);
                this[y].push(k), this.emit("sign", k, Z, z, G);
                break;
              }
              default: {
                const Z = new p(J);
                this[y].push(Z), this.failureReply(Z);
              }
            }
          if (((this[R] = -1), q === H)) {
            this[E] = null;
            break;
          } else (this[E] = j = j.slice(q)), (H = j.length), (q = 0);
        }
        Q();
      }
      _destroy(w, O) {
        m(this), O();
      }
      _final(w) {
        m(this), w();
      }
      sign(w, O, Q, j) {
        if (this[_] !== 0)
          throw new Error("Client-only method called with server role");
        typeof Q == "function"
          ? ((j = Q), (Q = void 0))
          : (typeof Q != "object" || Q === null) && (Q = void 0);
        let H = 0;
        if (((w = ol(w)), w instanceof Error))
          throw new Error("Invalid public key argument");
        if (w.type === "ssh-rsa" && Q)
          switch (Q.hash) {
            case "sha256":
              H = 2;
              break;
            case "sha512":
              H = 4;
              break;
          }
        w = w.getPublicSSH();
        const q = 13,
          J = w.length,
          Z = O.length;
        let z = 0;
        const U = Buffer.allocUnsafe(4 + 1 + 4 + J + 4 + Z + 4);
        return (
          kr(U, U.length - 4, z),
          (U[(z += 4)] = q),
          kr(U, J, ++z),
          w.copy(U, (z += 4)),
          kr(U, Z, (z += J)),
          O.copy(U, (z += 4)),
          kr(U, H, (z += Z)),
          typeof j != "function" && (j = j0),
          this[y].push({ type: q, cb: j }),
          this.push(U)
        );
      }
      getIdentities(w) {
        if (this[_] !== 0)
          throw new Error("Client-only method called with server role");
        const O = 11;
        let Q = 0;
        const j = Buffer.allocUnsafe(4 + 1);
        return (
          kr(j, j.length - 4, Q),
          (j[(Q += 4)] = O),
          typeof w != "function" && (w = j0),
          this[y].push({ type: O, cb: w }),
          this.push(j)
        );
      }
      failureReply(w) {
        if (this[_] !== 1)
          throw new Error("Server-only method called with client role");
        if (!(w instanceof p)) throw new Error("Wrong request argument");
        if (w.hasResponded()) return !0;
        let O = 0;
        const Q = Buffer.allocUnsafe(4 + 1);
        return kr(Q, Q.length - 4, O), (Q[(O += 4)] = 5), h(this, w, Q);
      }
      getIdentitiesReply(w, O) {
        if (this[_] !== 1)
          throw new Error("Server-only method called with client role");
        if (!(w instanceof p)) throw new Error("Wrong request argument");
        if (w.hasResponded()) return !0;
        if (w.getType() !== 11) throw new Error("Invalid response to request");
        if (!Array.isArray(O))
          throw new Error("Keys argument must be an array");
        let Q = 4;
        const j = [];
        for (let J = 0; J < O.length; ++J) {
          const Z = O[J];
          if (typeof Z != "object" || Z === null)
            throw new Error(`Invalid key entry: ${Z}`);
          let z, U;
          if (jA(Z)) z = Z;
          else if (jA(Z.pubKey)) z = Z.pubKey;
          else if (
            typeof Z.pubKey != "object" ||
            Z.pubKey === null ||
            (({ pubKey: z, comment: U } = Z.pubKey),
            (z = ol(z)),
            z instanceof Error)
          )
            continue;
          (U = z.comment || U),
            (z = z.getPublicSSH()),
            (Q += 4 + z.length),
            U && typeof U == "string"
              ? (U = Buffer.from(U))
              : Buffer.isBuffer(U) || (U = Bte),
            (Q += 4 + U.length),
            j.push({ pubKey: z, comment: U });
        }
        let H = 0;
        const q = Buffer.allocUnsafe(4 + 1 + Q);
        kr(q, q.length - 4, H),
          (q[(H += 4)] = 12),
          kr(q, j.length, ++H),
          (H += 4);
        for (let J = 0; J < j.length; ++J) {
          const { pubKey: Z, comment: z } = j[J];
          kr(q, Z.length, H),
            Z.copy(q, (H += 4)),
            kr(q, z.length, (H += Z.length)),
            (H += 4),
            z.length && (z.copy(q, H), (H += z.length));
        }
        return h(this, w, q);
      }
      signReply(w, O) {
        if (this[_] !== 1)
          throw new Error("Server-only method called with client role");
        if (!(w instanceof p)) throw new Error("Wrong request argument");
        if (w.hasResponded()) return !0;
        if (w.getType() !== 13) throw new Error("Invalid response to request");
        if (!Buffer.isBuffer(O))
          throw new Error("Signature argument must be a Buffer");
        if (O.length === 0)
          throw new Error("Signature argument must be non-empty");
        let Q = 0;
        const j = w.getContext(),
          H = Buffer.byteLength(j),
          q = Buffer.allocUnsafe(4 + 1 + 4 + 4 + H + 4 + O.length);
        return (
          kr(q, q.length - 4, Q),
          (q[(Q += 4)] = 14),
          kr(q, 4 + H + 4 + O.length, ++Q),
          kr(q, H, (Q += 4)),
          q.utf8Write(j, (Q += 4), H),
          kr(q, O.length, (Q += H)),
          O.copy(q, (Q += 4)),
          h(this, w, q)
        );
      }
    };
  })(),
  Xm = Symbol("Agent"),
  si = Symbol("Agent Keys"),
  Ji = Symbol("Agent Keys Index"),
  vo = Symbol("Agent Init Callbacks");
let Fte = class {
  constructor(t) {
    if (typeof t == "string") t = mk(t);
    else if (!gk(t)) throw new Error("Invalid agent argument");
    (this[Xm] = t), (this[si] = null), (this[Ji] = -1), (this[vo] = null);
  }
  init(t) {
    if ((typeof t != "function" && (t = j0), this[si] === null))
      if (this[vo] === null) {
        this[vo] = [t];
        const n = (...r) => {
          process.nextTick(() => {
            const i = this[vo];
            this[vo] = null;
            for (const a of i) a(...r);
          });
        };
        this[Xm].getIdentities(
          kl((r, i) => {
            if (r) return n(r);
            if (!Array.isArray(i))
              return n(
                new Error("Agent implementation failed to provide keys"),
              );
            const a = [];
            for (let s of i) (s = ol(s)), !(s instanceof Error) && a.push(s);
            (this[si] = a), (this[Ji] = -1), n();
          }),
        );
      } else this[vo].push(t);
    else process.nextTick(t);
  }
  nextKey() {
    return this[si] === null || ++this[Ji] >= this[si].length
      ? !1
      : this[si][this[Ji]];
  }
  currentKey() {
    return this[si] === null || this[Ji] >= this[si].length
      ? null
      : this[si][this[Ji]];
  }
  pos() {
    return this[si] === null || this[Ji] >= this[si].length ? -1 : this[Ji];
  }
  reset() {
    this[Ji] = -1;
  }
  sign(...t) {
    this[Xm].sign(...t);
  }
};
function gk(e) {
  return e instanceof n1;
}
var vk = {
    AgentContext: Fte,
    AgentProtocol: M0,
    BaseAgent: n1,
    createAgent: mk,
    CygwinAgent: hk,
    isAgent: gk,
    OpenSSHAgent: Jp,
    PageantAgent: pk,
  },
  yk = {};
const { kMaxLength: jte } = ks,
  {
    createInflate: Mte,
    constants: {
      DEFLATE: Hte,
      INFLATE: qte,
      Z_DEFAULT_CHUNK: Gte,
      Z_DEFAULT_COMPRESSION: Qte,
      Z_DEFAULT_MEMLEVEL: Wte,
      Z_DEFAULT_STRATEGY: zte,
      Z_DEFAULT_WINDOWBITS: Kte,
      Z_PARTIAL_FLUSH: Vte,
    },
  } = mc,
  Yte = Mte()._handle.constructor;
function Xte() {
  throw new Error("Should not get here");
}
function Jte(e, t, n) {
  const r = this._owner,
    i = new Error(e);
  (i.errno = t), (i.code = n), (r._err = i);
}
function r1(e) {
  e._handle && (e._handle.close(), (e._handle = null));
}
class bk {
  constructor(t) {
    const n = Kte,
      r = Qte,
      i = Wte,
      a = zte,
      s = void 0;
    (this._err = void 0),
      (this._writeState = new Uint32Array(2)),
      (this._chunkSize = Gte),
      (this._maxOutputLength = jte),
      (this._outBuffer = Buffer.allocUnsafe(this._chunkSize)),
      (this._outOffset = 0),
      (this._handle = new Yte(t)),
      (this._handle._owner = this),
      (this._handle.onerror = Jte),
      this._handle.init(n, r, i, a, this._writeState, Xte, s);
  }
  writeSync(t, n) {
    const r = this._handle;
    if (!r) throw new Error("Invalid Zlib instance");
    let i = t.length,
      a = this._chunkSize - this._outOffset,
      s = 0,
      o,
      c,
      l,
      f = 0;
    const u = this._writeState;
    let d = this._outBuffer,
      p = this._outOffset;
    const h = this._chunkSize;
    for (;;) {
      if ((r.writeSync(Vte, t, s, i, d, p, a), this._err)) throw this._err;
      (o = u[0]), (c = u[1]);
      const g = i - c,
        v = a - o;
      if (v > 0) {
        const y = p === 0 && v === d.length ? d : d.slice(p, p + v);
        if (
          ((p += v),
          l ? (l.push === void 0 ? (l = [l, y]) : l.push(y)) : (l = y),
          (f += y.byteLength),
          f > this._maxOutputLength)
        )
          throw (
            (r1(this),
            new Error(
              `Output length exceeded maximum of ${this._maxOutputLength}`,
            ))
          );
      } else if (v !== 0) throw new Error("have should not go down");
      if (
        ((o === 0 || p >= h) && ((a = h), (p = 0), (d = Buffer.allocUnsafe(h))),
        o === 0)
      )
        (s += g), (i = c);
      else break;
    }
    if (
      ((this._outBuffer = d),
      (this._outOffset = p),
      f === 0 && (l = Buffer.alloc(0)),
      n)
    )
      return (l.totalLen = f), l;
    if (l.push === void 0) return l;
    const m = Buffer.allocUnsafe(f);
    for (let g = 0, v = 0; g < l.length; ++g) {
      const y = l[g];
      m.set(y, v), (v += y.length);
    }
    return m;
  }
}
let Zte = class {
    constructor(t) {
      (this.allocStart = 0),
        (this.allocStartKEX = 0),
        (this._protocol = t),
        (this._zlib = new bk(Hte));
    }
    cleanup() {
      this._zlib && r1(this._zlib);
    }
    alloc(t, n) {
      return Buffer.allocUnsafe(t);
    }
    finalize(t, n) {
      if (this._protocol._kexinit === void 0 || n) {
        const r = this._zlib.writeSync(t, !0),
          i = this._protocol._cipher.allocPacket(r.totalLen);
        if (r.push === void 0) i.set(r, 5);
        else
          for (let a = 0, s = 5; a < r.length; ++a) {
            const o = r[a];
            i.set(o, s), (s += o.length);
          }
        return i;
      }
      return t;
    }
  },
  ene = class {
    constructor(t) {
      (this.allocStart = 5), (this.allocStartKEX = 5), (this._protocol = t);
    }
    cleanup() {}
    alloc(t, n) {
      return this._protocol._kexinit === void 0 || n
        ? this._protocol._cipher.allocPacket(t)
        : Buffer.allocUnsafe(t);
    }
    finalize(t, n) {
      return t;
    }
  },
  tne = class {
    constructor() {
      this._zlib = new bk(qte);
    }
    cleanup() {
      this._zlib && r1(this._zlib);
    }
    read(t) {
      return this._zlib.writeSync(t, !1);
    }
  },
  nne = class {
    cleanup() {}
    read(t) {
      return t;
    }
  };
var _k = {
  PacketReader: nne,
  PacketWriter: ene,
  ZlibPacketReader: tne,
  ZlibPacketWriter: Zte,
};
const {
    bufferSlice: Jm,
    bufferParser: de,
    doFatalError: sn,
    sigSSHToASN1: HA,
    writeUInt32BE: qA,
  } = Ki(),
  {
    CHANNEL_OPEN_FAILURE: rne,
    COMPAT: ine,
    MESSAGE: un,
    TERMINAL_MODE: Ek,
  } = es(),
  { parseKey: ane } = to,
  sne = Array.from(Object.entries(Ek)).reduce(
    (e, [t, n]) => ({ ...e, [t]: n }),
    {},
  );
var one = {
    [un.DISCONNECT]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readString(!0),
        i = de.readString();
      if ((de.clear(), i === void 0))
        return sn(e, "Inbound: Malformed DISCONNECT packet");
      e._debug && e._debug(`Inbound: Received DISCONNECT (${n}, "${r}")`);
      const a = e._handlers.DISCONNECT;
      a && a(e, n, r);
    },
    [un.IGNORE]: (e, t) => {
      e._debug && e._debug("Inbound: Received IGNORE");
    },
    [un.UNIMPLEMENTED]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed UNIMPLEMENTED packet");
      e._debug && e._debug(`Inbound: Received UNIMPLEMENTED (seqno ${n})`);
    },
    [un.DEBUG]: (e, t) => {
      de.init(t, 1);
      const n = de.readBool(),
        r = de.readString(!0),
        i = de.readString();
      if ((de.clear(), i === void 0))
        return sn(e, "Inbound: Malformed DEBUG packet");
      e._debug && e._debug("Inbound: Received DEBUG");
      const a = e._handlers.DEBUG;
      a && a(e, n, r);
    },
    [un.SERVICE_REQUEST]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0);
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed SERVICE_REQUEST packet");
      e._debug && e._debug(`Inbound: Received SERVICE_REQUEST (${n})`);
      const r = e._handlers.SERVICE_REQUEST;
      r && r(e, n);
    },
    [un.SERVICE_ACCEPT]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0);
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed SERVICE_ACCEPT packet");
      e._debug && e._debug(`Inbound: Received SERVICE_ACCEPT (${n})`);
      const r = e._handlers.SERVICE_ACCEPT;
      r && r(e, n);
    },
    [un.EXT_INFO]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      let r;
      if (n !== void 0) {
        r = [];
        for (let a = 0; a < n; ++a) {
          const s = de.readString(!0),
            o = de.readString();
          if (o !== void 0)
            switch (s) {
              case "server-sig-algs": {
                const c = o.latin1Slice(0, o.length).split(",");
                r.push({ name: s, algs: c });
                continue;
              }
              default:
                continue;
            }
          r = void 0;
          break;
        }
      }
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed EXT_INFO packet");
      e._debug && e._debug("Inbound: Received EXT_INFO");
      const i = e._handlers.EXT_INFO;
      i && i(e, r);
    },
    [un.USERAUTH_REQUEST]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0),
        r = de.readString(!0),
        i = de.readString(!0);
      let a, s;
      switch (i) {
        case "none":
          a = null;
          break;
        case "password": {
          const c = de.readBool();
          if (c !== void 0 && ((a = de.readString(!0)), a !== void 0 && c)) {
            const l = de.readString(!0);
            l !== void 0
              ? (a = { oldPassword: a, newPassword: l })
              : (a = void 0);
          }
          break;
        }
        case "publickey": {
          const c = de.readBool();
          if (c !== void 0) {
            const l = de.readString(!0);
            let f = l;
            const u = de.readString();
            let d;
            switch (l) {
              case "rsa-sha2-256":
                (f = "ssh-rsa"), (d = "sha256");
                break;
              case "rsa-sha2-512":
                (f = "ssh-rsa"), (d = "sha512");
                break;
            }
            if (c) {
              const p = de.pos();
              let h = de.readString();
              if (
                h !== void 0 &&
                (h.length > 4 + l.length + 4 &&
                  h.utf8Slice(4, 4 + l.length) === l &&
                  (h = Jm(h, 4 + l.length + 4)),
                (h = HA(h, f)),
                h)
              ) {
                const m = e._kex.sessionID,
                  g = Buffer.allocUnsafe(4 + m.length + p);
                qA(g, m.length, 0),
                  g.set(m, 4),
                  g.set(
                    new Uint8Array(t.buffer, t.byteOffset, p),
                    4 + m.length,
                  ),
                  (a = {
                    keyAlgo: f,
                    key: u,
                    signature: h,
                    blob: g,
                    hashAlgo: d,
                  });
              }
            } else
              (a = { keyAlgo: f, key: u, hashAlgo: d }),
                (s = "publickey -- check");
          }
          break;
        }
        case "hostbased": {
          const c = de.readString(!0);
          let l = c;
          const f = de.readString(),
            u = de.readString(!0),
            d = de.readString(!0);
          let p;
          switch (c) {
            case "rsa-sha2-256":
              (l = "ssh-rsa"), (p = "sha256");
              break;
            case "rsa-sha2-512":
              (l = "ssh-rsa"), (p = "sha512");
              break;
          }
          const h = de.pos();
          let m = de.readString();
          if (
            m !== void 0 &&
            (m.length > 4 + c.length + 4 &&
              m.utf8Slice(4, 4 + c.length) === c &&
              (m = Jm(m, 4 + c.length + 4)),
            (m = HA(m, l)),
            m !== void 0)
          ) {
            const g = e._kex.sessionID,
              v = Buffer.allocUnsafe(4 + g.length + h);
            qA(v, g.length, 0),
              v.set(g, 4),
              v.set(new Uint8Array(t.buffer, t.byteOffset, h), 4 + g.length),
              (a = {
                keyAlgo: l,
                key: f,
                signature: m,
                blob: v,
                localHostname: u,
                localUsername: d,
                hashAlgo: p,
              });
          }
          break;
        }
        case "keyboard-interactive":
          de.skipString(), (a = de.readList());
          break;
        default:
          i !== void 0 && (a = de.readRaw());
      }
      if ((de.clear(), a === void 0))
        return sn(e, "Inbound: Malformed USERAUTH_REQUEST packet");
      s === void 0 && (s = i),
        e._authsQueue.push(i),
        e._debug && e._debug(`Inbound: Received USERAUTH_REQUEST (${s})`);
      const o = e._handlers.USERAUTH_REQUEST;
      o && o(e, n, r, i, a);
    },
    [un.USERAUTH_FAILURE]: (e, t) => {
      de.init(t, 1);
      const n = de.readList(),
        r = de.readBool();
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed USERAUTH_FAILURE packet");
      e._debug && e._debug(`Inbound: Received USERAUTH_FAILURE (${n})`),
        e._authsQueue.shift();
      const i = e._handlers.USERAUTH_FAILURE;
      i && i(e, n, r);
    },
    [un.USERAUTH_SUCCESS]: (e, t) => {
      e._debug && e._debug("Inbound: Received USERAUTH_SUCCESS"),
        e._authsQueue.shift();
      const n = e._handlers.USERAUTH_SUCCESS;
      n && n(e);
    },
    [un.USERAUTH_BANNER]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0),
        r = de.readString();
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed USERAUTH_BANNER packet");
      e._debug && e._debug("Inbound: Received USERAUTH_BANNER");
      const i = e._handlers.USERAUTH_BANNER;
      i && i(e, n);
    },
    60: (e, t) => {
      if (!e._authsQueue.length) {
        e._debug && e._debug("Inbound: Received payload type 60 without auth");
        return;
      }
      switch (e._authsQueue[0]) {
        case "password": {
          de.init(t, 1);
          const n = de.readString(!0),
            r = de.readString();
          if ((de.clear(), r === void 0))
            return sn(e, "Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet");
          e._debug && e._debug("Inbound: Received USERAUTH_PASSWD_CHANGEREQ");
          const i = e._handlers.USERAUTH_PASSWD_CHANGEREQ;
          i && i(e, n);
          break;
        }
        case "publickey": {
          de.init(t, 1);
          const n = de.readString(!0),
            r = de.readString();
          if ((de.clear(), r === void 0))
            return sn(e, "Inbound: Malformed USERAUTH_PK_OK packet");
          e._debug && e._debug("Inbound: Received USERAUTH_PK_OK"),
            e._authsQueue.shift();
          const i = e._handlers.USERAUTH_PK_OK;
          i && i(e, n, r);
          break;
        }
        case "keyboard-interactive": {
          de.init(t, 1);
          const n = de.readString(!0),
            r = de.readString(!0);
          de.readString();
          const i = de.readUInt32BE();
          let a;
          if (i !== void 0) {
            a = new Array(i);
            let o;
            for (o = 0; o < i; ++o) {
              const c = de.readString(!0),
                l = de.readBool();
              if (l === void 0) break;
              a[o] = { prompt: c, echo: l };
            }
            o !== i && (a = void 0);
          }
          if ((de.clear(), a === void 0))
            return sn(e, "Inbound: Malformed USERAUTH_INFO_REQUEST packet");
          e._debug && e._debug("Inbound: Received USERAUTH_INFO_REQUEST");
          const s = e._handlers.USERAUTH_INFO_REQUEST;
          s && s(e, n, r, a);
          break;
        }
        default:
          e._debug && e._debug("Inbound: Received unexpected payload type 60");
      }
    },
    61: (e, t) => {
      if (!e._authsQueue.length) {
        e._debug && e._debug("Inbound: Received payload type 61 without auth");
        return;
      }
      if (e._authsQueue[0] !== "keyboard-interactive")
        return sn(e, "Inbound: Received unexpected payload type 61");
      de.init(t, 1);
      const n = de.readUInt32BE();
      let r;
      if (n !== void 0) {
        r = new Array(n);
        let a;
        for (a = 0; a < n; ++a) {
          const s = de.readString(!0);
          if (s === void 0) break;
          r[a] = s;
        }
        a !== n && (r = void 0);
      }
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed USERAUTH_INFO_RESPONSE packet");
      e._debug && e._debug("Inbound: Received USERAUTH_INFO_RESPONSE");
      const i = e._handlers.USERAUTH_INFO_RESPONSE;
      i && i(e, r);
    },
    [un.GLOBAL_REQUEST]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0),
        r = de.readBool();
      let i;
      if (r !== void 0)
        switch (n) {
          case "tcpip-forward":
          case "cancel-tcpip-forward": {
            const s = de.readString(!0),
              o = de.readUInt32BE();
            o !== void 0 && (i = { bindAddr: s, bindPort: o });
            break;
          }
          case "streamlocal-forward@openssh.com":
          case "cancel-streamlocal-forward@openssh.com": {
            const s = de.readString(!0);
            s !== void 0 && (i = { socketPath: s });
            break;
          }
          case "no-more-sessions@openssh.com":
            i = null;
            break;
          case "hostkeys-00@openssh.com": {
            for (i = []; de.avail() > 0; ) {
              const s = de.readString();
              if (s === void 0) {
                i = void 0;
                break;
              }
              const o = ane(s);
              o instanceof Error || i.push(o);
            }
            break;
          }
          default:
            i = de.readRaw();
        }
      if ((de.clear(), i === void 0))
        return sn(e, "Inbound: Malformed GLOBAL_REQUEST packet");
      e._debug && e._debug(`Inbound: GLOBAL_REQUEST (${n})`);
      const a = e._handlers.GLOBAL_REQUEST;
      a ? a(e, n, r, i) : e.requestFailure();
    },
    [un.REQUEST_SUCCESS]: (e, t) => {
      const n = t.length > 1 ? Jm(t, 1) : null;
      e._debug && e._debug("Inbound: REQUEST_SUCCESS");
      const r = e._handlers.REQUEST_SUCCESS;
      r && r(e, n);
    },
    [un.REQUEST_FAILURE]: (e, t) => {
      e._debug && e._debug("Inbound: Received REQUEST_FAILURE");
      const n = e._handlers.REQUEST_FAILURE;
      n && n(e);
    },
    [un.CHANNEL_OPEN]: (e, t) => {
      de.init(t, 1);
      const n = de.readString(!0),
        r = de.readUInt32BE(),
        i = de.readUInt32BE(),
        a = de.readUInt32BE();
      let s;
      switch (n) {
        case "forwarded-tcpip":
        case "direct-tcpip": {
          const c = de.readString(!0),
            l = de.readUInt32BE(),
            f = de.readString(!0),
            u = de.readUInt32BE();
          u !== void 0 &&
            (s = {
              type: n,
              sender: r,
              window: i,
              packetSize: a,
              data: { destIP: c, destPort: l, srcIP: f, srcPort: u },
            });
          break;
        }
        case "forwarded-streamlocal@openssh.com":
        case "direct-streamlocal@openssh.com": {
          const c = de.readString(!0);
          c !== void 0 &&
            (s = {
              type: n,
              sender: r,
              window: i,
              packetSize: a,
              data: { socketPath: c },
            });
          break;
        }
        case "x11": {
          const c = de.readString(!0),
            l = de.readUInt32BE();
          l !== void 0 &&
            (s = {
              type: n,
              sender: r,
              window: i,
              packetSize: a,
              data: { srcIP: c, srcPort: l },
            });
          break;
        }
        default:
          s = { type: n, sender: r, window: i, packetSize: a, data: {} };
      }
      if ((de.clear(), s === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_OPEN packet");
      e._debug && e._debug(`Inbound: CHANNEL_OPEN (s:${r}, ${n})`);
      const o = e._handlers.CHANNEL_OPEN;
      o
        ? o(e, s)
        : e.channelOpenFail(s.sender, rne.ADMINISTRATIVELY_PROHIBITED, "", "");
    },
    [un.CHANNEL_OPEN_CONFIRMATION]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readUInt32BE(),
        i = de.readUInt32BE(),
        a = de.readUInt32BE(),
        s = de.avail() ? de.readRaw() : void 0;
      if ((de.clear(), a === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet");
      e._debug &&
        e._debug(`Inbound: CHANNEL_OPEN_CONFIRMATION (r:${n}, s:${r})`);
      const o = e._handlers.CHANNEL_OPEN_CONFIRMATION;
      o && o(e, { recipient: n, sender: r, window: i, packetSize: a, data: s });
    },
    [un.CHANNEL_OPEN_FAILURE]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readUInt32BE(),
        i = de.readString(!0),
        a = de.readString();
      if ((de.clear(), a === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_OPEN_FAILURE packet");
      e._debug && e._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${n})`);
      const s = e._handlers.CHANNEL_OPEN_FAILURE;
      s && s(e, n, r, i);
    },
    [un.CHANNEL_WINDOW_ADJUST]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readUInt32BE();
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_WINDOW_ADJUST packet");
      e._debug && e._debug(`Inbound: CHANNEL_WINDOW_ADJUST (r:${n}, ${r})`);
      const i = e._handlers.CHANNEL_WINDOW_ADJUST;
      i && i(e, n, r);
    },
    [un.CHANNEL_DATA]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readString();
      if ((de.clear(), r === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_DATA packet");
      e._debug && e._debug(`Inbound: CHANNEL_DATA (r:${n}, ${r.length})`);
      const i = e._handlers.CHANNEL_DATA;
      i && i(e, n, r);
    },
    [un.CHANNEL_EXTENDED_DATA]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readUInt32BE(),
        i = de.readString();
      if ((de.clear(), i === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_EXTENDED_DATA packet");
      e._debug &&
        e._debug(`Inbound: CHANNEL_EXTENDED_DATA (r:${n}, ${i.length})`);
      const a = e._handlers.CHANNEL_EXTENDED_DATA;
      a && a(e, n, i, r);
    },
    [un.CHANNEL_EOF]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_EOF packet");
      e._debug && e._debug(`Inbound: CHANNEL_EOF (r:${n})`);
      const r = e._handlers.CHANNEL_EOF;
      r && r(e, n);
    },
    [un.CHANNEL_CLOSE]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_CLOSE packet");
      e._debug && e._debug(`Inbound: CHANNEL_CLOSE (r:${n})`);
      const r = e._handlers.CHANNEL_CLOSE;
      r && r(e, n);
    },
    [un.CHANNEL_REQUEST]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE(),
        r = de.readString(!0),
        i = de.readBool();
      let a;
      if (i !== void 0)
        switch (r) {
          case "exit-status":
            (a = de.readUInt32BE()),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${a})`);
            break;
          case "exit-signal": {
            let o, c;
            if (e._compatFlags & ine.OLD_EXIT) {
              const f = de.readUInt32BE();
              switch (f) {
                case 1:
                  o = "HUP";
                  break;
                case 2:
                  o = "INT";
                  break;
                case 3:
                  o = "QUIT";
                  break;
                case 6:
                  o = "ABRT";
                  break;
                case 9:
                  o = "KILL";
                  break;
                case 14:
                  o = "ALRM";
                  break;
                case 15:
                  o = "TERM";
                  break;
                default:
                  f !== void 0 && (o = `UNKNOWN (${f})`);
              }
              c = !1;
            } else
              (o = de.readString(!0)),
                (c = de.readBool()),
                c === void 0 && (o = void 0);
            const l = de.readString(!0);
            de.skipString() !== void 0 &&
              (a = { signal: o, coreDumped: c, errorMessage: l }),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${o})`);
            break;
          }
          case "pty-req": {
            const o = de.readString(!0),
              c = de.readUInt32BE(),
              l = de.readUInt32BE(),
              f = de.readUInt32BE(),
              u = de.readUInt32BE(),
              d = de.readString();
            if (d !== void 0) {
              de.init(d, 1);
              let p = {};
              for (; de.avail(); ) {
                const h = de.readByte();
                if (h === Ek.TTY_OP_END) break;
                const m = sne[h],
                  g = de.readUInt32BE();
                if (h === void 0 || m === void 0 || g === void 0) {
                  p = void 0;
                  break;
                }
                p[m] = g;
              }
              p !== void 0 &&
                (a = {
                  term: o,
                  cols: c,
                  rows: l,
                  width: f,
                  height: u,
                  modes: p,
                });
            }
            e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
            break;
          }
          case "window-change": {
            const o = de.readUInt32BE(),
              c = de.readUInt32BE(),
              l = de.readUInt32BE(),
              f = de.readUInt32BE();
            f !== void 0 && (a = { cols: o, rows: c, width: l, height: f }),
              e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
            break;
          }
          case "x11-req": {
            const o = de.readBool(),
              c = de.readString(!0),
              l = de.readString(),
              f = de.readUInt32BE();
            f !== void 0 &&
              (a = { single: o, protocol: c, cookie: l, screen: f }),
              e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
            break;
          }
          case "env": {
            const o = de.readString(!0),
              c = de.readString(!0);
            c !== void 0 && (a = { name: o, value: c }),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${o}=${c})`);
            break;
          }
          case "shell":
            (a = null),
              e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
            break;
          case "exec":
            (a = de.readString(!0)),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${a})`);
            break;
          case "subsystem":
            (a = de.readString(!0)),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${a})`);
            break;
          case "signal":
            (a = de.readString(!0)),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${a})`);
            break;
          case "xon-xoff":
            (a = de.readBool()),
              e._debug &&
                e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r}: ${a})`);
            break;
          case "auth-agent-req@openssh.com":
            (a = null),
              e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
            break;
          default:
            (a = de.avail() ? de.readRaw() : null),
              e._debug && e._debug(`Inbound: CHANNEL_REQUEST (r:${n}, ${r})`);
        }
      if ((de.clear(), a === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_REQUEST packet");
      const s = e._handlers.CHANNEL_REQUEST;
      s && s(e, n, r, i, a);
    },
    [un.CHANNEL_SUCCESS]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_SUCCESS packet");
      e._debug && e._debug(`Inbound: CHANNEL_SUCCESS (r:${n})`);
      const r = e._handlers.CHANNEL_SUCCESS;
      r && r(e, n);
    },
    [un.CHANNEL_FAILURE]: (e, t) => {
      de.init(t, 1);
      const n = de.readUInt32BE();
      if ((de.clear(), n === void 0))
        return sn(e, "Inbound: Malformed CHANNEL_FAILURE packet");
      e._debug && e._debug(`Inbound: CHANNEL_FAILURE (r:${n})`);
      const r = e._handlers.CHANNEL_FAILURE;
      r && r(e, n);
    },
  },
  Zm,
  GA;
function wk() {
  if (GA) return Zm;
  GA = 1;
  const e = new Array(256);
  return (
    [i1().HANDLERS, one].forEach((t) => {
      for (let [n, r] of Object.entries(t))
        (n = +n), isFinite(n) && n >= 0 && n < e.length && (e[n] = r);
    }),
    (Zm = e),
    Zm
  );
}
var eg, QA;
function i1() {
  if (QA) return eg;
  QA = 1;
  const {
      createDiffieHellman: e,
      createDiffieHellmanGroup: t,
      createECDH: n,
      createHash: r,
      createPublicKey: i,
      diffieHellman: a,
      generateKeyPairSync: s,
      randomFillSync: o,
    } = pr,
    { Ber: c } = Yp,
    {
      COMPAT: l,
      curve25519Supported: f,
      DEFAULT_KEX: u,
      DEFAULT_SERVER_HOST_KEY: d,
      DEFAULT_CIPHER: p,
      DEFAULT_MAC: h,
      DEFAULT_COMPRESSION: m,
      DISCONNECT_REASON: g,
      MESSAGE: v,
    } = es(),
    { CIPHER_INFO: y, createCipher: _, createDecipher: E, MAC_INFO: R } = eo(),
    { parseDERKey: A } = to,
    {
      bufferFill: I,
      bufferParser: S,
      convertSignature: w,
      doFatalError: O,
      FastBuffer: Q,
      sigSSHToASN1: j,
      writeUInt32BE: H,
    } = Ki(),
    {
      PacketReader: q,
      PacketWriter: J,
      ZlibPacketReader: Z,
      ZlibPacketWriter: z,
    } = _k;
  let U;
  const G = 2048,
    L = 8192,
    k = Buffer.alloc(0);
  function W(ne) {
    let Y;
    if (ne._compatFlags & l.BAD_DHGEX) {
      const M = ne._offer.lists.kex;
      let oe = M.array,
        Ee = !1;
      for (let le = 0; le < oe.length; ++le)
        oe[le].includes("group-exchange") &&
          (Ee || ((Ee = !0), (oe = oe.slice())), oe.splice(le--, 1));
      if (Ee) {
        let le = 17 + ne._offer.totalSize + 1 + 4;
        const te = Buffer.from(oe.join(","));
        le -= M.buffer.length - te.length;
        const ie = ne._offer.lists.all,
          X = new Uint8Array(
            ie.buffer,
            ie.byteOffset + 4 + M.buffer.length,
            ie.length - (4 + M.buffer.length),
          );
        (Y = Buffer.allocUnsafe(le)),
          H(Y, te.length, 17),
          Y.set(te, 17 + 4),
          Y.set(X, 17 + 4 + te.length);
      }
    }
    Y === void 0 &&
      ((Y = Buffer.allocUnsafe(1 + 16 + ne._offer.totalSize + 1 + 4)),
      ne._offer.copyAllTo(Y, 17)),
      ne._debug && ne._debug("Outbound: Sending KEXINIT"),
      (Y[0] = v.KEXINIT),
      o(Y, 1, 16),
      I(Y, 0, Y.length - 5),
      (ne._kexinit = Y),
      (ne._packetRW.write.allocStart = 0);
    {
      const M = ne._packetRW.write.allocStartKEX,
        oe = ne._packetRW.write.alloc(Y.length, !0);
      oe.set(Y, M), ne._cipher.encrypt(ne._packetRW.write.finalize(oe, !0));
    }
  }
  function F(ne, Y) {
    const M = {
      kex: void 0,
      serverHostKey: void 0,
      cs: { cipher: void 0, mac: void 0, compress: void 0, lang: void 0 },
      sc: { cipher: void 0, mac: void 0, compress: void 0, lang: void 0 },
    };
    if (
      (S.init(Y, 17),
      (M.kex = S.readList()) === void 0 ||
        (M.serverHostKey = S.readList()) === void 0 ||
        (M.cs.cipher = S.readList()) === void 0 ||
        (M.sc.cipher = S.readList()) === void 0 ||
        (M.cs.mac = S.readList()) === void 0 ||
        (M.sc.mac = S.readList()) === void 0 ||
        (M.cs.compress = S.readList()) === void 0 ||
        (M.sc.compress = S.readList()) === void 0 ||
        (M.cs.lang = S.readList()) === void 0 ||
        (M.sc.lang = S.readList()) === void 0)
    )
      return (
        S.clear(),
        O(ne, "Received malformed KEXINIT", "handshake", g.KEY_EXCHANGE_FAILED)
      );
    const oe = S.pos(),
      Ee = oe < Y.length && Y[oe] === 1;
    S.clear();
    const le = ne._offer,
      te = M;
    let ie = le.lists.kex.array;
    if (ne._compatFlags & l.BAD_DHGEX) {
      let dt = !1;
      for (let ht = 0; ht < ie.length; ++ht)
        ie[ht].indexOf("group-exchange") !== -1 &&
          (dt || ((dt = !0), (ie = ie.slice())), ie.splice(ht--, 1));
    }
    let X, he, be;
    const ye = ne._debug;
    ye && ye("Inbound: Handshake in progress"),
      ye && ye(`Handshake: (local) KEX method: ${ie}`),
      ye && ye(`Handshake: (remote) KEX method: ${te.kex}`);
    let Qe;
    for (
      ne._server
        ? ((he = ie), (X = te.kex), (Qe = X.indexOf("ext-info-c") !== -1))
        : ((he = te.kex), (X = ie), (Qe = he.indexOf("ext-info-s") !== -1)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching key exchange algorithm"),
        O(
          ne,
          "Handshake failed: no matching key exchange algorithm",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.kex = X[be]),
      ye && ye(`Handshake: KEX algorithm: ${X[be]}`),
      Ee &&
        (!te.kex.length || X[be] !== te.kex[0]) &&
        (ne._skipNextInboundPacket = !0);
    const lt = le.lists.serverHostKey.array;
    for (
      ye && ye(`Handshake: (local) Host key format: ${lt}`),
        ye && ye(`Handshake: (remote) Host key format: ${te.serverHostKey}`),
        ne._server
          ? ((he = lt), (X = te.serverHostKey))
          : ((he = te.serverHostKey), (X = lt)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching host key format"),
        O(
          ne,
          "Handshake failed: no matching host key format",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.serverHostKey = X[be]), ye && ye(`Handshake: Host key format: ${X[be]}`);
    const Lt = le.lists.cs.cipher.array;
    for (
      ye && ye(`Handshake: (local) C->S cipher: ${Lt}`),
        ye && ye(`Handshake: (remote) C->S cipher: ${te.cs.cipher}`),
        ne._server
          ? ((he = Lt), (X = te.cs.cipher))
          : ((he = te.cs.cipher), (X = Lt)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching C->S cipher"),
        O(
          ne,
          "Handshake failed: no matching C->S cipher",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.cs.cipher = X[be]), ye && ye(`Handshake: C->S Cipher: ${X[be]}`);
    const We = le.lists.sc.cipher.array;
    for (
      ye && ye(`Handshake: (local) S->C cipher: ${We}`),
        ye && ye(`Handshake: (remote) S->C cipher: ${te.sc.cipher}`),
        ne._server
          ? ((he = We), (X = te.sc.cipher))
          : ((he = te.sc.cipher), (X = We)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching S->C cipher"),
        O(
          ne,
          "Handshake failed: no matching S->C cipher",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.sc.cipher = X[be]), ye && ye(`Handshake: S->C cipher: ${X[be]}`);
    const bt = le.lists.cs.mac.array;
    if (
      (ye && ye(`Handshake: (local) C->S MAC: ${bt}`),
      ye && ye(`Handshake: (remote) C->S MAC: ${te.cs.mac}`),
      y[M.cs.cipher].authLen > 0)
    )
      (M.cs.mac = ""), ye && ye("Handshake: C->S MAC: <implicit>");
    else {
      for (
        ne._server
          ? ((he = bt), (X = te.cs.mac))
          : ((he = te.cs.mac), (X = bt)),
          be = 0;
        be < X.length && he.indexOf(X[be]) === -1;
        ++be
      );
      if (be === X.length)
        return (
          ye && ye("Handshake: No matching C->S MAC"),
          O(
            ne,
            "Handshake failed: no matching C->S MAC",
            "handshake",
            g.KEY_EXCHANGE_FAILED,
          )
        );
      (M.cs.mac = X[be]), ye && ye(`Handshake: C->S MAC: ${X[be]}`);
    }
    const wt = le.lists.sc.mac.array;
    if (
      (ye && ye(`Handshake: (local) S->C MAC: ${wt}`),
      ye && ye(`Handshake: (remote) S->C MAC: ${te.sc.mac}`),
      y[M.sc.cipher].authLen > 0)
    )
      (M.sc.mac = ""), ye && ye("Handshake: S->C MAC: <implicit>");
    else {
      for (
        ne._server
          ? ((he = wt), (X = te.sc.mac))
          : ((he = te.sc.mac), (X = wt)),
          be = 0;
        be < X.length && he.indexOf(X[be]) === -1;
        ++be
      );
      if (be === X.length)
        return (
          ye && ye("Handshake: No matching S->C MAC"),
          O(
            ne,
            "Handshake failed: no matching S->C MAC",
            "handshake",
            g.KEY_EXCHANGE_FAILED,
          )
        );
      (M.sc.mac = X[be]), ye && ye(`Handshake: S->C MAC: ${X[be]}`);
    }
    const ct = le.lists.cs.compress.array;
    for (
      ye && ye(`Handshake: (local) C->S compression: ${ct}`),
        ye && ye(`Handshake: (remote) C->S compression: ${te.cs.compress}`),
        ne._server
          ? ((he = ct), (X = te.cs.compress))
          : ((he = te.cs.compress), (X = ct)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching C->S compression"),
        O(
          ne,
          "Handshake failed: no matching C->S compression",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.cs.compress = X[be]), ye && ye(`Handshake: C->S compression: ${X[be]}`);
    const ze = le.lists.sc.compress.array;
    for (
      ye && ye(`Handshake: (local) S->C compression: ${ze}`),
        ye && ye(`Handshake: (remote) S->C compression: ${te.sc.compress}`),
        ne._server
          ? ((he = ze), (X = te.sc.compress))
          : ((he = te.sc.compress), (X = ze)),
        be = 0;
      be < X.length && he.indexOf(X[be]) === -1;
      ++be
    );
    if (be === X.length)
      return (
        ye && ye("Handshake: No matching S->C compression"),
        O(
          ne,
          "Handshake failed: no matching S->C compression",
          "handshake",
          g.KEY_EXCHANGE_FAILED,
        )
      );
    (M.sc.compress = X[be]),
      ye && ye(`Handshake: S->C compression: ${X[be]}`),
      (M.cs.lang = ""),
      (M.sc.lang = ""),
      ne._kex &&
        (ne._kexinit || W(ne),
        (ne._decipher._onPayload = N.bind(ne, { firstPacket: !1 }))),
      (ne._kex = x(M, ne, Y)),
      (ne._kex.remoteExtInfoEnabled = Qe),
      ne._kex.start();
  }
  const x = (() => {
      function ne(te) {
        let ie = 0,
          X = te.length;
        for (; te[ie] === 0; ) ++ie, --X;
        let he;
        return (
          te[ie] & 128
            ? ((he = Buffer.allocUnsafe(1 + X)),
              (he[0] = 0),
              te.copy(he, 1, ie),
              (te = he))
            : X !== te.length &&
              ((he = Buffer.allocUnsafe(X)), te.copy(he, 0, ie), (te = he)),
          te
        );
      }
      class Y {
        constructor(ie, X, he) {
          (this._protocol = X),
            (this.sessionID = X._kex ? X._kex.sessionID : void 0),
            (this.negotiated = ie),
            (this.remoteExtInfoEnabled = !1),
            (this._step = 1),
            (this._public = null),
            (this._dh = null),
            (this._sentNEWKEYS = !1),
            (this._receivedNEWKEYS = !1),
            (this._finished = !1),
            (this._hostVerified = !1),
            (this._kexinit = X._kexinit),
            (this._remoteKexinit = he),
            (this._identRaw = X._identRaw),
            (this._remoteIdentRaw = X._remoteIdentRaw),
            (this._hostKey = void 0),
            (this._dhData = void 0),
            (this._sig = void 0);
        }
        finish(ie) {
          if (this._finished) return !1;
          this._finished = !0;
          const X = this._protocol._server,
            he = this.negotiated,
            be = this.convertPublicKey(this._dhData);
          let ye = this.computeSecret(this._dhData);
          if (ye instanceof Error)
            return (
              (ye.message = `Error while computing DH secret (${this.type}): ${ye.message}`),
              (ye.level = "handshake"),
              O(this._protocol, ye, g.KEY_EXCHANGE_FAILED)
            );
          const Qe = r(this.hashName);
          V(Qe, X ? this._remoteIdentRaw : this._identRaw),
            V(Qe, X ? this._identRaw : this._remoteIdentRaw),
            V(Qe, X ? this._remoteKexinit : this._kexinit),
            V(Qe, X ? this._kexinit : this._remoteKexinit);
          const lt = X ? this._hostKey.getPublicSSH() : this._hostKey;
          if ((V(Qe, lt), this.type === "groupex")) {
            const ze = this.getDHParams(),
              dt = Buffer.allocUnsafe(4);
            H(dt, this._minBits, 0),
              Qe.update(dt),
              H(dt, this._prefBits, 0),
              Qe.update(dt),
              H(dt, this._maxBits, 0),
              Qe.update(dt),
              V(Qe, ze.prime),
              V(Qe, ze.generator);
          }
          V(Qe, X ? be : this.getPublicKey());
          const Lt = X ? this.getPublicKey() : be;
          V(Qe, Lt), V(Qe, ye);
          const We = Qe.digest();
          if (X) {
            let ze;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                ze = "sha256";
                break;
              case "rsa-sha2-512":
                ze = "sha512";
                break;
            }
            this._protocol._debug &&
              this._protocol._debug("Generating signature ...");
            let dt = this._hostKey.sign(We, ze);
            if (dt instanceof Error)
              return O(
                this._protocol,
                `Handshake failed: signature generation failed for ${this._hostKey.type} host key: ${dt.message}`,
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            if (((dt = w(dt, this._hostKey.type)), dt === !1))
              return O(
                this._protocol,
                `Handshake failed: signature conversion failed for ${this._hostKey.type} host key`,
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            const ht = this.negotiated.serverHostKey,
              an = Buffer.byteLength(ht),
              $n = 4 + an + 4 + dt.length;
            let Wt = this._protocol._packetRW.write.allocStartKEX;
            const Jt = this._protocol._packetRW.write.alloc(
              1 + 4 + lt.length + 4 + Lt.length + 4 + $n,
              !0,
            );
            if (
              ((Jt[Wt] = v.KEXDH_REPLY),
              H(Jt, lt.length, ++Wt),
              Jt.set(lt, (Wt += 4)),
              H(Jt, Lt.length, (Wt += lt.length)),
              Jt.set(Lt, (Wt += 4)),
              H(Jt, $n, (Wt += Lt.length)),
              H(Jt, an, (Wt += 4)),
              Jt.utf8Write(ht, (Wt += 4), an),
              H(Jt, dt.length, (Wt += an)),
              Jt.set(dt, (Wt += 4)),
              this._protocol._debug)
            ) {
              let Zt;
              switch (this.type) {
                case "group":
                  Zt = "KEXDH_REPLY";
                  break;
                case "groupex":
                  Zt = "KEXDH_GEX_REPLY";
                  break;
                default:
                  Zt = "KEXECDH_REPLY";
              }
              this._protocol._debug(`Outbound: Sending ${Zt}`);
            }
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(Jt, !0),
            );
          } else {
            S.init(this._sig, 0);
            const ze = S.readString(!0);
            if (!ze)
              return O(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            if (ze !== he.serverHostKey)
              return O(
                this._protocol,
                `Wrong signature type: ${ze}, expected: ${he.serverHostKey}`,
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            let dt = S.readString();
            if ((S.clear(), dt === void 0))
              return O(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            if (!(dt = j(dt, ze)))
              return O(
                this._protocol,
                "Malformed signature",
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
            let ht;
            {
              S.init(this._hostKey, 0);
              const Wt = S.readString(!0),
                Jt = this._hostKey.slice(S.pos());
              if ((S.clear(), (ht = A(Jt, Wt)), ht instanceof Error))
                return (
                  (ht.level = "handshake"),
                  O(this._protocol, ht, g.KEY_EXCHANGE_FAILED)
                );
            }
            let an;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                an = "sha256";
                break;
              case "rsa-sha2-512":
                an = "sha512";
                break;
            }
            this._protocol._debug &&
              this._protocol._debug("Verifying signature ...");
            const $n = ht.verify(We, dt, an);
            if ($n !== !0)
              return (
                $n instanceof Error
                  ? this._protocol._debug &&
                    this._protocol._debug(
                      `Signature verification failed: ${$n.stack}`,
                    )
                  : this._protocol._debug &&
                    this._protocol._debug("Signature verification failed"),
                O(
                  this._protocol,
                  "Handshake failed: signature verification failed",
                  "handshake",
                  g.KEY_EXCHANGE_FAILED,
                )
              );
            this._protocol._debug &&
              this._protocol._debug("Verified signature");
          }
          (X || !ie) && re(this);
          let bt, wt;
          const ct = (ze) => {
            if (bt)
              return (
                re(this),
                (bt.outbound.seqno = this._protocol._cipher.outSeqno),
                this._protocol._cipher.free(),
                (this._protocol._cipher = _(bt)),
                (this._protocol._packetRW.write = wt),
                (bt = void 0),
                (wt = void 0),
                this._protocol._onHandshakeComplete(he),
                !1
              );
            this.sessionID || (this.sessionID = We);
            {
              const ni = Buffer.allocUnsafe(4 + ye.length);
              H(ni, ye.length, 0), ni.set(ye, 4), (ye = ni);
            }
            const dt = y[he.cs.cipher],
              ht = y[he.sc.cipher],
              an = B(dt.ivLen, this.hashName, ye, We, this.sessionID, "A"),
              $n = B(ht.ivLen, this.hashName, ye, We, this.sessionID, "B"),
              Wt = B(dt.keyLen, this.hashName, ye, We, this.sessionID, "C"),
              Jt = B(ht.keyLen, this.hashName, ye, We, this.sessionID, "D");
            let Zt, jr;
            dt.authLen ||
              ((Zt = R[he.cs.mac]),
              (jr = B(Zt.len, this.hashName, ye, We, this.sessionID, "E")));
            let Nn, Vr;
            ht.authLen ||
              ((Nn = R[he.sc.mac]),
              (Vr = B(Nn.len, this.hashName, ye, We, this.sessionID, "F")));
            const Vi = {
              inbound: {
                onPayload: this._protocol._onPayload,
                seqno: this._protocol._decipher.inSeqno,
                decipherInfo: X ? dt : ht,
                decipherIV: X ? an : $n,
                decipherKey: X ? Wt : Jt,
                macInfo: X ? Zt : Nn,
                macKey: X ? jr : Vr,
              },
              outbound: {
                onWrite: this._protocol._onWrite,
                seqno: this._protocol._cipher.outSeqno,
                cipherInfo: X ? ht : dt,
                cipherIV: X ? $n : an,
                cipherKey: X ? Jt : Wt,
                macInfo: X ? Nn : Zt,
                macKey: X ? Vr : jr,
              },
            };
            this._protocol._decipher.free(),
              (bt = Vi),
              (this._protocol._decipher = E(Vi));
            const On = { read: void 0, write: void 0 };
            switch (he.cs.compress) {
              case "zlib":
                X ? (On.read = new Z()) : (On.write = new z(this._protocol));
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  X ? (On.read = new Z()) : (On.write = new z(this._protocol));
                  break;
                }
              default:
                X ? (On.read = new q()) : (On.write = new J(this._protocol));
            }
            switch (he.sc.compress) {
              case "zlib":
                X ? (On.write = new z(this._protocol)) : (On.read = new Z());
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  X ? (On.write = new z(this._protocol)) : (On.read = new Z());
                  break;
                }
              default:
                X ? (On.write = new J(this._protocol)) : (On.read = new q());
            }
            return (
              this._protocol._packetRW.read.cleanup(),
              this._protocol._packetRW.write.cleanup(),
              (this._protocol._packetRW.read = On.read),
              (wt = On.write),
              (this._public = null),
              (this._dh = null),
              (this._kexinit = this._protocol._kexinit = void 0),
              (this._remoteKexinit = void 0),
              (this._identRaw = void 0),
              (this._remoteIdentRaw = void 0),
              (this._hostKey = void 0),
              (this._dhData = void 0),
              (this._sig = void 0),
              ze ? !1 : ct()
            );
          };
          if (((X || ie) && (this.finish = ct), !X)) return ct(ie);
        }
        start() {
          if (!this._protocol._server) {
            if (this._protocol._debug) {
              let be;
              switch (this.type) {
                case "group":
                  be = "KEXDH_INIT";
                  break;
                default:
                  be = "KEXECDH_INIT";
              }
              this._protocol._debug(`Outbound: Sending ${be}`);
            }
            const ie = this.getPublicKey();
            let X = this._protocol._packetRW.write.allocStartKEX;
            const he = this._protocol._packetRW.write.alloc(
              1 + 4 + ie.length,
              !0,
            );
            (he[X] = v.KEXDH_INIT),
              H(he, ie.length, ++X),
              he.set(ie, (X += 4)),
              this._protocol._cipher.encrypt(
                this._protocol._packetRW.write.finalize(he, !0),
              );
          }
        }
        getPublicKey() {
          this.generateKeys();
          const ie = this._public;
          if (ie) return this.convertPublicKey(ie);
        }
        convertPublicKey(ie) {
          let X,
            he = 0,
            be = ie.length;
          for (; ie[he] === 0; ) ++he, --be;
          return ie[he] & 128
            ? ((X = Buffer.allocUnsafe(1 + be)),
              (X[0] = 0),
              ie.copy(X, 1, he),
              X)
            : (be !== ie.length &&
                ((X = Buffer.allocUnsafe(be)), ie.copy(X, 0, he), (ie = X)),
              ie);
        }
        computeSecret(ie) {
          this.generateKeys();
          try {
            return ne(this._dh.computeSecret(ie));
          } catch (X) {
            return X;
          }
        }
        parse(ie) {
          const X = ie[0];
          switch (this._step) {
            case 1:
              if (this._protocol._server) {
                if (X !== v.KEXDH_INIT)
                  return O(
                    this._protocol,
                    `Received packet ${X} instead of ${v.KEXDH_INIT}`,
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  );
                this._protocol._debug &&
                  this._protocol._debug("Received DH Init"),
                  S.init(ie, 1);
                const he = S.readString();
                if ((S.clear(), he === void 0))
                  return O(
                    this._protocol,
                    "Received malformed KEX*_INIT",
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  );
                this._dhData = he;
                let be =
                  this._protocol._hostKeys[this.negotiated.serverHostKey];
                Array.isArray(be) && (be = be[0]),
                  (this._hostKey = be),
                  this.finish();
              } else {
                if (X !== v.KEXDH_REPLY)
                  return O(
                    this._protocol,
                    `Received packet ${X} instead of ${v.KEXDH_REPLY}`,
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  );
                this._protocol._debug &&
                  this._protocol._debug("Received DH Reply"),
                  S.init(ie, 1);
                let he, be, ye;
                if (
                  (he = S.readString()) === void 0 ||
                  (be = S.readString()) === void 0 ||
                  (ye = S.readString()) === void 0
                )
                  return (
                    S.clear(),
                    O(
                      this._protocol,
                      "Received malformed KEX*_REPLY",
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    )
                  );
                S.clear(), S.init(he, 0);
                const Qe = S.readString(!0);
                if ((S.clear(), Qe === void 0))
                  return O(
                    this._protocol,
                    "Received malformed host public key",
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  );
                if (Qe !== this.negotiated.serverHostKey)
                  switch (this.negotiated.serverHostKey) {
                    case "rsa-sha2-256":
                    case "rsa-sha2-512":
                      if (Qe === "ssh-rsa") break;
                    default:
                      return O(
                        this._protocol,
                        "Host key does not match negotiated type",
                        "handshake",
                        g.KEY_EXCHANGE_FAILED,
                      );
                  }
                (this._hostKey = he), (this._dhData = be), (this._sig = ye);
                let lt = !1,
                  Lt;
                if (
                  (this._protocol._hostVerifier === void 0
                    ? ((Lt = !0),
                      this._protocol._debug &&
                        this._protocol._debug(
                          "Host accepted by default (no verification)",
                        ))
                    : (Lt = this._protocol._hostVerifier(he, (We) => {
                        if (!lt) {
                          if (((lt = !0), We === !1))
                            return (
                              this._protocol._debug &&
                                this._protocol._debug(
                                  "Host denied (verification failed)",
                                ),
                              O(
                                this._protocol,
                                "Host denied (verification failed)",
                                "handshake",
                                g.KEY_EXCHANGE_FAILED,
                              )
                            );
                          this._protocol._debug &&
                            this._protocol._debug("Host accepted (verified)"),
                            (this._hostVerified = !0),
                            this._receivedNEWKEYS ? this.finish() : re(this);
                        }
                      })),
                  Lt === void 0)
                ) {
                  ++this._step;
                  return;
                }
                if (((lt = !0), Lt === !1))
                  return (
                    this._protocol._debug &&
                      this._protocol._debug(
                        "Host denied (verification failed)",
                      ),
                    O(
                      this._protocol,
                      "Host denied (verification failed)",
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    )
                  );
                this._protocol._debug &&
                  this._protocol._debug("Host accepted (verified)"),
                  (this._hostVerified = !0),
                  re(this);
              }
              ++this._step;
              break;
            case 2:
              return X !== v.NEWKEYS
                ? O(
                    this._protocol,
                    `Received packet ${X} instead of ${v.NEWKEYS}`,
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  )
                : (this._protocol._debug &&
                    this._protocol._debug("Inbound: NEWKEYS"),
                  (this._receivedNEWKEYS = !0),
                  ++this._step,
                  this.finish(!this._protocol._server && !this._hostVerified));
            default:
              return O(
                this._protocol,
                `Received unexpected packet ${X} after NEWKEYS`,
                "handshake",
                g.KEY_EXCHANGE_FAILED,
              );
          }
        }
      }
      class M extends Y {
        constructor(ie, ...X) {
          super(...X),
            (this.type = "25519"),
            (this.hashName = ie),
            (this._keys = null);
        }
        generateKeys() {
          this._keys || (this._keys = s("x25519"));
        }
        getPublicKey() {
          return (
            this.generateKeys(),
            this._keys.publicKey
              .export({ type: "spki", format: "der" })
              .slice(-32)
          );
        }
        convertPublicKey(ie) {
          let X,
            he = 0,
            be = ie.length;
          for (; ie[he] === 0; ) ++he, --be;
          return (
            ie.length === 32 ||
              (be !== ie.length &&
                ((X = Buffer.allocUnsafe(be)), ie.copy(X, 0, he), (ie = X))),
            ie
          );
        }
        computeSecret(ie) {
          this.generateKeys();
          try {
            const X = new c.Writer();
            return (
              X.startSequence(),
              X.startSequence(),
              X.writeOID("1.3.101.110"),
              X.endSequence(),
              X.startSequence(c.BitString),
              X.writeByte(0),
              X._ensure(ie.length),
              ie.copy(X._buf, X._offset, 0, ie.length),
              (X._offset += ie.length),
              X.endSequence(),
              X.endSequence(),
              ne(
                a({
                  privateKey: this._keys.privateKey,
                  publicKey: i({ key: X.buffer, type: "spki", format: "der" }),
                }),
              )
            );
          } catch (X) {
            return X;
          }
        }
      }
      class oe extends Y {
        constructor(ie, X, ...he) {
          super(...he),
            (this.type = "ecdh"),
            (this.curveName = ie),
            (this.hashName = X);
        }
        generateKeys() {
          this._dh ||
            ((this._dh = n(this.curveName)),
            (this._public = this._dh.generateKeys()));
        }
      }
      class Ee extends Y {
        constructor(ie, ...X) {
          super(...X),
            (this.type = "groupex"),
            (this.hashName = ie),
            (this._prime = null),
            (this._generator = null),
            (this._minBits = G),
            (this._prefBits = ce(this.negotiated)),
            this._protocol._compatFlags & l.BUG_DHGEX_LARGE &&
              (this._prefBits = Math.min(this._prefBits, 4096)),
            (this._maxBits = L);
        }
        start() {
          if (this._protocol._server) return;
          this._protocol._debug &&
            this._protocol._debug("Outbound: Sending KEXDH_GEX_REQUEST");
          let ie = this._protocol._packetRW.write.allocStartKEX;
          const X = this._protocol._packetRW.write.alloc(1 + 4 + 4 + 4, !0);
          (X[ie] = v.KEXDH_GEX_REQUEST),
            H(X, this._minBits, ++ie),
            H(X, this._prefBits, (ie += 4)),
            H(X, this._maxBits, (ie += 4)),
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(X, !0),
            );
        }
        generateKeys() {
          !this._dh &&
            this._prime &&
            this._generator &&
            ((this._dh = e(this._prime, this._generator)),
            (this._public = this._dh.generateKeys()));
        }
        setDHParams(ie, X) {
          if (!Buffer.isBuffer(ie)) throw new Error("Invalid prime value");
          if (!Buffer.isBuffer(X)) throw new Error("Invalid generator value");
          (this._prime = ie), (this._generator = X);
        }
        getDHParams() {
          if (this._dh)
            return {
              prime: ne(this._dh.getPrime()),
              generator: ne(this._dh.getGenerator()),
            };
        }
        parse(ie) {
          const X = ie[0];
          switch (this._step) {
            case 1: {
              if (this._protocol._server)
                return X !== v.KEXDH_GEX_REQUEST
                  ? O(
                      this._protocol,
                      `Received packet ${X} instead of ` + v.KEXDH_GEX_REQUEST,
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    )
                  : O(
                      this._protocol,
                      "Group exchange not implemented for server",
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    );
              if (X !== v.KEXDH_GEX_GROUP)
                return O(
                  this._protocol,
                  `Received packet ${X} instead of ${v.KEXDH_GEX_GROUP}`,
                  "handshake",
                  g.KEY_EXCHANGE_FAILED,
                );
              this._protocol._debug &&
                this._protocol._debug("Received DH GEX Group"),
                S.init(ie, 1);
              let he, be;
              if (
                (he = S.readString()) === void 0 ||
                (be = S.readString()) === void 0
              )
                return (
                  S.clear(),
                  O(
                    this._protocol,
                    "Received malformed KEXDH_GEX_GROUP",
                    "handshake",
                    g.KEY_EXCHANGE_FAILED,
                  )
                );
              S.clear(), this.setDHParams(he, be), this.generateKeys();
              const ye = this.getPublicKey();
              this._protocol._debug &&
                this._protocol._debug("Outbound: Sending KEXDH_GEX_INIT");
              let Qe = this._protocol._packetRW.write.allocStartKEX;
              const lt = this._protocol._packetRW.write.alloc(
                1 + 4 + ye.length,
                !0,
              );
              (lt[Qe] = v.KEXDH_GEX_INIT),
                H(lt, ye.length, ++Qe),
                lt.set(ye, (Qe += 4)),
                this._protocol._cipher.encrypt(
                  this._protocol._packetRW.write.finalize(lt, !0),
                ),
                ++this._step;
              break;
            }
            case 2:
              if (this._protocol._server)
                return X !== v.KEXDH_GEX_INIT
                  ? O(
                      this._protocol,
                      `Received packet ${X} instead of ${v.KEXDH_GEX_INIT}`,
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    )
                  : (this._protocol._debug &&
                      this._protocol._debug("Received DH GEX Init"),
                    O(
                      this._protocol,
                      "Group exchange not implemented for server",
                      "handshake",
                      g.KEY_EXCHANGE_FAILED,
                    ));
              if (X !== v.KEXDH_GEX_REPLY)
                return O(
                  this._protocol,
                  `Received packet ${X} instead of ${v.KEXDH_GEX_REPLY}`,
                  "handshake",
                  g.KEY_EXCHANGE_FAILED,
                );
              this._protocol._debug &&
                this._protocol._debug("Received DH GEX Reply"),
                (this._step = 1),
                (ie[0] = v.KEXDH_REPLY),
                (this.parse = Y.prototype.parse),
                this.parse(ie);
          }
        }
      }
      class le extends Y {
        constructor(ie, X, ...he) {
          super(...he),
            (this.type = "group"),
            (this.groupName = ie),
            (this.hashName = X);
        }
        start() {
          if (!this._protocol._server) {
            this._protocol._debug &&
              this._protocol._debug("Outbound: Sending KEXDH_INIT");
            const ie = this.getPublicKey();
            let X = this._protocol._packetRW.write.allocStartKEX;
            const he = this._protocol._packetRW.write.alloc(
              1 + 4 + ie.length,
              !0,
            );
            (he[X] = v.KEXDH_INIT),
              H(he, ie.length, ++X),
              he.set(ie, (X += 4)),
              this._protocol._cipher.encrypt(
                this._protocol._packetRW.write.finalize(he, !0),
              );
          }
        }
        generateKeys() {
          this._dh ||
            ((this._dh = t(this.groupName)),
            (this._public = this._dh.generateKeys()));
        }
        getDHParams() {
          if (this._dh)
            return {
              prime: ne(this._dh.getPrime()),
              generator: ne(this._dh.getGenerator()),
            };
        }
      }
      return (te, ...ie) => {
        if (typeof te != "object" || te === null)
          throw new Error("Invalid negotiated argument");
        const X = te.kex;
        if (typeof X == "string") {
          switch (((ie = [te, ...ie]), X)) {
            case "curve25519-sha256":
            case "curve25519-sha256@libssh.org":
              if (!f) break;
              return new M("sha256", ...ie);
            case "ecdh-sha2-nistp256":
              return new oe("prime256v1", "sha256", ...ie);
            case "ecdh-sha2-nistp384":
              return new oe("secp384r1", "sha384", ...ie);
            case "ecdh-sha2-nistp521":
              return new oe("secp521r1", "sha512", ...ie);
            case "diffie-hellman-group1-sha1":
              return new le("modp2", "sha1", ...ie);
            case "diffie-hellman-group14-sha1":
              return new le("modp14", "sha1", ...ie);
            case "diffie-hellman-group14-sha256":
              return new le("modp14", "sha256", ...ie);
            case "diffie-hellman-group15-sha512":
              return new le("modp15", "sha512", ...ie);
            case "diffie-hellman-group16-sha512":
              return new le("modp16", "sha512", ...ie);
            case "diffie-hellman-group17-sha512":
              return new le("modp17", "sha512", ...ie);
            case "diffie-hellman-group18-sha512":
              return new le("modp18", "sha512", ...ie);
            case "diffie-hellman-group-exchange-sha1":
              return new Ee("sha1", ...ie);
            case "diffie-hellman-group-exchange-sha256":
              return new Ee("sha256", ...ie);
          }
          throw new Error(`Unsupported key exchange algorithm: ${X}`);
        }
        throw new Error(`Invalid key exchange type: ${X}`);
      };
    })(),
    T = (() => {
      const ne = [
        "kex",
        "serverHostKey",
        ["cs", "cipher"],
        ["sc", "cipher"],
        ["cs", "mac"],
        ["sc", "mac"],
        ["cs", "compress"],
        ["sc", "compress"],
        ["cs", "lang"],
        ["sc", "lang"],
      ];
      return class {
        constructor(M) {
          if (typeof M != "object" || M === null)
            throw new TypeError("Argument must be an object");
          const oe = {
            kex: void 0,
            serverHostKey: void 0,
            cs: { cipher: void 0, mac: void 0, compress: void 0, lang: void 0 },
            sc: { cipher: void 0, mac: void 0, compress: void 0, lang: void 0 },
            all: void 0,
          };
          let Ee = 0;
          for (const ie of ne) {
            let X, he, be, ye;
            if (typeof ie == "string") (X = oe), (he = M[ie]), (be = ye = ie);
            else {
              const lt = ie[0];
              (X = oe[lt]),
                (ye = ie[1]),
                (he = M[lt][ye]),
                (be = `${lt}.${ye}`);
            }
            const Qe = { array: void 0, buffer: void 0 };
            if (Buffer.isBuffer(he))
              (Qe.array = ("" + he).split(",")),
                (Qe.buffer = he),
                (Ee += 4 + he.length);
            else {
              if (
                (typeof he == "string" && (he = he.split(",")),
                Array.isArray(he))
              )
                (Qe.array = he), (Qe.buffer = Buffer.from(he.join(",")));
              else throw new TypeError(`Invalid \`${be}\` type: ${typeof he}`);
              Ee += 4 + Qe.buffer.length;
            }
            X[ye] = Qe;
          }
          const le = Buffer.allocUnsafe(Ee);
          oe.all = le;
          let te = 0;
          for (const ie of ne) {
            let X;
            typeof ie == "string"
              ? (X = oe[ie].buffer)
              : (X = oe[ie[0]][ie[1]].buffer),
              (te = H(le, X.length, te)),
              le.set(X, te),
              (te += X.length);
          }
          (this.totalSize = Ee), (this.lists = oe);
        }
        copyAllTo(M, oe) {
          const Ee = this.lists.all;
          if (typeof oe != "number")
            throw new TypeError(`Invalid offset value: ${typeof oe}`);
          if (M.length - oe < Ee.length)
            throw new Error("Insufficient space to copy list");
          return M.set(Ee, oe), Ee.length;
        }
      };
    })(),
    V = (() => {
      const ne = Buffer.allocUnsafe(4);
      return (Y, M) => {
        H(ne, M.length, 0), Y.update(ne), Y.update(M);
      };
    })();
  function B(ne, Y, M, oe, Ee, le) {
    let te;
    if (ne) {
      let ie = r(Y).update(M).update(oe).update(le).update(Ee).digest();
      for (; ie.length < ne; ) {
        const X = r(Y).update(M).update(oe).update(ie).digest(),
          he = Buffer.allocUnsafe(ie.length + X.length);
        he.set(ie, 0), he.set(X, ie.length), (ie = he);
      }
      ie.length === ne ? (te = ie) : (te = new Q(ie.buffer, ie.byteOffset, ne));
    } else te = k;
    return te;
  }
  function N(ne, Y) {
    if (Y.length === 0) {
      this._debug && this._debug("Inbound: Skipping empty packet payload");
      return;
    }
    if (this._skipNextInboundPacket) {
      this._skipNextInboundPacket = !1;
      return;
    }
    Y = this._packetRW.read.read(Y);
    const M = Y[0];
    switch (M) {
      case v.DISCONNECT:
      case v.IGNORE:
      case v.UNIMPLEMENTED:
      case v.DEBUG:
        return U || (U = wk()), U[M](this, Y);
      case v.KEXINIT:
        return ne.firstPacket
          ? ((ne.firstPacket = !1), F(this, Y))
          : O(
              this,
              "Received extra KEXINIT during handshake",
              "handshake",
              g.KEY_EXCHANGE_FAILED,
            );
      default:
        if (M < 20 || M > 49)
          return O(
            this,
            `Received unexpected packet type ${M}`,
            "handshake",
            g.KEY_EXCHANGE_FAILED,
          );
    }
    return this._kex.parse(Y);
  }
  function ce(ne) {
    const Y = y[ne.cs.cipher],
      M = y[ne.sc.cipher],
      oe =
        Math.max(
          0,
          Y.sslName === "des-ede3-cbc" ? 14 : Y.keyLen,
          Y.blockLen,
          Y.ivLen,
          M.sslName === "des-ede3-cbc" ? 14 : M.keyLen,
          M.blockLen,
          M.ivLen,
        ) * 8;
    return oe <= 112 ? 2048 : oe <= 128 ? 3072 : oe <= 192 ? 7680 : 8192;
  }
  function re(ne) {
    if (!ne._sentNEWKEYS) {
      ne._protocol._debug && ne._protocol._debug("Outbound: Sending NEWKEYS");
      const Y = ne._protocol._packetRW.write.allocStartKEX,
        M = ne._protocol._packetRW.write.alloc(1, !0);
      (M[Y] = v.NEWKEYS),
        ne._protocol._cipher.encrypt(
          ne._protocol._packetRW.write.finalize(M, !0),
        ),
        (ne._sentNEWKEYS = !0);
    }
  }
  return (
    (eg = {
      KexInit: T,
      kexinit: W,
      onKEXPayload: N,
      DEFAULT_KEXINIT_CLIENT: new T({
        kex: u.concat(["ext-info-c"]),
        serverHostKey: d,
        cs: { cipher: p, mac: h, compress: m, lang: [] },
        sc: { cipher: p, mac: h, compress: m, lang: [] },
      }),
      DEFAULT_KEXINIT_SERVER: new T({
        kex: u,
        serverHostKey: d,
        cs: { cipher: p, mac: h, compress: m, lang: [] },
        sc: { cipher: p, mac: h, compress: m, lang: [] },
      }),
      HANDLERS: { [v.KEXINIT]: F },
    }),
    eg
  );
}
const cne = "ssh2",
  lne = "1.14.0",
  une = "Brian White <mscdex@mscdex.net>",
  fne = "SSH2 client and server modules written in pure JavaScript for node.js",
  dne = "./lib/index.js",
  pne = { node: ">=10.16.0" },
  hne = { asn1: "^0.2.6", "bcrypt-pbkdf": "^1.0.2" },
  mne = { "@mscdex/eslint-config": "^1.1.0", eslint: "^7.32.0" },
  gne = { "cpu-features": "~0.0.8", nan: "^2.17.0" },
  vne = {
    install: "node install.js",
    rebuild: "node install.js",
    test: "node test/test.js",
    lint: "eslint --cache --report-unused-disable-directives --ext=.js .eslintrc.js examples lib test",
    "lint:fix": "npm run lint -- --fix",
  },
  yne = ["ssh", "ssh2", "sftp", "secure", "shell", "exec", "remote", "client"],
  bne = [
    { type: "MIT", url: "http://github.com/mscdex/ssh2/raw/master/LICENSE" },
  ],
  _ne = { type: "git", url: "http://github.com/mscdex/ssh2.git" },
  Ene = {
    name: cne,
    version: lne,
    author: une,
    description: fne,
    main: dne,
    engines: pne,
    dependencies: hne,
    devDependencies: mne,
    optionalDependencies: gne,
    scripts: vne,
    keywords: yne,
    licenses: bne,
    repository: _ne,
  },
  { inspect: xk } = wr,
  { bindingAvailable: wne, NullCipher: xne, NullDecipher: Ane } = eo(),
  {
    COMPAT_CHECKS: Sne,
    DISCONNECT_REASON: Ak,
    eddsaSupported: Ine,
    MESSAGE: et,
    SIGNALS: WA,
    TERMINAL_MODE: H0,
  } = es(),
  {
    DEFAULT_KEXINIT_CLIENT: $ne,
    DEFAULT_KEXINIT_SERVER: Cne,
    KexInit: zA,
    kexinit: Sk,
    onKEXPayload: Rne,
  } = i1(),
  { parseKey: KA } = to,
  kne = wk(),
  {
    bufferCopy: Tf,
    bufferFill: Tne,
    bufferSlice: Ik,
    convertSignature: VA,
    sendPacket: tt,
    writeUInt32BE: fe,
  } = Ki(),
  {
    PacketReader: Nne,
    PacketWriter: One,
    ZlibPacketReader: $k,
    ZlibPacketWriter: Ck,
  } = _k,
  Pne = Ene.version,
  Dne = new Map(Object.values(Ak).map((e) => [e, 1])),
  Rk = Buffer.from(`SSH-2.0-ssh2js${Pne}`),
  Lne = Buffer.from(`${Rk}\r
`),
  Bne = 8192,
  Une = 1024,
  YA = Buffer.from([
    et.GLOBAL_REQUEST,
    0,
    0,
    0,
    21,
    107,
    101,
    101,
    112,
    97,
    108,
    105,
    118,
    101,
    64,
    111,
    112,
    101,
    110,
    115,
    115,
    104,
    46,
    99,
    111,
    109,
    1,
  ]),
  Fne = Buffer.from([H0.TTY_OP_END]);
function tg() {}
let jne = class {
  constructor(t) {
    const n = t.onWrite;
    if (typeof n != "function") throw new Error("Missing onWrite function");
    this._onWrite = (p) => {
      n(p);
    };
    const r = t.onError;
    if (typeof r != "function") throw new Error("Missing onError function");
    this._onError = (p) => {
      r(p);
    };
    const i = t.debug;
    this._debug =
      typeof i == "function"
        ? (p) => {
            i(p);
          }
        : void 0;
    const a = t.onHeader;
    this._onHeader =
      typeof a == "function"
        ? (...p) => {
            a(...p);
          }
        : tg;
    const s = t.onPacket;
    this._onPacket =
      typeof s == "function"
        ? () => {
            s();
          }
        : tg;
    let o = t.onHandshakeComplete;
    typeof o != "function" && (o = tg);
    let c;
    (this._onHandshakeComplete = (...p) => {
      this._debug && this._debug("Handshake completed"),
        c === void 0 ? (c = !0) : (c = !1);
      const h = this._queue;
      if (h) {
        (this._queue = void 0),
          this._debug &&
            this._debug(`Draining outbound queue (${h.length}) ...`);
        for (let m = 0; m < h.length; ++m) {
          const g = h[m];
          let v = this._packetRW.write.finalize(g);
          if (v === g) {
            const y = this._cipher.allocPacket(g.length);
            y.set(g, 5), (v = y);
          }
          tt(this, v);
        }
        this._debug && this._debug("... finished draining outbound queue");
      }
      c && this._server && this._kex.remoteExtInfoEnabled && zne(this), o(...p);
    }),
      (this._queue = void 0);
    const l = t.messageHandlers;
    typeof l == "object" && l !== null
      ? (this._handlers = l)
      : (this._handlers = {}),
      (this._onPayload = Gne.bind(this)),
      (this._server = !!t.server),
      (this._banner = void 0);
    let f;
    if (this._server) {
      if (typeof t.hostKeys != "object" || t.hostKeys === null)
        throw new Error("Missing server host key(s)");
      (this._hostKeys = t.hostKeys),
        typeof t.greeting == "string" &&
          t.greeting.length &&
          (f =
            t.greeting.slice(-2) ===
            `\r
`
              ? t.greeting
              : `${t.greeting}\r
`),
        typeof t.banner == "string" &&
          t.banner.length &&
          (this._banner =
            t.banner.slice(-2) ===
            `\r
`
              ? t.banner
              : `${t.banner}\r
`);
    } else this._hostKeys = void 0;
    let u = t.offer;
    typeof u != "object" || u === null
      ? (u = this._server ? Cne : $ne)
      : u.constructor !== zA &&
        (this._server || (u.kex = u.kex.concat(["ext-info-c"])),
        (u = new zA(u))),
      (this._kex = void 0),
      (this._kexinit = void 0),
      (this._offer = u),
      (this._cipher = new xne(0, this._onWrite)),
      (this._decipher = void 0),
      (this._skipNextInboundPacket = !1),
      (this._packetRW = { read: new Nne(), write: new One(this) }),
      (this._hostVerifier =
        !this._server && typeof t.hostVerifier == "function"
          ? t.hostVerifier
          : void 0),
      (this._parse = Hne),
      (this._buffer = void 0),
      (this._authsQueue = []),
      (this._authenticated = !1),
      (this._remoteIdentRaw = void 0);
    let d;
    if (typeof t.ident == "string")
      (this._identRaw = Buffer.from(`SSH-2.0-${t.ident}`)),
        (d = Buffer.allocUnsafe(this._identRaw.length + 2)),
        d.set(this._identRaw, 0),
        (d[d.length - 2] = 13),
        (d[d.length - 1] = 10);
    else if (Buffer.isBuffer(t.ident)) {
      const p = Buffer.allocUnsafe(8 + t.ident.length);
      p.latin1Write("SSH-2.0-", 0, 8),
        p.set(t.ident, 8),
        (this._identRaw = p),
        (d = Buffer.allocUnsafe(p.length + 2)),
        d.set(p, 0),
        (d[d.length - 2] = 13),
        (d[d.length - 1] = 10);
    } else (this._identRaw = Rk), (d = Lne);
    (this._compatFlags = 0),
      this._debug &&
        (wne
          ? this._debug("Custom crypto binding available")
          : this._debug("Custom crypto binding not available")),
      this._debug &&
        this._debug(`Local ident: ${xk(this._identRaw.toString())}`),
      (this.start = () => {
        (this.start = void 0), f && this._onWrite(f), this._onWrite(d);
      });
  }
  _destruct(t) {
    this._packetRW.read.cleanup(),
      this._packetRW.write.cleanup(),
      this._cipher && this._cipher.free(),
      this._decipher && this._decipher.free(),
      (typeof t != "string" || t.length === 0) && (t = "fatal error"),
      (this.parse = () => {
        throw new Error(`Instance unusable after ${t}`);
      }),
      (this._onWrite = () => {
        throw new Error(`Instance unusable after ${t}`);
      }),
      (this._destruct = void 0);
  }
  cleanup() {
    this._destruct && this._destruct();
  }
  parse(t, n, r) {
    for (; n < r; ) n = this._parse(t, n, r);
  }
  disconnect(t) {
    let r = this._packetRW.write.allocStartKEX;
    const i = this._packetRW.write.alloc(13, !0),
      a = r + 13;
    Dne.has(t) || (t = Ak.PROTOCOL_ERROR),
      (i[r] = et.DISCONNECT),
      fe(i, t, ++r),
      i.fill(0, (r += 4), a),
      this._debug && this._debug(`Outbound: Sending DISCONNECT (${t})`),
      tt(this, this._packetRW.write.finalize(i, !0), !0);
  }
  ping() {
    const t = this._packetRW.write.allocStart,
      n = this._packetRW.write.alloc(YA.length);
    n.set(YA, t),
      this._debug &&
        this._debug(
          "Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)",
        ),
      tt(this, this._packetRW.write.finalize(n));
  }
  rekey() {
    this._kexinit === void 0
      ? (this._debug && this._debug("Outbound: Initiated explicit rekey"),
        (this._queue = []),
        Sk(this))
      : this._debug && this._debug("Outbound: Ignoring rekey during handshake");
  }
  requestSuccess(t) {
    let n = this._packetRW.write.allocStart,
      r;
    Buffer.isBuffer(t)
      ? ((r = this._packetRW.write.alloc(1 + t.length)),
        (r[n] = et.REQUEST_SUCCESS),
        r.set(t, ++n))
      : ((r = this._packetRW.write.alloc(1)), (r[n] = et.REQUEST_SUCCESS)),
      this._debug && this._debug("Outbound: Sending REQUEST_SUCCESS"),
      tt(this, this._packetRW.write.finalize(r));
  }
  requestFailure() {
    const t = this._packetRW.write.allocStart,
      n = this._packetRW.write.alloc(1);
    (n[t] = et.REQUEST_FAILURE),
      this._debug && this._debug("Outbound: Sending REQUEST_FAILURE"),
      tt(this, this._packetRW.write.finalize(n));
  }
  channelSuccess(t) {
    let n = this._packetRW.write.allocStart;
    const r = this._packetRW.write.alloc(1 + 4);
    (r[n] = et.CHANNEL_SUCCESS),
      fe(r, t, ++n),
      this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${t})`),
      tt(this, this._packetRW.write.finalize(r));
  }
  channelFailure(t) {
    let n = this._packetRW.write.allocStart;
    const r = this._packetRW.write.alloc(1 + 4);
    (r[n] = et.CHANNEL_FAILURE),
      fe(r, t, ++n),
      this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${t})`),
      tt(this, this._packetRW.write.finalize(r));
  }
  channelEOF(t) {
    let n = this._packetRW.write.allocStart;
    const r = this._packetRW.write.alloc(1 + 4);
    (r[n] = et.CHANNEL_EOF),
      fe(r, t, ++n),
      this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${t})`),
      tt(this, this._packetRW.write.finalize(r));
  }
  channelClose(t) {
    let n = this._packetRW.write.allocStart;
    const r = this._packetRW.write.alloc(1 + 4);
    (r[n] = et.CHANNEL_CLOSE),
      fe(r, t, ++n),
      this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${t})`),
      tt(this, this._packetRW.write.finalize(r));
  }
  channelWindowAdjust(t, n) {
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + 4);
    (i[r] = et.CHANNEL_WINDOW_ADJUST),
      fe(i, t, ++r),
      fe(i, n, (r += 4)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${t}, ${n})`),
      tt(this, this._packetRW.write.finalize(i));
  }
  channelData(t, n) {
    const r = Buffer.isBuffer(n),
      i = r ? n.length : Buffer.byteLength(n);
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 4 + i);
    (s[a] = et.CHANNEL_DATA),
      fe(s, t, ++a),
      fe(s, i, (a += 4)),
      r ? s.set(n, (a += 4)) : s.utf8Write(n, (a += 4), i),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_DATA (r:${t}, ${i})`),
      tt(this, this._packetRW.write.finalize(s));
  }
  channelExtData(t, n, r) {
    const i = Buffer.isBuffer(n),
      a = i ? n.length : Buffer.byteLength(n);
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(1 + 4 + 4 + 4 + a);
    (o[s] = et.CHANNEL_EXTENDED_DATA),
      fe(o, t, ++s),
      fe(o, r, (s += 4)),
      fe(o, a, (s += 4)),
      i ? o.set(n, (s += 4)) : o.utf8Write(n, (s += 4), a),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${t})`),
      tt(this, this._packetRW.write.finalize(o));
  }
  channelOpenConfirm(t, n, r, i) {
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);
    (s[a] = et.CHANNEL_OPEN_CONFIRMATION),
      fe(s, t, ++a),
      fe(s, n, (a += 4)),
      fe(s, r, (a += 4)),
      fe(s, i, (a += 4)),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${t}, l:${n})`,
        ),
      tt(this, this._packetRW.write.finalize(s));
  }
  channelOpenFail(t, n, r) {
    typeof r != "string" && (r = "");
    const i = Buffer.byteLength(r);
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 4 + 4 + i + 4);
    (s[a] = et.CHANNEL_OPEN_FAILURE),
      fe(s, t, ++a),
      fe(s, n, (a += 4)),
      fe(s, i, (a += 4)),
      (a += 4),
      i && (s.utf8Write(r, a, i), (a += i)),
      fe(s, 0, a),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${t})`),
      tt(this, this._packetRW.write.finalize(s));
  }
  service(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const n = Buffer.byteLength(t);
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + n);
    (i[r] = et.SERVICE_REQUEST),
      fe(i, n, ++r),
      i.utf8Write(t, (r += 4), n),
      this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${t})`),
      tt(this, this._packetRW.write.finalize(i));
  }
  authPassword(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(t),
      a = Buffer.byteLength(n),
      s = r ? Buffer.byteLength(r) : 0;
    let o = this._packetRW.write.allocStart;
    const c = this._packetRW.write.alloc(
      1 + 4 + i + 4 + 14 + 4 + 8 + 1 + 4 + a + (r ? 4 + s : 0),
    );
    (c[o] = et.USERAUTH_REQUEST),
      fe(c, i, ++o),
      c.utf8Write(t, (o += 4), i),
      fe(c, 14, (o += i)),
      c.utf8Write("ssh-connection", (o += 4), 14),
      fe(c, 8, (o += 14)),
      c.utf8Write("password", (o += 4), 8),
      (c[(o += 8)] = r ? 1 : 0),
      fe(c, a, ++o),
      Buffer.isBuffer(n)
        ? Tf(n, c, 0, a, (o += 4))
        : c.utf8Write(n, (o += 4), a),
      r
        ? (fe(c, s, (o += a)),
          Buffer.isBuffer(r)
            ? Tf(r, c, 0, s, (o += 4))
            : c.utf8Write(r, (o += 4), s),
          this._debug &&
            this._debug(
              "Outbound: Sending USERAUTH_REQUEST (changed password)",
            ))
        : this._debug &&
          this._debug("Outbound: Sending USERAUTH_REQUEST (password)"),
      this._authsQueue.push("password"),
      tt(this, this._packetRW.write.finalize(c));
  }
  authPK(t, n, r, i) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    if (((n = KA(n)), n instanceof Error)) throw new Error("Invalid key");
    const a = n.type;
    (n = n.getPublicSSH()),
      typeof r == "function" && ((i = r), (r = void 0)),
      r || (r = a);
    const s = Buffer.byteLength(t),
      o = Buffer.byteLength(r),
      c = n.length,
      l = this._kex.sessionID,
      f = l.length,
      u = (i ? 4 + f : 0) + 1 + 4 + s + 4 + 14 + 4 + 9 + 1 + 4 + o + 4 + c;
    let d, p;
    if (
      (i
        ? ((d = Buffer.allocUnsafe(u)),
          (p = 0),
          fe(d, f, p),
          d.set(l, (p += 4)),
          (p += f))
        : ((d = this._packetRW.write.alloc(u)),
          (p = this._packetRW.write.allocStart)),
      (d[p] = et.USERAUTH_REQUEST),
      fe(d, s, ++p),
      d.utf8Write(t, (p += 4), s),
      fe(d, 14, (p += s)),
      d.utf8Write("ssh-connection", (p += 4), 14),
      fe(d, 9, (p += 14)),
      d.utf8Write("publickey", (p += 4), 9),
      (d[(p += 9)] = i ? 1 : 0),
      fe(d, o, ++p),
      d.utf8Write(r, (p += 4), o),
      fe(d, c, (p += o)),
      d.set(n, (p += 4)),
      !i)
    ) {
      this._authsQueue.push("publickey"),
        this._debug &&
          this._debug(
            "Outbound: Sending USERAUTH_REQUEST (publickey -- check)",
          ),
        tt(this, this._packetRW.write.finalize(d));
      return;
    }
    i(d, (h) => {
      if (((h = VA(h, a)), h === !1))
        throw new Error("Error while converting handshake signature");
      const m = h.length;
      (p = this._packetRW.write.allocStart),
        (d = this._packetRW.write.alloc(
          1 + 4 + s + 4 + 14 + 4 + 9 + 1 + 4 + o + 4 + c + 4 + 4 + o + 4 + m,
        )),
        (d[p] = et.USERAUTH_REQUEST),
        fe(d, s, ++p),
        d.utf8Write(t, (p += 4), s),
        fe(d, 14, (p += s)),
        d.utf8Write("ssh-connection", (p += 4), 14),
        fe(d, 9, (p += 14)),
        d.utf8Write("publickey", (p += 4), 9),
        (d[(p += 9)] = 1),
        fe(d, o, ++p),
        d.utf8Write(r, (p += 4), o),
        fe(d, c, (p += o)),
        d.set(n, (p += 4)),
        fe(d, 4 + o + 4 + m, (p += c)),
        fe(d, o, (p += 4)),
        d.utf8Write(r, (p += 4), o),
        fe(d, m, (p += o)),
        d.set(h, (p += 4)),
        this._authsQueue.push("publickey"),
        this._debug &&
          this._debug("Outbound: Sending USERAUTH_REQUEST (publickey)"),
        tt(this, this._packetRW.write.finalize(d));
    });
  }
  authHostbased(t, n, r, i, a, s) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    if (((n = KA(n)), n instanceof Error)) throw new Error("Invalid key");
    const o = n.type;
    (n = n.getPublicSSH()),
      typeof a == "function" && ((s = a), (a = void 0)),
      a || (a = o);
    const c = Buffer.byteLength(t),
      l = Buffer.byteLength(a),
      f = n.length,
      u = this._kex.sessionID,
      d = u.length,
      p = Buffer.byteLength(r),
      h = Buffer.byteLength(i),
      m = Buffer.allocUnsafe(
        4 + d + 1 + 4 + c + 4 + 14 + 4 + 9 + 4 + l + 4 + f + 4 + p + 4 + h,
      );
    let g = 0;
    fe(m, d, g),
      m.set(u, (g += 4)),
      (m[(g += d)] = et.USERAUTH_REQUEST),
      fe(m, c, ++g),
      m.utf8Write(t, (g += 4), c),
      fe(m, 14, (g += c)),
      m.utf8Write("ssh-connection", (g += 4), 14),
      fe(m, 9, (g += 14)),
      m.utf8Write("hostbased", (g += 4), 9),
      fe(m, l, (g += 9)),
      m.utf8Write(a, (g += 4), l),
      fe(m, f, (g += l)),
      m.set(n, (g += 4)),
      fe(m, p, (g += f)),
      m.utf8Write(r, (g += 4), p),
      fe(m, h, (g += p)),
      m.utf8Write(i, (g += 4), h),
      s(m, (v) => {
        if (((v = VA(v, o)), !v))
          throw new Error("Error while converting handshake signature");
        const y = v.length,
          _ = m.length - d - 4;
        g = this._packetRW.write.allocStart;
        const E = this._packetRW.write.alloc(_ + 4 + 4 + l + 4 + y);
        Tf(m, E, 4 + d, m.length, g),
          fe(E, 4 + l + 4 + y, (g += _)),
          fe(E, l, (g += 4)),
          E.utf8Write(a, (g += 4), l),
          fe(E, y, (g += l)),
          E.set(v, (g += 4)),
          this._authsQueue.push("hostbased"),
          this._debug &&
            this._debug("Outbound: Sending USERAUTH_REQUEST (hostbased)"),
          tt(this, this._packetRW.write.finalize(E));
      });
  }
  authKeyboard(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const n = Buffer.byteLength(t);
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + n + 4 + 14 + 4 + 20 + 4 + 4);
    (i[r] = et.USERAUTH_REQUEST),
      fe(i, n, ++r),
      i.utf8Write(t, (r += 4), n),
      fe(i, 14, (r += n)),
      i.utf8Write("ssh-connection", (r += 4), 14),
      fe(i, 20, (r += 14)),
      i.utf8Write("keyboard-interactive", (r += 4), 20),
      fe(i, 0, (r += 20)),
      fe(i, 0, (r += 4)),
      this._authsQueue.push("keyboard-interactive"),
      this._debug &&
        this._debug(
          "Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)",
        ),
      tt(this, this._packetRW.write.finalize(i));
  }
  authNone(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const n = Buffer.byteLength(t);
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + n + 4 + 14 + 4 + 4);
    (i[r] = et.USERAUTH_REQUEST),
      fe(i, n, ++r),
      i.utf8Write(t, (r += 4), n),
      fe(i, 14, (r += n)),
      i.utf8Write("ssh-connection", (r += 4), 14),
      fe(i, 4, (r += 14)),
      i.utf8Write("none", (r += 4), 4),
      this._authsQueue.push("none"),
      this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (none)"),
      tt(this, this._packetRW.write.finalize(i));
  }
  authInfoRes(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let n = 0,
      r;
    if (t) {
      r = new Array(t.length);
      for (let s = 0; s < t.length; ++s) {
        const o = Buffer.byteLength(t[s]);
        (r[s] = o), (n += 4 + o);
      }
    }
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + n);
    if (((a[i] = et.USERAUTH_INFO_RESPONSE), t)) {
      fe(a, t.length, ++i), (i += 4);
      for (let s = 0; s < t.length; ++s) {
        const o = r[s];
        fe(a, o, i), (i += 4), o && (a.utf8Write(t[s], i, o), (i += o));
      }
    } else fe(a, 0, ++i);
    this._debug && this._debug("Outbound: Sending USERAUTH_INFO_RESPONSE"),
      tt(this, this._packetRW.write.finalize(a));
  }
  tcpipForward(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(t);
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + i + 4);
    (s[a] = et.GLOBAL_REQUEST),
      fe(s, 13, ++a),
      s.utf8Write("tcpip-forward", (a += 4), 13),
      (s[(a += 13)] = r === void 0 || r === !0 ? 1 : 0),
      fe(s, i, ++a),
      s.utf8Write(t, (a += 4), i),
      fe(s, n, (a += i)),
      this._debug &&
        this._debug("Outbound: Sending GLOBAL_REQUEST (tcpip-forward)"),
      tt(this, this._packetRW.write.finalize(s));
  }
  cancelTcpipForward(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(t);
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + i + 4);
    (s[a] = et.GLOBAL_REQUEST),
      fe(s, 20, ++a),
      s.utf8Write("cancel-tcpip-forward", (a += 4), 20),
      (s[(a += 20)] = r === void 0 || r === !0 ? 1 : 0),
      fe(s, i, ++a),
      s.utf8Write(t, (a += 4), i),
      fe(s, n, (a += i)),
      this._debug &&
        this._debug("Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)"),
      tt(this, this._packetRW.write.finalize(s));
  }
  openssh_streamLocalForward(t, n) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + 31 + 1 + 4 + r);
    (a[i] = et.GLOBAL_REQUEST),
      fe(a, 31, ++i),
      a.utf8Write("streamlocal-forward@openssh.com", (i += 4), 31),
      (a[(i += 31)] = n === void 0 || n === !0 ? 1 : 0),
      fe(a, r, ++i),
      a.utf8Write(t, (i += 4), r),
      this._debug &&
        this._debug(
          "Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)",
        ),
      tt(this, this._packetRW.write.finalize(a));
  }
  openssh_cancelStreamLocalForward(t, n) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + 38 + 1 + 4 + r);
    (a[i] = et.GLOBAL_REQUEST),
      fe(a, 38, ++i),
      a.utf8Write("cancel-streamlocal-forward@openssh.com", (i += 4), 38),
      (a[(i += 38)] = n === void 0 || n === !0 ? 1 : 0),
      fe(a, r, ++i),
      a.utf8Write(t, (i += 4), r),
      this._debug &&
        this._debug(
          "Outbound: Sending GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)",
        ),
      tt(this, this._packetRW.write.finalize(a));
  }
  directTcpip(t, n, r, i) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const a = Buffer.byteLength(i.srcIP),
      s = Buffer.byteLength(i.dstIP);
    let o = this._packetRW.write.allocStart;
    const c = this._packetRW.write.alloc(
      1 + 4 + 12 + 4 + 4 + 4 + 4 + a + 4 + 4 + s + 4,
    );
    (c[o] = et.CHANNEL_OPEN),
      fe(c, 12, ++o),
      c.utf8Write("direct-tcpip", (o += 4), 12),
      fe(c, t, (o += 12)),
      fe(c, n, (o += 4)),
      fe(c, r, (o += 4)),
      fe(c, s, (o += 4)),
      c.utf8Write(i.dstIP, (o += 4), s),
      fe(c, i.dstPort, (o += s)),
      fe(c, a, (o += 4)),
      c.utf8Write(i.srcIP, (o += 4), a),
      fe(c, i.srcPort, (o += a)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_OPEN (r:${t}, direct-tcpip)`),
      tt(this, this._packetRW.write.finalize(c));
  }
  openssh_directStreamLocal(t, n, r, i) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const a = Buffer.byteLength(i.socketPath);
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(
      1 + 4 + 30 + 4 + 4 + 4 + 4 + a + 4 + 4,
    );
    (o[s] = et.CHANNEL_OPEN),
      fe(o, 30, ++s),
      o.utf8Write("direct-streamlocal@openssh.com", (s += 4), 30),
      fe(o, t, (s += 30)),
      fe(o, n, (s += 4)),
      fe(o, r, (s += 4)),
      fe(o, a, (s += 4)),
      o.utf8Write(i.socketPath, (s += 4), a),
      Tne(o, 0, (s += a), s + 8),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${t}, direct-streamlocal@openssh.com)`,
        ),
      tt(this, this._packetRW.write.finalize(o));
  }
  openssh_noMoreSessions(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let n = this._packetRW.write.allocStart;
    const r = this._packetRW.write.alloc(1 + 4 + 28 + 1);
    (r[n] = et.GLOBAL_REQUEST),
      fe(r, 28, ++n),
      r.utf8Write("no-more-sessions@openssh.com", (n += 4), 28),
      (r[(n += 28)] = t === void 0 || t === !0 ? 1 : 0),
      this._debug &&
        this._debug(
          "Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)",
        ),
      tt(this, this._packetRW.write.finalize(r));
  }
  session(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);
    (a[i] = et.CHANNEL_OPEN),
      fe(a, 7, ++i),
      a.utf8Write("session", (i += 4), 7),
      fe(a, t, (i += 7)),
      fe(a, n, (i += 4)),
      fe(a, r, (i += 4)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_OPEN (r:${t}, session)`),
      tt(this, this._packetRW.write.finalize(a));
  }
  windowChange(t, n, r, i, a) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);
    (o[s] = et.CHANNEL_REQUEST),
      fe(o, t, ++s),
      fe(o, 13, (s += 4)),
      o.utf8Write("window-change", (s += 4), 13),
      (o[(s += 13)] = 0),
      fe(o, r, ++s),
      fe(o, n, (s += 4)),
      fe(o, a, (s += 4)),
      fe(o, i, (s += 4)),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, window-change)`,
        ),
      tt(this, this._packetRW.write.finalize(o));
  }
  pty(t, n, r, i, a, s, o, c) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    (!s || !s.length) && (s = "vt100"),
      o &&
        !Buffer.isBuffer(o) &&
        !Array.isArray(o) &&
        typeof o == "object" &&
        o !== null &&
        (o = Wne(o)),
      (!o || !o.length) && (o = Fne);
    const l = s.length,
      f = o.length;
    let u = this._packetRW.write.allocStart;
    const d = this._packetRW.write.alloc(
      1 + 4 + 4 + 7 + 1 + 4 + l + 4 + 4 + 4 + 4 + 4 + f,
    );
    if (
      ((d[u] = et.CHANNEL_REQUEST),
      fe(d, t, ++u),
      fe(d, 7, (u += 4)),
      d.utf8Write("pty-req", (u += 4), 7),
      (d[(u += 7)] = c === void 0 || c === !0 ? 1 : 0),
      fe(d, l, ++u),
      d.utf8Write(s, (u += 4), l),
      fe(d, r, (u += l)),
      fe(d, n, (u += 4)),
      fe(d, a, (u += 4)),
      fe(d, i, (u += 4)),
      fe(d, f, (u += 4)),
      (u += 4),
      Array.isArray(o))
    )
      for (let p = 0; p < f; ++p) d[u++] = o[p];
    else Buffer.isBuffer(o) && d.set(o, u);
    this._debug &&
      this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${t}, pty-req)`),
      tt(this, this._packetRW.write.finalize(d));
  }
  shell(t, n) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);
    (i[r] = et.CHANNEL_REQUEST),
      fe(i, t, ++r),
      fe(i, 5, (r += 4)),
      i.utf8Write("shell", (r += 4), 5),
      (i[(r += 5)] = n === void 0 || n === !0 ? 1 : 0),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${t}, shell)`),
      tt(this, this._packetRW.write.finalize(i));
  }
  exec(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.isBuffer(n),
      a = i ? n.length : Buffer.byteLength(n);
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + a);
    (o[s] = et.CHANNEL_REQUEST),
      fe(o, t, ++s),
      fe(o, 4, (s += 4)),
      o.utf8Write("exec", (s += 4), 4),
      (o[(s += 4)] = r === void 0 || r === !0 ? 1 : 0),
      fe(o, a, ++s),
      i ? o.set(n, (s += 4)) : o.utf8Write(n, (s += 4), a),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${t}, exec: ${n})`),
      tt(this, this._packetRW.write.finalize(o));
  }
  signal(t, n) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const r = n;
    if (
      ((n = n.toUpperCase()),
      n.slice(0, 3) === "SIG" && (n = n.slice(3)),
      WA[n] !== 1)
    )
      throw new Error(`Invalid signal: ${r}`);
    const i = n.length;
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 4 + 6 + 1 + 4 + i);
    (s[a] = et.CHANNEL_REQUEST),
      fe(s, t, ++a),
      fe(s, 6, (a += 4)),
      s.utf8Write("signal", (a += 4), 6),
      (s[(a += 6)] = 0),
      fe(s, i, ++a),
      s.utf8Write(n, (a += 4), i),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${t}, signal: ${n})`),
      tt(this, this._packetRW.write.finalize(s));
  }
  env(t, n, r, i) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const a = Buffer.byteLength(n),
      s = Buffer.isBuffer(r),
      o = s ? r.length : Buffer.byteLength(r);
    let c = this._packetRW.write.allocStart;
    const l = this._packetRW.write.alloc(1 + 4 + 4 + 3 + 1 + 4 + a + 4 + o);
    (l[c] = et.CHANNEL_REQUEST),
      fe(l, t, ++c),
      fe(l, 3, (c += 4)),
      l.utf8Write("env", (c += 4), 3),
      (l[(c += 3)] = i === void 0 || i === !0 ? 1 : 0),
      fe(l, a, ++c),
      l.utf8Write(n, (c += 4), a),
      fe(l, o, (c += a)),
      s ? l.set(r, (c += 4)) : l.utf8Write(r, (c += 4), o),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, env: ${n}=${r})`,
        ),
      tt(this, this._packetRW.write.finalize(l));
  }
  x11Forward(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = n.protocol,
      a = n.cookie,
      s = Buffer.isBuffer(i),
      o = s ? i.length : Buffer.byteLength(i),
      c = Buffer.isBuffer(a),
      l = c ? a.length : Buffer.byteLength(a);
    let f = this._packetRW.write.allocStart;
    const u = this._packetRW.write.alloc(
      1 + 4 + 4 + 7 + 1 + 1 + 4 + o + 4 + l + 4,
    );
    (u[f] = et.CHANNEL_REQUEST),
      fe(u, t, ++f),
      fe(u, 7, (f += 4)),
      u.utf8Write("x11-req", (f += 4), 7),
      (u[(f += 7)] = r === void 0 || r === !0 ? 1 : 0),
      (u[++f] = n.single ? 1 : 0),
      fe(u, o, ++f),
      s ? u.set(i, (f += 4)) : u.utf8Write(i, (f += 4), o),
      fe(u, l, (f += o)),
      c ? u.set(a, (f += 4)) : u.latin1Write(a, (f += 4), l),
      fe(u, n.screen || 0, (f += l)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${t}, x11-req)`),
      tt(this, this._packetRW.write.finalize(u));
  }
  subsystem(t, n, r) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(n);
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + i);
    (s[a] = et.CHANNEL_REQUEST),
      fe(s, t, ++a),
      fe(s, 9, (a += 4)),
      s.utf8Write("subsystem", (a += 4), 9),
      (s[(a += 9)] = r === void 0 || r === !0 ? 1 : 0),
      fe(s, i, ++a),
      s.utf8Write(n, (a += 4), i),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, subsystem: ${n})`,
        ),
      tt(this, this._packetRW.write.finalize(s));
  }
  openssh_agentForward(t, n) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);
    (i[r] = et.CHANNEL_REQUEST),
      fe(i, t, ++r),
      fe(i, 26, (r += 4)),
      i.utf8Write("auth-agent-req@openssh.com", (r += 4), 26),
      (i[(r += 26)] = n === void 0 || n === !0 ? 1 : 0),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, auth-agent-req@openssh.com)`,
        ),
      tt(this, this._packetRW.write.finalize(i));
  }
  openssh_hostKeysProve(t) {
    if (this._server)
      throw new Error("Client-only method called in server mode");
    let n = 0;
    const r = [];
    for (const s of t) {
      const o = s.getPublicSSH();
      (n += 4 + o.length), r.push(o);
    }
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + 29 + 1 + n);
    (a[i] = et.GLOBAL_REQUEST),
      fe(a, 29, ++i),
      a.utf8Write("hostkeys-prove-00@openssh.com", (i += 4), 29),
      (a[(i += 29)] = 1),
      ++i;
    for (const s of r)
      fe(a, s.length, i), Tf(s, a, 0, s.length, (i += 4)), (i += s.length);
    this._debug &&
      this._debug(
        "Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)",
      ),
      tt(this, this._packetRW.write.finalize(a));
  }
  serviceAccept(t) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const n = Buffer.byteLength(t);
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + n);
    if (
      ((i[r] = et.SERVICE_ACCEPT),
      fe(i, n, ++r),
      i.utf8Write(t, (r += 4), n),
      this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${t})`),
      tt(this, this._packetRW.write.finalize(i)),
      this._server && this._banner && t === "ssh-userauth")
    ) {
      const a = this._banner;
      this._banner = void 0;
      const s = Buffer.byteLength(a);
      r = this._packetRW.write.allocStart;
      const o = this._packetRW.write.alloc(1 + 4 + s + 4);
      (o[r] = et.USERAUTH_BANNER),
        fe(o, s, ++r),
        o.utf8Write(a, (r += 4), s),
        fe(o, 0, (r += s)),
        this._debug && this._debug("Outbound: Sending USERAUTH_BANNER"),
        tt(this, this._packetRW.write.finalize(o));
    }
  }
  forwardedTcpip(t, n, r, i) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const a = Buffer.byteLength(i.boundAddr),
      s = Buffer.byteLength(i.remoteAddr);
    let o = this._packetRW.write.allocStart;
    const c = this._packetRW.write.alloc(
      1 + 4 + 15 + 4 + 4 + 4 + 4 + a + 4 + 4 + s + 4,
    );
    (c[o] = et.CHANNEL_OPEN),
      fe(c, 15, ++o),
      c.utf8Write("forwarded-tcpip", (o += 4), 15),
      fe(c, t, (o += 15)),
      fe(c, n, (o += 4)),
      fe(c, r, (o += 4)),
      fe(c, a, (o += 4)),
      c.utf8Write(i.boundAddr, (o += 4), a),
      fe(c, i.boundPort, (o += a)),
      fe(c, s, (o += 4)),
      c.utf8Write(i.remoteAddr, (o += 4), s),
      fe(c, i.remotePort, (o += s)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_OPEN (r:${t}, forwarded-tcpip)`),
      tt(this, this._packetRW.write.finalize(c));
  }
  x11(t, n, r, i) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const a = Buffer.byteLength(i.originAddr);
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(1 + 4 + 3 + 4 + 4 + 4 + 4 + a + 4);
    (o[s] = et.CHANNEL_OPEN),
      fe(o, 3, ++s),
      o.utf8Write("x11", (s += 4), 3),
      fe(o, t, (s += 3)),
      fe(o, n, (s += 4)),
      fe(o, r, (s += 4)),
      fe(o, a, (s += 4)),
      o.utf8Write(i.originAddr, (s += 4), a),
      fe(o, i.originPort, (s += a)),
      this._debug &&
        this._debug(`Outbound: Sending CHANNEL_OPEN (r:${t}, x11)`),
      tt(this, this._packetRW.write.finalize(o));
  }
  openssh_authAgent(t, n, r) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    let i = this._packetRW.write.allocStart;
    const a = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);
    (a[i] = et.CHANNEL_OPEN),
      fe(a, 22, ++i),
      a.utf8Write("auth-agent@openssh.com", (i += 4), 22),
      fe(a, t, (i += 22)),
      fe(a, n, (i += 4)),
      fe(a, r, (i += 4)),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${t}, auth-agent@openssh.com)`,
        ),
      tt(this, this._packetRW.write.finalize(a));
  }
  openssh_forwardedStreamLocal(t, n, r, i) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const a = Buffer.byteLength(i.socketPath);
    let s = this._packetRW.write.allocStart;
    const o = this._packetRW.write.alloc(1 + 4 + 33 + 4 + 4 + 4 + 4 + a + 4);
    (o[s] = et.CHANNEL_OPEN),
      fe(o, 33, ++s),
      o.utf8Write("forwarded-streamlocal@openssh.com", (s += 4), 33),
      fe(o, t, (s += 33)),
      fe(o, n, (s += 4)),
      fe(o, r, (s += 4)),
      fe(o, a, (s += 4)),
      o.utf8Write(i.socketPath, (s += 4), a),
      fe(o, 0, (s += a)),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${t}, forwarded-streamlocal@openssh.com)`,
        ),
      tt(this, this._packetRW.write.finalize(o));
  }
  exitStatus(t, n) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);
    (i[r] = et.CHANNEL_REQUEST),
      fe(i, t, ++r),
      fe(i, 11, (r += 4)),
      i.utf8Write("exit-status", (r += 4), 11),
      (i[(r += 11)] = 0),
      fe(i, n, ++r),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, exit-status: ${n})`,
        ),
      tt(this, this._packetRW.write.finalize(i));
  }
  exitSignal(t, n, r, i) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const a = n;
    if (typeof a != "string" || !a) throw new Error(`Invalid signal: ${a}`);
    let s = n.toUpperCase();
    if ((s.slice(0, 3) === "SIG" && (s = s.slice(3)), WA[s] !== 1))
      throw new Error(`Invalid signal: ${a}`);
    const o = Buffer.byteLength(s),
      c = i ? Buffer.byteLength(i) : 0;
    let l = this._packetRW.write.allocStart;
    const f = this._packetRW.write.alloc(
      1 + 4 + 4 + 11 + 1 + 4 + o + 1 + 4 + c + 4,
    );
    (f[l] = et.CHANNEL_REQUEST),
      fe(f, t, ++l),
      fe(f, 11, (l += 4)),
      f.utf8Write("exit-signal", (l += 4), 11),
      (f[(l += 11)] = 0),
      fe(f, o, ++l),
      f.utf8Write(s, (l += 4), o),
      (f[(l += o)] = r ? 1 : 0),
      fe(f, c, ++l),
      (l += 4),
      c && (f.utf8Write(i, l, c), (l += c)),
      fe(f, 0, l),
      this._debug &&
        this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${t}, exit-signal: ${n})`,
        ),
      tt(this, this._packetRW.write.finalize(f));
  }
  authFailure(t, n) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    if (this._authsQueue.length === 0) throw new Error("No auth in progress");
    let r;
    if ((typeof t == "boolean" && ((n = t), (t = void 0)), t)) {
      r = [];
      for (let o = 0; o < t.length; ++o)
        t[o].toLowerCase() !== "none" && r.push(t[o]);
      r = r.join(",");
    } else r = "";
    const i = r.length;
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + i + 1);
    (s[a] = et.USERAUTH_FAILURE),
      fe(s, i, ++a),
      s.utf8Write(r, (a += 4), i),
      (s[(a += i)] = n === !0 ? 1 : 0),
      this._authsQueue.shift(),
      this._debug && this._debug("Outbound: Sending USERAUTH_FAILURE"),
      tt(this, this._packetRW.write.finalize(s));
  }
  authSuccess() {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    if (this._authsQueue.length === 0) throw new Error("No auth in progress");
    const t = this._packetRW.write.allocStart,
      n = this._packetRW.write.alloc(1);
    (n[t] = et.USERAUTH_SUCCESS),
      this._authsQueue.shift(),
      (this._authenticated = !0),
      this._debug && this._debug("Outbound: Sending USERAUTH_SUCCESS"),
      tt(this, this._packetRW.write.finalize(n)),
      this._kex.negotiated.cs.compress === "zlib@openssh.com" &&
        (this._packetRW.read = new $k()),
      this._kex.negotiated.sc.compress === "zlib@openssh.com" &&
        (this._packetRW.write = new Ck(this));
  }
  authPKOK(t, n) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    if (this._authsQueue.length === 0 || this._authsQueue[0] !== "publickey")
      throw new Error('"publickey" auth not in progress');
    const r = Buffer.byteLength(t),
      i = n.length;
    let a = this._packetRW.write.allocStart;
    const s = this._packetRW.write.alloc(1 + 4 + r + 4 + i);
    (s[a] = et.USERAUTH_PK_OK),
      fe(s, r, ++a),
      s.utf8Write(t, (a += 4), r),
      fe(s, i, (a += r)),
      s.set(n, (a += 4)),
      this._authsQueue.shift(),
      this._debug && this._debug("Outbound: Sending USERAUTH_PK_OK"),
      tt(this, this._packetRW.write.finalize(s));
  }
  authPasswdChg(t) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    const n = Buffer.byteLength(t);
    let r = this._packetRW.write.allocStart;
    const i = this._packetRW.write.alloc(1 + 4 + n + 4);
    (i[r] = et.USERAUTH_PASSWD_CHANGEREQ),
      fe(i, n, ++r),
      i.utf8Write(t, (r += 4), n),
      fe(i, 0, (r += n)),
      this._debug && this._debug("Outbound: Sending USERAUTH_PASSWD_CHANGEREQ"),
      tt(this, this._packetRW.write.finalize(i));
  }
  authInfoReq(t, n, r) {
    if (!this._server)
      throw new Error("Server-only method called in client mode");
    let i = 0;
    const a = t ? Buffer.byteLength(t) : 0,
      s = n ? Buffer.byteLength(n) : 0;
    for (let l = 0; l < r.length; ++l)
      i += 4 + Buffer.byteLength(r[l].prompt) + 1;
    let o = this._packetRW.write.allocStart;
    const c = this._packetRW.write.alloc(1 + 4 + a + 4 + s + 4 + 4 + i);
    (c[o] = et.USERAUTH_INFO_REQUEST),
      fe(c, a, ++o),
      (o += 4),
      t && (c.utf8Write(t, o, a), (o += a)),
      fe(c, s, o),
      (o += 4),
      n && (c.utf8Write(n, o, s), (o += s)),
      fe(c, 0, o),
      fe(c, r.length, (o += 4)),
      (o += 4);
    for (let l = 0; l < r.length; ++l) {
      const f = r[l],
        u = Buffer.byteLength(f.prompt);
      fe(c, u, o),
        (o += 4),
        u && (c.utf8Write(f.prompt, o, u), (o += u)),
        (c[o++] = f.echo ? 1 : 0);
    }
    this._debug && this._debug("Outbound: Sending USERAUTH_INFO_REQUEST"),
      tt(this, this._packetRW.write.finalize(c));
  }
};
const Mne = /^SSH-(2\.0|1\.99)-([^ ]+)(?: (.*))?$/;
function Hne(e, t, n) {
  let r, i;
  this._buffer
    ? ((r = Buffer.allocUnsafe(this._buffer.length + (n - t))),
      r.set(this._buffer, 0),
      t === 0
        ? r.set(e, this._buffer.length)
        : r.set(
            new Uint8Array(e.buffer, e.byteOffset + t, n - t),
            this._buffer.length,
          ),
      (i = this._buffer.length),
      (t = 0))
    : ((r = e), (i = 0));
  const a = t;
  let s = t,
    o = t,
    c = !1,
    l = 0,
    f = 0;
  for (; t < r.length; ++t) {
    const u = r[t];
    if (u === 13) {
      c = !0;
      continue;
    }
    if (u === 10) {
      if (
        o > s &&
        o - s > 4 &&
        r[s] === 83 &&
        r[s + 1] === 83 &&
        r[s + 2] === 72 &&
        r[s + 3] === 45
      ) {
        const d = r.latin1Slice(a, o + 1),
          p = s === a ? d : d.slice(s - a),
          h = Mne.exec(p);
        if (!h) throw new Error("Invalid identification string");
        const m = {
          greeting: s === a ? "" : d.slice(0, s - a),
          identRaw: p,
          versions: { protocol: h[1], software: h[2] },
          comments: h[3],
        };
        return (
          (this._remoteIdentRaw = Buffer.from(p)),
          this._debug && this._debug(`Remote ident: ${xk(p)}`),
          (this._compatFlags = Qne(m)),
          (this._buffer = void 0),
          (this._decipher = new Ane(0, Rne.bind(this, { firstPacket: !0 }))),
          (this._parse = qne),
          this._onHeader(m),
          this._destruct ? (Sk(this), t + 1 - i) : n
        );
      }
      if (this._server) throw new Error("Greetings from clients not permitted");
      if (++f > Une) throw new Error("Max greeting lines exceeded");
      (c = !1), (s = t + 1), (l = 0);
    } else {
      if (c) throw new Error("Invalid header: expected newline");
      if (++l >= Bne) throw new Error("Header line too long");
    }
    o = t;
  }
  return this._buffer || (this._buffer = Ik(r, a)), t - i;
}
function qne(e, t, n) {
  return this._decipher.decrypt(e, t, n);
}
function Gne(e) {
  if ((this._onPacket(), e.length === 0)) {
    this._debug && this._debug("Inbound: Skipping empty packet payload");
    return;
  }
  e = this._packetRW.read.read(e);
  const t = e[0];
  t === et.USERAUTH_SUCCESS &&
    !this._server &&
    !this._authenticated &&
    ((this._authenticated = !0),
    this._kex.negotiated.cs.compress === "zlib@openssh.com" &&
      (this._packetRW.write = new Ck(this)),
    this._kex.negotiated.sc.compress === "zlib@openssh.com" &&
      (this._packetRW.read = new $k()));
  const n = kne[t];
  if (n === void 0) {
    this._debug && this._debug(`Inbound: Unsupported message type: ${t}`);
    return;
  }
  return n(this, e);
}
function Qne(e) {
  const t = e.versions.software;
  let n = 0;
  for (const r of Sne)
    typeof r[0] == "string"
      ? t === r[0] && (n |= r[1])
      : r[0].test(t) && (n |= r[1]);
  return n;
}
function Wne(e) {
  const t = Object.keys(e),
    n = Buffer.allocUnsafe(5 * t.length + 1);
  let r = 0;
  for (let i = 0; i < t.length; ++i) {
    const a = t[i];
    if (a === "TTY_OP_END") continue;
    const s = H0[a];
    if (s === void 0) continue;
    const o = e[a];
    typeof o == "number" &&
      isFinite(o) &&
      ((n[r++] = s),
      (n[r++] = o >>> 24),
      (n[r++] = o >>> 16),
      (n[r++] = o >>> 8),
      (n[r++] = o));
  }
  return (n[r++] = H0.TTY_OP_END), r < n.length ? Ik(n, 0, r) : n;
}
function zne(e) {
  let t =
    "ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss";
  Ine && (t = `ssh-ed25519,${t}`);
  const n = Buffer.byteLength(t);
  let r = e._packetRW.write.allocStart;
  const i = e._packetRW.write.alloc(1 + 4 + 4 + 15 + 4 + n);
  (i[r] = et.EXT_INFO),
    fe(i, 1, ++r),
    fe(i, 15, (r += 4)),
    i.utf8Write("server-sig-algs", (r += 4), 15),
    fe(i, n, (r += 15)),
    i.utf8Write(t, (r += 4), n),
    e._debug && e._debug("Outbound: Sending EXT_INFO"),
    tt(e, e._packetRW.write.finalize(i));
}
var kk = jne,
  Su = {};
const Ld = gc,
  { inspect: Kne } = wr;
function XA(e) {
  let t = "",
    n = e.length;
  const r = e[0] === "-" ? 1 : 0;
  for (; n >= r + 4; n -= 3) t = `_${e.slice(n - 3, n)}${t}`;
  return `${e.slice(0, n)}${t}`;
}
function JA(e, t) {
  if (
    (Ld(typeof t == "string", "`thing` has to be of type string"),
    Array.isArray(e))
  ) {
    const n = e.length;
    return (
      Ld(n > 0, "At least one expected value needs to be specified"),
      (e = e.map((r) => String(r))),
      n > 2
        ? `one of ${t} ${e.slice(0, n - 1).join(", ")}, or ` + e[n - 1]
        : n === 2
        ? `one of ${t} ${e[0]} or ${e[1]}`
        : `of ${t} ${e[0]}`
    );
  }
  return `of ${t} ${String(e)}`;
}
Su.ERR_INTERNAL_ASSERTION = class Tk extends Error {
  constructor(t) {
    super(), Error.captureStackTrace(this, Tk);
    const n = `This is caused by either a bug in ssh2 or incorrect usage of ssh2 internals.
Please open an issue with this stack trace at https://github.com/mscdex/ssh2/issues
`;
    this.message =
      t === void 0
        ? n
        : `${t}
${n}`;
  }
};
const Vne = 2 ** 32,
  ZA = (() => {
    try {
      return new Function("return 2n ** 32n")();
    } catch {}
  })();
Su.ERR_OUT_OF_RANGE = class Nk extends RangeError {
  constructor(t, n, r, i) {
    super(),
      Error.captureStackTrace(this, Nk),
      Ld(n, 'Missing "range" argument');
    let a = i ? t : `The value of "${t}" is out of range.`,
      s;
    Number.isInteger(r) && Math.abs(r) > Vne
      ? (s = XA(String(r)))
      : typeof r == "bigint"
      ? ((s = String(r)), (r > ZA || r < -ZA) && (s = XA(s)), (s += "n"))
      : (s = Kne(r)),
      (a += ` It must be ${n}. Received ${s}`),
      (this.message = a);
  }
};
let Ok = class Pk extends TypeError {
  constructor(t, n, r) {
    super(),
      Error.captureStackTrace(this, Pk),
      Ld(typeof t == "string", "'name' must be a string");
    let i;
    typeof n == "string" && n.startsWith("not ")
      ? ((i = "must not be"), (n = n.replace(/^not /, "")))
      : (i = "must be");
    let a;
    if (t.endsWith(" argument")) a = `The ${t} ${i} ${JA(n, "type")}`;
    else {
      const s = t.includes(".") ? "property" : "argument";
      a = `The "${t}" ${s} ${i} ${JA(n, "type")}`;
    }
    (a += `. Received type ${typeof r}`), (this.message = a);
  }
};
Su.ERR_INVALID_ARG_TYPE = Ok;
Su.validateNumber = function (t, n) {
  if (typeof t != "number") throw new Ok(n, "number", t);
};
const Yne = Hi,
  Oa = Xt,
  { constants: Tr } = Oa,
  { Readable: Dk, Writable: a1 } = Kr,
  { inherits: Lk, isDate: q0 } = wr,
  Xne = Buffer[Symbol.species],
  {
    bufferCopy: Aa,
    bufferSlice: uc,
    makeBufferParser: Jne,
    writeUInt32BE: _e,
  } = Ki(),
  aa = {
    SIZE: 1,
    UIDGID: 2,
    PERMISSIONS: 4,
    ACMODTIME: 8,
    EXTENDED: 2147483648,
  },
  ut = Buffer.alloc(28),
  Dt = {
    OK: 0,
    EOF: 1,
    NO_SUCH_FILE: 2,
    PERMISSION_DENIED: 3,
    FAILURE: 4,
    BAD_MESSAGE: 5,
    NO_CONNECTION: 6,
    CONNECTION_LOST: 7,
    OP_UNSUPPORTED: 8,
  },
  Zne = new Map(Object.values(Dt).map((e) => [e, 1])),
  ere = {
    [Dt.OK]: "No error",
    [Dt.EOF]: "End of file",
    [Dt.NO_SUCH_FILE]: "No such file or directory",
    [Dt.PERMISSION_DENIED]: "Permission denied",
    [Dt.FAILURE]: "Failure",
    [Dt.BAD_MESSAGE]: "Bad message",
    [Dt.NO_CONNECTION]: "No connection",
    [Dt.CONNECTION_LOST]: "Connection lost",
    [Dt.OP_UNSUPPORTED]: "Operation unsupported",
  },
  st = {
    INIT: 1,
    OPEN: 3,
    CLOSE: 4,
    READ: 5,
    WRITE: 6,
    LSTAT: 7,
    FSTAT: 8,
    SETSTAT: 9,
    FSETSTAT: 10,
    OPENDIR: 11,
    READDIR: 12,
    REMOVE: 13,
    MKDIR: 14,
    RMDIR: 15,
    REALPATH: 16,
    STAT: 17,
    RENAME: 18,
    READLINK: 19,
    SYMLINK: 20,
    EXTENDED: 200,
  },
  Pr = {
    VERSION: 2,
    STATUS: 101,
    HANDLE: 102,
    DATA: 103,
    NAME: 104,
    ATTRS: 105,
    EXTENDED: 201,
  },
  nt = { READ: 1, WRITE: 2, APPEND: 4, CREAT: 8, TRUNC: 16, EXCL: 32 },
  eS = 2 * 1024,
  Vt = 2 ** 32 - 1,
  tre = Buffer.from([0, 0, 0, 5, st.INIT, 0, 0, 0, 3]),
  nre = Buffer.from([0, 0, 0, 5, Pr.VERSION, 0, 0, 0, 3]),
  rre = /^SSH-2.0-(?:OpenSSH|dropbear)/,
  ng = 256 * 1024,
  me = Jne(),
  ire = {
    readable: !1,
    writable: !1,
    push: (e) => {},
    once: () => {},
    on: () => {},
    emit: () => {},
    end: () => {},
  };
function Bk() {}
let are = class extends Yne {
  constructor(t, n, r) {
    super(), (typeof r != "object" || !r) && (r = {});
    const i = t._protocol._remoteIdentRaw;
    (this.server = !!r.server),
      (this._debug = typeof r.debug == "function" ? r.debug : void 0),
      (this._isOpenSSH = i && rre.test(i)),
      (this._version = -1),
      (this._extensions = {}),
      (this._biOpt = r.biOpt),
      (this._pktLenBytes = 0),
      (this._pktLen = 0),
      (this._pktPos = 0),
      (this._pktType = 0),
      (this._pktData = void 0),
      (this._writeReqid = -1),
      (this._requests = {}),
      (this._maxInPktLen = ng),
      (this._maxOutPktLen = 34e3),
      (this._maxReadLen = (this._isOpenSSH ? ng : 34e3) - eS),
      (this._maxWriteLen = (this._isOpenSSH ? ng : 34e3) - eS),
      (this.maxOpenHandles = void 0),
      (this._client = t),
      (this._protocol = t._protocol),
      (this._callbacks = []),
      (this._hasX11 = !1),
      (this._exit = {
        code: void 0,
        signal: void 0,
        dump: void 0,
        desc: void 0,
      }),
      (this._waitWindow = !1),
      (this._chunkcb = void 0),
      (this._buffer = []),
      (this.type = n.type),
      (this.subtype = void 0),
      (this.incoming = n.incoming),
      (this.outgoing = n.outgoing),
      (this.stderr = ire),
      (this.readable = !0);
  }
  push(t) {
    if (t === null) {
      if ((Hk(this), !this.readable)) return;
      (this.readable = !1), this.emit("end");
      return;
    }
    let n = 0;
    for (; n < t.length; ) {
      if (this._pktLenBytes < 4) {
        let s = Math.min(4 - this._pktLenBytes, t.length - n);
        for (this._pktLenBytes += s; s--; )
          this._pktLen = (this._pktLen << 8) + t[n++];
        if (this._pktLenBytes < 4) return;
        if (this._pktLen === 0) return Bt(this, "Invalid packet length");
        if (this._pktLen > this._maxInPktLen) {
          const o = this._maxInPktLen;
          return Bt(
            this,
            `Packet length ${this._pktLen} exceeds max length of ${o}`,
          );
        }
        if (n >= t.length) return;
      }
      if (this._pktPos < this._pktLen) {
        const s = Math.min(this._pktLen - this._pktPos, t.length - n);
        if (
          (n !== 0 || s !== t.length
            ? s === this._pktLen
              ? (this._pkt = new Xne(t.buffer, t.byteOffset + n, s))
              : (this._pkt || (this._pkt = Buffer.allocUnsafe(this._pktLen)),
                this._pkt.set(
                  new Uint8Array(t.buffer, t.byteOffset + n, s),
                  this._pktPos,
                ))
            : s === this._pktLen
            ? (this._pkt = t)
            : (this._pkt || (this._pkt = Buffer.allocUnsafe(this._pktLen)),
              this._pkt.set(t, this._pktPos)),
          (n += s),
          (this._pktPos += s),
          this._pktPos < this._pktLen)
        )
          return;
      }
      const r = this._pkt[0],
        i = this._pkt;
      (this._pktLen = 0),
        (this._pktLenBytes = 0),
        (this._pkt = void 0),
        (this._pktPos = 0);
      const a = this.server ? ure[r] : lre[r];
      if (!a) return Bt(this, `Unknown packet type ${r}`);
      if (this._version === -1) {
        if (this.server) {
          if (r !== st.INIT) return Bt(this, `Expected INIT packet, got ${r}`);
        } else if (r !== Pr.VERSION)
          return Bt(this, `Expected VERSION packet, got ${r}`);
      }
      if (a(this, i) === !1) return;
    }
  }
  end() {
    this.destroy();
  }
  destroy() {
    (this.outgoing.state === "open" || this.outgoing.state === "eof") &&
      ((this.outgoing.state = "closing"),
      this._protocol.channelClose(this.outgoing.id));
  }
  _init() {
    (this._init = Bk), this.server || Tt(this, tre);
  }
  createReadStream(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    return new va(this, t, n);
  }
  createWriteStream(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    return new ti(this, t, n);
  }
  open(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    typeof r == "function" && ((i = r), (r = void 0));
    const a = typeof n == "number" ? n : jk(n);
    if (a === null) throw new Error(`Unknown flags string: ${n}`);
    let s = 0,
      o = 0;
    (typeof r == "string" || typeof r == "number") && (r = { mode: r }),
      typeof r == "object" &&
        r !== null &&
        ((r = ds(r)), (s = r.flags), (o = r.nb));
    const c = Buffer.byteLength(t);
    let l = 9;
    const f = Buffer.allocUnsafe(4 + 1 + 4 + 4 + c + 4 + 4 + o);
    _e(f, f.length - 4, 0), (f[4] = st.OPEN);
    const u = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(f, u, 5),
      _e(f, c, l),
      f.utf8Write(t, (l += 4), c),
      _e(f, a, (l += c)),
      _e(f, s, (l += 4)),
      o &&
        ((l += 4),
        o === ut.length ? f.set(ut, l) : Aa(ut, f, 0, o, l),
        (l += o)),
      (this._requests[u] = { cb: i });
    const d = Tt(this, f);
    this._debug &&
      this._debug(`SFTP: Outbound: ${d ? "Buffered" : "Sending"} OPEN`);
  }
  close(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    const r = t.length;
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.CLOSE);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.set(t, (i += 4)),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} CLOSE`);
  }
  read(t, n, r, i, a, s) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    if (!Buffer.isBuffer(n)) throw new Error("buffer is not a Buffer");
    if (r >= n.length) throw new Error("offset is out of bounds");
    if (r + i > n.length) throw new Error("length extends beyond buffer");
    if (a === null) throw new Error("null position currently unsupported");
    Uk(this, t, n, r, i, a, s);
  }
  readData(t, n, r, i, a, s) {
    this.read(t, n, r, i, a, s);
  }
  write(t, n, r, i, a, s) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    if (!Buffer.isBuffer(n)) throw new Error("buffer is not a Buffer");
    if (r > n.length) throw new Error("offset is out of bounds");
    if (r + i > n.length) throw new Error("length extends beyond buffer");
    if (a === null) throw new Error("null position currently unsupported");
    if (!i) {
      s && process.nextTick(s, void 0, 0);
      return;
    }
    const o = this._maxWriteLen,
      c = Math.max(i - o, 0),
      l = a;
    c && (i = o);
    const f = t.length;
    let u = 9;
    const d = Buffer.allocUnsafe(4 + 1 + 4 + 4 + f + 8 + 4 + i);
    _e(d, d.length - 4, 0), (d[4] = st.WRITE);
    const p = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(d, p, 5), _e(d, f, u), d.set(t, (u += 4)), (u += f);
    for (let m = 7; m >= 0; --m) (d[u + m] = a & 255), (a /= 256);
    _e(d, i, (u += 8)),
      Aa(n, d, r, r + i, (u += 4)),
      (this._requests[p] = {
        cb: (m) => {
          m
            ? typeof s == "function" && s(m)
            : c
            ? this.write(t, n, r + i, c, l + i, s)
            : typeof s == "function" && s(void 0, r + i);
        },
      });
    const h = Tt(this, d);
    if (this._debug) {
      const m = h ? "Sent" : "Buffered";
      this._debug(`SFTP: Outbound: ${m} WRITE (id:${p})`);
    }
  }
  writeData(t, n, r, i, a, s) {
    this.write(t, n, r, i, a, s);
  }
  fastGet(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    tS(this, Oa, t, n, r, i);
  }
  fastPut(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    tS(Oa, this, t, n, r, i);
  }
  readFile(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let i;
    if (
      (typeof r == "function"
        ? (i = r)
        : typeof n == "function" && ((i = n), (n = void 0)),
      typeof n == "string")
    )
      n = { encoding: n, flag: "r" };
    else if (!n) n = { encoding: null, flag: "r" };
    else if (typeof n != "object") throw new TypeError("Bad arguments");
    const a = n.encoding;
    if (a && !Buffer.isEncoding(a)) throw new Error(`Unknown encoding: ${a}`);
    let s,
      o,
      c,
      l = 0,
      f,
      u = 0;
    const d = n.flag || "r",
      p = () => {
        s === 0
          ? ((o = Buffer.allocUnsafe(8192)), this.read(f, o, 0, 8192, u, h))
          : this.read(f, o, l, s - l, u, h);
      },
      h = (g, v) => {
        let y;
        if (g) {
          if (((y = g.code === Dt.EOF), !y))
            return this.close(f, () => i && i(g));
        } else y = !1;
        if (y || (s === 0 && v === 0)) return m();
        (u += v),
          (l += v),
          s !== 0 ? (l === s ? m() : p()) : (c.push(uc(o, 0, v)), p());
      };
    h._wantEOFError = !0;
    const m = () => {
      this.close(
        f,
        (g) => (
          s === 0 ? (o = Buffer.concat(c, l)) : l < s && (o = uc(o, 0, l)),
          a && (o = o.toString(a)),
          i && i(g, o)
        ),
      );
    };
    this.open(t, d, 438, (g, v) => {
      if (g) return i && i(g);
      f = v;
      const y = (_, E) => {
        if (_) {
          this.stat(t, (R, A) => {
            if (R)
              return this.close(f, () => {
                i && i(_);
              });
            y(null, A);
          });
          return;
        }
        if (((s = E.size || 0), s === 0)) return (c = []), p();
        (o = Buffer.allocUnsafe(s)), p();
      };
      this.fstat(f, y);
    });
  }
  writeFile(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let a;
    if (
      (typeof i == "function"
        ? (a = i)
        : typeof r == "function" && ((a = r), (r = void 0)),
      typeof r == "string")
    )
      r = { encoding: r, mode: 438, flag: "w" };
    else if (!r) r = { encoding: "utf8", mode: 438, flag: "w" };
    else if (typeof r != "object") throw new TypeError("Bad arguments");
    if (r.encoding && !Buffer.isEncoding(r.encoding))
      throw new Error(`Unknown encoding: ${r.encoding}`);
    const s = r.flag || "w";
    this.open(t, s, r.mode, (o, c) => {
      if (o) a && a(o);
      else {
        const l = Buffer.isBuffer(n)
            ? n
            : Buffer.from("" + n, r.encoding || "utf8"),
          f = /a/.test(s) ? null : 0;
        if (f === null) {
          const u = (d, p) => {
            if (d) {
              this.stat(t, (h, m) => {
                if (h)
                  return this.close(c, () => {
                    a && a(d);
                  });
                u(null, m);
              });
              return;
            }
            G0(this, c, l, 0, l.length, p.size, a);
          };
          this.fstat(c, u);
          return;
        }
        G0(this, c, l, 0, l.length, f, a);
      }
    });
  }
  appendFile(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let a;
    if (
      (typeof i == "function"
        ? (a = i)
        : typeof r == "function" && ((a = r), (r = void 0)),
      typeof r == "string")
    )
      r = { encoding: r, mode: 438, flag: "a" };
    else if (!r) r = { encoding: "utf8", mode: 438, flag: "a" };
    else if (typeof r != "object") throw new TypeError("Bad arguments");
    r.flag || (r = Object.assign({ flag: "a" }, r)), this.writeFile(t, n, r, a);
  }
  exists(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    this.stat(t, (r) => {
      n && n(!r);
    });
  }
  unlink(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.REMOVE);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} REMOVE`);
  }
  rename(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(t),
      a = Buffer.byteLength(n);
    let s = 9;
    const o = Buffer.allocUnsafe(4 + 1 + 4 + 4 + i + 4 + a);
    _e(o, o.length - 4, 0), (o[4] = st.RENAME);
    const c = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(o, c, 5),
      _e(o, i, s),
      o.utf8Write(t, (s += 4), i),
      _e(o, a, (s += i)),
      o.utf8Write(n, (s += 4), a),
      (this._requests[c] = { cb: r });
    const l = Tt(this, o);
    this._debug &&
      this._debug(`SFTP: Outbound: ${l ? "Buffered" : "Sending"} RENAME`);
  }
  mkdir(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let i = 0,
      a = 0;
    typeof n == "function" && ((r = n), (n = void 0)),
      typeof n == "object" &&
        n !== null &&
        ((n = ds(n)), (i = n.flags), (a = n.nb));
    const s = Buffer.byteLength(t);
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + s + 4 + a);
    _e(c, c.length - 4, 0), (c[4] = st.MKDIR);
    const l = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(c, l, 5),
      _e(c, s, o),
      c.utf8Write(t, (o += 4), s),
      _e(c, i, (o += s)),
      a &&
        ((o += 4),
        a === ut.length ? c.set(ut, o) : Aa(ut, c, 0, a, o),
        (o += a)),
      (this._requests[l] = { cb: r });
    const f = Tt(this, c);
    this._debug &&
      this._debug(`SFTP: Outbound: ${f ? "Buffered" : "Sending"} MKDIR`);
  }
  rmdir(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.RMDIR);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} RMDIR`);
  }
  readdir(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    typeof n == "function" && ((r = n), (n = {})),
      (typeof n != "object" || n === null) && (n = {});
    const i = !(n && n.full);
    if (!Buffer.isBuffer(t) && typeof t != "string")
      throw new Error("missing directory handle or path");
    if (typeof t == "string") {
      const f = [];
      let u = 0;
      const d = (p, h) => {
        if (p) return r(p);
        this.readdir(h, n, (m, g) => {
          const v = m && m.code === Dt.EOF;
          if (m && !v) return this.close(h, () => r(m));
          if (v)
            return this.close(h, (y) => {
              if (y) return r(y);
              r(void 0, f);
            });
          for (let y = 0; y < g.length; ++y, ++u) f[u] = g[y];
          d(void 0, h);
        });
      };
      return this.opendir(t, d);
    }
    const a = t.length;
    let s = 9;
    const o = Buffer.allocUnsafe(4 + 1 + 4 + 4 + a);
    _e(o, o.length - 4, 0), (o[4] = st.READDIR);
    const c = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(o, c, 5),
      _e(o, a, s),
      o.set(t, (s += 4)),
      (this._requests[c] = {
        cb: i
          ? (f, u) => {
              if (typeof r == "function") {
                if (f) return r(f);
                for (let d = u.length - 1; d >= 0; --d)
                  (u[d].filename === "." || u[d].filename === "..") &&
                    u.splice(d, 1);
                r(void 0, u);
              }
            }
          : r,
      });
    const l = Tt(this, o);
    this._debug &&
      this._debug(`SFTP: Outbound: ${l ? "Buffered" : "Sending"} READDIR`);
  }
  fstat(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    const r = t.length;
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.FSTAT);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.set(t, (i += 4)),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} FSTAT`);
  }
  stat(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.STAT);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} STAT`);
  }
  lstat(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.LSTAT);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} LSTAT`);
  }
  opendir(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.OPENDIR);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = { cb: n });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} OPENDIR`);
  }
  setstat(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    let i = 0,
      a = 0;
    typeof n == "object" && n !== null
      ? ((n = ds(n)), (i = n.flags), (a = n.nb))
      : typeof n == "function" && (r = n);
    const s = Buffer.byteLength(t);
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + s + 4 + a);
    _e(c, c.length - 4, 0), (c[4] = st.SETSTAT);
    const l = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(c, l, 5),
      _e(c, s, o),
      c.utf8Write(t, (o += 4), s),
      _e(c, i, (o += s)),
      a &&
        ((o += 4),
        a === ut.length ? c.set(ut, o) : Aa(ut, c, 0, a, o),
        (o += a)),
      (this._requests[l] = { cb: r });
    const f = Tt(this, c);
    this._debug &&
      this._debug(`SFTP: Outbound: ${f ? "Buffered" : "Sending"} SETSTAT`);
  }
  fsetstat(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    let i = 0,
      a = 0;
    typeof n == "object" && n !== null
      ? ((n = ds(n)), (i = n.flags), (a = n.nb))
      : typeof n == "function" && (r = n);
    const s = t.length;
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + s + 4 + a);
    _e(c, c.length - 4, 0), (c[4] = st.FSETSTAT);
    const l = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(c, l, 5),
      _e(c, s, o),
      c.set(t, (o += 4)),
      _e(c, i, (o += s)),
      a &&
        ((o += 4),
        a === ut.length ? c.set(ut, o) : Aa(ut, c, 0, a, o),
        (o += a)),
      (this._requests[l] = { cb: r });
    const f = Tt(this, c);
    this._debug &&
      this._debug(`SFTP: Outbound: ${f ? "Buffered" : "Sending"} FSETSTAT`);
  }
  futimes(t, n, r, i) {
    return this.fsetstat(t, { atime: To(n), mtime: To(r) }, i);
  }
  utimes(t, n, r, i) {
    return this.setstat(t, { atime: To(n), mtime: To(r) }, i);
  }
  fchown(t, n, r, i) {
    return this.fsetstat(t, { uid: n, gid: r }, i);
  }
  chown(t, n, r, i) {
    return this.setstat(t, { uid: n, gid: r }, i);
  }
  fchmod(t, n, r) {
    return this.fsetstat(t, { mode: n }, r);
  }
  chmod(t, n, r) {
    return this.setstat(t, { mode: n }, r);
  }
  readlink(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.READLINK);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = {
        cb: (c, l) => {
          if (typeof n == "function") {
            if (c) return n(c);
            if (!l || !l.length)
              return n(new Error("Response missing link info"));
            n(void 0, l[0].filename);
          }
        },
      });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} READLINK`);
  }
  symlink(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const i = Buffer.byteLength(n),
      a = Buffer.byteLength(t);
    let s = 9;
    const o = Buffer.allocUnsafe(4 + 1 + 4 + 4 + i + 4 + a);
    _e(o, o.length - 4, 0), (o[4] = st.SYMLINK);
    const c = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(o, c, 5),
      this._isOpenSSH
        ? (_e(o, a, s),
          o.utf8Write(t, (s += 4), a),
          _e(o, i, (s += a)),
          o.utf8Write(n, (s += 4), i))
        : (_e(o, i, s),
          o.utf8Write(n, (s += 4), i),
          _e(o, a, (s += i)),
          o.utf8Write(t, (s += 4), a)),
      (this._requests[c] = { cb: r });
    const l = Tt(this, o);
    this._debug &&
      this._debug(`SFTP: Outbound: ${l ? "Buffered" : "Sending"} SYMLINK`);
  }
  realpath(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = Buffer.byteLength(t);
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0), (a[4] = st.REALPATH);
    const s = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(a, s, 5),
      _e(a, r, i),
      a.utf8Write(t, (i += 4), r),
      (this._requests[s] = {
        cb: (c, l) => {
          if (typeof n == "function") {
            if (c) return n(c);
            if (!l || !l.length)
              return n(new Error("Response missing path info"));
            n(void 0, l[0].filename);
          }
        },
      });
    const o = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} REALPATH`);
  }
  ext_openssh_rename(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const i = this._extensions["posix-rename@openssh.com"];
    if (!i || i !== "1")
      throw new Error("Server does not support this extended request");
    const a = Buffer.byteLength(t),
      s = Buffer.byteLength(n);
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + a + 4 + s);
    _e(c, c.length - 4, 0), (c[4] = st.EXTENDED);
    const l = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(c, l, 5),
      _e(c, 24, o),
      c.utf8Write("posix-rename@openssh.com", (o += 4), 24),
      _e(c, a, (o += 24)),
      c.utf8Write(t, (o += 4), a),
      _e(c, s, (o += a)),
      c.utf8Write(n, (o += 4), s),
      (this._requests[l] = { cb: r });
    const f = Tt(this, c);
    if (this._debug) {
      const u = f ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${u} posix-rename@openssh.com`);
    }
  }
  ext_openssh_statvfs(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = this._extensions["statvfs@openssh.com"];
    if (!r || r !== "2")
      throw new Error("Server does not support this extended request");
    const i = Buffer.byteLength(t);
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + i);
    _e(s, s.length - 4, 0), (s[4] = st.EXTENDED);
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, 5),
      _e(s, 19, a),
      s.utf8Write("statvfs@openssh.com", (a += 4), 19),
      _e(s, i, (a += 19)),
      s.utf8Write(t, (a += 4), i),
      (this._requests[o] = { extended: "statvfs@openssh.com", cb: n });
    const c = Tt(this, s);
    if (this._debug) {
      const l = c ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${l} statvfs@openssh.com`);
    }
  }
  ext_openssh_fstatvfs(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    const r = this._extensions["fstatvfs@openssh.com"];
    if (!r || r !== "2")
      throw new Error("Server does not support this extended request");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    const i = t.length;
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + i);
    _e(s, s.length - 4, 0), (s[4] = st.EXTENDED);
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, 5),
      _e(s, 20, a),
      s.utf8Write("fstatvfs@openssh.com", (a += 4), 20),
      _e(s, i, (a += 20)),
      s.set(t, (a += 4)),
      (this._requests[o] = { extended: "fstatvfs@openssh.com", cb: n });
    const c = Tt(this, s);
    if (this._debug) {
      const l = c ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${l} fstatvfs@openssh.com`);
    }
  }
  ext_openssh_hardlink(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["hardlink@openssh.com"] !== "1")
      throw new Error("Server does not support this extended request");
    const a = Buffer.byteLength(t),
      s = Buffer.byteLength(n);
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + a + 4 + s);
    _e(c, c.length - 4, 0), (c[4] = st.EXTENDED);
    const l = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(c, l, 5),
      _e(c, 20, o),
      c.utf8Write("hardlink@openssh.com", (o += 4), 20),
      _e(c, a, (o += 20)),
      c.utf8Write(t, (o += 4), a),
      _e(c, s, (o += a)),
      c.utf8Write(n, (o += 4), s),
      (this._requests[l] = { cb: r });
    const f = Tt(this, c);
    if (this._debug) {
      const u = f ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${u} hardlink@openssh.com`);
    }
  }
  ext_openssh_fsync(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["fsync@openssh.com"] !== "1")
      throw new Error("Server does not support this extended request");
    if (!Buffer.isBuffer(t)) throw new Error("handle is not a Buffer");
    const i = t.length;
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + i);
    _e(s, s.length - 4, 0), (s[4] = st.EXTENDED);
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, 5),
      _e(s, 17, a),
      s.utf8Write("fsync@openssh.com", (a += 4), 17),
      _e(s, i, (a += 17)),
      s.set(t, (a += 4)),
      (this._requests[o] = { cb: n });
    const c = Tt(this, s);
    this._debug &&
      this._debug(
        `SFTP: Outbound: ${c ? "Buffered" : "Sending"} fsync@openssh.com`,
      );
  }
  ext_openssh_lsetstat(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["lsetstat@openssh.com"] !== "1")
      throw new Error("Server does not support this extended request");
    let a = 0,
      s = 0;
    typeof n == "object" && n !== null
      ? ((n = ds(n)), (a = n.flags), (s = n.nb))
      : typeof n == "function" && (r = n);
    const o = Buffer.byteLength(t);
    let c = 9;
    const l = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + o + 4 + s);
    _e(l, l.length - 4, 0), (l[4] = st.EXTENDED);
    const f = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(l, f, 5),
      _e(l, 20, c),
      l.utf8Write("lsetstat@openssh.com", (c += 4), 20),
      _e(l, o, (c += 20)),
      l.utf8Write(t, (c += 4), o),
      _e(l, a, (c += o)),
      s &&
        ((c += 4),
        s === ut.length ? l.set(ut, c) : Aa(ut, l, 0, s, c),
        (c += s)),
      (this._requests[f] = { cb: r });
    const u = Tt(this, l);
    if (this._debug) {
      const d = u ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${d} lsetstat@openssh.com`);
    }
  }
  ext_openssh_expandPath(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["expand-path@openssh.com"] !== "1")
      throw new Error("Server does not support this extended request");
    const i = Buffer.byteLength(t);
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + i);
    _e(s, s.length - 4, 0), (s[4] = st.EXTENDED);
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, 5),
      _e(s, 23, a),
      s.utf8Write("expand-path@openssh.com", (a += 4), 23),
      _e(s, i, (a += 20)),
      s.utf8Write(t, (a += 4), i),
      (this._requests[o] = {
        cb: (l, f) => {
          if (typeof n == "function") {
            if (l) return n(l);
            if (!f || !f.length)
              return n(new Error("Response missing expanded path"));
            n(void 0, f[0].filename);
          }
        },
      });
    const c = Tt(this, s);
    if (this._debug) {
      const l = c ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${l} expand-path@openssh.com`);
    }
  }
  ext_copy_data(t, n, r, i, a, s) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["copy-data"] !== "1")
      throw new Error("Server does not support this extended request");
    if (!Buffer.isBuffer(t)) throw new Error("Source handle is not a Buffer");
    if (!Buffer.isBuffer(i))
      throw new Error("Destination handle is not a Buffer");
    let c = 0;
    const l = Buffer.allocUnsafe(
      4 + 1 + 4 + 4 + 9 + 4 + t.length + 8 + 8 + 4 + i.length + 8,
    );
    _e(l, l.length - 4, c), (c += 4), (l[c] = st.EXTENDED), ++c;
    const f = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(l, f, c),
      (c += 4),
      _e(l, 9, c),
      (c += 4),
      l.utf8Write("copy-data", c, 9),
      (c += 9),
      _e(l, t.length, c),
      (c += 4),
      l.set(t, c),
      (c += t.length);
    for (let d = 7; d >= 0; --d) (l[c + d] = n & 255), (n /= 256);
    c += 8;
    for (let d = 7; d >= 0; --d) (l[c + d] = r & 255), (r /= 256);
    (c += 8), _e(l, i.length, c), (c += 4), l.set(i, c), (c += i.length);
    for (let d = 7; d >= 0; --d) (l[c + d] = a & 255), (a /= 256);
    this._requests[f] = { cb: s };
    const u = Tt(this, l);
    if (this._debug) {
      const d = u ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${d} copy-data`);
    }
  }
  ext_home_dir(t, n) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["home-directory"] !== "1")
      throw new Error("Server does not support this extended request");
    if (typeof t != "string") throw new TypeError("username is not a string");
    let i = 0;
    const a = Buffer.byteLength(t),
      s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 14 + 4 + a);
    _e(s, s.length - 4, i), (i += 4), (s[i] = st.EXTENDED), ++i;
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, i),
      (i += 4),
      _e(s, 14, i),
      (i += 4),
      s.utf8Write("home-directory", i, 14),
      (i += 14),
      _e(s, a, i),
      (i += 4),
      s.utf8Write(t, i, a),
      (i += a),
      (this._requests[o] = {
        cb: (l, f) => {
          if (typeof n == "function") {
            if (l) return n(l);
            if (!f || !f.length)
              return n(new Error("Response missing home directory"));
            n(void 0, f[0].filename);
          }
        },
      });
    const c = Tt(this, s);
    if (this._debug) {
      const l = c ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${l} home-directory`);
    }
  }
  ext_users_groups(t, n, r) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    if (this._extensions["users-groups-by-id@openssh.com"] !== "1")
      throw new Error("Server does not support this extended request");
    if (!Array.isArray(t)) throw new TypeError("uids is not an array");
    for (const l of t)
      if (!Number.isInteger(l) || l < 0 || l > 2 ** 32 - 1)
        throw new Error("uid values must all be 32-bit unsigned integers");
    if (!Array.isArray(n)) throw new TypeError("gids is not an array");
    for (const l of n)
      if (!Number.isInteger(l) || l < 0 || l > 2 ** 32 - 1)
        throw new Error("gid values must all be 32-bit unsigned integers");
    let a = 0;
    const s = Buffer.allocUnsafe(
      4 + 1 + 4 + 4 + 30 + 4 + 4 * t.length + 4 + 4 * n.length,
    );
    _e(s, s.length - 4, a), (a += 4), (s[a] = st.EXTENDED), ++a;
    const o = (this._writeReqid = (this._writeReqid + 1) & Vt);
    _e(s, o, a),
      (a += 4),
      _e(s, 30, a),
      (a += 4),
      s.utf8Write("users-groups-by-id@openssh.com", a, 30),
      (a += 30),
      _e(s, 4 * t.length, a),
      (a += 4);
    for (const l of t) _e(s, l, a), (a += 4);
    _e(s, 4 * n.length, a), (a += 4);
    for (const l of n) _e(s, l, a), (a += 4);
    this._requests[o] = { extended: "users-groups-by-id@openssh.com", cb: r };
    const c = Tt(this, s);
    if (this._debug) {
      const l = c ? "Buffered" : "Sending";
      this._debug(`SFTP: Outbound: ${l} users-groups-by-id@openssh.com`);
    }
  }
  handle(t, n) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (!Buffer.isBuffer(n)) throw new Error("handle is not a Buffer");
    const r = n.length;
    if (r > 256) throw new Error("handle too large (> 256 bytes)");
    let i = 9;
    const a = Buffer.allocUnsafe(4 + 1 + 4 + 4 + r);
    _e(a, a.length - 4, 0),
      (a[4] = Pr.HANDLE),
      _e(a, t, 5),
      _e(a, r, i),
      r && a.set(n, (i += 4));
    const s = Tt(this, a);
    this._debug &&
      this._debug(`SFTP: Outbound: ${s ? "Buffered" : "Sending"} HANDLE`);
  }
  status(t, n, r) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (!Zne.has(n)) throw new Error(`Bad status code: ${n}`);
    r || (r = "");
    const i = Buffer.byteLength(r);
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + i + 4);
    _e(s, s.length - 4, 0),
      (s[4] = Pr.STATUS),
      _e(s, t, 5),
      _e(s, n, a),
      _e(s, i, (a += 4)),
      (a += 4),
      i && (s.utf8Write(r, a, i), (a += i)),
      _e(s, 0, a);
    const o = Tt(this, s);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} STATUS`);
  }
  data(t, n, r) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    const i = Buffer.isBuffer(n);
    if (!i && typeof n != "string")
      throw new Error("data is not a Buffer or string");
    let a;
    !i && !r && ((r = void 0), (a = !0));
    const s = i ? n.length : Buffer.byteLength(n, r);
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + s);
    _e(c, c.length - 4, 0),
      (c[4] = Pr.DATA),
      _e(c, t, 5),
      _e(c, s, o),
      s &&
        (i
          ? c.set(n, (o += 4))
          : a
          ? c.utf8Write(n, (o += 4), s)
          : c.write(n, (o += 4), s, r));
    const l = Tt(this, c);
    this._debug &&
      this._debug(`SFTP: Outbound: ${l ? "Buffered" : "Sending"} DATA`);
  }
  name(t, n) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (!Array.isArray(n)) {
      if (typeof n != "object" || n === null)
        throw new Error("names is not an object or array");
      n = [n];
    }
    const r = n.length;
    let i = 0,
      a;
    const s = [];
    for (let f = 0; f < r; ++f) {
      const u = n[f],
        d =
          !u || !u.filename || typeof u.filename != "string" ? "" : u.filename;
      i += 4 + Buffer.byteLength(d);
      const p =
        !u || !u.longname || typeof u.longname != "string" ? "" : u.longname;
      if (
        ((i += 4 + Buffer.byteLength(p)),
        typeof u.attrs == "object" && u.attrs !== null)
      ) {
        if (((a = ds(u.attrs)), (i += 4 + a.nb), a.nb)) {
          let h;
          a.nb === ut.length
            ? (h = new Uint8Array(ut))
            : ((h = new Uint8Array(a.nb)), Aa(ut, h, 0, a.nb, 0)),
            (a.bytes = h);
        }
        s.push(a);
      } else (i += 4), s.push(null);
    }
    let o = 9;
    const c = Buffer.allocUnsafe(4 + 1 + 4 + 4 + i);
    _e(c, c.length - 4, 0),
      (c[4] = Pr.NAME),
      _e(c, t, 5),
      _e(c, r, o),
      (o += 4);
    for (let f = 0; f < r; ++f) {
      const u = n[f];
      {
        const p =
            !u || !u.filename || typeof u.filename != "string"
              ? ""
              : u.filename,
          h = Buffer.byteLength(p);
        _e(c, h, o), (o += 4), h && (c.utf8Write(p, o, h), (o += h));
      }
      {
        const p =
            !u || !u.longname || typeof u.longname != "string"
              ? ""
              : u.longname,
          h = Buffer.byteLength(p);
        _e(c, h, o), (o += 4), h && (c.utf8Write(p, o, h), (o += h));
      }
      const d = s[f];
      d
        ? (_e(c, d.flags, o),
          (o += 4),
          d.flags && d.bytes && (c.set(d.bytes, o), (o += d.nb)))
        : (_e(c, 0, o), (o += 4));
    }
    const l = Tt(this, c);
    this._debug &&
      this._debug(`SFTP: Outbound: ${l ? "Buffered" : "Sending"} NAME`);
  }
  attrs(t, n) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    if (typeof n != "object" || n === null)
      throw new Error("attrs is not an object");
    n = ds(n);
    const r = n.flags,
      i = n.nb;
    let a = 9;
    const s = Buffer.allocUnsafe(4 + 1 + 4 + 4 + i);
    _e(s, s.length - 4, 0),
      (s[4] = Pr.ATTRS),
      _e(s, t, 5),
      _e(s, r, a),
      i &&
        ((a += 4),
        i === ut.length ? s.set(ut, a) : Aa(ut, s, 0, i, a),
        (a += i));
    const o = Tt(this, s);
    this._debug &&
      this._debug(`SFTP: Outbound: ${o ? "Buffered" : "Sending"} ATTRS`);
  }
};
function sre(e) {
  try {
    return Buffer.allocUnsafe(e);
  } catch (t) {
    return t;
  }
}
function Uk(e, t, n, r, i, a, s, o) {
  const c = e._maxReadLen,
    l = Math.max(i - c, 0);
  l && (i = c);
  const f = t.length;
  let u = 9,
    d = a;
  const p = Buffer.allocUnsafe(4 + 1 + 4 + 4 + f + 8 + 4);
  _e(p, p.length - 4, 0), (p[4] = st.READ);
  const h = (e._writeReqid = (e._writeReqid + 1) & Vt);
  _e(p, h, 5), _e(p, f, u), p.set(t, (u += 4)), (u += f);
  for (let v = 7; v >= 0; --v) (p[u + v] = d & 255), (d /= 256);
  _e(p, i, (u += 8)), typeof s != "function" && (s = Bk);
  const m = o || {
    nb: 0,
    position: a,
    off: r,
    origOff: r,
    len: void 0,
    overflow: void 0,
    cb: (v, y, _) => {
      const E = m.len,
        R = m.overflow;
      if (v) {
        if (s._wantEOFError || v.code !== Dt.EOF) return s(v);
      } else {
        if (_ > E) return s(new Error("Received more data than requested"));
        if (_ === E && R) {
          (m.nb += _),
            (m.position += _),
            (m.off += _),
            Uk(e, t, n, m.off, R, m.position, s, m);
          return;
        }
      }
      (_ = _ || 0),
        m.origOff === 0 && n.length === m.nb
          ? (y = n)
          : (y = uc(n, m.origOff, m.origOff + m.nb + _)),
        s(void 0, m.nb + _, y, m.position);
    },
    buffer: void 0,
  };
  (m.len = i),
    (m.overflow = l),
    (m.buffer = uc(n, r, r + i)),
    (e._requests[h] = m);
  const g = Tt(e, p);
  e._debug && e._debug(`SFTP: Outbound: ${g ? "Buffered" : "Sending"} READ`);
}
function tS(e, t, n, r, i, a) {
  let s = 64,
    o = 32768,
    c,
    l,
    f;
  typeof i == "function"
    ? (a = i)
    : typeof i == "object" &&
      i !== null &&
      (typeof i.concurrency == "number" &&
        i.concurrency > 0 &&
        !isNaN(i.concurrency) &&
        (s = i.concurrency),
      typeof i.chunkSize == "number" &&
        i.chunkSize > 0 &&
        !isNaN(i.chunkSize) &&
        (o = i.chunkSize),
      typeof i.fileSize == "number" &&
        i.fileSize > 0 &&
        !isNaN(i.fileSize) &&
        (f = i.fileSize),
      typeof i.step == "function" && (c = i.step),
      (typeof i.mode == "string" || typeof i.mode == "number") &&
        (l = s1(i.mode)));
  let u,
    d = 0,
    p = 0,
    h = !1,
    m,
    g,
    v,
    y = o * s;
  function _(E) {
    if (h) return;
    h = !0;
    let R = 0,
      A;
    m || g
      ? ((A = () => {
          --R === 0 && a(E);
        }),
        m && (e === Oa || e.outgoing.state === "open") && ++R,
        g && (t === Oa || t.outgoing.state === "open") && ++R,
        m && (e === Oa || e.outgoing.state === "open") && e.close(m, A),
        g && (t === Oa || t.outgoing.state === "open") && t.close(g, A))
      : a(E);
  }
  e.open(n, "r", (E, R) => {
    if (E) return _(E);
    (m = R), f === void 0 ? e.fstat(m, A) : A(null, { size: f });
    function A(I, S) {
      if (I) {
        if (e !== Oa) {
          e.stat(n, (w, O) => {
            if (w) return _(I);
            A(null, O);
          });
          return;
        }
        return _(I);
      }
      (u = S.size),
        t.open(r, "w", (w, O) => {
          if (w) return _(w);
          if (((g = O), u <= 0)) return _();
          for (; y > u; ) {
            if (s === 1) {
              y = u;
              break;
            }
            (y -= o), --s;
          }
          if (((v = sre(y)), v instanceof Error)) return _(v);
          l !== void 0
            ? t.fchmod(g, l, function J(Z) {
                if (Z) {
                  t.chmod(r, l, (z) => J());
                  return;
                }
                q();
              })
            : q();
          function Q(J, Z, z, U, G, L) {
            if (J) return _(J);
            (G = G || 0), t.write(g, v, G, Z, U, k);
            function k(W) {
              if (W) return _(W);
              if (((p += Z), c && c(p, Z, u), Z < L)) return H(G, U + Z, L - Z);
              if (p === u) {
                t.close(g, (x) => {
                  if (((g = void 0), x)) return _(x);
                  e.close(m, (T) => {
                    if (((m = void 0), T)) return _(T);
                    a();
                  });
                });
                return;
              }
              if (d >= u) return;
              const F = d + o > u ? u - d : o;
              H(G, d, F), (d += F);
            }
          }
          function j(J, Z, z) {
            return (U, G, L) => {
              Q(U, G, L, Z, J, z);
            };
          }
          function H(J, Z, z) {
            e.read(m, v, J, z, Z, j(J, Z, z));
          }
          function q() {
            let J = 0,
              Z = 0;
            for (; d < u && J < s; ) {
              const z = d + o > u ? u - d : o;
              H(Z, d, z), (Z += z), (d += z), ++J;
            }
          }
        });
    }
  });
}
function G0(e, t, n, r, i, a, s) {
  const o = typeof s == "function" ? s : void 0;
  e.write(t, n, r, i, a, (c, l) => {
    if (c)
      return e.close(t, () => {
        o && o(c);
      });
    l === i
      ? e.close(t, o)
      : ((r += l), (i -= l), (a += l), G0(e, t, n, r, i, a, o));
  });
}
class Fk {
  constructor(t) {
    (this.mode = t && t.mode),
      (this.uid = t && t.uid),
      (this.gid = t && t.gid),
      (this.size = t && t.size),
      (this.atime = t && t.atime),
      (this.mtime = t && t.mtime),
      (this.extended = t && t.extended);
  }
  isDirectory() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFDIR;
  }
  isFile() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFREG;
  }
  isBlockDevice() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFBLK;
  }
  isCharacterDevice() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFCHR;
  }
  isSymbolicLink() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFLNK;
  }
  isFIFO() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFIFO;
  }
  isSocket() {
    return (this.mode & Tr.S_IFMT) === Tr.S_IFSOCK;
  }
}
function ds(e) {
  let t = 0,
    n = 0;
  if (typeof e == "object" && e !== null) {
    if (typeof e.size == "number") {
      t |= aa.SIZE;
      const r = e.size;
      (ut[n++] = r / 72057594037927940),
        (ut[n++] = r / 281474976710656),
        (ut[n++] = r / 1099511627776),
        (ut[n++] = r / 4294967296),
        (ut[n++] = r / 16777216),
        (ut[n++] = r / 65536),
        (ut[n++] = r / 256),
        (ut[n++] = r);
    }
    if (typeof e.uid == "number" && typeof e.gid == "number") {
      t |= aa.UIDGID;
      const r = e.uid,
        i = e.gid;
      (ut[n++] = r >>> 24),
        (ut[n++] = r >>> 16),
        (ut[n++] = r >>> 8),
        (ut[n++] = r),
        (ut[n++] = i >>> 24),
        (ut[n++] = i >>> 16),
        (ut[n++] = i >>> 8),
        (ut[n++] = i);
    }
    if (typeof e.mode == "number" || typeof e.mode == "string") {
      const r = s1(e.mode);
      (t |= aa.PERMISSIONS),
        (ut[n++] = r >>> 24),
        (ut[n++] = r >>> 16),
        (ut[n++] = r >>> 8),
        (ut[n++] = r);
    }
    if (
      (typeof e.atime == "number" || q0(e.atime)) &&
      (typeof e.mtime == "number" || q0(e.mtime))
    ) {
      const r = To(e.atime),
        i = To(e.mtime);
      (t |= aa.ACMODTIME),
        (ut[n++] = r >>> 24),
        (ut[n++] = r >>> 16),
        (ut[n++] = r >>> 8),
        (ut[n++] = r),
        (ut[n++] = i >>> 24),
        (ut[n++] = i >>> 16),
        (ut[n++] = i >>> 8),
        (ut[n++] = i);
    }
  }
  return { flags: t, nb: n };
}
function To(e) {
  if (typeof e == "number" && e === e) return e;
  if (q0(e)) return parseInt(e.getTime() / 1e3, 10);
  throw new Error(`Cannot parse time: ${e}`);
}
function s1(e) {
  if (typeof e == "number" && e === e) return e;
  if (typeof e == "string") return s1(parseInt(e, 8));
  throw new Error(`Cannot parse mode: ${e}`);
}
const Q0 = {
  r: nt.READ,
  "r+": nt.READ | nt.WRITE,
  w: nt.TRUNC | nt.CREAT | nt.WRITE,
  wx: nt.TRUNC | nt.CREAT | nt.WRITE | nt.EXCL,
  xw: nt.TRUNC | nt.CREAT | nt.WRITE | nt.EXCL,
  "w+": nt.TRUNC | nt.CREAT | nt.READ | nt.WRITE,
  "wx+": nt.TRUNC | nt.CREAT | nt.READ | nt.WRITE | nt.EXCL,
  "xw+": nt.TRUNC | nt.CREAT | nt.READ | nt.WRITE | nt.EXCL,
  a: nt.APPEND | nt.CREAT | nt.WRITE,
  ax: nt.APPEND | nt.CREAT | nt.WRITE | nt.EXCL,
  xa: nt.APPEND | nt.CREAT | nt.WRITE | nt.EXCL,
  "a+": nt.APPEND | nt.CREAT | nt.READ | nt.WRITE,
  "ax+": nt.APPEND | nt.CREAT | nt.READ | nt.WRITE | nt.EXCL,
  "xa+": nt.APPEND | nt.CREAT | nt.READ | nt.WRITE | nt.EXCL,
};
function jk(e) {
  const t = Q0[e];
  return t !== void 0 ? t : null;
}
const ore = (() => {
  const e = Object.keys(Q0);
  return (t) => {
    for (let n = 0; n < e.length; ++n) {
      const r = e[n];
      if (Q0[r] === t) return r;
    }
    return null;
  };
})();
function No(e) {
  const t = me.readUInt32BE();
  if (t === void 0) return;
  const n = new Fk();
  if (t & aa.SIZE) {
    const r = me.readUInt64BE(e);
    if (r === void 0) return;
    n.size = r;
  }
  if (t & aa.UIDGID) {
    const r = me.readUInt32BE(),
      i = me.readUInt32BE();
    if (i === void 0) return;
    (n.uid = r), (n.gid = i);
  }
  if (t & aa.PERMISSIONS) {
    const r = me.readUInt32BE();
    if (r === void 0) return;
    n.mode = r;
  }
  if (t & aa.ACMODTIME) {
    const r = me.readUInt32BE(),
      i = me.readUInt32BE();
    if (i === void 0) return;
    (n.atime = r), (n.mtime = i);
  }
  if (t & aa.EXTENDED) {
    const r = me.readUInt32BE();
    if (r === void 0) return;
    const i = {};
    for (let a = 0; a < r; ++a) {
      const s = me.readString(!0),
        o = me.readString();
      if (o === void 0) return;
      i[s] = o;
    }
    n.extended = i;
  }
  return n;
}
function Tt(e, t) {
  const n = Mk(e, t);
  return n !== void 0 ? (e._buffer.push(n), !1) : !0;
}
function Mk(e, t) {
  const n = e.outgoing;
  if (n.state !== "open") return;
  if (n.window === 0) return (e._waitWindow = !0), (e._chunkcb = nS), t;
  let r;
  const i = t.length;
  let a = 0;
  for (; i - a > 0 && n.window > 0; ) {
    const s = Math.min(i - a, n.window, n.packetSize);
    (n.window -= s),
      n.window === 0 && ((e._waitWindow = !0), (e._chunkcb = nS)),
      a === 0 && s === i
        ? e._protocol.channelData(e.outgoing.id, t)
        : e._protocol.channelData(e.outgoing.id, uc(t, a, a + s)),
      (a += s);
  }
  return i - a > 0 && (a > 0 ? (r = uc(t, a, i)) : (r = t)), r;
}
function nS() {
  this._chunkcb = void 0;
  const e = this._buffer;
  let t = 0;
  for (; t < e.length; ) {
    const n = e[t],
      r = Mk(this, n);
    if (r !== void 0) {
      r !== n && (e[t] = r), t > 0 && (this._buffer = e.slice(t));
      return;
    }
    ++t;
  }
  t > 0 && (this._buffer = []);
}
function Bt(e, t, n) {
  const r = new Error(t);
  return (
    (r.level = "sftp-protocol"),
    !n && e._debug && e._debug(`SFTP: Inbound: ${t}`),
    e.emit("error", r),
    e.destroy(),
    Hk(e),
    !1
  );
}
function Hk(e) {
  const t = Object.keys(e._requests);
  if (t.length === 0) return;
  const n = e._requests;
  e._requests = {};
  const r = new Error("No response from server");
  for (let i = 0; i < t.length; ++i) {
    const a = n[t[i]];
    typeof a.cb == "function" && a.cb(r);
  }
}
function cre(e, t) {
  let n = 9;
  const r = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);
  _e(r, r.length - 4, 0), (r[4] = st.EXTENDED);
  const i = (e._writeReqid = (e._writeReqid + 1) & Vt);
  _e(r, i, 5),
    _e(r, 18, n),
    r.utf8Write("limits@openssh.com", (n += 4), 18),
    (e._requests[i] = { extended: "limits@openssh.com", cb: t });
  const a = Tt(e, r);
  if (e._debug) {
    const s = a ? "Buffered" : "Sending";
    e._debug(`SFTP: Outbound: ${s} limits@openssh.com`);
  }
}
const lre = {
    [Pr.VERSION]: (e, t) => {
      if (e._version !== -1) return Bt(e, "Duplicate VERSION packet");
      const n = {};
      me.init(t, 1);
      let r = me.readUInt32BE();
      for (; me.avail(); ) {
        const i = me.readString(!0),
          a = me.readString(!0);
        if (a === void 0) {
          r = void 0;
          break;
        }
        n[i] = a;
      }
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed VERSION packet");
      if (e._debug) {
        const i = Object.keys(n);
        i.length
          ? e._debug(`SFTP: Inbound: Received VERSION (v${r}, exts:${i})`)
          : e._debug(`SFTP: Inbound: Received VERSION (v${r})`);
      }
      if (
        ((e._version = r), (e._extensions = n), n["limits@openssh.com"] === "1")
      )
        return cre(e, (i, a) => {
          i ||
            (a.maxPktLen > 0 && (e._maxOutPktLen = a.maxPktLen),
            a.maxReadLen > 0 && (e._maxReadLen = a.maxReadLen),
            a.maxWriteLen > 0 && (e._maxWriteLen = a.maxWriteLen),
            (e.maxOpenHandles =
              a.maxOpenHandles > 0 ? a.maxOpenHandles : 1 / 0)),
            e.emit("ready");
        });
      e.emit("ready");
    },
    [Pr.STATUS]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readUInt32BE(),
        i = me.readString(!0);
      if ((me.clear(), e._debug)) {
        const s = JSON.stringify(i);
        e._debug(`SFTP: Inbound: Received STATUS (id:${n}, ${r}, ${s})`);
      }
      const a = e._requests[n];
      if ((delete e._requests[n], a && typeof a.cb == "function")) {
        if (r === Dt.OK) {
          a.cb();
          return;
        }
        const s = new Error(i || ere[r] || "Unknown status");
        (s.code = r), a.cb(s);
      }
    },
    [Pr.HANDLE]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString();
      if ((me.clear(), r === void 0))
        return (
          n !== void 0 && delete e._requests[n],
          Bt(e, "Malformed HANDLE packet")
        );
      e._debug && e._debug(`SFTP: Inbound: Received HANDLE (id:${n})`);
      const i = e._requests[n];
      delete e._requests[n], i && typeof i.cb == "function" && i.cb(void 0, r);
    },
    [Pr.DATA]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE();
      let r;
      if (
        (n !== void 0 && ((r = e._requests[n]), delete e._requests[n]),
        r && typeof r.cb == "function")
      )
        if (r.buffer) {
          const i = me.readString(r.buffer);
          if ((me.clear(), i !== void 0)) {
            e._debug &&
              e._debug(`SFTP: Inbound: Received DATA (id:${n}, ${i})`),
              r.cb(void 0, r.buffer, i);
            return;
          }
        } else {
          const i = me.readString();
          if ((me.clear(), i !== void 0)) {
            e._debug &&
              e._debug(`SFTP: Inbound: Received DATA (id:${n}, ${i.length})`),
              r.cb(void 0, i);
            return;
          }
        }
      else {
        const i = me.skipString();
        if ((me.clear(), i !== void 0)) {
          e._debug && e._debug(`SFTP: Inbound: Received DATA (id:${n}, ${i})`);
          return;
        }
      }
      return Bt(e, "Malformed DATA packet");
    },
    [Pr.NAME]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE();
      let r;
      n !== void 0 && ((r = e._requests[n]), delete e._requests[n]);
      const i = me.readUInt32BE();
      if (i !== void 0) {
        let a = [];
        for (let s = 0; s < i; ++s) {
          const o = me.readString(!0),
            c = me.readString(!0),
            l = No(e._biOpt);
          if (l === void 0) {
            a = void 0;
            break;
          }
          a.push({ filename: o, longname: c, attrs: l });
        }
        if (a !== void 0) {
          e._debug &&
            e._debug(`SFTP: Inbound: Received NAME (id:${n}, ${a.length})`),
            me.clear(),
            r && typeof r.cb == "function" && r.cb(void 0, a);
          return;
        }
      }
      return me.clear(), Bt(e, "Malformed NAME packet");
    },
    [Pr.ATTRS]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE();
      let r;
      n !== void 0 && ((r = e._requests[n]), delete e._requests[n]);
      const i = No(e._biOpt);
      if ((me.clear(), i !== void 0)) {
        e._debug && e._debug(`SFTP: Inbound: Received ATTRS (id:${n})`),
          r && typeof r.cb == "function" && r.cb(void 0, i);
        return;
      }
      return Bt(e, "Malformed ATTRS packet");
    },
    [Pr.EXTENDED]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE();
      if (n !== void 0) {
        const r = e._requests[n];
        if (r)
          switch ((delete e._requests[n], r.extended)) {
            case "statvfs@openssh.com":
            case "fstatvfs@openssh.com": {
              const i = e._biOpt,
                a = {
                  f_bsize: me.readUInt64BE(i),
                  f_frsize: me.readUInt64BE(i),
                  f_blocks: me.readUInt64BE(i),
                  f_bfree: me.readUInt64BE(i),
                  f_bavail: me.readUInt64BE(i),
                  f_files: me.readUInt64BE(i),
                  f_ffree: me.readUInt64BE(i),
                  f_favail: me.readUInt64BE(i),
                  f_sid: me.readUInt64BE(i),
                  f_flag: me.readUInt64BE(i),
                  f_namemax: me.readUInt64BE(i),
                };
              if (a.f_namemax === void 0) break;
              e._debug &&
                e._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ${r.extended})`,
                ),
                me.clear(),
                typeof r.cb == "function" && r.cb(void 0, a);
              return;
            }
            case "limits@openssh.com": {
              const i = {
                maxPktLen: me.readUInt64BE(),
                maxReadLen: me.readUInt64BE(),
                maxWriteLen: me.readUInt64BE(),
                maxOpenHandles: me.readUInt64BE(),
              };
              if (i.maxOpenHandles === void 0) break;
              e._debug &&
                e._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ${r.extended})`,
                ),
                me.clear(),
                typeof r.cb == "function" && r.cb(void 0, i);
              return;
            }
            case "users-groups-by-id@openssh.com": {
              const i = me.readUInt32BE();
              if (i === void 0) break;
              const a = new Array(i);
              for (let c = 0; c < a.length; ++c) a[c] = me.readString(!0);
              const s = me.readUInt32BE();
              if (s === void 0) break;
              const o = new Array(s);
              for (let c = 0; c < o.length; ++c) o[c] = me.readString(!0);
              if (o.length > 0 && o[o.length - 1] === void 0) break;
              e._debug &&
                e._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ${r.extended})`,
                ),
                me.clear(),
                typeof r.cb == "function" && r.cb(void 0, a, o);
              return;
            }
            default:
              e._debug &&
                e._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ???)`,
                ),
                me.clear(),
                typeof r.cb == "function" && r.cb();
              return;
          }
        else {
          e._debug &&
            e._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${n}, ???)`),
            me.clear();
          return;
        }
      }
      return me.clear(), Bt(e, "Malformed EXTENDED_REPLY packet");
    },
  },
  ure = {
    [st.INIT]: (e, t) => {
      if (e._version !== -1) return Bt(e, "Duplicate INIT packet");
      const n = {};
      me.init(t, 1);
      let r = me.readUInt32BE();
      for (; me.avail(); ) {
        const i = me.readString(!0),
          a = me.readString(!0);
        if (a === void 0) {
          r = void 0;
          break;
        }
        n[i] = a;
      }
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed INIT packet");
      if (e._debug) {
        const i = Object.keys(n);
        i.length
          ? e._debug(`SFTP: Inbound: Received INIT (v${r}, exts:${i})`)
          : e._debug(`SFTP: Inbound: Received INIT (v${r})`);
      }
      Tt(e, nre), (e._version = r), (e._extensions = n), e.emit("ready");
    },
    [st.OPEN]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0),
        i = me.readUInt32BE(),
        a = No(e._biOpt);
      if ((me.clear(), a === void 0)) return Bt(e, "Malformed OPEN packet");
      e._debug && e._debug(`SFTP: Inbound: Received OPEN (id:${n})`),
        e.emit("OPEN", n, r, i, a) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.CLOSE]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString();
      if ((me.clear(), r === void 0 || r.length > 256))
        return Bt(e, "Malformed CLOSE packet");
      e._debug && e._debug(`SFTP: Inbound: Received CLOSE (id:${n})`),
        e.emit("CLOSE", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.READ]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(),
        i = me.readUInt64BE(e._biOpt),
        a = me.readUInt32BE();
      if ((me.clear(), a === void 0 || r.length > 256))
        return Bt(e, "Malformed READ packet");
      e._debug && e._debug(`SFTP: Inbound: Received READ (id:${n})`),
        e.emit("READ", n, r, i, a) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.WRITE]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(),
        i = me.readUInt64BE(e._biOpt),
        a = me.readString();
      if ((me.clear(), a === void 0 || r.length > 256))
        return Bt(e, "Malformed WRITE packet");
      e._debug && e._debug(`SFTP: Inbound: Received WRITE (id:${n})`),
        e.emit("WRITE", n, r, i, a) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.LSTAT]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed LSTAT packet");
      e._debug && e._debug(`SFTP: Inbound: Received LSTAT (id:${n})`),
        e.emit("LSTAT", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.FSTAT]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString();
      if ((me.clear(), r === void 0 || r.length > 256))
        return Bt(e, "Malformed FSTAT packet");
      e._debug && e._debug(`SFTP: Inbound: Received FSTAT (id:${n})`),
        e.emit("FSTAT", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.SETSTAT]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0),
        i = No(e._biOpt);
      if ((me.clear(), i === void 0)) return Bt(e, "Malformed SETSTAT packet");
      e._debug && e._debug(`SFTP: Inbound: Received SETSTAT (id:${n})`),
        e.emit("SETSTAT", n, r, i) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.FSETSTAT]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(),
        i = No(e._biOpt);
      if ((me.clear(), i === void 0 || r.length > 256))
        return Bt(e, "Malformed FSETSTAT packet");
      e._debug && e._debug(`SFTP: Inbound: Received FSETSTAT (id:${n})`),
        e.emit("FSETSTAT", n, r, i) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.OPENDIR]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed OPENDIR packet");
      e._debug && e._debug(`SFTP: Inbound: Received OPENDIR (id:${n})`),
        e.emit("OPENDIR", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.READDIR]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString();
      if ((me.clear(), r === void 0 || r.length > 256))
        return Bt(e, "Malformed READDIR packet");
      e._debug && e._debug(`SFTP: Inbound: Received READDIR (id:${n})`),
        e.emit("READDIR", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.REMOVE]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed REMOVE packet");
      e._debug && e._debug(`SFTP: Inbound: Received REMOVE (id:${n})`),
        e.emit("REMOVE", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.MKDIR]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0),
        i = No(e._biOpt);
      if ((me.clear(), i === void 0)) return Bt(e, "Malformed MKDIR packet");
      e._debug && e._debug(`SFTP: Inbound: Received MKDIR (id:${n})`),
        e.emit("MKDIR", n, r, i) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.RMDIR]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed RMDIR packet");
      e._debug && e._debug(`SFTP: Inbound: Received RMDIR (id:${n})`),
        e.emit("RMDIR", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.REALPATH]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed REALPATH packet");
      e._debug && e._debug(`SFTP: Inbound: Received REALPATH (id:${n})`),
        e.emit("REALPATH", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.STAT]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed STAT packet");
      e._debug && e._debug(`SFTP: Inbound: Received STAT (id:${n})`),
        e.emit("STAT", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.RENAME]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0),
        i = me.readString(!0);
      if ((me.clear(), i === void 0)) return Bt(e, "Malformed RENAME packet");
      e._debug && e._debug(`SFTP: Inbound: Received RENAME (id:${n})`),
        e.emit("RENAME", n, r, i) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.READLINK]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if ((me.clear(), r === void 0)) return Bt(e, "Malformed READLINK packet");
      e._debug && e._debug(`SFTP: Inbound: Received READLINK (id:${n})`),
        e.emit("READLINK", n, r) || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.SYMLINK]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0),
        i = me.readString(!0);
      if ((me.clear(), i === void 0)) return Bt(e, "Malformed SYMLINK packet");
      e._debug && e._debug(`SFTP: Inbound: Received SYMLINK (id:${n})`);
      let a;
      e._isOpenSSH
        ? (a = e.emit("SYMLINK", n, i, r))
        : (a = e.emit("SYMLINK", n, r, i)),
        a || e.status(n, Dt.OP_UNSUPPORTED);
    },
    [st.EXTENDED]: (e, t) => {
      me.init(t, 1);
      const n = me.readUInt32BE(),
        r = me.readString(!0);
      if (r === void 0) return me.clear(), Bt(e, "Malformed EXTENDED packet");
      let i;
      me.avail() && (i = me.readRaw()),
        me.clear(),
        e._debug && e._debug(`SFTP: Inbound: Received EXTENDED (id:${n})`),
        e.emit("EXTENDED", n, r, i) || e.status(n, Dt.OP_UNSUPPORTED);
    },
  },
  { ERR_INVALID_ARG_TYPE: fre, ERR_OUT_OF_RANGE: Xf, validateNumber: dre } = Su,
  rS = 128;
let yr;
const W0 = [];
function pre(e) {
  W0.length > 0 ? (yr = W0.pop()) : (yr = Buffer.allocUnsafe(e)), (yr.used = 0);
}
function z0(e, t) {
  if (!Number.isSafeInteger(e))
    throw (
      (dre(e, t),
      Number.isInteger(e)
        ? new Xf(t, ">= 0 and <= 2 ** 53 - 1", e)
        : new Xf(t, "an integer", e))
    );
  if (e < 0) throw new Xf(t, ">= 0 and <= 2 ** 53 - 1", e);
}
function rg(e) {
  return (e + 7) & -8;
}
function va(e, t, n) {
  if (n === void 0) n = {};
  else if (typeof n == "string") n = { encoding: n };
  else {
    if (n === null || typeof n != "object")
      throw new TypeError('"options" argument must be a string or an object');
    n = Object.create(n);
  }
  if (
    (n.highWaterMark === void 0 && (n.highWaterMark = 64 * 1024),
    (n.emitClose = !1),
    (n.autoDestroy = !1),
    Dk.call(this, n),
    (this.path = t),
    (this.flags = n.flags === void 0 ? "r" : n.flags),
    (this.mode = n.mode === void 0 ? 438 : n.mode),
    (this.start = n.start),
    (this.end = n.end),
    (this.autoClose = n.autoClose === void 0 ? !0 : n.autoClose),
    (this.pos = 0),
    (this.bytesRead = 0),
    (this.isClosed = !1),
    (this.handle = n.handle === void 0 ? null : n.handle),
    (this.sftp = e),
    (this._opening = !1),
    this.start !== void 0 && (z0(this.start, "start"), (this.pos = this.start)),
    this.end === void 0)
  )
    this.end = 1 / 0;
  else if (
    this.end !== 1 / 0 &&
    (z0(this.end, "end"), this.start !== void 0 && this.start > this.end)
  )
    throw new Xf("start", `<= "end" (here: ${this.end})`, this.start);
  this.on("end", function () {
    this.autoClose && this.destroy();
  }),
    Buffer.isBuffer(this.handle) || this.open();
}
Lk(va, Dk);
va.prototype.open = function () {
  this._opening ||
    ((this._opening = !0),
    this.sftp.open(this.path, this.flags, this.mode, (e, t) => {
      if (((this._opening = !1), e)) {
        this.emit("error", e), this.autoClose && this.destroy();
        return;
      }
      (this.handle = t), this.emit("open", t), this.emit("ready"), this.read();
    }));
};
va.prototype._read = function (e) {
  if (!Buffer.isBuffer(this.handle))
    return this.once("open", () => this._read(e));
  if (this.destroyed) return;
  (!yr || yr.length - yr.used < rS) &&
    pre(this.readableHighWaterMark || this._readableState.highWaterMark);
  const t = yr;
  let n = Math.min(yr.length - yr.used, e);
  const r = yr.used;
  if (
    (this.end !== void 0 && (n = Math.min(this.end - this.pos + 1, n)), n <= 0)
  )
    return this.push(null);
  this.sftp.read(this.handle, yr, yr.used, n, this.pos, (i, a) => {
    if (i) {
      this.emit("error", i), this.autoClose && this.destroy();
      return;
    }
    let s = null;
    if (r + n === t.used && t === yr) t.used = rg(t.used + a - n);
    else {
      const o = (r + n) & -8,
        c = rg(r + a);
      o - c >= rS && W0.push(t.slice(c, o));
    }
    a > 0 && ((this.bytesRead += a), (s = t.slice(r, r + a))),
      (this.pos += a),
      this.push(s);
  }),
    (yr.used = rg(yr.used + n));
};
va.prototype._destroy = function (e, t) {
  if (this._opening && !Buffer.isBuffer(this.handle)) {
    this.once("open", iS.bind(null, this, t, e));
    return;
  }
  iS(this, t, e), (this.handle = null), (this._opening = !1);
};
function iS(e, t, n) {
  if (!e.handle) return r();
  e.sftp.close(e.handle, r);
  function r(i) {
    (i = i || n), t(i), (e.isClosed = !0), i || e.emit("close");
  }
}
va.prototype.close = function (e) {
  this.destroy(null, e);
};
Object.defineProperty(va.prototype, "pending", {
  get() {
    return this.handle === null;
  },
  configurable: !0,
});
function ti(e, t, n) {
  if (n === void 0) n = {};
  else if (typeof n == "string") n = { encoding: n };
  else {
    if (n === null || typeof n != "object")
      throw new TypeError('"options" argument must be a string or an object');
    n = Object.create(n);
  }
  (n.emitClose = !1),
    (n.autoDestroy = !1),
    a1.call(this, n),
    (this.path = t),
    (this.flags = n.flags === void 0 ? "w" : n.flags),
    (this.mode = n.mode === void 0 ? 438 : n.mode),
    (this.start = n.start),
    (this.autoClose = n.autoClose === void 0 ? !0 : n.autoClose),
    (this.pos = 0),
    (this.bytesWritten = 0),
    (this.isClosed = !1),
    (this.handle = n.handle === void 0 ? null : n.handle),
    (this.sftp = e),
    (this._opening = !1),
    this.start !== void 0 && (z0(this.start, "start"), (this.pos = this.start)),
    n.encoding && this.setDefaultEncoding(n.encoding),
    this.on("finish", function () {
      this._writableState.finalCalled || (this.autoClose && this.destroy());
    }),
    Buffer.isBuffer(this.handle) || this.open();
}
Lk(ti, a1);
ti.prototype._final = function (e) {
  this.autoClose && this.destroy(), e();
};
ti.prototype.open = function () {
  this._opening ||
    ((this._opening = !0),
    this.sftp.open(this.path, this.flags, this.mode, (e, t) => {
      if (((this._opening = !1), e)) {
        this.emit("error", e), this.autoClose && this.destroy();
        return;
      }
      this.handle = t;
      const n = (r) => {
        if (r) {
          this.sftp.chmod(this.path, this.mode, (i) => n());
          return;
        }
        if (this.flags[0] === "a") {
          const i = (a, s) => {
            if (a) {
              this.sftp.stat(this.path, (o, c) => {
                if (o) {
                  this.destroy(), this.emit("error", a);
                  return;
                }
                i(null, c);
              });
              return;
            }
            (this.pos = s.size), this.emit("open", t), this.emit("ready");
          };
          this.sftp.fstat(t, i);
          return;
        }
        this.emit("open", t), this.emit("ready");
      };
      this.sftp.fchmod(t, this.mode, n);
    }));
};
ti.prototype._write = function (e, t, n) {
  if (!Buffer.isBuffer(e)) {
    const r = new fre("data", "Buffer", e);
    return this.emit("error", r);
  }
  if (!Buffer.isBuffer(this.handle))
    return this.once("open", function () {
      this._write(e, t, n);
    });
  this.sftp.write(this.handle, e, 0, e.length, this.pos, (r, i) => {
    if (r) return this.autoClose && this.destroy(), n(r);
    (this.bytesWritten += i), n();
  }),
    (this.pos += e.length);
};
ti.prototype._writev = function (e, t) {
  if (!Buffer.isBuffer(this.handle))
    return this.once("open", function () {
      this._writev(e, t);
    });
  const n = this.sftp,
    r = this.handle;
  let i = e.length;
  const a = (s, o) => {
    if (s) return this.destroy(), t(s);
    (this.bytesWritten += o), --i === 0 && t();
  };
  for (let s = 0; s < e.length; ++s) {
    const o = e[s].chunk;
    n.write(r, o, 0, o.length, this.pos, a), (this.pos += o.length);
  }
};
typeof a1.prototype.destroy != "function" &&
  (ti.prototype.destroy = va.prototype.destroy);
ti.prototype._destroy = va.prototype._destroy;
ti.prototype.close = function (e) {
  if (e) {
    if (this.isClosed) {
      process.nextTick(e);
      return;
    }
    this.on("close", e);
  }
  this.autoClose || this.on("finish", this.destroy.bind(this)), this.end();
};
ti.prototype.destroySoon = ti.prototype.end;
Object.defineProperty(ti.prototype, "pending", {
  get() {
    return this.handle === null;
  },
  configurable: !0,
});
var Zp = {
  flagsToString: ore,
  OPEN_MODE: nt,
  SFTP: are,
  Stats: Fk,
  STATUS_CODE: Dt,
  stringToFlags: jk,
};
const { Duplex: hre, Readable: mre, Writable: gre } = Kr,
  {
    CHANNEL_EXTENDED_DATATYPE: { STDERR: aS },
  } = es(),
  { bufferSlice: Bd } = Ki(),
  vre = 32 * 1024,
  Iu = 2 * 1024 * 1024,
  o1 = Iu / 2;
class yre extends mre {
  constructor(t, n) {
    super(n), (this._channel = t);
  }
  _read(t) {
    this._channel._waitChanDrain &&
      ((this._channel._waitChanDrain = !1),
      this._channel.incoming.window <= o1 && c1(this._channel));
  }
}
class bre extends gre {
  constructor(t) {
    super({ highWaterMark: Iu }), (this._channel = t);
  }
  _write(t, n, r) {
    const i = this._channel,
      a = i._client._protocol,
      s = i.outgoing,
      o = s.packetSize,
      c = s.id;
    let l = s.window;
    const f = t.length;
    let u = 0;
    if (s.state === "open") {
      for (; f - u > 0 && l > 0; ) {
        let d = f - u;
        d > l && (d = l),
          d > o && (d = o),
          u === 0 && d === f
            ? a.channelExtData(c, t, aS)
            : a.channelExtData(c, Bd(t, u, u + d), aS),
          (u += d),
          (l -= d);
      }
      if (((s.window = l), f - u > 0)) {
        l === 0 && (i._waitWindow = !0),
          u > 0 ? (i._chunkErr = Bd(t, u, f)) : (i._chunkErr = t),
          (i._chunkcbErr = r);
        return;
      }
      r();
    }
  }
}
let _re = class extends hre {
  constructor(t, n, r) {
    const i = {
      highWaterMark: Iu,
      allowHalfOpen: !r || (r && r.allowHalfOpen !== !1),
      emitClose: !1,
    };
    super(i), (this.allowHalfOpen = i.allowHalfOpen);
    const a = !!(r && r.server);
    (this.server = a),
      (this.type = n.type),
      (this.subtype = void 0),
      (this.incoming = n.incoming),
      (this.outgoing = n.outgoing),
      (this._callbacks = []),
      (this._client = t),
      (this._hasX11 = !1),
      (this._exit = {
        code: void 0,
        signal: void 0,
        dump: void 0,
        desc: void 0,
      }),
      (this.stdin = this.stdout = this),
      a ? (this.stderr = new bre(this)) : (this.stderr = new yre(this, i)),
      (this._waitWindow = !1),
      (this._waitChanDrain = !1),
      (this._chunk = void 0),
      (this._chunkcb = void 0),
      (this._chunkErr = void 0),
      (this._chunkcbErr = void 0),
      this.on("finish", sS).on("prefinish", sS),
      this.on("end", oS).on("close", oS);
  }
  _read(t) {
    this._waitChanDrain &&
      ((this._waitChanDrain = !1), this.incoming.window <= o1 && c1(this));
  }
  _write(t, n, r) {
    const i = this._client._protocol,
      a = this.outgoing,
      s = a.packetSize,
      o = a.id;
    let c = a.window;
    const l = t.length;
    let f = 0;
    if (a.state === "open") {
      for (; l - f > 0 && c > 0; ) {
        let u = l - f;
        u > c && (u = c),
          u > s && (u = s),
          f === 0 && u === l
            ? i.channelData(o, t)
            : i.channelData(o, Bd(t, f, f + u)),
          (f += u),
          (c -= u);
      }
      if (((a.window = c), l - f > 0)) {
        c === 0 && (this._waitWindow = !0),
          f > 0 ? (this._chunk = Bd(t, f, l)) : (this._chunk = t),
          (this._chunkcb = r);
        return;
      }
      r();
    }
  }
  eof() {
    this.outgoing.state === "open" &&
      ((this.outgoing.state = "eof"),
      this._client._protocol.channelEOF(this.outgoing.id));
  }
  close() {
    (this.outgoing.state === "open" || this.outgoing.state === "eof") &&
      ((this.outgoing.state = "closing"),
      this._client._protocol.channelClose(this.outgoing.id));
  }
  destroy() {
    return this.end(), this.close(), this;
  }
  setWindow(t, n, r, i) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    this.type === "session" &&
      (this.subtype === "shell" || this.subtype === "exec") &&
      this.writable &&
      this.outgoing.state === "open" &&
      this._client._protocol.windowChange(this.outgoing.id, t, n, r, i);
  }
  signal(t) {
    if (this.server)
      throw new Error("Client-only method called in server mode");
    this.type === "session" &&
      this.writable &&
      this.outgoing.state === "open" &&
      this._client._protocol.signal(this.outgoing.id, t);
  }
  exit(t, n, r) {
    if (!this.server)
      throw new Error("Server-only method called in client mode");
    this.type === "session" &&
      this.writable &&
      this.outgoing.state === "open" &&
      (typeof t == "number"
        ? this._client._protocol.exitStatus(this.outgoing.id, t)
        : this._client._protocol.exitSignal(this.outgoing.id, t, n, r));
  }
};
function sS() {
  this.eof(),
    (this.server || !this.allowHalfOpen) && this.close(),
    (this.writable = !1);
}
function oS() {
  this.readable = !1;
}
function c1(e) {
  if (e.outgoing.state === "closed") return;
  const t = Iu - e.incoming.window;
  t <= 0 ||
    ((e.incoming.window += t),
    e._client._protocol.channelWindowAdjust(e.outgoing.id, t));
}
var qk = {
  Channel: _re,
  MAX_WINDOW: Iu,
  PACKET_SIZE: vre,
  windowAdjust: c1,
  WINDOW_THRESHOLD: o1,
};
const { SFTP: Ere } = Zp,
  Xc = 2 ** 32 - 1;
function Gk(e, t, n, r) {
  if ((e._chanMgr.remove(t), typeof r != "function")) return;
  let i;
  n instanceof Error
    ? (i = n)
    : typeof n == "object" && n !== null
    ? ((i = new Error(`(SSH) Channel open failure: ${n.description}`)),
      (i.reason = n.reason))
    : ((i = new Error(
        "(SSH) Channel open failure: server closed channel unexpectedly",
      )),
      (i.reason = "")),
    r(i);
}
function Qk(e, t, n, r, i) {
  if (typeof n == "function") {
    Gk(e, t, r, n);
    return;
  }
  if (
    typeof n != "object" ||
    n === null ||
    (n.incoming && n.incoming.state === "closed") ||
    (e._chanMgr.remove(t), n.server && n.constructor.name === "Session")
  )
    return;
  (n.incoming.state = "closed"),
    n.readable && n.push(null),
    n.server
      ? n.stderr.writable && n.stderr.end()
      : n.stderr.readable && n.stderr.push(null),
    n.constructor !== Ere &&
      (n.outgoing.state === "open" || n.outgoing.state === "eof") &&
      !i &&
      n.close(),
    n.outgoing.state === "closing" && (n.outgoing.state = "closed");
  const a = n._readableState,
    s = n._writableState;
  s && !s.ending && !s.finished && !i && n.end();
  const o = n._callbacks;
  n._callbacks = [];
  for (let c = 0; c < o.length; ++c) o[c](!0);
  if (n.server)
    !n.readable || n.destroyed || (a && a.endEmitted)
      ? n.emit("close")
      : n.once("end", () => n.emit("close"));
  else {
    let c;
    switch (n.type) {
      case "direct-streamlocal@openssh.com":
      case "direct-tcpip":
        c = () => n.emit("close");
        break;
      default: {
        const f = n._exit;
        c = () => {
          f.code === null
            ? n.emit("close", f.code, f.signal, f.dump, f.desc)
            : n.emit("close", f.code);
        };
      }
    }
    !n.readable || n.destroyed || (a && a.endEmitted) ? c() : n.once("end", c);
    const l = n.stderr._readableState;
    !n.stderr.readable || n.stderr.destroyed || (l && l.endEmitted)
      ? n.stderr.emit("close")
      : n.stderr.once("end", () => n.stderr.emit("close"));
  }
}
let wre = class {
  constructor(t) {
    (this._client = t),
      (this._channels = {}),
      (this._cur = -1),
      (this._count = 0);
  }
  add(t) {
    let n;
    if (this._cur < Xc) n = ++this._cur;
    else if (this._count === 0) (this._cur = 0), (n = 0);
    else {
      const r = this._channels;
      for (let i = 0; i < Xc; ++i)
        if (r[i] === void 0) {
          n = i;
          break;
        }
    }
    return n === void 0
      ? -1
      : ((this._channels[n] = t || !0), ++this._count, n);
  }
  update(t, n) {
    if (typeof t != "number" || t < 0 || t >= Xc || !isFinite(t))
      throw new Error(`Invalid channel id: ${t}`);
    n && this._channels[t] && (this._channels[t] = n);
  }
  get(t) {
    if (typeof t != "number" || t < 0 || t >= Xc || !isFinite(t))
      throw new Error(`Invalid channel id: ${t}`);
    return this._channels[t];
  }
  remove(t) {
    if (typeof t != "number" || t < 0 || t >= Xc || !isFinite(t))
      throw new Error(`Invalid channel id: ${t}`);
    this._channels[t] &&
      (delete this._channels[t], this._count && --this._count);
  }
  cleanup(t) {
    const n = this._channels;
    (this._channels = {}), (this._cur = -1), (this._count = 0);
    const r = Object.keys(n),
      i = this._client;
    for (let a = 0; a < r.length; ++a) {
      const s = +r[a],
        o = n[s];
      Qk(i, s, o._channel || o, t, !0);
    }
  }
};
const ig = (() => {
  const e = Object.prototype.toString;
  return (t) => e.call(t) === "[object RegExp]";
})();
function xre(e, t, n) {
  if (Array.isArray(e) && e.length > 0) {
    for (let r = 0; r < e.length; ++r)
      if (n.indexOf(e[r]) === -1)
        throw new Error(`Unsupported algorithm: ${e[r]}`);
    return e;
  }
  if (typeof e == "object" && e !== null) {
    const r = Object.keys(e);
    let i = t;
    for (let a = 0; a < r.length; ++a) {
      const s = r[a];
      let o = e[s];
      switch (s) {
        case "append":
          if ((Array.isArray(o) || (o = [o]), Array.isArray(o)))
            for (let c = 0; c < o.length; ++c) {
              const l = o[c];
              if (typeof l == "string") {
                if (!l || i.indexOf(l) !== -1) continue;
                if (n.indexOf(l) === -1)
                  throw new Error(`Unsupported algorithm: ${l}`);
                i === t && (i = i.slice()), i.push(l);
              } else if (ig(l))
                for (let f = 0; f < n.length; ++f) {
                  const u = n[f];
                  if (l.test(u)) {
                    if (i.indexOf(u) !== -1) continue;
                    i === t && (i = i.slice()), i.push(u);
                  }
                }
            }
          break;
        case "prepend":
          if ((Array.isArray(o) || (o = [o]), Array.isArray(o)))
            for (let c = o.length; c >= 0; --c) {
              const l = o[c];
              if (typeof l == "string") {
                if (!l || i.indexOf(l) !== -1) continue;
                if (n.indexOf(l) === -1)
                  throw new Error(`Unsupported algorithm: ${l}`);
                i === t && (i = i.slice()), i.unshift(l);
              } else if (ig(l))
                for (let f = n.length; f >= 0; --f) {
                  const u = n[f];
                  if (l.test(u)) {
                    if (i.indexOf(u) !== -1) continue;
                    i === t && (i = i.slice()), i.unshift(u);
                  }
                }
            }
          break;
        case "remove":
          if ((Array.isArray(o) || (o = [o]), Array.isArray(o)))
            for (let c = 0; c < o.length; ++c) {
              const l = o[c];
              if (typeof l == "string") {
                if (!l) continue;
                const f = i.indexOf(l);
                if (f === -1) continue;
                i === t && (i = i.slice()), i.splice(f, 1);
              } else if (ig(l))
                for (let f = 0; f < i.length; ++f)
                  l.test(i[f]) &&
                    (i === t && (i = i.slice()), i.splice(f, 1), --f);
            }
          break;
      }
    }
    return i;
  }
  return t;
}
var Wk = {
  ChannelManager: wre,
  generateAlgorithmList: xre,
  onChannelOpenFailure: Gk,
  onCHANNEL_CLOSE: Qk,
  isWritable: (e) =>
    e && e.writable && e._readableState && e._readableState.ended === !1,
};
const { createHash: Are, getHashes: Sre, randomFillSync: Ire } = pr,
  { Socket: $re } = ha,
  { lookup: Cre } = RT,
  Rre = Hi,
  kre = Sre(),
  {
    COMPAT: zk,
    CHANNEL_EXTENDED_DATATYPE: { STDERR: Tre },
    CHANNEL_OPEN_FAILURE: Jc,
    DEFAULT_CIPHER: cS,
    DEFAULT_COMPRESSION: lS,
    DEFAULT_KEX: uS,
    DEFAULT_MAC: fS,
    DEFAULT_SERVER_HOST_KEY: dS,
    DISCONNECT_REASON: pS,
    DISCONNECT_REASON_BY_VALUE: Nre,
    SUPPORTED_CIPHER: Ore,
    SUPPORTED_COMPRESSION: Pre,
    SUPPORTED_KEX: Dre,
    SUPPORTED_MAC: Lre,
    SUPPORTED_SERVER_HOST_KEY: Bre,
  } = es(),
  { init: Ure } = eo(),
  Fre = kk,
  { parseKey: Jf } = to,
  { SFTP: jre } = Zp,
  {
    bufferCopy: hS,
    makeBufferParser: Kk,
    makeError: Mre,
    readUInt32BE: Hre,
    sigSSHToASN1: qre,
    writeUInt32BE: ag,
  } = Ki(),
  { AgentContext: mS, createAgent: gS, isAgent: vS } = vk,
  {
    Channel: Vk,
    MAX_WINDOW: Ud,
    PACKET_SIZE: Fd,
    windowAdjust: yS,
    WINDOW_THRESHOLD: bS,
  } = qk,
  {
    ChannelManager: Gre,
    generateAlgorithmList: Zc,
    isWritable: Pn,
    onChannelOpenFailure: Qre,
    onCHANNEL_CLOSE: Wre,
  } = Wk,
  Nf = Kk(),
  Of = Kk(),
  cl = /^OpenSSH_(?:(?![0-4])\d)|(?:\d{2,})/,
  K0 = (e) => {};
let zre = class extends Rre {
  constructor() {
    super(),
      (this.config = {
        host: void 0,
        port: void 0,
        localAddress: void 0,
        localPort: void 0,
        forceIPv4: void 0,
        forceIPv6: void 0,
        keepaliveCountMax: void 0,
        keepaliveInterval: void 0,
        readyTimeout: void 0,
        ident: void 0,
        username: void 0,
        password: void 0,
        privateKey: void 0,
        tryKeyboard: void 0,
        agent: void 0,
        allowAgentFwd: void 0,
        authHandler: void 0,
        hostHashAlgo: void 0,
        hostHashCb: void 0,
        strictVendor: void 0,
        debug: void 0,
      }),
      (this._agent = void 0),
      (this._readyTimeout = void 0),
      (this._chanMgr = void 0),
      (this._callbacks = void 0),
      (this._forwarding = void 0),
      (this._forwardingUnix = void 0),
      (this._acceptX11 = void 0),
      (this._agentFwdEnabled = void 0),
      (this._remoteVer = void 0),
      (this._protocol = void 0),
      (this._sock = void 0),
      (this._resetKA = void 0);
  }
  connect(t) {
    if (this._sock && Pn(this._sock))
      return (
        this.once("close", () => {
          this.connect(t);
        }),
        this.end(),
        this
      );
    (this.config.host = t.hostname || t.host || "localhost"),
      (this.config.port = t.port || 22),
      (this.config.localAddress =
        typeof t.localAddress == "string" ? t.localAddress : void 0),
      (this.config.localPort =
        typeof t.localPort == "string" || typeof t.localPort == "number"
          ? t.localPort
          : void 0),
      (this.config.forceIPv4 = t.forceIPv4 || !1),
      (this.config.forceIPv6 = t.forceIPv6 || !1),
      (this.config.keepaliveCountMax =
        typeof t.keepaliveCountMax == "number" && t.keepaliveCountMax >= 0
          ? t.keepaliveCountMax
          : 3),
      (this.config.keepaliveInterval =
        typeof t.keepaliveInterval == "number" && t.keepaliveInterval > 0
          ? t.keepaliveInterval
          : 0),
      (this.config.readyTimeout =
        typeof t.readyTimeout == "number" && t.readyTimeout >= 0
          ? t.readyTimeout
          : 2e4),
      (this.config.ident =
        typeof t.ident == "string" || Buffer.isBuffer(t.ident)
          ? t.ident
          : void 0);
    const n = {
      kex: void 0,
      serverHostKey: void 0,
      cs: { cipher: void 0, mac: void 0, compress: void 0, lang: [] },
      sc: void 0,
    };
    let r = !0;
    if (
      (typeof t.algorithms == "object" &&
        t.algorithms !== null &&
        ((n.kex = Zc(t.algorithms.kex, uS, Dre)),
        n.kex !== uS && (r = !1),
        (n.serverHostKey = Zc(t.algorithms.serverHostKey, dS, Bre)),
        n.serverHostKey !== dS && (r = !1),
        (n.cs.cipher = Zc(t.algorithms.cipher, cS, Ore)),
        n.cs.cipher !== cS && (r = !1),
        (n.cs.mac = Zc(t.algorithms.hmac, fS, Lre)),
        n.cs.mac !== fS && (r = !1),
        (n.cs.compress = Zc(t.algorithms.compress, lS, Pre)),
        n.cs.compress !== lS && (r = !1),
        r || (n.sc = n.cs)),
      typeof t.username == "string")
    )
      this.config.username = t.username;
    else if (typeof t.user == "string") this.config.username = t.user;
    else throw new Error("Invalid username");
    (this.config.password =
      typeof t.password == "string" ? t.password : void 0),
      (this.config.privateKey =
        typeof t.privateKey == "string" || Buffer.isBuffer(t.privateKey)
          ? t.privateKey
          : void 0),
      (this.config.localHostname =
        typeof t.localHostname == "string" ? t.localHostname : void 0),
      (this.config.localUsername =
        typeof t.localUsername == "string" ? t.localUsername : void 0),
      (this.config.tryKeyboard = t.tryKeyboard === !0),
      typeof t.agent == "string" && t.agent.length
        ? (this.config.agent = gS(t.agent))
        : vS(t.agent)
        ? (this.config.agent = t.agent)
        : (this.config.agent = void 0),
      (this.config.allowAgentFwd =
        t.agentForward === !0 && this.config.agent !== void 0);
    let i = (this.config.authHandler =
      typeof t.authHandler == "function" || Array.isArray(t.authHandler)
        ? t.authHandler
        : void 0);
    this.config.strictVendor =
      typeof t.strictVendor == "boolean" ? t.strictVendor : !0;
    const a = (this.config.debug =
      typeof t.debug == "function" ? t.debug : void 0);
    if (t.agentForward === !0 && !this.config.allowAgentFwd)
      throw new Error(
        "You must set a valid agent path to allow agent forwarding",
      );
    let s = (this._callbacks = []);
    (this._chanMgr = new Gre(this)),
      (this._forwarding = {}),
      (this._forwardingUnix = {}),
      (this._acceptX11 = 0),
      (this._agentFwdEnabled = !1),
      (this._agent = this.config.agent ? this.config.agent : void 0),
      (this._remoteVer = void 0);
    let o;
    if (this.config.privateKey) {
      if (((o = Jf(this.config.privateKey, t.passphrase)), o instanceof Error))
        throw new Error(`Cannot parse privateKey: ${o.message}`);
      if ((Array.isArray(o) && (o = o[0]), o.getPrivatePEM() === null))
        throw new Error(
          "privateKey value does not contain a (valid) private key",
        );
    }
    let c;
    if (typeof t.hostVerifier == "function") {
      const U = t.hostVerifier;
      let G;
      kre.indexOf(t.hostHash) !== -1 && (G = Are(t.hostHash)),
        (c = (L, k) => {
          G && (G.update(L), (L = G.digest("hex")));
          const W = U(L, k);
          W !== void 0 && k(W);
        });
    }
    const l = (this._sock = t.sock || new $re());
    let f = !1,
      u = !1;
    this._protocol && this._protocol.cleanup();
    const d = a
      ? (U, G, L) => {
          a(`Debug output from server: ${JSON.stringify(L)}`);
        }
      : void 0;
    let p;
    const h = (this._protocol = new Fre({
      ident: this.config.ident,
      offer: r ? void 0 : n,
      onWrite: (U) => {
        Pn(l) && l.write(U);
      },
      onError: (U) => {
        U.level === "handshake" && clearTimeout(this._readyTimeout),
          h._destruct || l.removeAllListeners("data"),
          this.emit("error", U);
        try {
          l.end();
        } catch {}
      },
      onHeader: (U) => {
        (u = !0),
          (this._remoteVer = U.versions.software),
          U.greeting && this.emit("greeting", U.greeting);
      },
      onHandshakeComplete: (U) => {
        this.emit("handshake", U), f || ((f = !0), h.service("ssh-userauth"));
      },
      debug: a,
      hostVerifier: c,
      messageHandlers: {
        DEBUG: d,
        DISCONNECT: (U, G, L) => {
          if (G !== pS.BY_APPLICATION) {
            L ||
              ((L = Nre[G]),
              L === void 0 && (L = `Unexpected disconnection reason: ${G}`));
            const k = new Error(L);
            (k.code = G), this.emit("error", k);
          }
          l.end();
        },
        SERVICE_ACCEPT: (U, G) => {
          G === "ssh-userauth" && J();
        },
        EXT_INFO: (U, G) => {
          if (p === void 0) {
            for (const L of G)
              if (L.name === "server-sig-algs") {
                p = L.algs;
                return;
              }
            p = null;
          }
        },
        USERAUTH_BANNER: (U, G) => {
          this.emit("banner", G);
        },
        USERAUTH_SUCCESS: (U) => {
          E(), clearTimeout(this._readyTimeout), this.emit("ready");
        },
        USERAUTH_FAILURE: (U, G, L) => {
          if (S.keyAlgos) {
            const k = S.keyAlgos[0][0];
            if (
              (a && a(`Client: ${S.type} (${k}) auth failed`),
              S.keyAlgos.shift(),
              S.keyAlgos.length)
            ) {
              const [W, F] = S.keyAlgos[0];
              switch (S.type) {
                case "agent":
                  h.authPK(S.username, S.agentCtx.currentKey(), W);
                  return;
                case "publickey":
                  h.authPK(S.username, S.key, W);
                  return;
                case "hostbased":
                  h.authHostbased(
                    S.username,
                    S.key,
                    S.localHostname,
                    S.localUsername,
                    W,
                    (x, T) => {
                      const V = S.key.sign(x, F);
                      if (V instanceof Error)
                        return (
                          (V.message = `Error while signing with key: ${V.message}`),
                          (V.level = "client-authentication"),
                          this.emit("error", V),
                          J()
                        );
                      T(V);
                    },
                  );
                  return;
              }
            } else S.keyAlgos = void 0;
          }
          if (S.type === "agent") {
            const k = S.agentCtx.pos();
            return a && a(`Client: Agent key #${k + 1} failed`), Z();
          }
          a && a(`Client: ${S.type} auth failed`), (w = L), (O = G), J();
        },
        USERAUTH_PASSWD_CHANGEREQ: (U, G) => {
          S.type === "password" &&
            this.emit("change password", G, (L) => {
              h.authPassword(this.config.username, this.config.password, L);
            });
        },
        USERAUTH_PK_OK: (U) => {
          let G, L;
          if ((S.keyAlgos && ([G, L] = S.keyAlgos[0]), S.type === "agent")) {
            const k = S.agentCtx.currentKey();
            h.authPK(S.username, k, G, (W, F) => {
              const x = { hash: L };
              S.agentCtx.sign(k, W, x, (T, V) => {
                if (T) (T.level = "agent"), this.emit("error", T);
                else return F(V);
                Z();
              });
            });
          } else
            S.type === "publickey" &&
              h.authPK(S.username, S.key, G, (k, W) => {
                const F = S.key.sign(k, L);
                if (F instanceof Error)
                  return (
                    (F.message = `Error signing data with key: ${F.message}`),
                    (F.level = "client-authentication"),
                    this.emit("error", F),
                    J()
                  );
                W(F);
              });
        },
        USERAUTH_INFO_REQUEST: (U, G, L, k) => {
          if (S.type === "keyboard-interactive") {
            if ((Array.isArray(k) ? k.length : 0) === 0) {
              a && a("Client: Sending automatic USERAUTH_INFO_RESPONSE"),
                h.authInfoRes();
              return;
            }
            S.prompt(G, L, "", k, (F) => {
              h.authInfoRes(F);
            });
          }
        },
        REQUEST_SUCCESS: (U, G) => {
          s.length && s.shift()(!1, G);
        },
        REQUEST_FAILURE: (U) => {
          s.length && s.shift()(!0);
        },
        GLOBAL_REQUEST: (U, G, L, k) => {
          switch (G) {
            case "hostkeys-00@openssh.com":
              Jre(this, k, (W, F) => {
                W || this.emit("hostkeys", F);
              }),
                L && h.requestSuccess();
              break;
            default:
              L && h.requestFailure();
          }
        },
        CHANNEL_OPEN: (U, G) => {
          Yre(this, G);
        },
        CHANNEL_OPEN_CONFIRMATION: (U, G) => {
          const L = this._chanMgr.get(G.recipient);
          if (typeof L != "function") return;
          const k = L.type === "sftp",
            F = {
              type: k ? "session" : L.type,
              incoming: {
                id: G.recipient,
                window: Ud,
                packetSize: Fd,
                state: "open",
              },
              outgoing: {
                id: G.sender,
                window: G.window,
                packetSize: G.packetSize,
                state: "open",
              },
            },
            x = k ? new jre(this, F, { debug: a }) : new Vk(this, F);
          this._chanMgr.update(G.recipient, x), L(void 0, x);
        },
        CHANNEL_OPEN_FAILURE: (U, G, L, k) => {
          const W = this._chanMgr.get(G);
          if (typeof W != "function") return;
          Qre(this, G, { reason: L, description: k }, W);
        },
        CHANNEL_DATA: (U, G, L) => {
          const k = this._chanMgr.get(G);
          if (
            !(typeof k != "object" || k === null) &&
            k.incoming.window !== 0
          ) {
            if (((k.incoming.window -= L.length), k.push(L) === !1)) {
              k._waitChanDrain = !0;
              return;
            }
            k.incoming.window <= bS && yS(k);
          }
        },
        CHANNEL_EXTENDED_DATA: (U, G, L, k) => {
          if (k !== Tre) return;
          const W = this._chanMgr.get(G);
          if (
            !(typeof W != "object" || W === null) &&
            W.incoming.window !== 0
          ) {
            if (((W.incoming.window -= L.length), !W.stderr.push(L))) {
              W._waitChanDrain = !0;
              return;
            }
            W.incoming.window <= bS && yS(W);
          }
        },
        CHANNEL_WINDOW_ADJUST: (U, G, L) => {
          const k = this._chanMgr.get(G);
          typeof k != "object" ||
            k === null ||
            ((k.outgoing.window += L),
            k._waitWindow &&
              ((k._waitWindow = !1),
              k._chunk
                ? k._write(k._chunk, null, k._chunkcb)
                : k._chunkcb
                ? k._chunkcb()
                : k._chunkErr
                ? k.stderr._write(k._chunkErr, null, k._chunkcbErr)
                : k._chunkcbErr && k._chunkcbErr()));
        },
        CHANNEL_SUCCESS: (U, G) => {
          const L = this._chanMgr.get(G);
          typeof L != "object" ||
            L === null ||
            (this._resetKA(), L._callbacks.length && L._callbacks.shift()(!1));
        },
        CHANNEL_FAILURE: (U, G) => {
          const L = this._chanMgr.get(G);
          typeof L != "object" ||
            L === null ||
            (this._resetKA(), L._callbacks.length && L._callbacks.shift()(!0));
        },
        CHANNEL_REQUEST: (U, G, L, k, W) => {
          const F = this._chanMgr.get(G);
          if (typeof F != "object" || F === null) return;
          const x = F._exit;
          if (x.code === void 0) {
            switch (L) {
              case "exit-status":
                F.emit("exit", (x.code = W));
                return;
              case "exit-signal":
                F.emit(
                  "exit",
                  (x.code = null),
                  (x.signal = `SIG${W.signal}`),
                  (x.dump = W.coreDumped),
                  (x.desc = W.errorMessage),
                );
                return;
            }
            k && U.channelFailure(F.outgoing.id);
          }
        },
        CHANNEL_EOF: (U, G) => {
          const L = this._chanMgr.get(G);
          typeof L != "object" ||
            L === null ||
            (L.incoming.state === "open" &&
              ((L.incoming.state = "eof"),
              L.readable && L.push(null),
              L.stderr.readable && L.stderr.push(null)));
        },
        CHANNEL_CLOSE: (U, G) => {
          Wre(this, G, this._chanMgr.get(G));
        },
      },
    }));
    l.pause();
    const m = this.config.keepaliveInterval,
      g = this.config.keepaliveCountMax;
    let v = 0,
      y;
    const _ = () => {
      if (++v > g) {
        if ((clearInterval(y), l.readable)) {
          const U = new Error("Keepalive timeout");
          (U.level = "client-timeout"), this.emit("error", U), l.destroy();
        }
        return;
      }
      Pn(l) ? (s.push(E), h.ping()) : clearInterval(y);
    };
    function E() {
      m > 0 && ((v = 0), clearInterval(y), Pn(l) && (y = setInterval(_, m)));
    }
    this._resetKA = E;
    const R = (() => {
        let U = !1;
        return () => {
          if (!U && ((U = !0), I && !u)) {
            const G = Mre("Connection lost before handshake", "protocol", !0);
            this.emit("error", G);
          }
        };
      })(),
      A = (() => {
        let U = !1;
        return () => {
          U ||
            ((U = !0),
            (I = !0),
            a && a("Socket connected"),
            this.emit("connect"),
            Ure.then(() => {
              h.start(),
                l.on("data", (G) => {
                  try {
                    h.parse(G, 0, G.length);
                  } catch (L) {
                    this.emit("error", L);
                    try {
                      Pn(l) && l.end();
                    } catch {}
                  }
                }),
                l.stderr &&
                  typeof l.stderr.resume == "function" &&
                  l.stderr.resume(),
                l.resume();
            }).catch((G) => {
              this.emit("error", G);
              try {
                Pn(l) && l.end();
              } catch {}
            }));
        };
      })();
    let I = !1;
    l.on("connect", A)
      .on("timeout", () => {
        this.emit("timeout");
      })
      .on("error", (U) => {
        a && a(`Socket error: ${U.message}`),
          clearTimeout(this._readyTimeout),
          (U.level = "client-socket"),
          this.emit("error", U);
      })
      .on("end", () => {
        a && a("Socket ended"),
          R(),
          h.cleanup(),
          clearTimeout(this._readyTimeout),
          clearInterval(y),
          this.emit("end");
      })
      .on("close", () => {
        a && a("Socket closed"),
          R(),
          h.cleanup(),
          clearTimeout(this._readyTimeout),
          clearInterval(y),
          this.emit("close");
        const U = s;
        s = this._callbacks = [];
        const G = new Error("No response from server");
        for (let L = 0; L < U.length; ++L) U[L](G);
        this._chanMgr.cleanup(G);
      });
    let S,
      w = null,
      O = null;
    const Q = ["none"];
    this.config.password !== void 0 && Q.push("password"),
      o !== void 0 && Q.push("publickey"),
      this._agent !== void 0 && Q.push("agent"),
      this.config.tryKeyboard && Q.push("keyboard-interactive"),
      o !== void 0 &&
        this.config.localHostname !== void 0 &&
        this.config.localUsername !== void 0 &&
        Q.push("hostbased"),
      Array.isArray(i) ? (i = SS(i)) : typeof i != "function" && (i = SS(Q));
    let j = !1;
    const H = (U) => {
      if (!j) {
        if (((j = !0), U === !1)) {
          const G = new Error("All configured authentication methods failed");
          (G.level = "client-authentication"),
            this.emit("error", G),
            this.end();
          return;
        }
        if (typeof U == "string") {
          const G = U;
          if (Q.indexOf(G) === -1)
            return q(`Authentication method not allowed: ${G}`);
          const L = this.config.username;
          switch (G) {
            case "password":
              U = { type: G, username: L, password: this.config.password };
              break;
            case "publickey":
              U = { type: G, username: L, key: o };
              break;
            case "hostbased":
              U = {
                type: G,
                username: L,
                key: o,
                localHostname: this.config.localHostname,
                localUsername: this.config.localUsername,
              };
              break;
            case "agent":
              U = { type: G, username: L, agentCtx: new mS(this._agent) };
              break;
            case "keyboard-interactive":
              U = {
                type: G,
                username: L,
                prompt: (...k) => this.emit("keyboard-interactive", ...k),
              };
              break;
            case "none":
              U = { type: G, username: L };
              break;
            default:
              return q(`Skipping unsupported authentication method: ${U}`);
          }
        } else {
          if (typeof U != "object" || U === null)
            return q(`Skipping invalid authentication attempt: ${U}`);
          {
            const G = U.username;
            if (typeof G != "string")
              return q(`Skipping invalid authentication attempt: ${U}`);
            const L = U.type;
            switch (L) {
              case "password": {
                const { password: k } = U;
                if (typeof k != "string" && !Buffer.isBuffer(k))
                  return q("Skipping invalid password auth attempt");
                U = { type: L, username: G, password: k };
                break;
              }
              case "publickey": {
                const k = Jf(U.key, U.passphrase);
                if (k instanceof Error)
                  return q("Skipping invalid key auth attempt");
                if (!k.isPrivateKey()) return q("Skipping non-private key");
                U = { type: L, username: G, key: k };
                break;
              }
              case "hostbased": {
                const { localHostname: k, localUsername: W } = U,
                  F = Jf(U.key, U.passphrase);
                if (
                  F instanceof Error ||
                  typeof k != "string" ||
                  typeof W != "string"
                )
                  return q("Skipping invalid hostbased auth attempt");
                if (!F.isPrivateKey()) return q("Skipping non-private key");
                U = {
                  type: L,
                  username: G,
                  key: F,
                  localHostname: k,
                  localUsername: W,
                };
                break;
              }
              case "agent": {
                let k = U.agent;
                if (typeof k == "string" && k.length) k = gS(k);
                else if (!vS(k)) return q(`Skipping invalid agent: ${U.agent}`);
                U = { type: L, username: G, agentCtx: new mS(k) };
                break;
              }
              case "keyboard-interactive": {
                const { prompt: k } = U;
                if (typeof k != "function")
                  return q(
                    "Skipping invalid keyboard-interactive auth attempt",
                  );
                U = { type: L, username: G, prompt: k };
                break;
              }
              case "none":
                U = { type: L, username: G };
                break;
              default:
                return q(`Skipping unsupported authentication method: ${U}`);
            }
          }
        }
        S = U;
        try {
          const G = S.username;
          switch (S.type) {
            case "password":
              h.authPassword(G, S.password);
              break;
            case "publickey": {
              let L;
              if (((S.keyAlgos = sg(this, S.key, p)), S.keyAlgos))
                if (S.keyAlgos.length) L = S.keyAlgos[0][0];
                else
                  return q(
                    "Skipping key authentication (no mutual hash algorithm)",
                  );
              h.authPK(G, S.key, L);
              break;
            }
            case "hostbased": {
              let L, k;
              if (((S.keyAlgos = sg(this, S.key, p)), S.keyAlgos))
                if (S.keyAlgos.length) [L, k] = S.keyAlgos[0];
                else
                  return q(
                    "Skipping hostbased authentication (no mutual hash algorithm)",
                  );
              h.authHostbased(
                G,
                S.key,
                S.localHostname,
                S.localUsername,
                L,
                (W, F) => {
                  const x = S.key.sign(W, k);
                  if (x instanceof Error)
                    return (
                      (x.message = `Error while signing with key: ${x.message}`),
                      (x.level = "client-authentication"),
                      this.emit("error", x),
                      J()
                    );
                  F(x);
                },
              );
              break;
            }
            case "agent":
              S.agentCtx.init((L) => {
                if (L) return (L.level = "agent"), this.emit("error", L), J();
                Z();
              });
              break;
            case "keyboard-interactive":
              h.authKeyboard(G);
              break;
            case "none":
              h.authNone(G);
              break;
          }
        } finally {
          j = !1;
        }
      }
    };
    function q(U) {
      a && a(U), process.nextTick(J);
    }
    function J() {
      j = !1;
      const U = i(O, w, H);
      j || U === void 0 || H(U);
    }
    const Z = () => {
        if (S.type === "agent") {
          const U = S.agentCtx.nextKey();
          if (U === !1)
            a && a("Agent: No more keys left to try"),
              a && a("Client: agent auth failed"),
              J();
          else {
            const G = S.agentCtx.pos();
            let L;
            if (((S.keyAlgos = sg(this, U, p)), S.keyAlgos))
              if (S.keyAlgos.length) L = S.keyAlgos[0][0];
              else {
                a &&
                  a(`Agent: Skipping key #${G + 1} (no mutual hash algorithm)`),
                  Z();
                return;
              }
            a && a(`Agent: Trying key #${G + 1}`), h.authPK(S.username, U, L);
          }
        }
      },
      z = () => {
        this.config.readyTimeout > 0 &&
          (this._readyTimeout = setTimeout(() => {
            const U = new Error("Timed out while waiting for handshake");
            (U.level = "client-timeout"), this.emit("error", U), l.destroy();
          }, this.config.readyTimeout));
      };
    if (t.sock) z(), (typeof l.connecting == "boolean" && l.connecting) || A();
    else {
      let U = this.config.host;
      const G = this.config.forceIPv4,
        L = this.config.forceIPv6;
      a && a(`Client: Trying ${U} on port ${this.config.port} ...`);
      const k = () => {
        z(),
          l.connect({
            host: U,
            port: this.config.port,
            localAddress: this.config.localAddress,
            localPort: this.config.localPort,
          }),
          l.setMaxListeners(0),
          l.setTimeout(typeof t.timeout == "number" ? t.timeout : 0);
      };
      (!G && !L) || (G && L)
        ? k()
        : Cre(U, G ? 4 : 6, (W, F, x) => {
            if (W) {
              const T = G ? "IPv4" : "IPv6",
                V = new Error(
                  `Error while looking up ${T} address for '${U}': ${W}`,
                );
              clearTimeout(this._readyTimeout),
                (V.level = "client-dns"),
                this.emit("error", V),
                this.emit("close");
              return;
            }
            (U = F), k();
          });
    }
    return this;
  }
  end() {
    return (
      this._sock &&
        Pn(this._sock) &&
        (this._protocol.disconnect(pS.BY_APPLICATION), this._sock.end()),
      this
    );
  }
  destroy() {
    return this._sock && Pn(this._sock) && this._sock.destroy(), this;
  }
  exec(t, n, r) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    typeof n == "function" && ((r = n), (n = {}));
    const i = { allowHalfOpen: n.allowHalfOpen !== !1 };
    return (
      yo(this, "session", i, (a, s) => {
        if (a) {
          r(a);
          return;
        }
        const o = [];
        function c(l) {
          if (l) {
            s.close(), r(l);
            return;
          }
          o.length && o.shift()();
        }
        (this.config.allowAgentFwd === !0 ||
          (n && n.agentForward === !0 && this._agent !== void 0)) &&
          o.push(() => wS(s, c)),
          typeof n == "object" &&
            n !== null &&
            (typeof n.env == "object" && n.env !== null && xS(s, n.env),
            ((typeof n.pty == "object" && n.pty !== null) || n.pty === !0) &&
              o.push(() => ES(s, n.pty, c)),
            ((typeof n.x11 == "object" && n.x11 !== null) ||
              n.x11 === "number" ||
              n.x11 === !0) &&
              o.push(() => _S(s, n.x11, c))),
          o.push(() => Vre(s, t, n, r)),
          o.shift()();
      }),
      this
    );
  }
  shell(t, n, r) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    return (
      typeof t == "function"
        ? ((r = t), (t = n = void 0))
        : typeof n == "function" && ((r = n), (n = void 0)),
      t && (t.x11 !== void 0 || t.env !== void 0) && ((n = t), (t = void 0)),
      yo(this, "session", (i, a) => {
        if (i) {
          r(i);
          return;
        }
        const s = [];
        function o(c) {
          if (c) {
            a.close(), r(c);
            return;
          }
          s.length && s.shift()();
        }
        (this.config.allowAgentFwd === !0 ||
          (n && n.agentForward === !0 && this._agent !== void 0)) &&
          s.push(() => wS(a, o)),
          t !== !1 && s.push(() => ES(a, t, o)),
          typeof n == "object" &&
            n !== null &&
            (typeof n.env == "object" && n.env !== null && xS(a, n.env),
            ((typeof n.x11 == "object" && n.x11 !== null) ||
              n.x11 === "number" ||
              n.x11 === !0) &&
              s.push(() => _S(a, n.x11, o))),
          s.push(() => Kre(a, r)),
          s.shift()();
      }),
      this
    );
  }
  subsys(t, n) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    return (
      yo(this, "session", (r, i) => {
        if (r) {
          n(r);
          return;
        }
        AS(i, t, (a, s) => {
          if (a) {
            n(a);
            return;
          }
          n(void 0, s);
        });
      }),
      this
    );
  }
  forwardIn(t, n, r) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const i = typeof r == "function";
    return (
      i &&
        this._callbacks.push((a, s) => {
          if (a) {
            r(a !== !0 ? a : new Error(`Unable to bind to ${t}:${n}`));
            return;
          }
          let o = n;
          n === 0 &&
            s &&
            s.length >= 4 &&
            ((o = Hre(s, 0)),
            this._protocol._compatFlags & zk.DYN_RPORT_BUG || (n = o)),
            (this._forwarding[`${t}:${n}`] = o),
            r(void 0, o);
        }),
      this._protocol.tcpipForward(t, n, i),
      this
    );
  }
  unforwardIn(t, n, r) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const i = typeof r == "function";
    return (
      i &&
        this._callbacks.push((a) => {
          if (a) {
            r(a !== !0 ? a : new Error(`Unable to unbind from ${t}:${n}`));
            return;
          }
          delete this._forwarding[`${t}:${n}`], r();
        }),
      this._protocol.cancelTcpipForward(t, n, i),
      this
    );
  }
  forwardOut(t, n, r, i, a) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const s = { srcIP: t, srcPort: n, dstIP: r, dstPort: i };
    return (
      typeof a != "function" && (a = K0), yo(this, "direct-tcpip", s, a), this
    );
  }
  openssh_noMoreSessions(t) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const n = typeof t == "function";
    return !this.config.strictVendor ||
      (this.config.strictVendor && cl.test(this._remoteVer))
      ? (n &&
          this._callbacks.push((r) => {
            if (r) {
              t(r !== !0 ? r : new Error("Unable to disable future sessions"));
              return;
            }
            t();
          }),
        this._protocol.openssh_noMoreSessions(n),
        this)
      : n
      ? (process.nextTick(
          t,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version",
          ),
        ),
        this)
      : this;
  }
  openssh_forwardInStreamLocal(t, n) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const r = typeof n == "function";
    return !this.config.strictVendor ||
      (this.config.strictVendor && cl.test(this._remoteVer))
      ? (r &&
          this._callbacks.push((i) => {
            if (i) {
              n(i !== !0 ? i : new Error(`Unable to bind to ${t}`));
              return;
            }
            (this._forwardingUnix[t] = !0), n();
          }),
        this._protocol.openssh_streamLocalForward(t, r),
        this)
      : r
      ? (process.nextTick(
          n,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version",
          ),
        ),
        this)
      : this;
  }
  openssh_unforwardInStreamLocal(t, n) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    const r = typeof n == "function";
    return !this.config.strictVendor ||
      (this.config.strictVendor && cl.test(this._remoteVer))
      ? (r &&
          this._callbacks.push((i) => {
            if (i) {
              n(i !== !0 ? i : new Error(`Unable to unbind from ${t}`));
              return;
            }
            delete this._forwardingUnix[t], n();
          }),
        this._protocol.openssh_cancelStreamLocalForward(t, r),
        this)
      : r
      ? (process.nextTick(
          n,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version",
          ),
        ),
        this)
      : this;
  }
  openssh_forwardOutStreamLocal(t, n) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    return (
      typeof n != "function" && (n = K0),
      !this.config.strictVendor ||
      (this.config.strictVendor && cl.test(this._remoteVer))
        ? (yo(this, "direct-streamlocal@openssh.com", { socketPath: t }, n),
          this)
        : (process.nextTick(
            n,
            new Error(
              "strictVendor enabled and server is not OpenSSH or compatible version",
            ),
          ),
          this)
    );
  }
  sftp(t) {
    if (!this._sock || !Pn(this._sock)) throw new Error("Not connected");
    return (
      yo(this, "sftp", (n, r) => {
        if (n) {
          t(n);
          return;
        }
        AS(r, "sftp", (i, a) => {
          if (i) {
            t(i);
            return;
          }
          function s() {
            r.removeListener("ready", o),
              r.removeListener("error", c),
              r.removeListener("exit", l),
              r.removeListener("close", l);
          }
          function o() {
            s(), t(void 0, r);
          }
          function c(f) {
            s(), t(f);
          }
          function l(f, u) {
            s();
            let d;
            typeof f == "number"
              ? (d = `Received exit code ${f} while establishing SFTP session`)
              : u !== void 0
              ? (d = `Received signal ${u} while establishing SFTP session`)
              : (d = "Received unexpected SFTP session termination");
            const p = new Error(d);
            (p.code = f), (p.signal = u), t(p);
          }
          r.on("ready", o).on("error", c).on("exit", l).on("close", l),
            r._init();
        });
      }),
      this
    );
  }
  setNoDelay(t) {
    return (
      this._sock &&
        typeof this._sock.setNoDelay == "function" &&
        this._sock.setNoDelay(t),
      this
    );
  }
};
function yo(e, t, n, r) {
  const i = Ud,
    a = Fd;
  typeof n == "function" && ((r = n), (n = {}));
  const s = (c, l) => {
    r(c, l);
  };
  s.type = t;
  const o = e._chanMgr.add(s);
  if (o === -1) {
    r(new Error("No free channels available"));
    return;
  }
  switch (t) {
    case "session":
    case "sftp":
      e._protocol.session(o, i, a);
      break;
    case "direct-tcpip":
      e._protocol.directTcpip(o, i, a, n);
      break;
    case "direct-streamlocal@openssh.com":
      e._protocol.openssh_directStreamLocal(o, i, a, n);
      break;
    default:
      throw new Error(`Unsupported channel type: ${t}`);
  }
}
function _S(e, t, n) {
  const r = {
    single: !1,
    protocol: "MIT-MAGIC-COOKIE-1",
    cookie: void 0,
    screen: 0,
  };
  typeof t == "function"
    ? (n = t)
    : typeof t == "object" &&
      t !== null &&
      (typeof t.single == "boolean" && (r.single = t.single),
      typeof t.screen == "number" && (r.screen = t.screen),
      typeof t.protocol == "string" && (r.protocol = t.protocol),
      typeof t.cookie == "string"
        ? (r.cookie = t.cookie)
        : Buffer.isBuffer(t.cookie) &&
          (r.cookie = t.cookie.hexSlice(0, t.cookie.length))),
    r.cookie === void 0 && (r.cookie = Xre());
  const i = typeof n == "function";
  if (e.outgoing.state !== "open") {
    i && n(new Error("Channel is not open"));
    return;
  }
  i &&
    e._callbacks.push((a) => {
      if (a) {
        n(a !== !0 ? a : new Error("Unable to request X11"));
        return;
      }
      (e._hasX11 = !0),
        ++e._client._acceptX11,
        e.once("close", () => {
          e._client._acceptX11 && --e._client._acceptX11;
        }),
        n();
    }),
    e._client._protocol.x11Forward(e.outgoing.id, r, i);
}
function ES(e, t, n) {
  let r = 24,
    i = 80,
    a = 640,
    s = 480,
    o = "vt100",
    c = null;
  typeof t == "function"
    ? (n = t)
    : typeof t == "object" &&
      t !== null &&
      (typeof t.rows == "number" && (r = t.rows),
      typeof t.cols == "number" && (i = t.cols),
      typeof t.width == "number" && (a = t.width),
      typeof t.height == "number" && (s = t.height),
      typeof t.term == "string" && (o = t.term),
      typeof t.modes == "object" && (c = t.modes));
  const l = typeof n == "function";
  if (e.outgoing.state !== "open") {
    l && n(new Error("Channel is not open"));
    return;
  }
  l &&
    e._callbacks.push((f) => {
      if (f) {
        n(f !== !0 ? f : new Error("Unable to request a pseudo-terminal"));
        return;
      }
      n();
    }),
    e._client._protocol.pty(e.outgoing.id, r, i, s, a, o, c, l);
}
function wS(e, t) {
  const n = typeof t == "function";
  if (e.outgoing.state !== "open") {
    n && t(new Error("Channel is not open"));
    return;
  }
  if (e._client._agentFwdEnabled) {
    n && t(!1);
    return;
  }
  (e._client._agentFwdEnabled = !0),
    e._callbacks.push((r) => {
      if (r) {
        (e._client._agentFwdEnabled = !1),
          n &&
            t(r !== !0 ? r : new Error("Unable to request agent forwarding"));
        return;
      }
      n && t();
    }),
    e._client._protocol.openssh_agentForward(e.outgoing.id, !0);
}
function Kre(e, t) {
  if (e.outgoing.state !== "open") {
    t(new Error("Channel is not open"));
    return;
  }
  e._callbacks.push((n) => {
    if (n) {
      t(n !== !0 ? n : new Error("Unable to open shell"));
      return;
    }
    (e.subtype = "shell"), t(void 0, e);
  }),
    e._client._protocol.shell(e.outgoing.id, !0);
}
function Vre(e, t, n, r) {
  if (e.outgoing.state !== "open") {
    r(new Error("Channel is not open"));
    return;
  }
  e._callbacks.push((i) => {
    if (i) {
      r(i !== !0 ? i : new Error("Unable to exec"));
      return;
    }
    (e.subtype = "exec"),
      (e.allowHalfOpen = n.allowHalfOpen !== !1),
      r(void 0, e);
  }),
    e._client._protocol.exec(e.outgoing.id, t, !0);
}
function xS(e, t) {
  if (e.outgoing.state !== "open") return;
  const n = Object.keys(t || {});
  for (let r = 0; r < n.length; ++r) {
    const i = n[r],
      a = t[i];
    e._client._protocol.env(e.outgoing.id, i, a, !1);
  }
}
function AS(e, t, n) {
  if (e.outgoing.state !== "open") {
    n(new Error("Channel is not open"));
    return;
  }
  e._callbacks.push((r) => {
    if (r) {
      n(r !== !0 ? r : new Error(`Unable to start subsystem: ${t}`));
      return;
    }
    (e.subtype = "subsystem"), n(void 0, e);
  }),
    e._client._protocol.subsystem(e.outgoing.id, t, !0);
}
function Yre(e, t) {
  let n = -1,
    r;
  const i = () => {
      const c = {
          type: t.type,
          incoming: { id: n, window: Ud, packetSize: Fd, state: "open" },
          outgoing: {
            id: t.sender,
            window: t.window,
            packetSize: t.packetSize,
            state: "open",
          },
        },
        l = new Vk(e, c);
      return (
        e._chanMgr.update(n, l),
        e._protocol.channelOpenConfirm(t.sender, n, Ud, Fd),
        l
      );
    },
    a = () => {
      r === void 0 &&
        (n === -1 ? (r = Jc.RESOURCE_SHORTAGE) : (r = Jc.CONNECT_FAILED)),
        n !== -1 && e._chanMgr.remove(n),
        e._protocol.channelOpenFail(t.sender, r, "");
    },
    s = () => (
      (n = e._chanMgr.add()),
      n === -1 &&
        ((r = Jc.RESOURCE_SHORTAGE),
        e.config.debug &&
          e.config.debug(
            "Client: Automatic rejection of incoming channel open: no channels available",
          )),
      n !== -1
    ),
    o = t.data;
  switch (t.type) {
    case "forwarded-tcpip": {
      const c = e._forwarding[`${o.destIP}:${o.destPort}`];
      if (c !== void 0 && s()) {
        o.destPort === 0 && (o.destPort = c), e.emit("tcp connection", o, i, a);
        return;
      }
      break;
    }
    case "forwarded-streamlocal@openssh.com":
      if (e._forwardingUnix[o.socketPath] !== void 0 && s()) {
        e.emit("unix connection", o, i, a);
        return;
      }
      break;
    case "auth-agent@openssh.com":
      if (
        e._agentFwdEnabled &&
        typeof e._agent.getStream == "function" &&
        s()
      ) {
        e._agent.getStream((c, l) => {
          if (c) return a();
          const f = i();
          f.pipe(l).pipe(f);
        });
        return;
      }
      break;
    case "x11":
      if (e._acceptX11 !== 0 && s()) {
        e.emit("x11", o, i, a);
        return;
      }
      break;
    default:
      (r = Jc.UNKNOWN_CHANNEL_TYPE),
        e.config.debug &&
          e.config.debug(
            `Client: Automatic rejection of unsupported incoming channel open type: ${t.type}`,
          );
  }
  r === void 0 &&
    ((r = Jc.ADMINISTRATIVELY_PROHIBITED),
    e.config.debug &&
      e.config.debug(
        "Client: Automatic rejection of unexpected incoming channel open for: " +
          t.type,
      )),
    a();
}
const Xre = (() => {
  const e = Buffer.allocUnsafe(16);
  return () => (Ire(e, 0, 16), e.hexSlice(0, 16));
})();
function SS(e) {
  if (!Array.isArray(e)) throw new Error("authList must be an array");
  let t = 0;
  return (n, r, i) => (t === e.length ? !1 : e[t++]);
}
function Jre(e, t, n) {
  if (!e._sock || !Pn(e._sock)) return;
  if ((typeof n != "function" && (n = K0), !Array.isArray(t)))
    throw new TypeError("Invalid keys argument type");
  const r = [];
  for (const i of t) {
    const a = Jf(i);
    if (a instanceof Error) throw a;
    r.push(a);
  }
  if (
    !e.config.strictVendor ||
    (e.config.strictVendor && cl.test(e._remoteVer))
  ) {
    e._callbacks.push((i, a) => {
      if (i) {
        n(i !== !0 ? i : new Error("Server failed to prove supplied keys"));
        return;
      }
      const s = [];
      let o = 0;
      for (Nf.init(a, 0); Nf.avail() && o !== r.length; ) {
        const c = r[o++],
          l = c.getPublicSSH(),
          f = Nf.readString();
        Of.init(f, 0);
        const u = Of.readString(!0);
        let d = Of.readString(),
          p;
        if (u !== c.type)
          if (c.type === "ssh-rsa")
            switch (u) {
              case "rsa-sha2-256":
                p = "sha256";
                break;
              case "rsa-sha2-512":
                p = "sha512";
                break;
              default:
                continue;
            }
          else continue;
        const h = e._protocol._kex.sessionID,
          m = Buffer.allocUnsafe(4 + 29 + 4 + h.length + 4 + l.length);
        let g = 0;
        ag(m, 29, g),
          m.utf8Write("hostkeys-prove-00@openssh.com", (g += 4), 29),
          ag(m, h.length, (g += 29)),
          hS(h, m, 0, h.length, (g += 4)),
          ag(m, l.length, (g += h.length)),
          hS(l, m, 0, l.length, (g += 4)),
          (d = qre(d, u)) && c.verify(m, d, p) === !0 && s.push(c);
      }
      Of.clear(), Nf.clear(), n(null, s);
    }),
      e._protocol.openssh_hostKeysProve(r);
    return;
  }
  process.nextTick(
    n,
    new Error(
      "strictVendor enabled and server is not OpenSSH or compatible version",
    ),
  );
}
function sg(e, t, n) {
  switch (t.type) {
    case "ssh-rsa":
      if (
        (e._protocol._compatFlags & zk.IMPLY_RSA_SHA2_SIGALGS &&
          (Array.isArray(n)
            ? (n = ["rsa-sha2-256", "rsa-sha2-512", ...n])
            : (n = ["rsa-sha2-256", "rsa-sha2-512"])),
        Array.isArray(n))
      ) {
        if (n.indexOf("rsa-sha2-256") !== -1)
          return [["rsa-sha2-256", "sha256"]];
        if (n.indexOf("rsa-sha2-512") !== -1)
          return [["rsa-sha2-512", "sha512"]];
        if (n.indexOf("ssh-rsa") === -1) return [];
      }
      return [["ssh-rsa", "sha1"]];
  }
}
var Yk = zre;
(function (e) {
  const { Agent: t } = Ws,
    { Agent: n } = pI,
    { connect: r } = CT;
  let i;
  for (const o of [t, n]) {
    class c extends o {
      constructor(f, u) {
        super(u),
          (this._connectCfg = f),
          (this._defaultSrcIP = (u && u.srcIP) || "localhost");
      }
      createConnection(f, u) {
        const d = (f && f.localAddress) || this._defaultSrcIP,
          p = (f && f.localPort) || 0,
          h = f.host,
          m = f.port;
        i === void 0 && (i = Yk);
        const g = new i();
        let v = !1;
        g.on("ready", () => {
          g.forwardOut(d, p, h, m, (y, _) => {
            if (((v = !0), y)) return g.end(), u(y);
            _.once("close", () => g.end()), u(null, s(_, o, f));
          });
        })
          .on("error", u)
          .on("close", () => {
            v || u(new Error("Unexpected connection close"));
          })
          .connect(this._connectCfg);
      }
    }
    e[o === t ? "SSHTTPAgent" : "SSHTTPSAgent"] = c;
  }
  function a() {}
  function s(o, c, l) {
    if (c === t)
      return (
        (o.setKeepAlive = a),
        (o.setNoDelay = a),
        (o.setTimeout = a),
        (o.ref = a),
        (o.unref = a),
        (o.destroySoon = o.destroy),
        o
      );
    l.socket = o;
    const f = r(l),
      u = (() => {
        let d = !1;
        return () => {
          d || ((d = !0), o.isPaused() && o.resume());
        };
      })();
    return f.on("end", u).on("close", u), f;
  }
})(yk);
var l1 = { exports: {} };
const { Server: Zre } = ha,
  $u = Hi,
  { listenerCount: lr } = $u,
  {
    CHANNEL_OPEN_FAILURE: bo,
    DEFAULT_CIPHER: eie,
    DEFAULT_COMPRESSION: tie,
    DEFAULT_KEX: nie,
    DEFAULT_MAC: rie,
    DEFAULT_SERVER_HOST_KEY: iie,
    DISCONNECT_REASON: _o,
    DISCONNECT_REASON_BY_VALUE: aie,
    SUPPORTED_CIPHER: sie,
    SUPPORTED_COMPRESSION: oie,
    SUPPORTED_KEX: cie,
    SUPPORTED_MAC: lie,
    SUPPORTED_SERVER_HOST_KEY: uie,
  } = es(),
  { init: fie } = eo(),
  { KexInit: die } = i1(),
  { parseKey: IS } = to,
  pie = kk,
  { SFTP: hie } = Zp,
  { writeUInt32BE: mie } = Ki(),
  {
    Channel: Eo,
    MAX_WINDOW: Ra,
    PACKET_SIZE: ka,
    windowAdjust: gie,
    WINDOW_THRESHOLD: vie,
  } = qk,
  {
    ChannelManager: yie,
    generateAlgorithmList: el,
    isWritable: Pf,
    onChannelOpenFailure: bie,
    onCHANNEL_CLOSE: _ie,
  } = Wk,
  Eie = 10;
class fc extends $u {
  constructor(t, n, r, i, a) {
    super(),
      (this.username = this.user = n),
      (this.service = r),
      (this.method = i),
      (this._initialResponse = !1),
      (this._finalResponse = !1),
      (this._multistep = !1),
      (this._cbfinal = (s, o, c) => {
        this._finalResponse || ((this._finalResponse = !0), a(this, s, o, c));
      }),
      (this._protocol = t);
  }
  accept() {
    this._cleanup && this._cleanup(),
      (this._initialResponse = !0),
      this._cbfinal(!0);
  }
  reject(t, n) {
    this._cleanup && this._cleanup(),
      (this._initialResponse = !0),
      this._cbfinal(!1, t, n);
  }
}
class $S extends fc {
  constructor(t, n, r, i, a, s) {
    super(t, n, r, i, s),
      (this._multistep = !0),
      (this._cb = void 0),
      (this._onInfoResponse = (o) => {
        const c = this._cb;
        c && ((this._cb = void 0), c(o));
      }),
      (this.submethods = a),
      this.on("abort", () => {
        this._cb && this._cb(new Error("Authentication request aborted"));
      });
  }
  prompt(t, n, r, i) {
    Array.isArray(t) || (t = [t]),
      typeof n == "function"
        ? ((i = n), (n = r = void 0))
        : typeof r == "function"
        ? ((i = r), (r = void 0))
        : typeof i != "function" && (i = void 0);
    for (let a = 0; a < t.length; ++a)
      typeof t[a] == "string" && (t[a] = { prompt: t[a], echo: !0 });
    (this._cb = i),
      (this._initialResponse = !0),
      this._protocol.authInfoReq(n, r, t);
  }
}
class wie extends fc {
  constructor(t, n, r, i, a, s) {
    super(t, n, r, i, s),
      (this.key = { algo: a.keyAlgo, data: a.key }),
      (this.hashAlgo = a.hashAlgo),
      (this.signature = a.signature),
      (this.blob = a.blob);
  }
  accept() {
    this.signature
      ? fc.prototype.accept.call(this)
      : ((this._initialResponse = !0),
        this._protocol.authPKOK(this.key.algo, this.key.data));
  }
}
class xie extends fc {
  constructor(t, n, r, i, a, s) {
    super(t, n, r, i, s),
      (this.key = { algo: a.keyAlgo, data: a.key }),
      (this.hashAlgo = a.hashAlgo),
      (this.signature = a.signature),
      (this.blob = a.blob),
      (this.localHostname = a.localHostname),
      (this.localUsername = a.localUsername);
  }
}
class CS extends fc {
  constructor(t, n, r, i, a, s) {
    super(t, n, r, i, s), (this.password = a), (this._changeCb = void 0);
  }
  requestChange(t, n) {
    if (this._changeCb) throw new Error("Change request already in progress");
    if (typeof t != "string")
      throw new Error("prompt argument must be a string");
    if (typeof n != "function")
      throw new Error("Callback argument must be a function");
    (this._changeCb = n), this._protocol.authPasswdChg(t);
  }
}
class Sa extends $u {
  constructor(t, n, r) {
    super(),
      (this.type = "session"),
      (this.subtype = void 0),
      (this.server = !0),
      (this._ending = !1),
      (this._channel = void 0),
      (this._chanInfo = {
        type: "session",
        incoming: { id: r, window: Ra, packetSize: ka, state: "open" },
        outgoing: {
          id: n.sender,
          window: n.window,
          packetSize: n.packetSize,
          state: "open",
        },
      });
  }
}
class fi extends $u {
  constructor(t, n) {
    if ((super(), typeof t != "object" || t === null))
      throw new Error("Missing configuration object");
    const r = Object.create(null),
      i = [],
      a = t.hostKeys;
    if (!Array.isArray(a)) throw new Error("hostKeys must be an array");
    const s =
        typeof t.algorithms == "object" && t.algorithms !== null
          ? t.algorithms
          : {},
      o = el(s.serverHostKey, iie, uie);
    for (let d = 0; d < a.length; ++d) {
      let p;
      if (
        (Buffer.isBuffer(a[d]) || typeof a[d] == "string"
          ? (p = IS(a[d]))
          : (p = IS(a[d].key, a[d].passphrase)),
        p instanceof Error)
      )
        throw new Error(`Cannot parse privateKey: ${p.message}`);
      if ((Array.isArray(p) && (p = p[0]), p.getPrivatePEM() === null))
        throw new Error("privateKey value contains an invalid private key");
      if (!i.includes(p.type))
        if (p.type === "ssh-rsa") {
          let h = o.indexOf("ssh-rsa");
          const m = o.indexOf("rsa-sha2-256"),
            g = o.indexOf("rsa-sha2-512");
          h === -1 && (h = 1 / 0),
            [h, m, g].sort(Aie).forEach((v) => {
              if (v === -1) return;
              let y;
              switch (v) {
                case h:
                  y = "ssh-rsa";
                  break;
                case m:
                  y = "rsa-sha2-256";
                  break;
                case g:
                  y = "rsa-sha2-512";
                  break;
                default:
                  return;
              }
              (r[y] = p), i.push(y);
            });
        } else (r[p.type] = p), i.push(p.type);
    }
    const c = {
      kex: el(s.kex, nie, cie),
      serverHostKey: i,
      cs: {
        cipher: el(s.cipher, eie, sie),
        mac: el(s.hmac, rie, lie),
        compress: el(s.compress, tie, oie),
        lang: [],
      },
      sc: void 0,
    };
    (c.sc = c.cs), typeof n == "function" && this.on("connection", n);
    const l = typeof t.debug == "function" ? t.debug : void 0,
      f = t.ident ? Buffer.from(t.ident) : void 0,
      u = new die(c);
    (this._srv = new Zre((d) => {
      if (this._connections >= this.maxConnections) {
        d.destroy();
        return;
      }
      ++this._connections,
        d.once("close", () => {
          --this._connections;
        });
      let p;
      if (l) {
        const h = `[${process.hrtime().join(".")}] `;
        p = (m) => {
          l(`${h}${m}`);
        };
      }
      new Xk(d, r, f, u, p, this, t);
    })
      .on("error", (d) => {
        this.emit("error", d);
      })
      .on("listening", () => {
        this.emit("listening");
      })
      .on("close", () => {
        this.emit("close");
      })),
      (this._connections = 0),
      (this.maxConnections = 1 / 0);
  }
  injectSocket(t) {
    this._srv.emit("connection", t);
  }
  listen(...t) {
    return this._srv.listen(...t), this;
  }
  address() {
    return this._srv.address();
  }
  getConnections(t) {
    return this._srv.getConnections(t), this;
  }
  close(t) {
    return this._srv.close(t), this;
  }
  ref() {
    return this._srv.ref(), this;
  }
  unref() {
    return this._srv.unref(), this;
  }
}
fi.KEEPALIVE_CLIENT_INTERVAL = 15e3;
fi.KEEPALIVE_CLIENT_COUNT_MAX = 3;
class Xk extends $u {
  constructor(t, n, r, i, a, s, o) {
    super();
    let c = 0,
      l = !1,
      f = [],
      u,
      d,
      p;
    const h = [];
    (this._sock = t),
      (this._chanMgr = new yie(this)),
      (this._debug = a),
      (this.noMoreSessions = !1),
      (this.authenticated = !1);
    function m(I) {}
    this.on("error", m);
    const g = a
        ? (I, S, w) => {
            a(`Debug output from client: ${JSON.stringify(w)}`);
          }
        : void 0,
      v =
        typeof o.keepaliveInterval == "number" &&
        isFinite(o.keepaliveInterval) &&
        o.keepaliveInterval > 0
          ? o.keepaliveInterval
          : typeof fi.KEEPALIVE_CLIENT_INTERVAL == "number" &&
            isFinite(fi.KEEPALIVE_CLIENT_INTERVAL) &&
            fi.KEEPALIVE_CLIENT_INTERVAL > 0
          ? fi.KEEPALIVE_CLIENT_INTERVAL
          : -1,
      y =
        typeof o.keepaliveCountMax == "number" &&
        isFinite(o.keepaliveCountMax) &&
        o.keepaliveCountMax >= 0
          ? o.keepaliveCountMax
          : typeof fi.KEEPALIVE_CLIENT_COUNT_MAX == "number" &&
            isFinite(fi.KEEPALIVE_CLIENT_COUNT_MAX) &&
            fi.KEEPALIVE_CLIENT_COUNT_MAX >= 0
          ? fi.KEEPALIVE_CLIENT_COUNT_MAX
          : -1;
    let _ = 0;
    v !== -1 &&
      y !== -1 &&
      (this.once("ready", () => {
        const I = () => {
          clearInterval(d);
        };
        this.on("close", I).on("end", I),
          (d = setInterval(() => {
            if (++_ > y) {
              clearInterval(d);
              const S = new Error("Keepalive timeout");
              (S.level = "client-timeout"), this.emit("error", S), this.end();
            } else E.ping();
          }, v));
      }),
      (p = () => {
        d && d.refresh(), (_ = 0);
      }));
    const E = (this._protocol = new pie({
      server: !0,
      hostKeys: n,
      ident: r,
      offer: i,
      onPacket: p,
      greeting: o.greeting,
      banner: o.banner,
      onWrite: (I) => {
        Pf(t) && t.write(I);
      },
      onError: (I) => {
        E._destruct || t.removeAllListeners("data"), this.emit("error", I);
        try {
          t.end();
        } catch {}
      },
      onHeader: (I) => {
        this.removeListener("error", m);
        const S = {
          ip: t.remoteAddress,
          family: t.remoteFamily,
          port: t.remotePort,
          header: I,
        };
        if (!s.emit("connection", this, S)) {
          E.disconnect(_o.BY_APPLICATION), t.end();
          return;
        }
        I.greeting && this.emit("greeting", I.greeting);
      },
      onHandshakeComplete: (I) => {
        ++c > 1 && this.emit("rekey"), this.emit("handshake", I);
      },
      debug: a,
      messageHandlers: {
        DEBUG: g,
        DISCONNECT: (I, S, w) => {
          if (S !== _o.BY_APPLICATION) {
            w ||
              ((w = aie[S]),
              w === void 0 && (w = `Unexpected disconnection reason: ${S}`));
            const O = new Error(w);
            (O.code = S), this.emit("error", O);
          }
          t.end();
        },
        CHANNEL_OPEN: (I, S) => {
          if (
            (S.type === "session" && this.noMoreSessions) ||
            !this.authenticated
          ) {
            const Z = bo.ADMINISTRATIVELY_PROHIBITED;
            return E.channelOpenFail(S.sender, Z);
          }
          let w = -1,
            O,
            Q = !1,
            j;
          const H = () => {
              Q ||
                ((Q = !0),
                O === void 0 &&
                  (w === -1
                    ? (O = bo.RESOURCE_SHORTAGE)
                    : (O = bo.CONNECT_FAILED)),
                w !== -1 && this._chanMgr.remove(w),
                E.channelOpenFail(S.sender, O, ""));
            },
            q = () => (
              (w = this._chanMgr.add()),
              w === -1 &&
                ((O = bo.RESOURCE_SHORTAGE),
                a &&
                  a(
                    "Automatic rejection of incoming channel open: no channels available",
                  )),
              w !== -1
            ),
            J = S.data;
          switch (S.type) {
            case "session":
              if (lr(this, "session") && q()) {
                (j = () => {
                  if (Q) return;
                  Q = !0;
                  const Z = new Sa(this, S, w);
                  return (
                    this._chanMgr.update(w, Z),
                    E.channelOpenConfirm(S.sender, w, Ra, ka),
                    Z
                  );
                }),
                  this.emit("session", j, H);
                return;
              }
              break;
            case "direct-tcpip":
              if (lr(this, "tcpip") && q()) {
                (j = () => {
                  if (Q) return;
                  Q = !0;
                  const Z = {
                      type: void 0,
                      incoming: {
                        id: w,
                        window: Ra,
                        packetSize: ka,
                        state: "open",
                      },
                      outgoing: {
                        id: S.sender,
                        window: S.window,
                        packetSize: S.packetSize,
                        state: "open",
                      },
                    },
                    z = new Eo(this, Z, { server: !0 });
                  return (
                    this._chanMgr.update(w, z),
                    E.channelOpenConfirm(S.sender, w, Ra, ka),
                    z
                  );
                }),
                  this.emit("tcpip", j, H, J);
                return;
              }
              break;
            case "direct-streamlocal@openssh.com":
              if (lr(this, "openssh.streamlocal") && q()) {
                (j = () => {
                  if (Q) return;
                  Q = !0;
                  const Z = {
                      type: void 0,
                      incoming: {
                        id: w,
                        window: Ra,
                        packetSize: ka,
                        state: "open",
                      },
                      outgoing: {
                        id: S.sender,
                        window: S.window,
                        packetSize: S.packetSize,
                        state: "open",
                      },
                    },
                    z = new Eo(this, Z, { server: !0 });
                  return (
                    this._chanMgr.update(w, z),
                    E.channelOpenConfirm(S.sender, w, Ra, ka),
                    z
                  );
                }),
                  this.emit("openssh.streamlocal", j, H, J);
                return;
              }
              break;
            default:
              (O = bo.UNKNOWN_CHANNEL_TYPE),
                a &&
                  a(
                    `Automatic rejection of unsupported incoming channel open type: ${S.type}`,
                  );
          }
          O === void 0 &&
            ((O = bo.ADMINISTRATIVELY_PROHIBITED),
            a &&
              a(
                `Automatic rejection of unexpected incoming channel open for: ${S.type}`,
              )),
            H();
        },
        CHANNEL_OPEN_CONFIRMATION: (I, S) => {
          const w = this._chanMgr.get(S.recipient);
          if (typeof w != "function") return;
          const O = {
              type: w.type,
              incoming: {
                id: S.recipient,
                window: Ra,
                packetSize: ka,
                state: "open",
              },
              outgoing: {
                id: S.sender,
                window: S.window,
                packetSize: S.packetSize,
                state: "open",
              },
            },
            Q = new Eo(this, O, { server: !0 });
          this._chanMgr.update(S.recipient, Q), w(void 0, Q);
        },
        CHANNEL_OPEN_FAILURE: (I, S, w, O) => {
          const Q = this._chanMgr.get(S);
          if (typeof Q != "function") return;
          bie(this, S, { reason: w, description: O }, Q);
        },
        CHANNEL_DATA: (I, S, w) => {
          let O = this._chanMgr.get(S);
          if (
            !(typeof O != "object" || O === null) &&
            !(O.constructor === Sa && ((O = O._channel), !O)) &&
            O.incoming.window !== 0
          ) {
            if (((O.incoming.window -= w.length), O.push(w) === !1)) {
              O._waitChanDrain = !0;
              return;
            }
            O.incoming.window <= vie && gie(O);
          }
        },
        CHANNEL_EXTENDED_DATA: (I, S, w, O) => {},
        CHANNEL_WINDOW_ADJUST: (I, S, w) => {
          let O = this._chanMgr.get(S);
          typeof O != "object" ||
            O === null ||
            (O.constructor === Sa && ((O = O._channel), !O)) ||
            ((O.outgoing.window += w),
            O._waitWindow &&
              ((O._waitWindow = !1),
              O._chunk
                ? O._write(O._chunk, null, O._chunkcb)
                : O._chunkcb
                ? O._chunkcb()
                : O._chunkErr
                ? O.stderr._write(O._chunkErr, null, O._chunkcbErr)
                : O._chunkcbErr && O._chunkcbErr()));
        },
        CHANNEL_SUCCESS: (I, S) => {
          let w = this._chanMgr.get(S);
          typeof w != "object" ||
            w === null ||
            (w.constructor === Sa && ((w = w._channel), !w)) ||
            (w._callbacks.length && w._callbacks.shift()(!1));
        },
        CHANNEL_FAILURE: (I, S) => {
          let w = this._chanMgr.get(S);
          typeof w != "object" ||
            w === null ||
            (w.constructor === Sa && ((w = w._channel), !w)) ||
            (w._callbacks.length && w._callbacks.shift()(!0));
        },
        CHANNEL_REQUEST: (I, S, w, O, Q) => {
          const j = this._chanMgr.get(S);
          if (typeof j != "object" || j === null) return;
          let H = !1,
            q,
            J;
          if (j.constructor !== Sa) {
            O && E.channelFailure(j.outgoing.id);
            return;
          }
          if (
            (O &&
              (w !== "shell" &&
                w !== "exec" &&
                w !== "subsystem" &&
                (q = () => {
                  H ||
                    j._ending ||
                    j._channel ||
                    ((H = !0), E.channelSuccess(j._chanInfo.outgoing.id));
                }),
              (J = () => {
                H ||
                  j._ending ||
                  j._channel ||
                  ((H = !0), E.channelFailure(j._chanInfo.outgoing.id));
              })),
            j._ending)
          ) {
            J && J();
            return;
          }
          switch (w) {
            case "env":
              if (lr(j, "env")) {
                j.emit("env", q, J, { key: Q.name, val: Q.value });
                return;
              }
              break;
            case "pty-req":
              if (lr(j, "pty")) {
                j.emit("pty", q, J, Q);
                return;
              }
              break;
            case "window-change":
              lr(j, "window-change")
                ? j.emit("window-change", q, J, Q)
                : J && J();
              break;
            case "x11-req":
              if (lr(j, "x11")) {
                j.emit("x11", q, J, Q);
                return;
              }
              break;
            case "signal":
              if (lr(j, "signal")) {
                j.emit("signal", q, J, { name: Q });
                return;
              }
              break;
            case "auth-agent-req@openssh.com":
              if (lr(j, "auth-agent")) {
                j.emit("auth-agent", q, J);
                return;
              }
              break;
            case "shell":
              if (lr(j, "shell")) {
                (q = () => {
                  if (H || j._ending || j._channel) return;
                  (H = !0), O && E.channelSuccess(j._chanInfo.outgoing.id);
                  const Z = new Eo(this, j._chanInfo, { server: !0 });
                  return (Z.subtype = j.subtype = w), (j._channel = Z), Z;
                }),
                  j.emit("shell", q, J);
                return;
              }
              break;
            case "exec":
              if (lr(j, "exec")) {
                (q = () => {
                  if (H || j._ending || j._channel) return;
                  (H = !0), O && E.channelSuccess(j._chanInfo.outgoing.id);
                  const Z = new Eo(this, j._chanInfo, { server: !0 });
                  return (Z.subtype = j.subtype = w), (j._channel = Z), Z;
                }),
                  j.emit("exec", q, J, { command: Q });
                return;
              }
              break;
            case "subsystem": {
              let Z = Q === "sftp";
              if (
                ((q = () => {
                  if (H || j._ending || j._channel) return;
                  (H = !0), O && E.channelSuccess(j._chanInfo.outgoing.id);
                  let z;
                  return (
                    Z
                      ? (z = new hie(this, j._chanInfo, {
                          server: !0,
                          debug: a,
                        }))
                      : ((z = new Eo(this, j._chanInfo, { server: !0 })),
                        (z.subtype = j.subtype = `${w}:${Q}`)),
                    (j._channel = z),
                    z
                  );
                }),
                Q === "sftp")
              ) {
                if (lr(j, "sftp")) {
                  j.emit("sftp", q, J);
                  return;
                }
                Z = !1;
              }
              if (lr(j, "subsystem")) {
                j.emit("subsystem", q, J, { name: Q });
                return;
              }
              break;
            }
          }
          a && a(`Automatic rejection of incoming channel request: ${w}`),
            J && J();
        },
        CHANNEL_EOF: (I, S) => {
          let w = this._chanMgr.get(S);
          typeof w != "object" ||
            w === null ||
            (w.constructor === Sa &&
              (w._ending || ((w._ending = !0), w.emit("eof"), w.emit("end")),
              (w = w._channel),
              !w)) ||
            (w.incoming.state === "open" &&
              ((w.incoming.state = "eof"), w.readable && w.push(null)));
        },
        CHANNEL_CLOSE: (I, S) => {
          let w = this._chanMgr.get(S);
          typeof w != "object" ||
            w === null ||
            (w.constructor === Sa &&
              ((w._ending = !0), w.emit("close"), (w = w._channel), !w)) ||
            _ie(this, S, w);
        },
        SERVICE_REQUEST: (I, S) => {
          if (c === 0 || l || this.authenticated || S !== "ssh-userauth") {
            E.disconnect(_o.SERVICE_NOT_AVAILABLE), t.end();
            return;
          }
          (l = !0), E.serviceAccept(S);
        },
        USERAUTH_REQUEST: (I, S, w, O, Q) => {
          if (
            c === 0 ||
            this.authenticated ||
            (u && (u.username !== S || u.service !== w)) ||
            (O !== "password" &&
              O !== "publickey" &&
              O !== "hostbased" &&
              O !== "keyboard-interactive" &&
              O !== "none") ||
            f.length === Eie
          ) {
            E.disconnect(_o.PROTOCOL_ERROR), t.end();
            return;
          } else if (w !== "ssh-connection") {
            E.disconnect(_o.SERVICE_NOT_AVAILABLE), t.end();
            return;
          }
          let j;
          switch (O) {
            case "keyboard-interactive":
              j = new $S(E, S, w, O, Q, R);
              break;
            case "publickey":
              j = new wie(E, S, w, O, Q, R);
              break;
            case "hostbased":
              j = new xie(E, S, w, O, Q, R);
              break;
            case "password":
              if (u && u instanceof CS && u._changeCb) {
                const H = u._changeCb;
                (u._changeCb = void 0), H(Q.newPassword);
                return;
              }
              j = new CS(E, S, w, O, Q, R);
              break;
            case "none":
              j = new fc(E, S, w, O, R);
              break;
          }
          if (u)
            if (u._initialResponse)
              u._multistep &&
                !u._finalResponse &&
                (u._cleanup && u._cleanup(), u.emit("abort"));
            else return f.push(j);
          (u = j),
            lr(this, "authentication")
              ? this.emit("authentication", u)
              : u.reject();
        },
        USERAUTH_INFO_RESPONSE: (I, S) => {
          u && u instanceof $S && u._onInfoResponse(S);
        },
        GLOBAL_REQUEST: (I, S, w, O) => {
          const Q = { type: null, buf: null };
          function j(H, q) {
            (Q.type = H), (Q.buf = q), A();
          }
          if (
            (w && h.push(Q),
            (S === "tcpip-forward" ||
              S === "cancel-tcpip-forward" ||
              S === "no-more-sessions@openssh.com" ||
              S === "streamlocal-forward@openssh.com" ||
              S === "cancel-streamlocal-forward@openssh.com") &&
              lr(this, "request") &&
              this.authenticated)
          ) {
            let H, q;
            if (w) {
              let J = !1;
              (H = (Z) => {
                if (J) return;
                J = !0;
                let z;
                S === "tcpip-forward" &&
                  O.bindPort === 0 &&
                  typeof Z == "number" &&
                  ((z = Buffer.allocUnsafe(4)), mie(z, Z, 0)),
                  j("SUCCESS", z);
              }),
                (q = () => {
                  J || ((J = !0), j("FAILURE"));
                });
            }
            if (S === "no-more-sessions@openssh.com") {
              (this.noMoreSessions = !0), H && H();
              return;
            }
            this.emit("request", H, q, S, O);
          } else w && j("FAILURE");
        },
      },
    }));
    t.pause(),
      fie
        .then(() => {
          E.start(),
            t.on("data", (I) => {
              try {
                E.parse(I, 0, I.length);
              } catch (S) {
                this.emit("error", S);
                try {
                  Pf(t) && t.end();
                } catch {}
              }
            }),
            t.resume();
        })
        .catch((I) => {
          this.emit("error", I);
          try {
            Pf(t) && t.end();
          } catch {}
        }),
      t
        .on("error", (I) => {
          (I.level = "socket"), this.emit("error", I);
        })
        .once("end", () => {
          a && a("Socket ended"), E.cleanup(), this.emit("end");
        })
        .once("close", () => {
          a && a("Socket closed"), E.cleanup(), this.emit("close");
          const I = new Error("No response from server");
          this._chanMgr.cleanup(I);
        });
    const R = (I, S, w, O) => {
      u === I &&
        !this.authenticated &&
        (S
          ? ((u = void 0),
            (this.authenticated = !0),
            E.authSuccess(),
            (f = []),
            this.emit("ready"))
          : (E.authFailure(w, O),
            f.length &&
              ((u = f.pop()),
              lr(this, "authentication")
                ? this.emit("authentication", u)
                : u.reject())));
    };
    function A() {
      for (; h.length > 0 && h[0].type; ) {
        const I = h.shift();
        I.type === "SUCCESS" && E.requestSuccess(I.buf),
          I.type === "FAILURE" && E.requestFailure();
      }
    }
  }
  end() {
    return (
      this._sock &&
        Pf(this._sock) &&
        (this._protocol.disconnect(_o.BY_APPLICATION), this._sock.end()),
      this
    );
  }
  x11(t, n, r) {
    return og(this, "x11", { originAddr: t, originPort: n }, r), this;
  }
  forwardOut(t, n, r, i, a) {
    return (
      og(
        this,
        "forwarded-tcpip",
        { boundAddr: t, boundPort: n, remoteAddr: r, remotePort: i },
        a,
      ),
      this
    );
  }
  openssh_forwardOutStreamLocal(t, n) {
    return (
      og(this, "forwarded-streamlocal@openssh.com", { socketPath: t }, n), this
    );
  }
  rekey(t) {
    let n;
    try {
      this._protocol.rekey();
    } catch (r) {
      n = r;
    }
    typeof t == "function" &&
      (n ? process.nextTick(t, n) : this.once("rekey", t));
  }
  setNoDelay(t) {
    return (
      this._sock &&
        typeof this._sock.setNoDelay == "function" &&
        this._sock.setNoDelay(t),
      this
    );
  }
}
function og(e, t, n, r) {
  const i = Ra,
    a = ka;
  typeof n == "function" && ((r = n), (n = {}));
  const s = (c, l) => {
    r(c, l);
  };
  s.type = t;
  const o = e._chanMgr.add(s);
  if (o === -1) {
    r(new Error("No free channels available"));
    return;
  }
  switch (t) {
    case "forwarded-tcpip":
      e._protocol.forwardedTcpip(o, i, a, n);
      break;
    case "x11":
      e._protocol.x11(o, i, a, n);
      break;
    case "forwarded-streamlocal@openssh.com":
      e._protocol.openssh_forwardedStreamLocal(o, i, a, n);
      break;
    default:
      throw new Error(`Unsupported channel type: ${t}`);
  }
}
function Aie(e, t) {
  return e - t;
}
l1.exports = fi;
l1.exports.IncomingClient = Xk;
var Sie = l1.exports;
const {
    createCipheriv: Iie,
    generateKeyPair: $ie,
    generateKeyPairSync: Cie,
    getCurves: Rie,
    randomBytes: RS,
  } = pr,
  { Ber: vn } = Yp,
  kie = rk.pbkdf,
  { CIPHER_INFO: Tie } = eo(),
  Nie = 16,
  Oie = 16,
  Pie = Rie(),
  Die = new Map(Object.entries(Tie));
function kS(e, t) {
  if (typeof e != "string") throw new TypeError("Key type must be a string");
  const n = { type: "spki", format: "der" },
    r = { type: "pkcs8", format: "der" };
  switch (e.toLowerCase()) {
    case "rsa": {
      if (typeof t != "object" || t === null)
        throw new TypeError("Missing options object for RSA key");
      const i = t.bits;
      if (!Number.isInteger(i))
        throw new TypeError("RSA bits must be an integer");
      if (i <= 0 || i > 16384)
        throw new RangeError("RSA bits must be non-zero and <= 16384");
      return [
        "rsa",
        { modulusLength: i, publicKeyEncoding: n, privateKeyEncoding: r },
      ];
    }
    case "ecdsa": {
      if (typeof t != "object" || t === null)
        throw new TypeError("Missing options object for ECDSA key");
      if (!Number.isInteger(t.bits))
        throw new TypeError("ECDSA bits must be an integer");
      let i;
      switch (t.bits) {
        case 256:
          i = "prime256v1";
          break;
        case 384:
          i = "secp384r1";
          break;
        case 521:
          i = "secp521r1";
          break;
        default:
          throw new Error("ECDSA bits must be 256, 384, or 521");
      }
      if (!Pie.includes(i)) throw new Error("Unsupported ECDSA bits value");
      return [
        "ec",
        { namedCurve: i, publicKeyEncoding: n, privateKeyEncoding: r },
      ];
    }
    case "ed25519":
      return ["ed25519", { publicKeyEncoding: n, privateKeyEncoding: r }];
    default:
      throw new Error(`Unsupported key type: ${e}`);
  }
}
function Lie(e, t, n) {
  switch (e) {
    case "rsa": {
      let r = new vn.Reader(n);
      if ((r.readSequence(), r.readInt() !== 0))
        throw new Error("Unsupported version in RSA private key");
      if ((r.readSequence(), r.readOID() !== "1.2.840.113549.1.1.1"))
        throw new Error("Bad RSA private OID");
      if (r.readByte() !== vn.Null)
        throw new Error("Malformed RSA private key (expected null)");
      if (r.readByte() !== 0)
        throw new Error(
          "Malformed RSA private key (expected zero-length null)",
        );
      if (
        ((r = new vn.Reader(r.readString(vn.OctetString, !0))),
        r.readSequence(),
        r.readInt() !== 0)
      )
        throw new Error("Unsupported version in RSA private key");
      const i = r.readString(vn.Integer, !0),
        a = r.readString(vn.Integer, !0),
        s = r.readString(vn.Integer, !0),
        o = r.readString(vn.Integer, !0),
        c = r.readString(vn.Integer, !0);
      r.readString(vn.Integer, !0), r.readString(vn.Integer, !0);
      const l = r.readString(vn.Integer, !0),
        f = Buffer.from("ssh-rsa"),
        u = Buffer.allocUnsafe(
          4 +
            f.length +
            4 +
            i.length +
            4 +
            a.length +
            4 +
            s.length +
            4 +
            l.length +
            4 +
            o.length +
            4 +
            c.length,
        );
      let d = 0;
      u.writeUInt32BE(f.length, (d += 0)),
        u.set(f, (d += 4)),
        u.writeUInt32BE(i.length, (d += f.length)),
        u.set(i, (d += 4)),
        u.writeUInt32BE(a.length, (d += i.length)),
        u.set(a, (d += 4)),
        u.writeUInt32BE(s.length, (d += a.length)),
        u.set(s, (d += 4)),
        u.writeUInt32BE(l.length, (d += s.length)),
        u.set(l, (d += 4)),
        u.writeUInt32BE(o.length, (d += l.length)),
        u.set(o, (d += 4)),
        u.writeUInt32BE(c.length, (d += o.length)),
        u.set(c, (d += 4));
      const p = Buffer.allocUnsafe(4 + f.length + 4 + a.length + 4 + i.length);
      return (
        (d = 0),
        p.writeUInt32BE(f.length, (d += 0)),
        p.set(f, (d += 4)),
        p.writeUInt32BE(a.length, (d += f.length)),
        p.set(a, (d += 4)),
        p.writeUInt32BE(i.length, (d += a.length)),
        p.set(i, (d += 4)),
        { sshName: f.toString(), priv: u, pub: p }
      );
    }
    case "ec": {
      let r = new vn.Reader(t);
      if (
        (r.readSequence(),
        r.readSequence(),
        r.readOID() !== "1.2.840.10045.2.1")
      )
        throw new Error("Bad ECDSA public OID");
      r.readOID();
      let i = r.readString(vn.BitString, !0);
      {
        let d = 0;
        for (; d < i.length && i[d] === 0; ++d);
        d > 0 && (i = i.slice(d));
      }
      if (((r = new vn.Reader(n)), r.readSequence(), r.readInt() !== 0))
        throw new Error("Unsupported version in ECDSA private key");
      if ((r.readSequence(), r.readOID() !== "1.2.840.10045.2.1"))
        throw new Error("Bad ECDSA private OID");
      const a = r.readOID();
      let s;
      switch (a) {
        case "1.2.840.10045.3.1.7":
          s = "nistp256";
          break;
        case "1.3.132.0.34":
          s = "nistp384";
          break;
        case "1.3.132.0.35":
          s = "nistp521";
          break;
        default:
          throw new Error("Unsupported curve in ECDSA private key");
      }
      if (
        ((r = new vn.Reader(r.readString(vn.OctetString, !0))),
        r.readSequence(),
        r.readInt() !== 1)
      )
        throw new Error("Unsupported version in ECDSA private key");
      const o = Buffer.concat([
          Buffer.from([0]),
          r.readString(vn.OctetString, !0),
        ]),
        c = Buffer.from(`ecdsa-sha2-${s}`);
      s = Buffer.from(s);
      const l = Buffer.allocUnsafe(
        4 + c.length + 4 + s.length + 4 + i.length + 4 + o.length,
      );
      let f = 0;
      l.writeUInt32BE(c.length, (f += 0)),
        l.set(c, (f += 4)),
        l.writeUInt32BE(s.length, (f += c.length)),
        l.set(s, (f += 4)),
        l.writeUInt32BE(i.length, (f += s.length)),
        l.set(i, (f += 4)),
        l.writeUInt32BE(o.length, (f += i.length)),
        l.set(o, (f += 4));
      const u = Buffer.allocUnsafe(4 + c.length + 4 + s.length + 4 + i.length);
      return (
        (f = 0),
        u.writeUInt32BE(c.length, (f += 0)),
        u.set(c, (f += 4)),
        u.writeUInt32BE(s.length, (f += c.length)),
        u.set(s, (f += 4)),
        u.writeUInt32BE(i.length, (f += s.length)),
        u.set(i, (f += 4)),
        { sshName: c.toString(), priv: l, pub: u }
      );
    }
    case "ed25519": {
      let r = new vn.Reader(t);
      if ((r.readSequence(), r.readSequence(), r.readOID() !== "1.3.101.112"))
        throw new Error("Bad ED25519 public OID");
      let i = r.readString(vn.BitString, !0);
      {
        let f = 0;
        for (; f < i.length && i[f] === 0; ++f);
        f > 0 && (i = i.slice(f));
      }
      if (((r = new vn.Reader(n)), r.readSequence(), r.readInt() !== 0))
        throw new Error("Unsupported version in ED25519 private key");
      if ((r.readSequence(), r.readOID() !== "1.3.101.112"))
        throw new Error("Bad ED25519 private OID");
      r = new vn.Reader(r.readString(vn.OctetString, !0));
      const a = r.readString(vn.OctetString, !0),
        s = Buffer.from("ssh-ed25519"),
        o = Buffer.allocUnsafe(
          4 + s.length + 4 + i.length + 4 + (a.length + i.length),
        );
      let c = 0;
      o.writeUInt32BE(s.length, (c += 0)),
        o.set(s, (c += 4)),
        o.writeUInt32BE(i.length, (c += s.length)),
        o.set(i, (c += 4)),
        o.writeUInt32BE(a.length + i.length, (c += i.length)),
        o.set(a, (c += 4)),
        o.set(i, (c += a.length));
      const l = Buffer.allocUnsafe(4 + s.length + 4 + i.length);
      return (
        (c = 0),
        l.writeUInt32BE(s.length, (c += 0)),
        l.set(s, (c += 4)),
        l.writeUInt32BE(i.length, (c += s.length)),
        l.set(i, (c += 4)),
        { sshName: s.toString(), priv: o, pub: l }
      );
    }
  }
}
function TS(e, t, n, r) {
  let i = "new",
    a,
    s = "";
  if (
    typeof r == "object" &&
    r !== null &&
    (typeof r.comment == "string" && r.comment && (s = r.comment),
    typeof r.format == "string" && r.format && (i = r.format),
    r.passphrase)
  ) {
    let o;
    if (typeof r.passphrase == "string") o = Buffer.from(r.passphrase);
    else if (Buffer.isBuffer(r.passphrase)) o = r.passphrase;
    else throw new Error("Invalid passphrase");
    if (r.cipher === void 0) throw new Error("Missing cipher name");
    const c = Die.get(r.cipher);
    if (c === void 0) throw new Error("Invalid cipher name");
    if (i === "new") {
      let l = Oie;
      if (r.rounds !== void 0) {
        if (!Number.isInteger(r.rounds))
          throw new TypeError("rounds must be an integer");
        r.rounds > 0 && (l = r.rounds);
      }
      const f = Buffer.allocUnsafe(c.keyLen + c.ivLen),
        u = RS(Nie);
      if (kie(o, o.length, u, u.length, f, f.length, l) !== 0)
        return new Error("Failed to generate information to encrypt key");
      const p = Buffer.allocUnsafe(4 + u.length + 4);
      {
        let h = 0;
        p.writeUInt32BE(u.length, (h += 0)),
          p.set(u, (h += 4)),
          p.writeUInt32BE(l, (h += u.length));
      }
      a = {
        cipher: c,
        cipherName: r.cipher,
        kdfName: "bcrypt",
        kdfOptions: p,
        key: f.slice(0, c.keyLen),
        iv: f.slice(c.keyLen),
      };
    }
  }
  switch (i) {
    case "new": {
      let o = `-----BEGIN OPENSSH PRIVATE KEY-----
`,
        c;
      const l = Buffer.from(a ? a.cipherName : "none"),
        f = Buffer.from(a ? a.kdfName : "none"),
        u = a ? a.kdfOptions : Buffer.alloc(0),
        d = a ? a.cipher.blockLen : 8,
        p = Lie(e, t, n),
        h = RS(4),
        m = Buffer.from(s),
        g = 4 + 4 + p.priv.length + 4 + m.length;
      let v = [];
      for (let A = 1; (g + v.length) % d; ++A) v.push(A & 255);
      v = Buffer.from(v);
      let y = Buffer.allocUnsafe(g + v.length),
        _;
      {
        let A = 0;
        y.set(h, (A += 0)),
          y.set(h, (A += 4)),
          y.set(p.priv, (A += 4)),
          y.writeUInt32BE(m.length, (A += p.priv.length)),
          y.set(m, (A += 4)),
          y.set(v, (A += m.length));
      }
      if (a) {
        const A = { authTagLength: a.cipher.authLen },
          I = Iie(a.cipher.sslName, a.key, a.iv, A);
        I.setAutoPadding(!1),
          (y = Buffer.concat([I.update(y), I.final()])),
          a.cipher.authLen > 0 ? (_ = I.getAuthTag()) : (_ = Buffer.alloc(0)),
          a.key.fill(0),
          a.iv.fill(0);
      } else _ = Buffer.alloc(0);
      const E = Buffer.from("openssh-key-v1\0"),
        R = Buffer.allocUnsafe(
          E.length +
            4 +
            l.length +
            4 +
            f.length +
            4 +
            u.length +
            4 +
            4 +
            p.pub.length +
            4 +
            y.length +
            _.length,
        );
      {
        let A = 0;
        R.set(E, (A += 0)),
          R.writeUInt32BE(l.length, (A += E.length)),
          R.set(l, (A += 4)),
          R.writeUInt32BE(f.length, (A += l.length)),
          R.set(f, (A += 4)),
          R.writeUInt32BE(u.length, (A += f.length)),
          R.set(u, (A += 4)),
          R.writeUInt32BE(1, (A += u.length)),
          R.writeUInt32BE(p.pub.length, (A += 4)),
          R.set(p.pub, (A += 4)),
          R.writeUInt32BE(y.length, (A += p.pub.length)),
          R.set(y, (A += 4)),
          R.set(_, (A += y.length));
      }
      {
        const A = R.base64Slice(0, R.length);
        let I = A.replace(
          /.{64}/g,
          `$&
`,
        );
        A.length & 63 &&
          (I += `
`),
          (o += I);
      }
      {
        const A = p.pub.base64Slice(0, p.pub.length);
        c = `${p.sshName} ${A}${s ? ` ${s}` : ""}`;
      }
      return (
        (o += `-----END OPENSSH PRIVATE KEY-----
`),
        { private: o, public: c }
      );
    }
    default:
      throw new Error("Invalid output key format");
  }
}
function Bie() {}
var Uie = {
  generateKeyPair: (e, t, n) => {
    typeof t == "function" && ((n = t), (t = void 0)),
      typeof n != "function" && (n = Bie);
    const r = kS(e, t);
    $ie(...r, (i, a, s) => {
      if (i) return n(i);
      let o;
      try {
        o = TS(r[0], a, s, t);
      } catch (c) {
        return n(c);
      }
      n(null, o);
    });
  },
  generateKeyPairSync: (e, t) => {
    const n = kS(e, t),
      { publicKey: r, privateKey: i } = Cie(...n);
    return TS(n[0], r, i, t);
  },
};
const {
    AgentProtocol: Fie,
    BaseAgent: jie,
    createAgent: Mie,
    CygwinAgent: Hie,
    OpenSSHAgent: qie,
    PageantAgent: Gie,
  } = vk,
  { SSHTTPAgent: Qie, SSHTTPSAgent: Wie } = yk,
  { parseKey: zie } = to,
  {
    flagsToString: Kie,
    OPEN_MODE: Vie,
    STATUS_CODE: Yie,
    stringToFlags: Xie,
  } = Zp;
var Jie = {
  AgentProtocol: Fie,
  BaseAgent: jie,
  createAgent: Mie,
  Client: Yk,
  CygwinAgent: Hie,
  HTTPAgent: Qie,
  HTTPSAgent: Wie,
  OpenSSHAgent: qie,
  PageantAgent: Gie,
  Server: Sie,
  utils: {
    parseKey: zie,
    ...Uie,
    sftp: {
      flagsToString: Kie,
      OPEN_MODE: Vie,
      STATUS_CODE: Yie,
      stringToFlags: Xie,
    },
  },
};
const NS = fI.homedir();
function OS(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a string, got ${typeof e}`);
  return NS ? e.replace(/^~(?=$|\/|\\)/, NS) : e;
}
let Rs = [];
function cg(e) {
  return (
    Rs.find((t) => t.uuid === e) || {
      uuid: e,
      client: null,
      hostname: null,
      serverLabel: null,
    }
  );
}
function lg(e, t) {
  const n = Rs.findIndex((r) => r.uuid === e);
  n !== -1
    ? (Rs[n] = { ...Rs[n], ...t })
    : Rs.push({
        uuid: e,
        client: null,
        hostname: null,
        serverLabel: null,
        ...t,
      });
}
function Zie({
  host: e,
  username: t,
  port: n = 22,
  password: r,
  privateKeyPath: i,
  privateKeyPassphrase: a,
}) {
  return new Promise((s, o) => {
    const c = new Jie.Client();
    c.on("ready", () => {
      console.log("[SSH CLIENT] Connected!"),
        c.forwardIn("", Number(rt.port()), (f) => {
          f && (console.error(`[SSH CLIENT] ${f}`), o(f)),
            console.log(
              `[SSH CLIENT] Listening for connections on server on port ${rt.port()}!`,
            ),
            s(c);
        });
    }),
      c.on("error", (f) => {
        console.log(`[SSH CLIENT] ${f}`), o(f);
      }),
      c.on("end", () => console.log("[SSH CLIENT] Disconnected!")),
      c.on("tcp connection", (f, u) => {
        console.log("[SSH CLIENT] TCP connection incoming", f);
        const d = new ha.Socket();
        d.connect(Number(rt.port()), "localhost", function () {
          const p = u();
          console.log(
            "[SSH CLIENT] Accepted remote connection. Forwarding packets...",
          ),
            d.pipe(p).pipe(d);
        });
      }),
      console.log(`[SSH CLIENT] Connecting to SSH (${t}@${e}:${n})...`);
    let l = null;
    r ||
      (l = i
        ? require("fs").readFileSync(OS(i))
        : require("fs").readFileSync(OS("~/.ssh/id_rsa"))),
      c.connect({
        host: e,
        username: t,
        port: n,
        password: r || void 0,
        privateKey: l,
        passphrase: a || void 0,
        readyTimeout: 5e3,
      });
  });
}
const Tl = {
  getConnectedServers: function () {
    return Rs.filter((e) => e.client).map((e) => e.uuid);
  },
  disconnectAll() {
    this.getConnectedServers().forEach((e) => this.disconnect(e));
  },
  disconnect: function (e) {
    const t = cg(e);
    t.client
      ? (console.log("[SSH CLIENT] Disconnecting."),
        t.client.end(),
        lg(e, { client: null, hostname: null, serverLabel: null }))
      : console.log("[SSH CLIENT] Not connected");
  },
  connect: function (e) {
    console.log("[SSH CLIENT] Preparing to connect to SSH...");
    const t = cg(e.uuid);
    return (
      t.client &&
        (console.log(
          "[SSH CLIENT] SSH was already connected... Disconnecting.",
        ),
        this.disconnect(t.uuid)),
      new Promise((n, r) => {
        Zie(e).then(
          (i) => {
            i.exec("hostname", (a, s) =>
              s.on("data", (o) =>
                lg(e.uuid, {
                  hostname: o.toString().replace(
                    `
`,
                    "",
                  ),
                }),
              ),
            ),
              lg(e.uuid, { client: i, serverLabel: e.label }),
              n(cg(e.uuid));
          },
          (i) => r(i),
        );
      })
    );
  },
};
var Jk = { exports: {} },
  ug = { exports: {} },
  PS;
function eae() {
  return (
    PS ||
      ((PS = 1),
      (function (e, t) {
        (function (n, r) {
          e.exports = r();
        })(Tn, function () {
          function n(m) {
            return !isNaN(parseFloat(m)) && isFinite(m);
          }
          function r(m) {
            return m.charAt(0).toUpperCase() + m.substring(1);
          }
          function i(m) {
            return function () {
              return this[m];
            };
          }
          var a = ["isConstructor", "isEval", "isNative", "isToplevel"],
            s = ["columnNumber", "lineNumber"],
            o = ["fileName", "functionName", "source"],
            c = ["args"],
            l = ["evalOrigin"],
            f = a.concat(s, o, c, l);
          function u(m) {
            if (m)
              for (var g = 0; g < f.length; g++)
                m[f[g]] !== void 0 && this["set" + r(f[g])](m[f[g]]);
          }
          (u.prototype = {
            getArgs: function () {
              return this.args;
            },
            setArgs: function (m) {
              if (Object.prototype.toString.call(m) !== "[object Array]")
                throw new TypeError("Args must be an Array");
              this.args = m;
            },
            getEvalOrigin: function () {
              return this.evalOrigin;
            },
            setEvalOrigin: function (m) {
              if (m instanceof u) this.evalOrigin = m;
              else if (m instanceof Object) this.evalOrigin = new u(m);
              else
                throw new TypeError(
                  "Eval Origin must be an Object or StackFrame",
                );
            },
            toString: function () {
              var m = this.getFileName() || "",
                g = this.getLineNumber() || "",
                v = this.getColumnNumber() || "",
                y = this.getFunctionName() || "";
              return this.getIsEval()
                ? m
                  ? "[eval] (" + m + ":" + g + ":" + v + ")"
                  : "[eval]:" + g + ":" + v
                : y
                ? y + " (" + m + ":" + g + ":" + v + ")"
                : m + ":" + g + ":" + v;
            },
          }),
            (u.fromString = function (g) {
              var v = g.indexOf("("),
                y = g.lastIndexOf(")"),
                _ = g.substring(0, v),
                E = g.substring(v + 1, y).split(","),
                R = g.substring(y + 1);
              if (R.indexOf("@") === 0)
                var A = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(R, ""),
                  I = A[1],
                  S = A[2],
                  w = A[3];
              return new u({
                functionName: _,
                args: E || void 0,
                fileName: I,
                lineNumber: S || void 0,
                columnNumber: w || void 0,
              });
            });
          for (var d = 0; d < a.length; d++)
            (u.prototype["get" + r(a[d])] = i(a[d])),
              (u.prototype["set" + r(a[d])] = (function (m) {
                return function (g) {
                  this[m] = !!g;
                };
              })(a[d]));
          for (var p = 0; p < s.length; p++)
            (u.prototype["get" + r(s[p])] = i(s[p])),
              (u.prototype["set" + r(s[p])] = (function (m) {
                return function (g) {
                  if (!n(g)) throw new TypeError(m + " must be a Number");
                  this[m] = Number(g);
                };
              })(s[p]));
          for (var h = 0; h < o.length; h++)
            (u.prototype["get" + r(o[h])] = i(o[h])),
              (u.prototype["set" + r(o[h])] = (function (m) {
                return function (g) {
                  this[m] = String(g);
                };
              })(o[h]));
          return u;
        });
      })(ug)),
    ug.exports
  );
}
(function (e, t) {
  (function (n, r) {
    e.exports = r(eae());
  })(Tn, function (r) {
    var i = /(^|@)\S+:\d+/,
      a = /^\s*at .*(\S+:\d+|\(native\))/m,
      s = /^(eval@)?(\[native code])?$/;
    return {
      parse: function (c) {
        if (typeof c.stacktrace < "u" || typeof c["opera#sourceloc"] < "u")
          return this.parseOpera(c);
        if (c.stack && c.stack.match(a)) return this.parseV8OrIE(c);
        if (c.stack) return this.parseFFOrSafari(c);
        throw new Error("Cannot parse given Error object");
      },
      extractLocation: function (c) {
        if (c.indexOf(":") === -1) return [c];
        var l = /(.+?)(?::(\d+))?(?::(\d+))?$/,
          f = l.exec(c.replace(/[()]/g, ""));
        return [f[1], f[2] || void 0, f[3] || void 0];
      },
      parseV8OrIE: function (c) {
        var l = c.stack
          .split(
            `
`,
          )
          .filter(function (f) {
            return !!f.match(a);
          }, this);
        return l.map(function (f) {
          f.indexOf("(eval ") > -1 &&
            (f = f
              .replace(/eval code/g, "eval")
              .replace(/(\(eval at [^()]*)|(,.*$)/g, ""));
          var u = f
              .replace(/^\s+/, "")
              .replace(/\(eval code/g, "(")
              .replace(/^.*?\s+/, ""),
            d = u.match(/ (\(.+\)$)/);
          u = d ? u.replace(d[0], "") : u;
          var p = this.extractLocation(d ? d[1] : u),
            h = (d && u) || void 0,
            m = ["eval", "<anonymous>"].indexOf(p[0]) > -1 ? void 0 : p[0];
          return new r({
            functionName: h,
            fileName: m,
            lineNumber: p[1],
            columnNumber: p[2],
            source: f,
          });
        }, this);
      },
      parseFFOrSafari: function (c) {
        var l = c.stack
          .split(
            `
`,
          )
          .filter(function (f) {
            return !f.match(s);
          }, this);
        return l.map(function (f) {
          if (
            (f.indexOf(" > eval") > -1 &&
              (f = f.replace(
                / line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,
                ":$1",
              )),
            f.indexOf("@") === -1 && f.indexOf(":") === -1)
          )
            return new r({ functionName: f });
          var u = /((.*".+"[^@]*)?[^@]*)(?:@)/,
            d = f.match(u),
            p = d && d[1] ? d[1] : void 0,
            h = this.extractLocation(f.replace(u, ""));
          return new r({
            functionName: p,
            fileName: h[0],
            lineNumber: h[1],
            columnNumber: h[2],
            source: f,
          });
        }, this);
      },
      parseOpera: function (c) {
        return !c.stacktrace ||
          (c.message.indexOf(`
`) > -1 &&
            c.message.split(`
`).length >
              c.stacktrace.split(`
`).length)
          ? this.parseOpera9(c)
          : c.stack
          ? this.parseOpera11(c)
          : this.parseOpera10(c);
      },
      parseOpera9: function (c) {
        for (
          var l = /Line (\d+).*script (?:in )?(\S+)/i,
            f = c.message.split(`
`),
            u = [],
            d = 2,
            p = f.length;
          d < p;
          d += 2
        ) {
          var h = l.exec(f[d]);
          h &&
            u.push(new r({ fileName: h[2], lineNumber: h[1], source: f[d] }));
        }
        return u;
      },
      parseOpera10: function (c) {
        for (
          var l = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i,
            f = c.stacktrace.split(`
`),
            u = [],
            d = 0,
            p = f.length;
          d < p;
          d += 2
        ) {
          var h = l.exec(f[d]);
          h &&
            u.push(
              new r({
                functionName: h[3] || void 0,
                fileName: h[2],
                lineNumber: h[1],
                source: f[d],
              }),
            );
        }
        return u;
      },
      parseOpera11: function (c) {
        var l = c.stack
          .split(
            `
`,
          )
          .filter(function (f) {
            return !!f.match(i) && !f.match(/^Error created at/);
          }, this);
        return l.map(function (f) {
          var u = f.split("@"),
            d = this.extractLocation(u.pop()),
            p = u.shift() || "",
            h =
              p
                .replace(/<anonymous function(: (\w+))?>/, "$2")
                .replace(/\([^)]*\)/g, "") || void 0,
            m;
          p.match(/\(([^)]*)\)/) && (m = p.replace(/^[^(]+\(([^)]*)\)$/, "$1"));
          var g =
            m === void 0 || m === "[arguments not available]"
              ? void 0
              : m.split(",");
          return new r({
            functionName: h,
            args: g,
            fileName: d[0],
            lineNumber: d[1],
            columnNumber: d[2],
            source: f,
          });
        }, this);
      },
    };
  });
})(Jk);
var tae = Jk.exports;
const nae = Wl(tae),
  rae = "Ray",
  iae = "2.7.5",
  aae = "dist-electron/main/index.js",
  sae = "Ray app",
  oae = { name: "Spatie", email: "info@spatie.be" },
  cae = "MIT",
  lae = { env: { VITE_DEV_SERVER_URL: "http://127.0.0.1:7777/" } },
  uae = {
    dev: "vite --logLevel info",
    bundle: "tsc && vite build",
    build: "electron-builder",
    "build:m1": "electron-builder --config=electron-builder-m1.json5",
    preview: "vite preview",
    pree2e: "vite build --mode=test",
    e2e: "playwright test",
    storybook: "storybook dev -p 6006",
    "build-storybook": "storybook build",
    postinstall: "electron-builder install-app-deps",
  },
  fae = {
    "@electron/notarize": "^2.1.0",
    "@flareapp/flare-client": "^3.0.5",
    "@flareapp/flare-react": "^3.0.5",
    "@flareapp/vite-plugin-sourcemap-uploader": "^1.0.2",
    "@playwright/test": "^1.36.2",
    "@storybook/addon-essentials": "^7.1.1",
    "@storybook/addon-interactions": "^7.1.1",
    "@storybook/addon-links": "^7.1.1",
    "@storybook/blocks": "^7.1.1",
    "@storybook/react": "^7.1.1",
    "@storybook/react-vite": "^7.1.1",
    "@storybook/testing-library": "^0.2.0",
    "@types/canvas-confetti": "^1.6.0",
    "@types/cors": "^2.8.13",
    "@types/dompurify": "^3.0.2",
    "@types/prettier": "^2.7.3",
    "@types/react": "^18.0.28",
    "@types/react-dom": "^18.0.11",
    "@types/ssh2": "^1.11.13",
    "@vitejs/plugin-react": "^4.0.1",
    autoprefixer: "^10.4.14",
    "body-parser": "^1.20.2",
    "canvas-confetti": "^1.6.0",
    cors: "^2.8.5",
    dompurify: "^3.0.5",
    dotenv: "^16.3.1",
    electron: "^25.3.2",
    "electron-builder": "^24.6.3",
    "electron-devtools-installer": "^3.2.0",
    "electron-log": "^5.0.0-beta.24",
    "electron-store": "^8.1.0",
    "electron-updater": "^6.1.1",
    "error-stack-parser": "^2.1.4",
    express: "^4.18.2",
    "highlight.js": "^11.8.0",
    "highlightjs-blade": "^0.1.0",
    postcss: "^8.4.27",
    prettier: "^2.8.8",
    "prop-types": "^15.8.1",
    react: "^18.2.0",
    "react-dom": "^18.2.0",
    "react-inspector": "^6.0.2",
    "react-select": "^5.7.4",
    "react-virtuoso": "^4.4.2",
    sass: "^1.64.1",
    "sql-formatter": "^12.2.4",
    ssh2: "^1.14.0",
    storybook: "^7.1.1",
    tailwindcss: "^3.3.3",
    typescript: "^5.0.2",
    untildify: "^5.0.0",
    vite: "^4.4.7",
    "vite-plugin-electron": "^0.12.0",
    "vite-plugin-electron-renderer": "^0.14.1",
  },
  dae = { node: "^20.0.0" },
  pae = { "@mdx-js/rollup": "^2.3.0", "cpu-features": "0.0.8" },
  fg = {
    name: rae,
    version: iae,
    main: aae,
    description: sae,
    author: oae,
    license: cae,
    private: !0,
    debug: lae,
    scripts: uae,
    devDependencies: fae,
    engines: dae,
    dependencies: pae,
  };
var V0 = { exports: {} },
  dg = { exports: {} },
  DS;
function Zk() {
  return (
    DS ||
      ((DS = 1),
      (function (e) {
        let t = {};
        try {
          t = require("electron");
        } catch {}
        t.ipcRenderer && n(t), (e.exports = n);
        function n({ contextBridge: r, ipcRenderer: i }) {
          if (!i) return;
          i.on("__ELECTRON_LOG_IPC__", (s, o) => {
            window.postMessage({ cmd: "message", ...o });
          }),
            i
              .invoke("__ELECTRON_LOG__", { cmd: "getOptions" })
              .catch((s) =>
                console.error(
                  new Error(
                    `electron-log isn't initialized in the main process. Please call log.initialize() before. ${s.message}`,
                  ),
                ),
              );
          const a = {
            sendToMain(s) {
              try {
                i.send("__ELECTRON_LOG__", s);
              } catch (o) {
                console.error("electronLog.sendToMain ", o, "data:", s),
                  i.send("__ELECTRON_LOG__", {
                    cmd: "errorHandler",
                    error: {
                      message: o == null ? void 0 : o.message,
                      stack: o == null ? void 0 : o.stack,
                    },
                    errorName: "sendToMain",
                  });
              }
            },
            log(...s) {
              a.sendToMain({ data: s, level: "info" });
            },
          };
          for (const s of [
            "error",
            "warn",
            "info",
            "verbose",
            "debug",
            "silly",
          ])
            a[s] = (...o) => a.sendToMain({ data: o, level: s });
          if (r && process.contextIsolated)
            try {
              r.exposeInMainWorld("__electronLog", a);
            } catch {}
          typeof window == "object"
            ? (window.__electronLog = a)
            : (__electronLog = a);
        }
      })(dg)),
    dg.exports
  );
}
var pg = { exports: {} },
  hg,
  LS;
function hae() {
  if (LS) return hg;
  (LS = 1), (hg = e);
  function e(t) {
    return Object.defineProperties(n, {
      defaultLabel: { value: "", writable: !0 },
      labelPadding: { value: !0, writable: !0 },
      maxLabelLength: { value: 0, writable: !0 },
      labelLength: {
        get() {
          switch (typeof n.labelPadding) {
            case "boolean":
              return n.labelPadding ? n.maxLabelLength : 0;
            case "number":
              return n.labelPadding;
            default:
              return 0;
          }
        },
      },
    });
    function n(r) {
      n.maxLabelLength = Math.max(n.maxLabelLength, r.length);
      const i = {};
      for (const a of [...t.levels, "log"])
        i[a] = (...s) => t.logData(s, { level: a, scope: r });
      return i;
    }
  }
  return hg;
}
var mg, BS;
function eT() {
  if (BS) return mg;
  BS = 1;
  const e = hae(),
    n = class n {
      constructor({
        allowUnknownLevel: i = !1,
        errorHandler: a,
        eventLogger: s,
        initializeFn: o,
        isDev: c = !1,
        levels: l = ["error", "warn", "info", "verbose", "debug", "silly"],
        logId: f,
        transportFactories: u = {},
        variables: d,
      } = {}) {
        At(this, "errorHandler", null);
        At(this, "eventLogger", null);
        At(this, "functions", {});
        At(this, "hooks", []);
        At(this, "isDev", !1);
        At(this, "levels", null);
        At(this, "logId", null);
        At(this, "scope", null);
        At(this, "transports", {});
        At(this, "variables", {});
        (this.addLevel = this.addLevel.bind(this)),
          (this.create = this.create.bind(this)),
          (this.logData = this.logData.bind(this)),
          (this.processMessage = this.processMessage.bind(this)),
          (this.allowUnknownLevel = i),
          (this.initializeFn = o),
          (this.isDev = c),
          (this.levels = l),
          (this.logId = f),
          (this.transportFactories = u),
          (this.variables = d || {}),
          (this.scope = e(this)),
          this.addLevel("log", !1);
        for (const p of this.levels) this.addLevel(p, !1);
        (this.errorHandler = a),
          a == null || a.setOptions({ logFn: this.error }),
          (this.eventLogger = s),
          s == null || s.setOptions({ logger: this });
        for (const [p, h] of Object.entries(u)) this.transports[p] = h(this);
        n.instances[f] = this;
      }
      static getInstance({ logId: i }) {
        return this.instances[i] || this.instances.default;
      }
      addLevel(i, a = this.levels.length) {
        a !== !1 && this.levels.splice(a, 0, i),
          (this[i] = (...s) => this.logData(s, { level: i })),
          (this.functions[i] = this[i]);
      }
      catchErrors(i) {
        return (
          this.processMessage(
            {
              data: [
                "log.catchErrors is deprecated. Use log.errorHandler instead",
              ],
              level: "warn",
            },
            { transports: ["console"] },
          ),
          this.errorHandler.startCatching(i)
        );
      }
      create(i) {
        return (
          typeof i == "string" && (i = { logId: i }),
          new n({
            ...i,
            errorHandler: this.errorHandler,
            initializeFn: this.initializeFn,
            isDev: this.isDev,
            transportFactories: this.transportFactories,
            variables: { ...this.variables },
          })
        );
      }
      compareLevels(i, a, s = this.levels) {
        const o = s.indexOf(i),
          c = s.indexOf(a);
        return c === -1 || o === -1 ? !0 : c <= o;
      }
      initialize({ preload: i = !0, spyRendererConsole: a = !1 } = {}) {
        this.initializeFn({ logger: this, preload: i, spyRendererConsole: a });
      }
      logData(i, a = {}) {
        this.processMessage({ data: i, ...a });
      }
      processMessage(i, { transports: a = this.transports } = {}) {
        if (i.cmd === "errorHandler") {
          this.errorHandler.handle(i.error, {
            errorName: i.errorName,
            processType: "renderer",
            showDialog: !!i.showDialog,
          });
          return;
        }
        let s = i.level;
        this.allowUnknownLevel ||
          (s = this.levels.includes(i.level) ? i.level : "info");
        const o = {
          date: new Date(),
          ...i,
          level: s,
          variables: { ...this.variables, ...i.variables },
        };
        for (const [c, l] of this.transportEntries(a))
          if (
            !(typeof l != "function" || l.level === !1) &&
            this.compareLevels(l.level, i.level)
          )
            try {
              const f = this.hooks.reduce((u, d) => u && d(u, l, c), o);
              f && l({ ...f, data: [...f.data] });
            } catch (f) {
              this.processInternalErrorFn(f);
            }
      }
      processInternalErrorFn(i) {}
      transportEntries(i = this.transports) {
        return (Array.isArray(i) ? i : Object.entries(i))
          .map((s) => {
            switch (typeof s) {
              case "string":
                return this.transports[s] ? [s, this.transports[s]] : null;
              case "function":
                return [s.name, s];
              default:
                return Array.isArray(s) ? s : null;
            }
          })
          .filter(Boolean);
      }
    };
  At(n, "instances", {});
  let t = n;
  return (mg = t), mg;
}
var gg, US;
function mae() {
  if (US) return gg;
  US = 1;
  const e = console.error;
  class t {
    constructor({ logFn: r = null } = {}) {
      At(this, "logFn", null);
      At(this, "onError", null);
      At(this, "showDialog", !1);
      At(this, "preventDefault", !0);
      (this.handleError = this.handleError.bind(this)),
        (this.handleRejection = this.handleRejection.bind(this)),
        (this.startCatching = this.startCatching.bind(this)),
        (this.logFn = r);
    }
    handle(
      r,
      {
        logFn: i = this.logFn,
        errorName: a = "",
        onError: s = this.onError,
        showDialog: o = this.showDialog,
      } = {},
    ) {
      try {
        (s == null
          ? void 0
          : s({ error: r, errorName: a, processType: "renderer" })) !== !1 &&
          i({ error: r, errorName: a, showDialog: o });
      } catch {
        e(r);
      }
    }
    setOptions({ logFn: r, onError: i, preventDefault: a, showDialog: s }) {
      typeof r == "function" && (this.logFn = r),
        typeof i == "function" && (this.onError = i),
        typeof a == "boolean" && (this.preventDefault = a),
        typeof s == "boolean" && (this.showDialog = s);
    }
    startCatching({ onError: r, showDialog: i } = {}) {
      this.isActive ||
        ((this.isActive = !0),
        this.setOptions({ onError: r, showDialog: i }),
        window.addEventListener("error", (a) => {
          var s;
          this.preventDefault && ((s = a.preventDefault) == null || s.call(a)),
            this.handleError(a.error || a);
        }),
        window.addEventListener("unhandledrejection", (a) => {
          var s;
          this.preventDefault && ((s = a.preventDefault) == null || s.call(a)),
            this.handleRejection(a.reason || a);
        }));
    }
    handleError(r) {
      this.handle(r, { errorName: "Unhandled" });
    }
    handleRejection(r) {
      const i = r instanceof Error ? r : new Error(JSON.stringify(r));
      this.handle(i, { errorName: "Unhandled rejection" });
    }
  }
  return (gg = t), gg;
}
var vg, FS;
function gae() {
  if (FS) return vg;
  (FS = 1), (vg = t);
  const e = {
    error: console.error,
    warn: console.warn,
    info: console.info,
    verbose: console.info,
    debug: console.debug,
    silly: console.debug,
    log: console.log,
  };
  function t(n) {
    return Object.assign(r, {
      format: "{h}:{i}:{s}.{ms}{scope} â€º {text}",
      formatDataFn({
        data: i = [],
        date: a = new Date(),
        format: s = r.format,
        logId: o = n.logId,
        scope: c = n.scopeName,
        ...l
      }) {
        return typeof s == "function"
          ? s({ ...l, data: i, date: a, logId: o, scope: c })
          : (typeof s != "string" ||
              (i.unshift(s),
              typeof i[1] == "string" &&
                i[1].match(/%[1cdfiOos]/) &&
                (i = [`${i[0]} ${i[1]}`, ...i.slice(2)]),
              (i[0] = i[0]
                .replace(/\{(\w+)}/g, (f, u) => {
                  var d;
                  switch (u) {
                    case "level":
                      return l.level;
                    case "logId":
                      return o;
                    case "scope":
                      return c ? ` (${c})` : "";
                    case "text":
                      return "";
                    case "y":
                      return a.getFullYear().toString(10);
                    case "m":
                      return (a.getMonth() + 1).toString(10).padStart(2, "0");
                    case "d":
                      return a.getDate().toString(10).padStart(2, "0");
                    case "h":
                      return a.getHours().toString(10).padStart(2, "0");
                    case "i":
                      return a.getMinutes().toString(10).padStart(2, "0");
                    case "s":
                      return a.getSeconds().toString(10).padStart(2, "0");
                    case "ms":
                      return a.getMilliseconds().toString(10).padStart(3, "0");
                    case "iso":
                      return a.toISOString();
                    default:
                      return ((d = l.variables) == null ? void 0 : d[u]) || f;
                  }
                })
                .trim())),
            i);
      },
      writeFn({ level: i, data: a }) {
        const s = e[i] || e.info;
        setTimeout(() => s(...a));
      },
    });
    function r(i) {
      r.writeFn({ ...i, data: r.formatDataFn(i) });
    }
  }
  return vg;
}
var yg, jS;
function vae() {
  if (jS) return yg;
  (jS = 1), (yg = t);
  const e = new Set([Promise, WeakMap, WeakSet]);
  function t(n) {
    return Object.assign(r, {
      depth: 5,
      serializeFn(i, { depth: a = 5, seen: s = new WeakSet() } = {}) {
        return a < 1
          ? `[${typeof i}]`
          : s.has(i)
          ? i
          : ["function", "symbol"].includes(typeof i)
          ? i.toString()
          : Object(i) !== i
          ? i
          : e.has(i.constructor)
          ? `[${i.constructor.name}]`
          : Array.isArray(i)
          ? i.map((o) => r.serializeFn(o, { level: a - 1, seen: s }))
          : i instanceof Error
          ? i.stack
          : i instanceof Map
          ? new Map(
              Array.from(i).map(([o, c]) => [
                r.serializeFn(o, { level: a - 1, seen: s }),
                r.serializeFn(c, { level: a - 1, seen: s }),
              ]),
            )
          : i instanceof Set
          ? new Set(
              Array.from(i).map((o) =>
                r.serializeFn(o, { level: a - 1, seen: s }),
              ),
            )
          : (s.add(i),
            Object.fromEntries(
              Object.entries(i).map(([o, c]) => [
                o,
                r.serializeFn(c, { level: a - 1, seen: s }),
              ]),
            ));
      },
    });
    function r(i) {
      if (!window.__electronLog) {
        n.processMessage(
          {
            data: [
              "electron-log: logger isn't initialized in the main process",
            ],
            level: "error",
          },
          { transports: ["console"] },
        );
        return;
      }
      try {
        __electronLog.sendToMain(r.serializeFn(i, { depth: r.depth }));
      } catch (a) {
        n.transports.console({
          data: ["electronLog.transports.ipc", a, "data:", i.data],
          level: "error",
        });
      }
    }
  }
  return yg;
}
var MS;
function yae() {
  return (
    MS ||
      ((MS = 1),
      (function (e) {
        const t = eT(),
          n = mae(),
          r = gae(),
          i = vae();
        (e.exports = a()),
          (e.exports.Logger = t),
          (e.exports.default = e.exports);
        function a() {
          const s = new t({
            allowUnknownLevel: !0,
            errorHandler: new n(),
            initializeFn: () => {},
            logId: "default",
            transportFactories: { console: r, ipc: i },
            variables: { processType: "renderer" },
          });
          return (
            s.errorHandler.setOptions({
              logFn({ error: o, errorName: c, showDialog: l }) {
                s.transports.console({
                  data: [c, o].filter(Boolean),
                  level: "error",
                }),
                  s.transports.ipc({
                    cmd: "errorHandler",
                    error: {
                      cause: o == null ? void 0 : o.cause,
                      code: o == null ? void 0 : o.code,
                      name: o == null ? void 0 : o.name,
                      message: o == null ? void 0 : o.message,
                      stack: o == null ? void 0 : o.stack,
                    },
                    errorName: c,
                    logId: s.logId,
                    showDialog: l,
                  });
              },
            }),
            typeof window == "object" &&
              window.addEventListener("message", (o) => {
                const { cmd: c, logId: l, ...f } = o.data || {},
                  u = t.getInstance({ logId: l });
                c === "message" &&
                  u.processMessage(f, { transports: ["console"] });
              }),
            new Proxy(s, {
              get(o, c) {
                return typeof o[c] < "u"
                  ? o[c]
                  : (...l) => s.logData(l, { level: c });
              },
            })
          );
        }
      })(pg)),
    pg.exports
  );
}
var bg = { exports: {} },
  _g,
  HS;
function Cu() {
  if (HS) return _g;
  HS = 1;
  const e = Fr,
    t = pt;
  let n;
  try {
    n = require("electron");
  } catch {
    n = null;
  }
  _g = {
    getAppUserDataPath() {
      return f("userData");
    },
    getName: i,
    getPath: f,
    getVersion: o,
    getVersions() {
      return {
        app: `${i()} ${o()}`,
        electron: `Electron ${process.versions.electron}`,
        os: c(),
      };
    },
    isDev() {
      const p = r();
      return (p == null ? void 0 : p.isPackaged) !== void 0
        ? !p.isPackaged
        : typeof process.execPath == "string"
        ? t.basename(process.execPath).toLowerCase().startsWith("electron")
        : process.env.NODE_ENV === "development" ||
          process.env.ELECTRON_IS_DEV === "1";
    },
    isElectron() {
      return !!process.versions.electron;
    },
    onAppEvent(p, h) {
      var m;
      return (
        (m = n == null ? void 0 : n.app) == null || m.on(p, h),
        () => {
          var g;
          (g = n == null ? void 0 : n.app) == null || g.off(p, h);
        }
      );
    },
    onEveryWebContentsEvent(p, h) {
      var g, v;
      return (
        (g = n == null ? void 0 : n.webContents) == null ||
          g.getAllWebContents().forEach((y) => {
            y.on(p, h);
          }),
        (v = n == null ? void 0 : n.app) == null ||
          v.on("web-contents-created", m),
        () => {
          var y, _;
          (y = n == null ? void 0 : n.webContents) == null ||
            y.getAllWebContents().forEach((E) => {
              E.off(p, h);
            }),
            (_ = n == null ? void 0 : n.app) == null ||
              _.off("web-contents-created", m);
        }
      );
      function m(y, _) {
        _.on(p, h);
      }
    },
    onIpc(p, h) {
      var m;
      (m = s()) == null || m.on(p, h);
    },
    onIpcInvoke(p, h) {
      var m, g;
      (g = (m = s()) == null ? void 0 : m.handle) == null || g.call(m, p, h);
    },
    openUrl(p, h = console.error) {
      var m;
      (m = a("shell")) == null || m.openExternal(p).catch(h);
    },
    setPreloadFileForSessions({
      filePath: p,
      includeFutureSession: h = !0,
      sessions: m = [
        ((g) =>
          (g = n == null ? void 0 : n.session) == null
            ? void 0
            : g.defaultSession)(),
      ],
    }) {
      var y;
      for (const _ of m.filter(Boolean)) v(_);
      h &&
        ((y = n == null ? void 0 : n.app) == null ||
          y.on("session-created", (_) => {
            v(_);
          }));
      function v(_) {
        _.setPreloads([..._.getPreloads(), p]);
      }
    },
    sendIpc(p, h) {
      process.type === "browser"
        ? d(p, h)
        : process.type === "renderer" && u(p, h);
    },
    showErrorBox(p, h) {
      const m = a("dialog");
      m && m.showErrorBox(p, h);
    },
    whenAppReady() {
      var p;
      return (
        ((p = n == null ? void 0 : n.app) == null ? void 0 : p.whenReady()) ||
        Promise.resolve()
      );
    },
  };
  function r() {
    return a("app");
  }
  function i() {
    const p = r();
    return p ? ("name" in p ? p.name : p.getName()) : null;
  }
  function a(p) {
    return (n == null ? void 0 : n[p]) || null;
  }
  function s() {
    return process.type === "browser" && n != null && n.ipcMain
      ? n.ipcMain
      : process.type === "renderer" && n != null && n.ipcRenderer
      ? n.ipcRenderer
      : null;
  }
  function o() {
    const p = r();
    return p ? ("version" in p ? p.version : p.getVersion()) : null;
  }
  function c() {
    let p = e.type().replace("_", " "),
      h = e.release();
    return p === "Darwin" && ((p = "macOS"), (h = l())), `${p} ${h}`;
  }
  function l() {
    const p = Number(e.release().split(".")[0]);
    return p <= 19 ? `10.${p - 4}` : p - 9;
  }
  function f(p) {
    const h = r();
    if (!h) return null;
    try {
      return h.getPath(p);
    } catch {
      return null;
    }
  }
  function u(p, h) {
    var m;
    (m = s()) == null || m.send(p, h);
  }
  function d(p, h) {
    var m;
    (m = n == null ? void 0 : n.BrowserWindow) == null ||
      m.getAllWindows().forEach((g) => {
        var v;
        ((v = g.webContents) == null ? void 0 : v.isDestroyed()) === !1 &&
          g.webContents.send(p, h);
      });
  }
  return _g;
}
var Eg, qS;
function bae() {
  if (qS) return Eg;
  qS = 1;
  const e = Xt,
    t = Fr,
    n = pt,
    r = Cu(),
    i = Zk();
  Eg = {
    initialize({ logger: o, preload: c = !0, spyRendererConsole: l = !1 }) {
      r.whenAppReady()
        .then(() => {
          c && a(c), l && s(o);
        })
        .catch(o.warn);
    },
  };
  function a(o) {
    let c =
      typeof o == "string"
        ? o
        : n.resolve(__dirname, "../renderer/electron-log-preload.js");
    if (!e.existsSync(c)) {
      c = n.join(
        r.getAppUserDataPath() || t.tmpdir(),
        "electron-log-preload.js",
      );
      const l = `
      try {
        (${i.toString()})(require('electron'));
      } catch(e) {
        console.error(e);
      }
    `;
      e.writeFileSync(c, l, "utf8");
    }
    r.setPreloadFileForSessions({ filePath: c });
  }
  function s(o) {
    const c = ["verbose", "info", "warning", "error"];
    r.onEveryWebContentsEvent("console-message", (l, f, u) => {
      o.processMessage({
        data: [u],
        level: c[f],
        variables: { processType: "renderer" },
      });
    });
  }
  return Eg;
}
var wg, GS;
function eh() {
  if (GS) return wg;
  (GS = 1), (wg = { transform: e });
  function e({
    logger: t,
    message: n,
    transport: r,
    initialData: i = (n == null ? void 0 : n.data) || [],
    transforms: a = r == null ? void 0 : r.transforms,
  }) {
    return a.reduce(
      (s, o) =>
        typeof o == "function"
          ? o({ data: s, logger: t, message: n, transport: r })
          : s,
      i,
    );
  }
  return wg;
}
var xg, QS;
function tT() {
  if (QS) return xg;
  QS = 1;
  const { transform: e } = eh();
  xg = {
    concatFirstStringElements: t,
    formatScope: r,
    formatText: a,
    formatVariables: i,
    timeZoneFromOffset: n,
    format({
      message: s,
      logger: o,
      transport: c,
      data: l = s == null ? void 0 : s.data,
    }) {
      switch (typeof c.format) {
        case "string":
          return e({
            message: s,
            logger: o,
            transforms: [i, r, a],
            transport: c,
            initialData: [c.format, ...l],
          });
        case "function":
          return c.format({
            data: l,
            level: (s == null ? void 0 : s.level) || "info",
            logger: o,
            message: s,
            transport: c,
          });
        default:
          return l;
      }
    },
  };
  function t({ data: s }) {
    return typeof s[0] != "string" ||
      typeof s[1] != "string" ||
      s[0].match(/%[1cdfiOos]/)
      ? s
      : [`${s[0]} ${s[1]}`, ...s.slice(2)];
  }
  function n(s) {
    const o = Math.abs(s),
      c = s >= 0 ? "-" : "+",
      l = Math.floor(o / 60)
        .toString()
        .padStart(2, "0"),
      f = (o % 60).toString().padStart(2, "0");
    return `${c}${l}:${f}`;
  }
  function r({ data: s, logger: o, message: c }) {
    const { defaultLabel: l, labelLength: f } =
        (o == null ? void 0 : o.scope) || {},
      u = s[0];
    let d = c.scope;
    d || (d = l);
    let p;
    return (
      d === ""
        ? (p = f > 0 ? "".padEnd(f + 3) : "")
        : typeof d == "string"
        ? (p = ` (${d})`.padEnd(f + 3))
        : (p = ""),
      (s[0] = u.replace("{scope}", p)),
      s
    );
  }
  function i({ data: s, message: o }) {
    let c = s[0];
    if (typeof c != "string") return s;
    c = c.replace("{level}]", `${o.level}]`.padEnd(6, " "));
    const l = o.date || new Date();
    return (
      (s[0] = c
        .replace(/\{(\w+)}/g, (f, u) => {
          var d;
          switch (u) {
            case "level":
              return o.level || "info";
            case "logId":
              return o.logId;
            case "y":
              return l.getFullYear().toString(10);
            case "m":
              return (l.getMonth() + 1).toString(10).padStart(2, "0");
            case "d":
              return l.getDate().toString(10).padStart(2, "0");
            case "h":
              return l.getHours().toString(10).padStart(2, "0");
            case "i":
              return l.getMinutes().toString(10).padStart(2, "0");
            case "s":
              return l.getSeconds().toString(10).padStart(2, "0");
            case "ms":
              return l.getMilliseconds().toString(10).padStart(3, "0");
            case "z":
              return n(l.getTimezoneOffset());
            case "iso":
              return l.toISOString();
            default:
              return ((d = o.variables) == null ? void 0 : d[u]) || f;
          }
        })
        .trim()),
      s
    );
  }
  function a({ data: s }) {
    const o = s[0];
    if (typeof o != "string") return s;
    if (o.lastIndexOf("{text}") === o.length - 6)
      return (s[0] = o.replace(/\s?{text}/, "")), s[0] === "" && s.shift(), s;
    const l = o.split("{text}");
    let f = [];
    return (
      l[0] !== "" && f.push(l[0]),
      (f = f.concat(s.slice(1))),
      l[1] !== "" && f.push(l[1]),
      f
    );
  }
  return xg;
}
var Ag = { exports: {} },
  WS;
function u1() {
  return (
    WS ||
      ((WS = 1),
      (function (e) {
        const t = wr;
        e.exports = {
          serialize: r,
          maxDepth({
            data: i,
            transport: a,
            depth: s = (a == null ? void 0 : a.depth) ?? 6,
          }) {
            if (!i) return i;
            if (s < 1)
              return Array.isArray(i)
                ? "[array]"
                : typeof i == "object" && i
                ? "[object]"
                : i;
            if (Array.isArray(i))
              return i.map((c) =>
                e.exports.maxDepth({ data: c, depth: s - 1 }),
              );
            if (
              typeof i != "object" ||
              (i && typeof i.toISOString == "function")
            )
              return i;
            if (i === null) return null;
            if (i instanceof Error) return i;
            const o = {};
            for (const c in i)
              Object.prototype.hasOwnProperty.call(i, c) &&
                (o[c] = e.exports.maxDepth({ data: i[c], depth: s - 1 }));
            return o;
          },
          toJSON({ data: i }) {
            return JSON.parse(JSON.stringify(i, n()));
          },
          toString({ data: i, transport: a }) {
            const s = (a == null ? void 0 : a.inspectOptions) || {},
              o = i.map((c) => {
                if (c !== void 0)
                  try {
                    const l = JSON.stringify(c, n(), "  ");
                    return l === void 0 ? void 0 : JSON.parse(l);
                  } catch {
                    return c;
                  }
              });
            return t.formatWithOptions(s, ...o);
          },
        };
        function n(i = {}) {
          const a = new WeakSet();
          return function (s, o) {
            if (typeof o == "object" && o !== null) {
              if (a.has(o)) return;
              a.add(o);
            }
            return r(s, o, i);
          };
        }
        function r(i, a, s = {}) {
          const o = (s == null ? void 0 : s.serializeMapAndSet) !== !1;
          return a instanceof Error
            ? a.stack
            : a &&
                (typeof a == "function"
                  ? `[function] ${a.toString()}`
                  : o && a instanceof Map && Object.fromEntries
                  ? Object.fromEntries(a)
                  : o && a instanceof Set && Array.from
                  ? Array.from(a)
                  : a);
        }
      })(Ag)),
    Ag.exports
  );
}
var Sg, zS;
function f1() {
  if (zS) return Sg;
  (zS = 1),
    (Sg = {
      transformStyles: r,
      applyAnsiStyles({ data: i }) {
        return r(i, t, n);
      },
      removeStyles({ data: i }) {
        return r(i, () => "");
      },
    });
  const e = {
    unset: "\x1B[0m",
    black: "\x1B[30m",
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m",
    cyan: "\x1B[36m",
    white: "\x1B[37m",
  };
  function t(i) {
    const a = i.replace(/color:\s*(\w+).*/, "$1").toLowerCase();
    return e[a] || "";
  }
  function n(i) {
    return i + e.unset;
  }
  function r(i, a, s) {
    const o = {};
    return i.reduce((c, l, f, u) => {
      if (o[f]) return c;
      if (typeof l == "string") {
        let d = f,
          p = !1;
        (l = l.replace(/%[1cdfiOos]/g, (h) => {
          if (((d += 1), h !== "%c")) return h;
          const m = u[d];
          return typeof m == "string" ? ((o[d] = !0), (p = !0), a(m, l)) : h;
        })),
          p && s && (l = s(l));
      }
      return c.push(l), c;
    }, []);
  }
  return Sg;
}
var Ig, KS;
function _ae() {
  if (KS) return Ig;
  KS = 1;
  const { concatFirstStringElements: e, format: t } = tT(),
    { maxDepth: n, toJSON: r } = u1(),
    { applyAnsiStyles: i, removeStyles: a } = f1(),
    { transform: s } = eh(),
    o = {
      error: console.error,
      warn: console.warn,
      info: console.info,
      verbose: console.info,
      debug: console.debug,
      silly: console.debug,
      log: console.log,
    };
  Ig = f;
  const l = `%c{h}:{i}:{s}.{ms}{scope}%c ${
    process.platform === "win32" ? ">" : "â€º"
  } {text}`;
  Object.assign(f, { DEFAULT_FORMAT: l });
  function f(m) {
    return Object.assign(g, {
      format: l,
      level: "silly",
      transforms: [u, t, p, e, n, r],
      useStyles: process.env.FORCE_STYLES,
      writeFn({ message: v }) {
        (o[v.level] || o.info)(...v.data);
      },
    });
    function g(v) {
      const y = s({ logger: m, message: v, transport: g });
      g.writeFn({ message: { ...v, data: y } });
    }
  }
  function u({ data: m, message: g, transport: v }) {
    return v.format !== l ? m : [`color:${h(g.level)}`, "color:unset", ...m];
  }
  function d(m, g) {
    if (typeof m == "boolean") return m;
    const y = g === "error" || g === "warn" ? process.stderr : process.stdout;
    return y && y.isTTY;
  }
  function p(m) {
    const { message: g, transport: v } = m;
    return (d(v.useStyles, g.level) ? i : a)(m);
  }
  function h(m) {
    const g = { error: "red", warn: "yellow", info: "cyan", default: "unset" };
    return g[m] || g.default;
  }
  return Ig;
}
var $g, VS;
function nT() {
  if (VS) return $g;
  VS = 1;
  const e = Hi,
    t = Xt,
    n = Fr;
  class r extends e {
    constructor({
      path: o,
      writeOptions: c = { encoding: "utf8", flag: "a", mode: 438 },
      writeAsync: l = !1,
    }) {
      super();
      At(this, "asyncWriteQueue", []);
      At(this, "bytesWritten", 0);
      At(this, "hasActiveAsyncWriting", !1);
      At(this, "path", null);
      At(this, "initialSize");
      At(this, "writeOptions", null);
      At(this, "writeAsync", !1);
      (this.path = o), (this.writeOptions = c), (this.writeAsync = l);
    }
    get size() {
      return this.getSize();
    }
    clear() {
      try {
        return (
          t.writeFileSync(this.path, "", {
            mode: this.writeOptions.mode,
            flag: "w",
          }),
          this.reset(),
          !0
        );
      } catch (o) {
        return o.code === "ENOENT" ? !0 : (this.emit("error", o, this), !1);
      }
    }
    crop(o) {
      try {
        const c = i(this.path, o || 4096);
        this.clear(), this.writeLine(`[log cropped]${n.EOL}${c}`);
      } catch (c) {
        this.emit(
          "error",
          new Error(`Couldn't crop file ${this.path}. ${c.message}`),
          this,
        );
      }
    }
    getSize() {
      if (this.initialSize === void 0)
        try {
          const o = t.statSync(this.path);
          this.initialSize = o.size;
        } catch {
          this.initialSize = 0;
        }
      return this.initialSize + this.bytesWritten;
    }
    increaseBytesWrittenCounter(o) {
      this.bytesWritten += Buffer.byteLength(o, this.writeOptions.encoding);
    }
    isNull() {
      return !1;
    }
    nextAsyncWrite() {
      const o = this;
      if (this.hasActiveAsyncWriting || this.asyncWriteQueue.length === 0)
        return;
      const c = this.asyncWriteQueue.join("");
      (this.asyncWriteQueue = []),
        (this.hasActiveAsyncWriting = !0),
        t.writeFile(this.path, c, this.writeOptions, (l) => {
          (o.hasActiveAsyncWriting = !1),
            l
              ? o.emit(
                  "error",
                  new Error(`Couldn't write to ${o.path}. ${l.message}`),
                  this,
                )
              : o.increaseBytesWrittenCounter(c),
            o.nextAsyncWrite();
        });
    }
    reset() {
      (this.initialSize = void 0), (this.bytesWritten = 0);
    }
    toString() {
      return this.path;
    }
    writeLine(o) {
      if (((o += n.EOL), this.writeAsync)) {
        this.asyncWriteQueue.push(o), this.nextAsyncWrite();
        return;
      }
      try {
        t.writeFileSync(this.path, o, this.writeOptions),
          this.increaseBytesWrittenCounter(o);
      } catch (c) {
        this.emit(
          "error",
          new Error(`Couldn't write to ${this.path}. ${c.message}`),
          this,
        );
      }
    }
  }
  $g = r;
  function i(a, s) {
    const o = Buffer.alloc(s),
      c = t.statSync(a),
      l = Math.min(c.size, s),
      f = Math.max(0, c.size - s),
      u = t.openSync(a, "r"),
      d = t.readSync(u, o, 0, l, f);
    return t.closeSync(u), o.toString("utf8", 0, d);
  }
  return $g;
}
var Cg, YS;
function Eae() {
  if (YS) return Cg;
  YS = 1;
  const e = nT();
  class t extends e {
    clear() {}
    crop() {}
    getSize() {
      return 0;
    }
    isNull() {
      return !0;
    }
    writeLine() {}
  }
  return (Cg = t), Cg;
}
var Rg, XS;
function wae() {
  if (XS) return Rg;
  XS = 1;
  const e = Hi,
    t = Xt,
    n = pt,
    r = nT(),
    i = Eae();
  class a extends e {
    constructor() {
      super();
      At(this, "store", {});
      this.emitError = this.emitError.bind(this);
    }
    provide({ filePath: c, writeOptions: l, writeAsync: f = !1 }) {
      let u;
      try {
        if (((c = n.resolve(c)), this.store[c])) return this.store[c];
        u = this.createFile({ filePath: c, writeOptions: l, writeAsync: f });
      } catch (d) {
        (u = new i({ path: c })), this.emitError(d, u);
      }
      return u.on("error", this.emitError), (this.store[c] = u), u;
    }
    createFile({ filePath: c, writeOptions: l, writeAsync: f }) {
      return (
        this.testFileWriting(c),
        new r({ path: c, writeOptions: l, writeAsync: f })
      );
    }
    emitError(c, l) {
      this.emit("error", c, l);
    }
    testFileWriting(c) {
      t.mkdirSync(n.dirname(c), { recursive: !0 }),
        t.writeFileSync(c, "", { flag: "a" });
    }
  }
  return (Rg = a), Rg;
}
var kg, JS;
function xae() {
  if (JS) return kg;
  JS = 1;
  const e = Xt,
    t = pt;
  kg = { readPackageJson: n, tryReadJsonAt: r };
  function n() {
    return (
      r(require.main && require.main.filename) ||
      r(a()) ||
      r(process.resourcesPath, "app.asar") ||
      r(process.resourcesPath, "app") ||
      r(process.cwd()) || { name: null, version: null }
    );
  }
  function r(...s) {
    if (!s[0]) return null;
    try {
      const o = t.join(...s),
        c = i("package.json", o);
      if (!c) return null;
      const l = JSON.parse(e.readFileSync(c, "utf8")),
        f = l.productName || l.name;
      if (!f || f.toLowerCase() === "electron") return null;
      if (l.productName || l.name) return { name: f, version: l.version };
    } catch {
      return null;
    }
  }
  function i(s, o) {
    let c = o;
    for (;;) {
      const l = t.parse(c),
        f = l.root,
        u = l.dir;
      if (e.existsSync(t.join(c, s))) return t.resolve(t.join(c, s));
      if (c === f) return null;
      c = u;
    }
  }
  function a() {
    const s = process.argv.filter((c) => c.indexOf("--user-data-dir=") === 0);
    return s.length === 0 || typeof s[0] != "string"
      ? null
      : s[0].replace("--user-data-dir=", "");
  }
  return kg;
}
var Tg, ZS;
function Aae() {
  if (ZS) return Tg;
  ZS = 1;
  const e = Fr,
    t = pt,
    n = Cu(),
    r = xae();
  Tg = {
    getAppData: i,
    getLibraryDefaultDir: s,
    getLibraryTemplate: o,
    getNameAndVersion: c,
    getPathVariables: l,
    getUserData: f,
  };
  function i(u) {
    const d = n.getPath("appData");
    if (d) return d;
    const p = a();
    switch (u) {
      case "darwin":
        return t.join(p, "Library/Application Support");
      case "win32":
        return process.env.APPDATA || t.join(p, "AppData/Roaming");
      default:
        return process.env.XDG_CONFIG_HOME || t.join(p, ".config");
    }
  }
  function a() {
    return e.homedir ? e.homedir() : process.env.HOME;
  }
  function s(u, d) {
    return u === "darwin"
      ? t.join(a(), "Library/Logs", d)
      : t.join(f(u, d), "logs");
  }
  function o(u) {
    return u === "darwin"
      ? t.join(a(), "Library/Logs", "{appName}")
      : t.join(i(u), "{appName}", "logs");
  }
  function c() {
    let u = n.getName() || "",
      d = n.getVersion();
    if ((u.toLowerCase() === "electron" && ((u = ""), (d = "")), u && d))
      return { name: u, version: d };
    const p = r.readPackageJson();
    return (
      u || (u = p.name),
      d || (d = p.version),
      u || (u = "Electron"),
      { name: u, version: d }
    );
  }
  function l(u) {
    const d = c(),
      p = d.name,
      h = d.version;
    return {
      appData: i(u),
      appName: p,
      appVersion: h,
      electronDefaultDir: n.getPath("logs"),
      home: a(),
      libraryDefaultDir: s(u, p),
      libraryTemplate: o(u),
      temp: n.getPath("temp") || e.tmpdir(),
      userData: f(u, p),
    };
  }
  function f(u, d) {
    return n.getName() !== d
      ? t.join(i(u), d)
      : n.getPath("userData") || t.join(i(u), d);
  }
  return Tg;
}
var Ng, eI;
function Sae() {
  if (eI) return Ng;
  eI = 1;
  const e = Xt,
    t = pt,
    n = Fr,
    r = wae(),
    i = Aae(),
    { transform: a } = eh(),
    { removeStyles: s } = f1(),
    { format: o } = tT(),
    { toString: c } = u1();
  Ng = f;
  const l = new r();
  function f(d, p = l) {
    let h;
    return (
      p.listenerCount("error") < 1 &&
        p.on("error", (E, R) => {
          v(`Can't write to ${R}`, E);
        }),
      Object.assign(m, {
        fileName: u(d.variables.processType),
        format: "[{y}-{m}-{d} {h}:{i}:{s}.{ms}] [{level}]{scope} {text}",
        getFile: y,
        inspectOptions: { depth: 5 },
        level: "silly",
        maxSize: 1024 ** 2,
        readAllLogs: _,
        sync: !0,
        transforms: [s, o, c],
        writeOptions: { flag: "a", mode: 438, encoding: "utf8" },
        archiveLogFn(E) {
          const R = E.toString(),
            A = t.parse(R);
          try {
            e.renameSync(R, t.join(A.dir, `${A.name}.old${A.ext}`));
          } catch (I) {
            v("Could not rotate log", I);
            const S = Math.round(m.maxSize / 4);
            E.crop(Math.min(S, 256 * 1024));
          }
        },
        resolvePathFn(E) {
          return t.join(E.libraryDefaultDir, E.fileName);
        },
      })
    );
    function m(E) {
      const R = y(E);
      m.maxSize > 0 && R.size > m.maxSize && (m.archiveLogFn(R), R.reset());
      const I = a({ logger: d, message: E, transport: m });
      R.writeLine(I);
    }
    function g() {
      h ||
        ((h = i.getPathVariables(process.platform)),
        typeof m.archiveLog == "function" &&
          ((m.archiveLogFn = m.archiveLog),
          v("archiveLog is deprecated. Use archiveLogFn instead")),
        typeof m.resolvePath == "function" &&
          ((m.resolvePathFn = m.resolvePath),
          v("resolvePath is deprecated. Use resolvePathFn instead")));
    }
    function v(E, R = null, A = "error") {
      const I = [`electron-log.transports.file: ${E}`];
      R && I.push(R),
        d.transports.console({ data: I, date: new Date(), level: A });
    }
    function y(E) {
      g();
      const R = { ...h, fileName: m.fileName },
        A = m.resolvePathFn(R, E);
      return p.provide({
        filePath: A,
        writeAsync: !m.sync,
        writeOptions: m.writeOptions,
      });
    }
    function _({ fileFilter: E = (R) => R.endsWith(".log") } = {}) {
      const R = { ...h, fileName: m.fileName },
        A = t.dirname(m.resolvePathFn(R));
      return e
        .readdirSync(A)
        .map((I) => t.join(A, I))
        .filter(E)
        .map((I) => {
          try {
            return { path: I, lines: e.readFileSync(I, "utf8").split(n.EOL) };
          } catch {
            return null;
          }
        })
        .filter(Boolean);
    }
  }
  function u(d = process.type) {
    switch (d) {
      case "renderer":
        return "renderer.log";
      case "worker":
        return "worker.log";
      default:
        return "main.log";
    }
  }
  return Ng;
}
var Og, tI;
function Iae() {
  if (tI) return Og;
  tI = 1;
  const e = Ws,
    t = pI,
    { transform: n } = eh(),
    { removeStyles: r } = f1(),
    { toJSON: i, maxDepth: a } = u1();
  Og = s;
  function s(o) {
    return Object.assign(c, {
      client: { name: "electron-application" },
      depth: 6,
      level: !1,
      requestOptions: {},
      transforms: [r, i, a],
      makeBodyFn({ message: l }) {
        return JSON.stringify({
          client: c.client,
          data: l.data,
          date: l.date.getTime(),
          level: l.level,
          scope: l.scope,
          variables: l.variables,
        });
      },
      processErrorFn({ error: l }) {
        o.processMessage(
          { data: [`electron-log: can't POST ${c.url}`, l], level: "warn" },
          { transports: ["console", "file"] },
        );
      },
      sendRequestFn({ serverUrl: l, requestOptions: f, body: u }) {
        const p = (l.startsWith("https:") ? t : e).request(l, {
          method: "POST",
          ...f,
          headers: {
            "Content-Type": "application/json",
            "Content-Length": u.length,
            ...f.headers,
          },
        });
        return p.write(u), p.end(), p;
      },
    });
    function c(l) {
      if (!c.url) return;
      const f = c.makeBodyFn({
          logger: o,
          message: { ...l, data: n({ logger: o, message: l, transport: c }) },
          transport: c,
        }),
        u = c.sendRequestFn({
          serverUrl: c.url,
          requestOptions: c.requestOptions,
          body: Buffer.from(f, "utf8"),
        });
      u.on("error", (d) =>
        c.processErrorFn({
          error: d,
          logger: o,
          message: l,
          request: u,
          transport: c,
        }),
      );
    }
  }
  return Og;
}
var Pg, nI;
function $ae() {
  if (nI) return Pg;
  nI = 1;
  const e = Cu();
  class t {
    constructor({
      logFn: i = null,
      onError: a = null,
      showDialog: s = !0,
    } = {}) {
      At(this, "isActive", !1);
      At(this, "logFn", null);
      At(this, "onError", null);
      At(this, "showDialog", !0);
      (this.createIssue = this.createIssue.bind(this)),
        (this.handleError = this.handleError.bind(this)),
        (this.handleRejection = this.handleRejection.bind(this)),
        this.setOptions({ logFn: i, onError: a, showDialog: s }),
        (this.startCatching = this.startCatching.bind(this)),
        (this.stopCatching = this.stopCatching.bind(this));
    }
    handle(
      i,
      {
        logFn: a = this.logFn,
        onError: s = this.onError,
        processType: o = "browser",
        showDialog: c = this.showDialog,
        errorName: l = "",
      } = {},
    ) {
      i = n(i);
      try {
        if (typeof s == "function") {
          const f = e.getVersions(),
            u = this.createIssue;
          if (
            s({
              createIssue: u,
              error: i,
              errorName: l,
              processType: o,
              versions: f,
            }) === !1
          )
            return;
        }
        l ? a(l, i) : a(i),
          c &&
            !l.includes("rejection") &&
            e.showErrorBox(
              `A JavaScript error occurred in the ${o} process`,
              i.stack,
            );
      } catch {
        console.error(i);
      }
    }
    setOptions({ logFn: i, onError: a, showDialog: s }) {
      typeof i == "function" && (this.logFn = i),
        typeof a == "function" && (this.onError = a),
        typeof s == "boolean" && (this.showDialog = s);
    }
    startCatching({ onError: i, showDialog: a } = {}) {
      this.isActive ||
        ((this.isActive = !0),
        this.setOptions({ onError: i, showDialog: a }),
        process.on("uncaughtException", this.handleError),
        process.on("unhandledRejection", this.handleRejection));
    }
    stopCatching() {
      (this.isActive = !1),
        process.removeListener("uncaughtException", this.handleError),
        process.removeListener("unhandledRejection", this.handleRejection);
    }
    createIssue(i, a) {
      e.openUrl(`${i}?${new URLSearchParams(a).toString()}`);
    }
    handleError(i) {
      this.handle(i, { errorName: "Unhandled" });
    }
    handleRejection(i) {
      const a = i instanceof Error ? i : new Error(JSON.stringify(i));
      this.handle(a, { errorName: "Unhandled rejection" });
    }
  }
  function n(r) {
    if (r instanceof Error) return r;
    if (r && typeof r == "object") {
      if (r.message) return Object.assign(new Error(r.message), r);
      try {
        return new Error(JSON.stringify(r));
      } catch (i) {
        return new Error(`Couldn't normalize error ${String(r)}: ${i}`);
      }
    }
    return new Error(`Can't normalize error ${String(r)}`);
  }
  return (Pg = t), Pg;
}
var Dg, rI;
function Cae() {
  if (rI) return Dg;
  rI = 1;
  const e = Cu();
  class t {
    constructor(r = {}) {
      At(this, "disposers", []);
      At(this, "format", "{eventSource}#{eventName}:");
      At(this, "formatters", {
        app: {
          "certificate-error": ({ args: r }) =>
            this.arrayToObject(r.slice(1, 4), ["url", "error", "certificate"]),
          "child-process-gone": ({ args: r }) => (r.length === 1 ? r[0] : r),
          "render-process-gone": ({ args: [r, i] }) =>
            i && typeof i == "object"
              ? { ...i, ...this.getWebContentsDetails(r) }
              : [],
        },
        webContents: {
          "console-message": ({ args: [r, i, a, s] }) => {
            if (!(r < 3)) return { message: i, source: `${s}:${a}` };
          },
          "did-fail-load": ({ args: r }) =>
            this.arrayToObject(r, [
              "errorCode",
              "errorDescription",
              "validatedURL",
              "isMainFrame",
              "frameProcessId",
              "frameRoutingId",
            ]),
          "did-fail-provisional-load": ({ args: r }) =>
            this.arrayToObject(r, [
              "errorCode",
              "errorDescription",
              "validatedURL",
              "isMainFrame",
              "frameProcessId",
              "frameRoutingId",
            ]),
          "plugin-crashed": ({ args: r }) =>
            this.arrayToObject(r, ["name", "version"]),
          "preload-error": ({ args: r }) =>
            this.arrayToObject(r, ["preloadPath", "error"]),
        },
      });
      At(this, "events", {
        app: {
          "certificate-error": !0,
          "child-process-gone": !0,
          "render-process-gone": !0,
        },
        webContents: {
          "did-fail-load": !0,
          "did-fail-provisional-load": !0,
          "plugin-crashed": !0,
          "preload-error": !0,
          unresponsive: !0,
        },
      });
      At(this, "level", "error");
      At(this, "scope", "");
      this.setOptions(r);
    }
    setOptions({
      events: r,
      level: i,
      logger: a,
      format: s,
      formatters: o,
      scope: c,
    }) {
      typeof r == "object" && (this.events = r),
        typeof i == "string" && (this.level = i),
        typeof a == "object" && (this.logger = a),
        (typeof s == "string" || typeof s == "function") && (this.format = s),
        typeof o == "object" && (this.formatters = o),
        typeof c == "string" && (this.scope = c);
    }
    startLogging(r = {}) {
      this.setOptions(r), this.disposeListeners();
      for (const i of this.getEventNames(this.events.app))
        this.disposers.push(
          e.onAppEvent(i, (...a) => {
            this.handleEvent({
              eventSource: "app",
              eventName: i,
              handlerArgs: a,
            });
          }),
        );
      for (const i of this.getEventNames(this.events.webContents))
        this.disposers.push(
          e.onEveryWebContentsEvent(i, (...a) => {
            this.handleEvent({
              eventSource: "webContents",
              eventName: i,
              handlerArgs: a,
            });
          }),
        );
    }
    stopLogging() {
      this.disposeListeners();
    }
    arrayToObject(r, i) {
      const a = {};
      return (
        i.forEach((s, o) => {
          a[s] = r[o];
        }),
        r.length > i.length && (a.unknownArgs = r.slice(i.length)),
        a
      );
    }
    disposeListeners() {
      this.disposers.forEach((r) => r()), (this.disposers = []);
    }
    formatEventLog({ eventName: r, eventSource: i, handlerArgs: a }) {
      var d;
      const [s, ...o] = a;
      if (typeof this.format == "function")
        return this.format({ args: o, event: s, eventName: r, eventSource: i });
      const c = (d = this.formatters[i]) == null ? void 0 : d[r];
      let l = o;
      if (
        (typeof c == "function" &&
          (l = c({ args: o, event: s, eventName: r, eventSource: i })),
        !l)
      )
        return;
      const f = {};
      return (
        Array.isArray(l)
          ? (f.args = l)
          : typeof l == "object" && Object.assign(f, l),
        i === "webContents" &&
          Object.assign(
            f,
            this.getWebContentsDetails(s == null ? void 0 : s.sender),
          ),
        [
          this.format
            .replace("{eventSource}", i === "app" ? "App" : "WebContents")
            .replace("{eventName}", r),
          f,
        ]
      );
    }
    getEventNames(r) {
      return !r || typeof r != "object"
        ? []
        : Object.entries(r)
            .filter(([i, a]) => a)
            .map(([i]) => i);
    }
    getWebContentsDetails(r) {
      if (!(r != null && r.loadURL)) return {};
      try {
        return { webContents: { id: r.id, url: r.getURL() } };
      } catch {
        return {};
      }
    }
    handleEvent({ eventName: r, eventSource: i, handlerArgs: a }) {
      var o;
      const s = this.formatEventLog({
        eventName: r,
        eventSource: i,
        handlerArgs: a,
      });
      if (s) {
        const c = this.scope ? this.logger.scope(this.scope) : this.logger;
        (o = c == null ? void 0 : c[this.level]) == null || o.call(c, ...s);
      }
    }
  }
  return (Dg = t), Dg;
}
var iI;
function Rae() {
  return (
    iI ||
      ((iI = 1),
      (function (e) {
        const t = Cu(),
          { initialize: n } = bae(),
          r = _ae(),
          i = Sae(),
          a = Iae(),
          s = eT(),
          o = $ae(),
          c = Cae(),
          l = new s({
            errorHandler: new o(),
            eventLogger: new c(),
            initializeFn: n,
            isDev: t.isDev(),
            logId: "default",
            transportFactories: { console: r, file: i, remote: a },
            variables: { processType: "main" },
          });
        (l.processInternalErrorFn = (u) => {
          l.transports.console.writeFn({
            data: ["Unhandled electron-log error", u],
            level: "error",
          });
        }),
          (e.exports = l),
          (e.exports.Logger = s),
          (e.exports.default = e.exports),
          t.onIpc("__ELECTRON_LOG__", (u, d) => {
            d.scope && s.getInstance(d).scope(d.scope);
            const p = new Date(d.date);
            f({ ...d, date: p.getTime() ? p : new Date() });
          }),
          t.onIpcInvoke("__ELECTRON_LOG__", (u, { cmd: d = "", logId: p }) => {
            switch (d) {
              case "getOptions":
                return { levels: s.getInstance({ logId: p }).levels, logId: p };
              default:
                return f({ data: [`Unknown cmd '${d}'`], level: "error" }), {};
            }
          });
        function f(u) {
          var d;
          (d = s.getInstance(u)) == null || d.processMessage(u);
        }
      })(bg)),
    bg.exports
  );
}
const kae =
  typeof process > "u" ||
  process.type === "renderer" ||
  process.type === "worker";
kae ? (Zk(), (V0.exports = yae())) : (V0.exports = Rae());
var Tae = V0.exports;
const Gs = Wl(Tae),
  Lg = {
    key: "HQX4zyAHcakeRvCv25TDJVrqZW5fYNcE",
    reportingUrl: "https://flareapp.io/api/reports",
  };
function d1(e, t = {}) {
  const n = {
    notifier: `Ray node client v${fg.version}`,
    exception_class:
      e.constructor && e.constructor.name ? e.constructor.name : "undefined",
    seen_at: Math.round(Date.now() / 1e3),
    message: e.message,
    language: "javascript",
    context: t,
    stacktrace: Oae(e),
    sourcemap_version_id: fg.version,
    glows: [],
    solutions: [],
    application_path: "../..",
    application_version: fg.version,
  };
  Nae(n);
}
function Nae(e) {
  fetch(Lg.reportingUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      "X-Requested-With": "fetch",
      "x-api-token": Lg.key,
    },
    body: JSON.stringify({ ...e, key: Lg.key }),
  })
    .then((t) => {
      var n;
      if (
        (n = t.headers.get("content-type")) != null &&
        n.includes("application/json")
      )
        return t.json();
      throw new Error("Could not send error report to Flare.");
    })
    .then((t) => {
      Gs.debug("Error report sent to flare.");
    })
    .catch((t) => {
      Gs.error("Could not send error report to Flare.");
    });
}
function Oae(e) {
  return Pae(e)
    ? nae
        .parse(e)
        .map((t) => ({
          line_number: t.lineNumber || 1,
          column_number: t.columnNumber || 1,
          method: t.functionName || "Anonymous or unknown function",
          file: t.fileName || "Unknown file",
          code_snippet: { 0: "Could not read from file." },
          trimmed_column_number: null,
          class: "",
        }))
    : [
        {
          line_number: 0,
          column_number: 0,
          method: "unknown",
          file: "unknown",
          code_snippet: { 0: "Could not read from file: stacktrace missing" },
          trimmed_column_number: null,
          class: "unknown",
        },
      ];
}
function Pae(e) {
  return (
    !!e &&
    (!!e.stack || !!e.stacktrace || !!e["opera#sourceloc"]) &&
    typeof (e.stack || e.stacktrace || e["opera#sourceloc"]) == "string" &&
    e.stack !== `${e.name}: ${e.message}`
  );
}
function aI(e) {
  return kT
    .createHash("md5")
    .update(e || "", "utf8")
    .digest("hex");
}
const Df = {
    async getServers() {
      const e = rt.servers(),
        t = Dae();
      return e.map((n) => {
        var s, o;
        const r = aI(n.privateKeyPath),
          i =
            (n.privateKeyPath &&
              ((s = t.find((c) => c.account === `private_key_${r}`)) == null
                ? void 0
                : s.password)) ||
            void 0,
          a =
            ((o = t.find((c) => c.account === `ssh_password_${n.uuid}`)) == null
              ? void 0
              : o.password) || void 0;
        return { ...n, password: a, privateKeyPassphrase: i };
      });
    },
    updateServer(e) {
      const {
        uuid: t,
        label: n,
        host: r,
        username: i,
        port: a,
        needsCredentialsUpdate: s,
        privateKeyPath: o,
        password: c,
      } = e;
      return (
        rt.updateServer({
          uuid: t,
          label: n,
          host: r,
          username: i,
          port: a,
          needsCredentialsUpdate: s,
          privateKeyPath: o,
        }),
        c ? sI(`ssh_password_${e.uuid}`, c) : oI(`ssh_password_${e.uuid}`)
      );
    },
    updatePrivateKey({ privateKeyPath: e, privateKeyPassphrase: t }) {
      const n = aI(e);
      sI(`private_key_${n}`, t);
    },
    removeServer(e) {
      rt.removeServer(e.uuid), oI(`ssh_password_${e.uuid}`);
    },
  },
  p1 = new Mp({
    name: "ray-encrypted",
    watch: !0,
    encryptionKey: "this_only_obfuscates",
  });
function sI(e, t) {
  const n = xe.safeStorage.encryptString(t);
  p1.set(e, n.toString("latin1"));
}
function oI(e) {
  p1.delete(e);
}
function Dae() {
  return Object.entries(p1.store).map(([e, t]) => {
    try {
      const n = xe.safeStorage.decryptString(Buffer.from(t, "latin1"));
      return { account: e, password: n };
    } catch (n) {
      return d1(n), { account: e };
    }
  });
}
function Lae() {
  xe.ipcMain.handle("connect-ssh", async (e, t) => ({
    uuid: (await Tl.connect(t)).uuid,
  })),
    xe.ipcMain.on("disconnect-ssh", (e, t) => {
      var n, r;
      Tl.disconnect(t.uuid),
        (r =
          (n = Yt.find((i) => {
            var a;
            return ((a = i.remoteServer) == null ? void 0 : a.uuid) === t.uuid;
          })) == null
            ? void 0
            : n.window) == null || r.close();
    }),
    xe.ipcMain.on("update-server", (e, t) => Df.updateServer(t)),
    xe.ipcMain.handle("get-servers", () => Df.getServers()),
    xe.ipcMain.on("update-private-key-passphrase", (e, t) =>
      Df.updatePrivateKey(t),
    ),
    xe.ipcMain.on("remove-server", (e, t) => Df.removeServer(t)),
    xe.ipcMain.handle("is-server-connected", (e, t) =>
      Tl.getConnectedServers().includes(t),
    );
}
let rT = !1;
function Bae() {
  Lae(),
    xe.ipcMain.on("open-url", (e, t) => {
      L0(t);
    }),
    xe.ipcMain.on("open-editor", (e, { path: t, lineNumber: n = 1 }) => {
      const i = rt
        .editorString()
        .replace("%path", encodeURIComponent(t))
        .replace("%line", encodeURIComponent(n));
      xe.shell.openExternal(i);
    }),
    xe.ipcMain.handle(
      "flare-report",
      async (e, { report: t, id: n, groupUuid: r }) => {
        var i;
        try {
          const a = await fetch("https://flareapp.io/api/public-reports", {
            body: JSON.stringify({
              report: t,
              tabs: [
                "stackTraceTab",
                "requestTab",
                "appTab",
                "userTab",
                "contextTab",
                "debugTab",
              ],
            }),
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
          });
          if (
            (i = a.headers.get("content-type")) != null &&
            i.includes("application/json")
          ) {
            const s = await a.json(),
              o = Yt.find((u) => u.window.id === e.sender.id);
            if (!o) return;
            const c = o.screens.find((u) => u.groups.has(r));
            if (!c) return;
            const l = c.groups.get(r);
            if (!l) return;
            const f = l.items.find((u) => u.id === n);
            if (!f || f.type !== "exception") return;
            (f.meta = { ...f.meta, flare_response: s }), ts(o);
          }
        } catch (a) {
          console.error(a);
        }
      },
    ),
    xe.app.on("before-quit", () => {
      (rT = !0), Tl.disconnectAll();
      const e = Yt[0].window;
      e != null && e.isVisible() && nte(e.getBounds()),
        xe.globalShortcut.unregisterAll();
    });
}
let Oi = null;
function Uae() {
  if (Oi) return Oi.show();
  (Oi = new xe.BrowserWindow(Qp())),
    Oi.on("closed", () => (Oi = null)),
    Wp(Oi, { page: "servers" }),
    zp(Oi);
}
xe.ipcMain.on("open-servers-window", Uae);
let Yt = [];
function ts(e) {
  e.window.webContents.send("screen-updated", {
    screen: e.screens[e.activeScreenIndex],
    activeIndex: e.activeScreenIndex,
    amountOfScreens: e.screens.length,
  }),
    e.window.webContents.send("screens-updated", sT(e));
}
function iT({ windowName: e, projectName: t, hostname: n, remoteServer: r }) {
  var l;
  const i = Yt.length === 0,
    a = {
      ...Qp(),
      skipTaskbar: !1,
      icon: xe.nativeImage.createFromPath(
        Hp
          ? `${xe.app.getAppPath()}/resources/extraFiles/icon128x128.png`
          : pt.join(process.resourcesPath, "icon128x128.png"),
      ),
      show: !1,
      ...(i ? JR() : ZR()),
    },
    s = new xe.BrowserWindow(a);
  s.on("page-title-updated", (f) => f.preventDefault());
  const o = r ? r.serverLabel || n : void 0,
    c = {
      window: s,
      isPaused: !1,
      windowName: e,
      projectName: t,
      hostname: n,
      remoteServer: r,
      screens: [{ groups: new Map() }],
      activeScreenIndex: 0,
    };
  Yt.push(c),
    s == null ||
      s.on("close", (f) => {
        if (rT || !vs.autoUpdater.autoInstallOnAppQuit) return;
        r &&
          (Oi == null || Oi.webContents.send(`server-disconnected-${r.uuid}`),
          Tl.disconnect(r.uuid)),
          Yt.length === 1
            ? (f.preventDefault(), s.hide())
            : (Yt = Yt.filter((d) => d.windowName !== e));
      }),
    rt.shouldShowDockIcon() ||
      ((l = xe.app.dock) == null || l.hide(), s.setSkipTaskbar(!0)),
    Wp(s, {
      page: "main",
      windowName: e,
      projectName: t,
      remoteServerLabel: o,
    }),
    s.webContents.on("dom-ready", () => {
      ese(c), ts(c);
    }),
    zp(s, i);
}
xe.ipcMain.on("set-paused", (e, t) => {
  const n = Yt.find((r) => r.window.id === e.sender.id);
  n && ((n.isPaused = t), n.window.webContents.send("paused-changed", t));
});
xe.ipcMain.handle("get-paused", (e) => {
  const t = Yt.find((n) => n.window.id === e.sender.id);
  if (t) return t.isPaused;
});
xe.ipcMain.on("set-screen-index", (e, t) => {
  const n = Yt.find((r) => r.window.id === e.sender.id);
  n && ((n.activeScreenIndex = t), ts(n));
});
function th(e, t) {
  e.screens.at(-1).groups.size === 0 && e.screens.pop(),
    e.screens.push({ groups: new Map(), name: t }),
    (e.activeScreenIndex = e.screens.length - 1),
    ts(e);
}
function aT(e) {
  (e.screens = [{ groups: new Map(), name: "" }]),
    (e.activeScreenIndex = 0),
    ts(e);
}
xe.ipcMain.on("new-screen", (e) => {
  const t = Yt.find((n) => n.window.id === e.sender.id);
  t && th(t);
});
function sT(e) {
  return e.screens.map(({ name: t }, n) => ({ name: t, index: n }));
}
xe.ipcMain.handle("get-screens", (e) => {
  const t = Yt.find((n) => n.window.id === e.sender.id);
  return t ? sT(t) : [];
});
xe.ipcMain.on("set-collapsed", (e, { id: t, isCollapsed: n }) => {
  const r = Yt.find((s) => s.window.id === e.sender.id);
  if (!r) return [];
  const a = r.screens[r.activeScreenIndex].groups.get(t);
  a && ((a.collapsed = n), ts(r));
});
xe.ipcMain.on("toggle-collapsed", (e, { id: t }) => {
  const n = Yt.find((a) => a.window.id === e.sender.id);
  if (!n) return [];
  const i = n.screens[n.activeScreenIndex].groups.get(t);
  i && ((i.collapsed = !i.collapsed), ts(n));
});
const Fae = {
    log: (e) =>
      e.content.values.map((t, n) => {
        var r;
        return {
          type: "log",
          content: t.toString(),
          meta: {
            clipboard_data:
              (r = e.content.meta) == null ? void 0 : r[n].clipboard_data,
          },
        };
      }),
    mailable: (e) => ({
      type: "mailable",
      mailable_class: e.content.mailable_class,
      html: e.content.html,
      from: e.content.from,
      subject: e.content.subject,
      to: e.content.to,
      cc: e.content.cc,
      bcc: e.content.bcc,
    }),
    measure: (e) => ({
      type: "measure",
      name: e.content.name,
      is_new_timer: e.content.is_new_timer,
      total_time: e.content.total_time,
      max_memory_usage_during_total_time:
        e.content.max_memory_usage_during_total_time,
      time_since_last_call: e.content.time_since_last_call,
      max_memory_usage_since_last_call: e.content.time_since_last_call,
    }),
    trace: (e) => ({ type: "trace", frames: e.content.frames }),
    table: (e) => ({
      type: "table",
      values: e.content.values,
      label: e.content.label ?? "Table",
    }),
    carbon: (e) => ({
      type: "carbon",
      formatted: e.content.formatted,
      timestamp: e.content.timestamp,
      timezone: e.content.timezone,
    }),
    caller: (e) => ({ type: "caller", frame: e.content.frame }),
    eloquent_model: (e) => ({
      type: "eloquent_model",
      attributes: e.content.attributes,
      relations: e.content.relations,
      class_name: e.content.class_name,
    }),
    application_log: (e) => ({
      type: "application_log",
      value: e.content.value,
      context: e.content.context || void 0,
    }),
    custom: (e) => ({
      type: "custom",
      content: e.content.content,
      label: e.content.label,
    }),
    json: (e) => ({ type: "json", value: e.content.value }),
    json_string: (e) => ({ type: "json_string", value: e.content.value }),
    event: (e) => ({
      type: "event",
      name: e.content.name,
      event: e.content.event,
      payload: e.content.payload,
      class_based_event: e.content.class_based_event,
    }),
    job_event: (e) => ({
      type: "job_event",
      event_name: e.content.event_name,
      job: e.content.job,
      exception: e.content.exception,
    }),
    response: (e) => ({
      type: "response",
      status_code: e.content.status_code,
      headers: e.content.headers,
      content: e.content.content,
      json: e.content.json,
    }),
    executed_query: (e) => ({
      type: "executed_query",
      content: e.content.sql,
      connectionName: e.content.connection_name ?? "",
      duration: e.content.time,
      bindings: e.content.bindings,
    }),
    view: (e) => ({
      type: "view",
      view_path: e.content.view_path,
      view_path_relative_to_project_root:
        e.content.view_path_relative_to_project_root,
      data: e.content.data,
    }),
    exception: (e) => {
      const t = e.content.frames[0];
      return {
        type: "exception",
        class: e.content.class,
        message: e.content.message,
        frames: e.content.frames,
        meta: e.content.meta,
        lineNumber: t.line_number,
        fileName: t.file_name.substring(t.file_name.lastIndexOf("/") + 1),
        path: t.file_name,
      };
    },
    separator: () => ({ type: "separator" }),
    create_lock: (e) => ({ type: "lock", lockName: e.content.name }),
  },
  h1 = new Map();
function jae(e) {
  h1.set(e.name, e);
}
function Mae(e, t) {
  const n = h1.get(e);
  n && ((n.active = !1), (n.stop_execution = t));
}
function oT(e) {
  const t = h1.get(e);
  return (
    t || {
      name: e,
      active: !1,
      stop_execution: !1,
      displayed_on_group_uuid: "",
    }
  );
}
xe.ipcMain.on("deactivate-lock", (e, { lockName: t, stopExecution: n }) => {
  Mae(t, n);
});
xe.ipcMain.handle("get-lock", (e, t) => oT(t));
const Hae = {
  hide:
    () =>
    ({ screen: e, groupUuid: t }) => {
      if (!e.groups.has(t)) return;
      const n = e.groups.get(t);
      n.collapsed = !0;
    },
  remove:
    () =>
    ({ screen: e, groupUuid: t }) => {
      e.groups.has(t) && e.groups.delete(t);
    },
  notify:
    (e) =>
    ({ window: t }) => {
      const n = new xe.Notification({ title: "Ray", body: e.content.value });
      n.on("click", () => {
        t.window.show();
      }),
        n.show();
    },
  color:
    (e) =>
    ({ screen: t, groupUuid: n }) => {
      if (!t.groups.has(n)) return;
      const r = t.groups.get(n);
      r.color = e.content.color;
    },
  size:
    (e) =>
    ({ screen: t, groupUuid: n }) => {
      if (!t.groups.has(n)) return;
      t.groups.get(n).items.forEach((i) => (i.style.text = e.content.size));
    },
  label:
    (e) =>
    ({ screen: t, groupUuid: n }) => {
      if (!t.groups.has(n)) return;
      t.groups.get(n).items.forEach((i) => (i.label = e.content.label));
    },
  screen_color:
    (e) =>
    ({ screen: t }) => {
      t.color = e.content.color;
    },
  show_app:
    () =>
    ({ window: e }) => {
      e.window.show();
    },
  hide_app:
    () =>
    ({ window: e }) => {
      e.window.hide();
    },
  confetti:
    () =>
    ({ window: e }) => {
      e.window.webContents.send("shoot-confetti");
    },
  create_lock:
    (e) =>
    ({ groupUuid: t }) => {
      const n = {
        name: e.content.name,
        active: !0,
        stop_execution: !1,
        displayed_on_group_uuid: t,
      };
      jae(n);
    },
  expand:
    (e) =>
    ({ screen: t, groupUuid: n }) => {
      if (!t.groups.has(n)) return;
      t.groups.get(n).items.forEach((i) => (i.expand = e.content));
    },
};
function qae(e) {
  return { groupUuid: e.uuid, time: new Date().toTimeString().slice(0, 8) };
}
function Gae(e) {
  return {
    path: e.origin.file,
    lineNumber: e.origin.line_number,
    hostname: e.origin.hostname === Fr.hostname() ? void 0 : e.origin.hostname,
    fileName: e.origin
      ? e.origin.file.substring(e.origin.file.lastIndexOf("/") + 1)
      : "",
  };
}
function Qae(e, t) {
  const n = Fae[e.type],
    r = Hae[e.type];
  let i, a;
  if ((r && (i = r(e)), n)) {
    const s = Gae(e);
    let o = n(e);
    Array.isArray(o) || (o = [o]),
      (a = o.map((c) => ({
        id: Math.random(),
        style: { color: "gray", text: "" },
        ...t,
        ...s,
        ...c,
      })));
  }
  return i || a
    ? { action: i, items: a }
    : (console.error("Payload type not recognised:", e.type, e), {});
}
function cI(e, t) {
  return e.type === t;
}
function Wae(e, t) {
  let n = [],
    r = [];
  const i = qae(e);
  e.payloads.forEach((a) => {
    if (cI(a, "new_screen")) {
      th(t, a.content.name);
      return;
    }
    if (cI(a, "clear_all")) {
      aT(t);
      return;
    }
    const { items: s, action: o } = Qae(a, i);
    s && n.push(...s), o && r.push(o);
  }),
    Gee(n) && zae(n, t),
    r.length > 0 &&
      r.forEach((a) => {
        a({
          window: t,
          screen: t.screens[t.activeScreenIndex],
          groupUuid: e.uuid,
        });
      });
}
function zae(e, t) {
  const n = e[0].groupUuid,
    r = t.screens[t.activeScreenIndex];
  if (r.groups.has(n)) {
    r.groups.get(n).items = e;
    return;
  }
  r.groups.set(n, { uuid: n, items: e, collapsed: !1, color: "gray" });
  const a =
    t.screens.reduce((s, o) => s + o.groups.size, 0) - rt.historyLimit();
  a > 0 && Kae(t, a);
}
function Kae(e, t) {
  for (; t > 0; ) {
    console.log(e.screens);
    const n = e.screens[0].groups.size;
    if (n > t) {
      const r = e.screens[0].groups.entries();
      for (let i = 0; i < t; i++) {
        const a = r.next().value[0];
        console.log(`removing key ${i}`, a), e.screens[0].groups.delete(a);
      }
      t = 0;
      return;
    }
    if (e.screens.length === 1) {
      e.screens[0].groups.clear(), (t = 0);
      return;
    }
    e.screens.shift(), e.activeScreenIndex--, (t -= n);
  }
}
let er = null;
function dc() {
  if (er) return er.show();
  (er = new xe.BrowserWindow({ ...Qp(), minHeight: 600, minWidth: 400 })),
    er.on("closed", () => (er = null)),
    Wp(er, { page: "license" }),
    zp(er);
}
function cT() {
  er == null || er.close(), (er = null);
}
xe.ipcMain.on("openLicense", dc);
xe.ipcMain.on("closeLicense", cT);
const Vae = 10;
let Bg = fn.getAmountOfRequests(),
  lT = fn.getHasActiveLicense(),
  uT = fn.getIsLicenseOverlayLocked();
async function Yae() {
  Zae();
  const e = fn.getSignedLicense();
  if (e) {
    await dT(e);
    return;
  }
  pc(!1), dc();
}
function Xae() {
  Bg++, fn.setAmountOfRequests(Bg), !lT && Bg >= Vae && (hT(!0), dc());
}
function fT(e) {
  const t = new YR(e);
  if (
    (fn.store(t),
    er == null || er.webContents.send("setLicense", t),
    !t.isActive())
  ) {
    t.isValid() ||
      (gi("unexpected"),
      Gs.warn("Invalid license", { licenseResponse: e }),
      d1(new Error("Invalid license"), { licenseResponse: e })),
      t.isExpired() && gi("expired"),
      pc(!1),
      dc();
    return;
  }
  pc(!0), hT(!1), cT();
}
async function dT(e) {
  try {
    const t = await Gp.post(`/activations/${e.activation_code}/show`, {
      license_key: e.license_key,
    });
    fn.endGracePeriod(), Y0(null), gi(null), fT(t);
  } catch (t) {
    if ((t == null ? void 0 : t.status) === 404) {
      pc(!1), dc(), gi("notActivated");
      return;
    }
    (t == null ? void 0 : t.message) === "fetch failed" &&
      (gi("networkFailed"), Gs.debug(t));
    const n = fn.getGracePeriod();
    n.isInGracePeriod || fn.startGracePeriod(),
      n.hasGracePeriodExpired && (pc(!1), dc()),
      Y0(fn.getGracePeriod().endOfGracePeriod);
  }
}
async function Jae({ licenseKey: e }) {
  const t = Fr.hostname().trim(),
    n = fn.getSignedLicense();
  gi(null);
  try {
    n && (await pT());
    const r = await Gp.post("/activations", { license_key: e.trim(), name: t });
    fT(r);
  } catch (r) {
    (r == null ? void 0 : r.status) === 404 ||
    (r == null ? void 0 : r.status) === 422
      ? gi("invalid")
      : (gi("unexpected"),
        Gs.warn(r),
        d1(r, {
          request_data: { license_key: e.trim().slice(0, 5), name: t },
        }));
  }
}
async function pT() {
  await fn.delete(), Y0(null), pc(!1), gi(null);
}
function Zae() {
  xe.ipcMain.handle("decoupleLicense", pT),
    xe.ipcMain.handle("submit-license", (e, t) => Jae(t)),
    xe.ipcMain.handle("check-license", async (e) => {
      const t = fn.getSignedLicense();
      if (!t) {
        gi("notActivated");
        return;
      }
      return dT(t);
    });
}
function gi(e) {
  fn.setErrorMessage(e);
}
function Y0(e) {
  fn.setEndOfGracePeriod(e);
}
function pc(e) {
  (lT = e), fn.setHasActiveLicense(e);
}
function hT(e) {
  (uT = e),
    fn.setIsLicenseOverlayLocked(e),
    er && (e ? (er.closable = !1) : (er.closable = !0));
}
const Qs = dD();
Qs.use(kv.json({ limit: "4000mb" }));
Qs.use(kv.urlencoded({ limit: "4000mb", extended: !0 }));
Qs.use(kv.text({ limit: "4000mb" }));
Qs.use(kD());
let jo,
  lI = !1;
const Mo = {};
function uI(e, t) {
  if (!Mo[e]) return (Mo[e] = [t]);
  Mo[e].push(t);
}
function ese(e) {
  const t = Mo[e.windowName] ?? [];
  delete Mo[e.windowName], t.forEach((n) => gT(e, n));
}
function tse() {
  Qs.post("/", (e, t) => {
    tte(), Xae();
    let n;
    const r = rt.newWindow(),
      i = e.body.payloads[0].origin.hostname,
      a = e.body.meta.project_name;
    let s = `${i || "0"}-${a || "0"}`;
    const o = Rs.find((c) => c.hostname === i);
    if (!lI && !o) {
      if (Yt[0].isPaused) return;
      (Yt[0].projectName = a),
        (Yt[0].hostname = i),
        Yt[0].window.webContents.send("updateProjectName", a),
        (lI = !0);
    }
    if (r === "never") n = Yt[0];
    else {
      if (
        (r === "project"
          ? (n = Yt.find((c) => c.hostname === i && c.projectName === a))
          : r === "server" && (n = Yt.find((c) => c.hostname === i)),
        !n)
      )
        return (
          iT({ windowName: s, projectName: a, hostname: i, remoteServer: o }),
          uI(s, e.body),
          t.send("ok")
        );
      if (Mo[s]) return uI(s, e.body), t.send("ok");
    }
    gT(n, e.body), t.send("ok");
  }),
    Qs.get("/locks/:lockName", async (e, t) => {
      const n = e.params.lockName,
        r = oT(n);
      console.log(r), t.send(r);
    }),
    mT(),
    jo.on("listening", () => {
      const e = jo.address().port;
      console.info(`Listening on port ${e}...`);
    }),
    jo.on("error", (e) => {
      const t = e;
      t.code === "EADDRINUSE" && console.error(`port ${t.port} already in use`);
    });
}
function mT() {
  const e = rt.port();
  jo = (jo || Qs).listen(e);
}
function nse() {
  jo.close(() => mT());
}
function gT(e, t) {
  !e.isPaused && !uT && (Wae(t, e), ts(e));
}
let Ia;
function rse() {
  const e =
    process.env.NODE_ENV === "development"
      ? `${xe.app.getAppPath()}/resources/extraFiles/tray/trayTemplate@2x.png`
      : pt.join(process.resourcesPath, "tray/trayTemplate@2x.png");
  return (
    (Ia = new xe.Tray(xe.nativeImage.createFromPath(e))),
    Ia.setIgnoreDoubleClickEvents(!0),
    Ia.on("click", () =>
      xe.BrowserWindow.getAllWindows().forEach((t) => t.show()),
    ),
    Ia.on("right-click", function () {
      const t = [
        {
          label: "Show/Hide Ray",
          accelerator: "CmdOrCtrl+H",
          click: () => {
            const n = Yt.some(({ window: r }) => r.isFocused());
            xe.BrowserWindow.getAllWindows().forEach((r) =>
              n ? r.hide() : r.show(),
            );
          },
        },
        {
          label: "Reset to center of screen",
          accelerator: "CmdOrCtrl+Shift+R",
          click: () => {
            xe.BrowserWindow.getAllWindows().forEach((n) => {
              n == null || n.center(), n == null || n.show();
            });
          },
        },
        { label: "Preferences", accelerator: "CmdOrCtrl+,", click: WR },
        { role: "quit", accelerator: "CmdOrCtrl+Q" },
      ];
      Ia == null || Ia.popUpContextMenu(xe.Menu.buildFromTemplate(t));
    }),
    Ia
  );
}
function ise() {
  if (xe.app.runningUnderARM64Translation && Fr.platform() === "darwin") {
    const e = ["Download now", "No thanks"];
    xe.dialog
      .showMessageBox({
        title: "Rosetta",
        message:
          "It appears that you are running the Intel version of Ray in ARM64 Translation (Rosetta). The Apple Silicon version of the app is now available, and should bring huge performance improvements. Get it at https://myray.app",
        buttons: e,
      })
      .then((t) => {
        (t == null ? void 0 : t.response) !== void 0 &&
          e[t.response] === "Download now" &&
          xe.shell.openExternal(
            "https://spatie.be/products/ray/download/macosAppleSilicon/latest",
          );
      });
  }
}
function ase() {
  (Gs.transports.file.level = "debug"),
    (vs.autoUpdater.logger = Gs),
    vs.autoUpdater.on("update-downloaded", (e) => {
      const t = {
        type: "info",
        buttons: ["Restart", "Later"],
        title: "Application Update",
        message: process.platform === "win32" ? e.releaseNotes : e.releaseName,
        detail: `A new version (${e.version}) has been downloaded. Restart Ray to apply the updates.`,
      };
      xe.dialog.showMessageBox(t).then((n) => {
        n.response === 0 &&
          ((vs.autoUpdater.autoInstallOnAppQuit = !1),
          vs.autoUpdater.quitAndInstall());
      });
    }),
    vs.autoUpdater.checkForUpdatesAndNotify().then((e) => {
      !e ||
        !(
          (e == null ? void 0 : e.updateInfo.version) !== xe.app.getVersion()
        ) ||
        console.log(
          "A new version is available, it will be downloaded in the background.",
        );
    });
}
process.env.DIST_ELECTRON = Gl.join(__dirname, "../");
process.env.DIST = Gl.join(process.env.DIST_ELECTRON, "../dist");
process.env.PUBLIC = process.env.VITE_DEV_SERVER_URL
  ? Gl.join(process.env.DIST_ELECTRON, "../public")
  : process.env.DIST;
fI.release().startsWith("6.1") && xe.app.disableHardwareAcceleration();
process.platform === "win32" && xe.app.setAppUserModelId(xe.app.getName());
xe.app.requestSingleInstanceLock()
  ? xe.app.on("second-instance", () => {
      Yt[0].window.show();
    })
  : xe.app.quit();
xe.app.whenReady().then(async () => {
  Jee(),
    Bae(),
    ase(),
    await Yae(),
    iT({ windowName: 0 }),
    tse(),
    rse(),
    Vee(),
    qp(),
    ise();
});
xe.app.on("activate", () => {
  var e;
  (e = Yt[0]) == null || e.window.show();
});
